# *工厂模式*

<br/>

### 工厂模式的介绍
---
#### 1. 工厂模式的定义
> Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses (在基类中定义创建对象的一个接口，让子类决定实例化哪个类，工厂方法让一个类的实例化延迟到子类中进行)
#### 2. 工厂模式的分类
- 简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）
<img src = "https://i.loli.net/2019/08/03/rekC2RuSsgZhzy8.jpg" width = "100%" height = "70%" align = "center" />

- 工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式
<img src = "https://i.loli.net/2019/08/03/o1ZFqdbg8KUPaXY.jpg" width = "100%" height = "70%" align = "center" />

- 抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式
<img src = "https://i.loli.net/2019/08/03/jGva4cSi5mhlzqf.jpg" width = "100%" height = "70%" align = "center" />

#### 3. 使用工厂模式的好处
- 从客户的角度说来说，它只需要负责从工厂中获取工厂所生产的产品（类），并不用关心在创建该类的过程当中所包含的具体的实现，作为工厂的角度来说，它使得产品（类）的创建与客户之间形成了一种隔阂，通过这种设计模式不同模块间的职责明确
- 降低代码的 `耦合性`，减少代码的 `冗余`，提升代码的进一步 `拓展性`

<br/>

### 简单工厂模式
---
#### 1. 简单工厂工厂的介绍  
- 通过定义一个工厂，并接受用户所需要的需求进行产品的生产

#### 2. 简单工厂所存在的问题
- 简单工厂在原则上来说只有一个具体的工厂，并且这个工厂负责提供各式各样的产品，换句话说，如果所需要提供产品过于庞大且繁琐的话，则这个工厂就会显得过于臃肿

#### 2. 简单工厂的实现方式
- 抽象成员：用于抽象产品的本身
```csharp
    public interface IProduct
    {
        string ProductName { get; set; }

        void SaleProduct();
    }
```
- 产品：被生产的产品的实例
```csharp
   public class Computer : IProduct
    {
        private string _productName;
        public string ProductName
        {
            get { return _productName; }
            set { this._productName = value; }
        }

        public void SaleProduct()
        {
            // do....
        }
    }
```
- 工厂：用于生产客户需求的产品并返回给客户
```csharp
    public static IProduct GetProductObj(string productName)
    {
        IProduct product;
        switch (productName)
        {
            case "Computer":
                product = new Computer();
                break;
            // case…
            default:
                product = null;
                break;
        }
        return product;
    }
```
- 客户：通过工厂去获取自己所需要的产品
```csharp
    class Program
    {
        static void Main(string[] args)
        {
            // 客户通过工厂向工厂提取产品
            IProduct product = ProductFactory.GetProductObj("Computer");

            product.SaleProduct();
        }
    }
```

<br/>

### 工厂方法模式
---
#### 1. 工厂方法简单介绍
- 工厂方法模式属于简单工厂模式的进一步抽象，区别于简单工厂模式，在该模式中不再通过一个统一的工厂用于提供所需要的产品，而是针对不同的产品能够提供不同的工厂去用于生产
- 工厂方法模式定义了一个抽象的工厂成员，让集成该抽象工厂成员的子类去决定将哪一个类进行实例化，工厂方法模式让一个类的实例化延迟到其子类

#### 2. 工厂方法所存在的问题
- 工厂方法模式属于简单工厂模式的进一步的抽象，虽然使用它能够解决简单工厂所带来的代码冗余、工厂臃肿的问题，然而使用它却 <span style="color:red">额外的增加了编写的代码</span>

#### 3. 工厂方法的实现方式
- 抽象成员：用于抽象产品的本身
```csharp
    public interface IProduct
    {
        void SaleProduct();
    }
```
- 产品：被生产的产品的实例
```csharp
    public class Computer : IProduct
    {
        public void SaleProduct()
        {
            // do...
        }
    }
```
- 抽象工厂：用于抽象工厂实例的本身
```csharp
    public interface IProductFactory
    {
        IProduct CreateProduct();
    }
```
- 工厂：不同的产品间拥有着不同的工厂，并且通过这个工厂返回所对应产品的抽象成员
```csharp
    public IProduct CreateProduct()
    {
        return new Computer();
    }
```
- 客户：指定所需要的工厂，并且获取到一个工厂的抽象成员（我并不知道工厂的实例具体是谁），并且通过这个工厂获取所对应的产品的抽象成员（我并不知道产品的实例具体是谁）
```csharp
    class Program
    {
        static void Main(string[] args)
        {
            // 构建工厂
            IProductFactory productFactory = new ComputerFactory();
            // 获取产品
            IProduct product = productFactory.CreateProduct();

            product.SaleProduct();
        }
    }
```