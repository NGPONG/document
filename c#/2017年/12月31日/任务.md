# 任务 Task

<br/>

### 前言

##### 1. 背景
- TPL引入新的基于Task的编程模型，通过这种编程模型可以发挥多核的功效，提升应用程序的性能，不需要编写底层复杂且重量级的线程代码

##### 2. Task与线程之间的区别
Task并不是线程，虽然其内部是使用底层的线程(软件线程，调度在特定的硬件线程或逻辑内核上)运行的，但Task与线程之间并没有一对一的关系，简而言之并不是创建十个Task就会调度是个线程去执行
> Task的概念有点类似于`线程池`，但是它相对于直接使用`线程池`的时候，Task会有更小的开销和把控性

##### 3. System.Threading.Tasks.Task
- 介绍
    - 一个`Task`表示一个异步操作，Task提供了很多方法和属性，通过这些方法和属性能够对Task的执行进行控制，并且能够获得其状态信息，它的创建和执行都是独立的，因此可以对关联操作的执行拥有完全的控制权
- Task的状态与生命周期
    - 一个Task实例只会完成其生命周期一次，当Task到达它的3种最终状态之一后，就无法回到之前的任何状态
    <img src = "https://i.loli.net/2019/07/15/5d2c1ddc35c9045567.png" width = "70%" height = "70%" align = "center" />
    - 关于一个Task在其生命中的不同状态，.NET通过其实例属性`Status`来标注出来，其类型为一个枚举
        状态 | 说明
        ------- | -------
        Canceled | 该任务已通过对其自身的 CancellationToken 引发 OperationCanceledException 对取消进行了确认，此时该标记处于已发送信号状态；或者在该任务开始执行之前，已向该任务的 CancellationToken 发出了信号
        Created|该任务已初始化，但尚未被计划
        Faulted|由于未处理异常的原因而完成的任务
        RanToCompletion|已成功完成执行的任务
        Running|该任务正在运行，但尚未完成
        WaitingForActivation|该任务正在等待 .NET Framework 基础结构在内部将其激活并进行计划
        WaitingForChildrenToComplete|该任务已完成执行，正在隐式等待附加的子任务完成
        WaitingToRun|该任务已被计划执行，但尚未开始执行
- 创建一个新的Task时，Task调度器`默认`依赖于底层的线程池引擎，会使用工作窃取队列找到一个最合适的线程，然后将Task加入队列，Task所包含的代码会在一个线程中运行
<img src = "https://i.loli.net/2019/07/15/5d2c19265879b22417.png" width = "70%" height = "70%" align = "center" />

---

### Task的具体使用

##### 1. 开启一个任务  
- 基础创建方式，当创建好Task的实例后，我们需要手动调用其实例的`Start()`函数才可标记Task的实例为可调度状态
```csharp
    Task taskDefault = new Task(() =>
    {
        Console.WriteLine($"我是taskDefault，由线程【{Thread.CurrentThread.ManagedThreadId}】执行我");
    });
    taskDefault.Start();
```
- 使用默认的任务工厂进行创建，当实例被创建后则自动标记其为可调度状态
```csharp
    Task taskFactory = Task.Factory.StartNew(()=>
    {
        Console.WriteLine($"我是taskFactory，由线程【{Thread.CurrentThread.ManagedThreadId}】执行我");
    });
```
- 使用简化的方式创建，其效果等同于上一种，但是第二种的灵活性会更高一点
```csharp
    Task taskRun = Task.Run(() =>
    {
        Console.WriteLine($"我是taskRun，由线程【{Thread.CurrentThread.ManagedThreadId}】执行我");
    });
```
- 为Task构建输入参数和输出参数      
    - 除了普通的`Task`之外，`Task`还有一个泛型的版本`Task<TResult>`用于指定返回的类型
    - `Task.Factory.StartNew()`拥有着多种`Action`和`Func`的重载用于指定有参数无返回值/有返回值有参数/有返回值无参数/无参数无返回值的函数的指向
    - 当我们指定了`Task<TResult>`的`TResult`的类型后，在调用初始化Task的话一定会返回`Task<TResult>`类型的实例，我们可以根据这个实例的`Result`属性用于获取`Task`所执行任务的返回值，需要注意的是，当我们调用了`Result`属性获取返回值的时候，**会阻塞当前线程的继续运行直至`Task`执行结束并返回**
```csharp
    Task<string> myTask = Task<string>.Factory.StartNew((object state) =>
    {
        Thread.Sleep(10000);
        return state.ToString();
    }, "Hello,World!");

    // 并获取Task的返回值，并阻塞当前线程的继续执行直至Task所指向的函数调用完毕
    string resultStr = myTask.Result;
```
- 关于Task的状态分布
    - Canceled：当Task捕捉到所绑定的信号量取消后所变更的状态
    ```csharp
        CancellationTokenSource cts = new CancellationTokenSource();
        Task task = Task.Run(() =>
        {
            while (true)
            {
                if (cts.IsCancellationRequested)
                {
                    cts.Token.ThrowIfCancellationRequested();
                }
            }
        }, cts.Token);

        // 等待Task启动后再取消
        Thread.Sleep(1000);

        cts.Cancel();

        // 取消了之后可能Task的状态未及时更新过来，也要等待一下
        Thread.Sleep(1000);
    ```