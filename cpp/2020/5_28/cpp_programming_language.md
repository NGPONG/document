# *Cpp Programming language*


<br/>


## 目录

- [Namespace](#namespace)
  - [命名空间的定义](#命名空间的定义)
  - [匿名命名空间](#匿名命名空间)
  - [匿名命名空间中的 extern](#匿名命名空间中的-extern)
  - [作用域](#作用域)
    - [显式的引用某一处的作用域](#显式的引用某一处的作用域)
  - [命名空间下成员的声明和定义](#命名空间下成员的声明和定义)
- [表达式和值类别](#表达式和值类别)
  - [表达式](#表达式)
  - [值类别](#值类别)
    - [左值](#左值)
    - [右值](#右值)
    - [值类别小结](#值类别小结)
- [引用](#引用)
  - [引用变量的本质](#引用变量的本质)
  - [左值引用](#左值引用)
  - [右值引用](#右值引用)
  - [左右值引用的函数重载策略](#左右值引用的函数重载策略)
  - [数组引用](#数组引用)
  - [指针引用](#指针引用)
- [常量的增强](#常量的增强)
- [类型赋值](#类型赋值)
  - [匿名对象](#匿名对象)
  - [定义法](#定义法)
  - [隐式法](#隐式法)
  - [括号法](#括号法)
  - [new](#new)
    - [语义使用时必须要注意的问题](#语义使用时必须要注意的问题)
    - [语义用于修饰一个数组类型的构造](#语义用于修饰一个数组类型的构造)
    - [布置-new](#布置-new)
    - [关于内存不足时的错误处理动作](#关于内存不足时的错误处理动作)
    - [无异常 new](#nothrow-new)
  - [delete](#delete)
  - [new/delete vs. malloc/free](#newdeletevsmallocfree)
- [类](#类)
  - [访问权限符](#访问权限符)
  - [this-和-base](#this-和-base)
  - [类中的成员的声明和定义](#类中的成员的声明和定义)
  - [成员函数和函数指针](#成员函数和函数指针)
  - [构造函数](#构造函数)
    - [拷贝构造函数](#拷贝构造函数)
    - [移动构造函数](#移动构造函数)
    - [编译器自动添加的拷贝构造函数和拷贝复制运算符](#编译器自动添加的拷贝构造函数和拷贝复制运算符)
    - [拷贝移动消除](#拷贝移动消除)
    - [explicit关键字](#explicit关键字)
    - [构造函数中的初始化参数列表](#构造函数中的初始化参数列表)
  - [析构函数](#析构函数)
  - [关于类中的静态成员](#关于类中的静态成员)
    - [静态成员的声明和实现](#静态成员的声明和实现)
  - [常函数和常对象](#常函数和常对象)
    - [常函数](#常函数)
    - [常对象](#常对象)
    - [mutable](#mutable)
  - [类的前置声明](#类的前置声明)
  - [继承](#继承)
    - [继承的内存模型](#继承的内存模型)
    - [子类和父类实例的释放顺序(析构函数的调用顺序)](#子类和父类实例的释放顺序(析构函数的调用顺序))
    - [当子类的析构函数被调用了后，它里面的内存是真的被清空了吗？](#当子类的析构函数被调用了后，它里面的内存是真的被清空了吗)
    - [显示指定父类构造函数进行父类成员的初始化工作](#显示指定父类构造函数进行父类成员的初始化工作)
    - [引用父类中的成员](#引用父类中的成员)
    - [里式转换](#里式转换)
    - [菱形继承](#菱形继承)
    - [虚继承](#虚继承)
    - [虚函数](#虚函数)
      - [如何编写虚函数](#如何编写虚函数)
      - [虚函数的内部实现](#虚函数的内部实现)
    - [虚析构](#虚析构)
    - [纯虚函数](#纯虚函数)
    - [是否可以使用私有成员来实现虚函数或虚析构](#是否可以使用私有成员来实现虚函数或虚析构)
    - [友元成员](#友元成员)
- [函数的扩展](#函数的扩展)
  - [内联函数](#内联函数)
    - [内联函数的定义](#内联函数的定义)
  - [函数的参数默认值](#函数的参数默认值)
  - [函数的重载](#函数的重载)
- [运算符重载](#运算符重载)
  - [什么是运算符重载函数](#什么是运算符重载函数)
  - [运算符重载的使用事项](#运算符重载的使用事项)
  - [各运算符重载时的约束](#各运算符重载时的约束)
- [模板](#模板)
  - [模板的声明](#模板的声明)
  - [指定模板的虚拟类型 T](#指定模板的虚拟类型)
  - [指定虚拟类型 T 的默认类型](#指定虚拟类型的默认类型)
  - [类模板使用默认类型时存在的限制](#类模板使用默认类型时存在的限制)
  - [模板成员的声明与实现](#模板成员的声明与实现)
  - [模板机制](#模板机制)
    - [函数模板](#函数模板)
    - [类模板](#类模板)
    - [模板中使用友元](#模板中使用友元)
- [类型转换](#类型转换)
  - [静态类型转换](#静态类型转换)
  - [动态类型转换](#动态类型转换)
  - [常量类型转换](#常量类型转换)
  - [重定义转换](#重定义转换)
- [异常](#异常)
  - [异常捕获](#异常捕获)
  - [抛出异常](#抛出异常)
  - [关于 catch 块中所声明的异常类型的效率问题](#关于catch块中所声明的异常类型的效率问题)
  - [系统标准异常接口](#系统标准异常接口)
- [lambda](#lambda)
  - [lambda表达式的构成](#lambda表达式的构成)
  - [lambda表达式与函数指针](#lambda表达式与函数指针)
- [自动推导类型](#自动推导类型)
  - [auto](#auto)
  - [decltype](#decltype)
- [智能指针](#智能指针)
  - [auto_ptr](#auto_ptr)
  - [unique_ptr](#unique_ptr)
  - [shared_ptr](#shared_ptr)
  - [weak_ptr](#weak_ptr)
- [STL](#STL)
  - [容器](#容器)
    - [string](#string)
    - [vector](#vector)
    - [deque](#deque)
    - [stack](#stack)
    - [queue](#queue)
    - [list](#list)
    - [pair](#pair)
    - [set/multiset/unorder_set](#set)
    - [map/multimap/unorder_map](#map)
  - [仿函数](#仿函数)
  - [适配器](#适配器)
    - [仿函数适配器](#仿函数适配器)
    - [取反适配器](#取反适配器)
    - [函数适配器](#函数适配器)
    - [成员函数适配器](#成员函数适配器)
  - [算法](#算法)
    - [遍历算法](#遍历算法)
    - [查找算法](#查找算法)
    - [排序算法](#排序算法)
    - [拷贝/替换/合并算法](#拷贝替换合并算法)
    - [算数生成算法](#算数生成算法)
    - [集合算法](#集合算法)
  - [迭代器](#迭代器)

<br/>

!!!
    <font color = "red">cpp 是对于 c 语言的一项扩展工作</font>，故其基本特性是直接沿用 c 语言而进行扩展的，这也就意味着，在 cpp 项目中，我们是可以书写 c 语言的代码(需要经过特殊的声明处理) ; 但是反过来却不行，在 c 语言的源文件中是无法使用 cpp 中的特性
    
    本篇文档主要是针对 cpp 所额外衍生出来的特性进行讲解，关于一些基本概念可以参考 [C-Programming-language](#https://github.com/NGPONG/document/blob/master/C/2019/12_18/C_Programming_Language.md)


<br/>

## Namespace

<span id="Namespace"></span>

<span id="命名空间的定义"></span>

### 命名空间的定义

---

cpp 引入了命名空间的概念以为了解决在 c 语言中所存在的成员命名重复的问题，其概念和其余的 OOP 语言类似，<font color = "red">一个命名空间下所声明的成员其所属的作用域范围则在该命名空间当中，需要使用它们，则需要显式的引入它们所在的命名空间</font>

```cpp
#include <iostream>
using namespace std;

namespace Number {
  int i = 10;
}

int main(void) {
  using namespace Number;
  cout << i << endl;
  
  cout << Number::i << endl;

  return EXIT_SUCCESS;
}
```

值得一提的是，<font color = "red">命名空间是允许嵌套命名空间而存在的</font>，那么相应的，作为内部被嵌套的命名空间其内部成员的作用域范围也仅在被嵌套的命名空间内部，我们对它的引用也同样需要经过多层的解析才能够完成

```cpp
#include <iostream>
using namespace std;

namespace Number {
  namespace Number_sub {
    int j = 40;
  }
  int i = 10;
}

int main(void) {
  using namespace Number::Number_sub;
  cout << j << endl;
  
  cout << Number::Number_sub::j << endl;

  return EXIT_SUCCESS;
}
```

此外，我们还可以<font color = "red">为命名空间添加别名，我们可以将该声明处置在任何作用域内，以组成我们所需要的作用域声明使用方式</font>

```cpp
#include <iostream>
using namespace std;

namespace Number {
  int i = 10;
}

namespace MyFunction {
  void foo_1(){
    namespace t_number = Number;
    cout << t_number::i << endl;
  };
}

namespace t_number = Number;
int main(void) {
  MyFunction::foo_1();
  
  cout << t_number::i << endl;

  return EXIT_SUCCESS;
}
```

<br/>

<span id="匿名命名空间"></span>

### 匿名命名空间

---

<font color = "red">匿名命名空间中的标识符只能在本文件内访问，其内部下所声明的所有东西(包括命名空间)都会扩展至当前编译单元基础上的全局作用域内，而不再是当前命名空间的作用域内</font>，这就<font color = "red">相当于为当前命名空间下的所有成员添加 'static' 关键字，_**并沿用其特性**_</font>

```cpp
namespace {
  int i = 10;
}
int main(void) {
  int z = i + 10;
  int y = ::i + 20;
}
```

<span id = "注意匿名命名空间下和全局命名空间下存在成员符号冲突的问题"></span>

需要注意的是，当匿名命名空间内存在某个成员的符号和全局命名空间下的某个成员一致，则在对该成员的调用过程中，会隐藏掉属于匿名命名空间下该成员的定义，并且，我们要保证对该成员的调用必须通过 :: 来完成(即引用全局命名空间)，否则会出现编译错误，因为直接使用成员名的时候引用的作用域会直接扩展至全局作用域，而全局作用域下由于这两个符号名是相同的，这时候就会出现二义性的情况，那么如果我们使用 :: 符号进行调用的话，会优先匹配匿名命名空间外的成员，虽然匿名命名空间外的成员和匿名命名空间内的成员同属一个全局作用域下，但是由于 :: 会优先匹配命名空间外的成员，故这里编译器会把它们两个暂时看作不同属一个作用域下，借助此机制我们可以完成对于声明在命名空间外的那个函数的调用工作

```cpp
#include <iostream>
using namespace std;

namespace {
  void fun_test(void) {
    cout << "anonymous scope" << endl;
  }
}

void fun_test(void) {
  cout << "global scope" << endl;
}

int main(void) {
  ::fun_test();

  return EXIT_SUCCESS;
}
```

<br/>

<span id="匿名命名空间中的-extern"></span>

### 匿名命名空间中的 extern

---

由于匿名命名空间内的所有成员都会添加上 'static' 关键字，所以当我们我们想对其中的某个成员的声明引入 'extern' 关键字，使之声明扩展至其他的编译单元内的定义是无效的，并且，该成员即便使用了该关键字并且在找不到该声明所对应的定义时不会产生链接失败的问题(当在链接阶段在当前编译单元中如果找不到相符的定义，则以 static 的特性初始化这个变量的内存区)，唯一的作用可能就是能够通过该关键字把当前变量的声明修饰为能够在当前编译单元中寻找链接定义的符号

那么，假设一个匿名命名空间下存在某一个成员的声明，并且通过了 extern 关键字使之声明能够扩展至当前编译单元内寻找相符的符号定义时，我们要<font color = "red">保证对于该成员的调用使用了 :: 去引用全局作用域下的该成员的名字，否则会出现该成员的调用出现二义性的情况</font> ； <font color = "red">除此之外，我们要保证对于该成员调用之前，能够出现该声明所即将链接到的定义，否则会出现该声明未定义的情况</font>

```cpp
namespace {
  extern int i;
}

static int i = 0x400; /* static 关键字可加也可以不加 */

int main(void) {
  int y = ::i + 10;
}
```

<br/>

<span id="作用域"></span>

### 作用域

---

cpp 中更加深化了作用域的概念，<font color = "red">实际上这些概念也仅仅是作为在c语言中所出现的情景的一种更进一步的补充说明</font>(没有太多新的概念)，具体来说，cpp 把作用域划分了以下三种类型 : 

- 声明域$(declaration \:\: region)$: 声明标识符的区域，如在函数外面声明的全局变量，它的声明域为声明所在的文件 ; 在函数内声明的局部变量，它的声明域为声明所在的代码块
- 潜在作用域$(potential \:\: scope)$: 从声明点开始，到声明域的末尾的区域，简而言之就是对成员声明之前使用情况的一种说明，规范化了具体的这个潜在范围
- 作用域$(scope)$: 标识符对程序可见的范围，标识符在其潜在作用域内，并非在任何地方都是可见的。例如，局部变量可以屏蔽全局变量、嵌套层次中的内层变量可以屏蔽外层变量，从而被屏蔽的全局或外层变量在其倍屏蔽的区域内是不可见的,所以，一个标识符的作用域可能小于其潜在作用域
- 全局作用域和局部作用域: 这一点可以延续该[文档](#https://github.com/NGPONG/document/blob/master/C/2019/12_18/C_Programming_Language.md)的说明，这里不做过多的赘述

值得再次强调的是，<font color = "red">cpp同样需要遵循着编译器对代码段由上至下进行编译的规律</font>，举个例子，当我们在一个函数内使用了在全局作用域下的成员，当这个成员声明的位置在使用该成员的代码段的下面的话，那么编译的时候就会报错，如下面的代码

```cpp
int main(void){
  cout << a << endl; /* failure */
  cout << b << endl; /* failure */
  cout << c << endl; /* failure */
}
namspace TEST {
  int a = 1024;
}
namspace {
  int b = 256;
}
int c = 64;
```

<br/>

<span id = "显式的引用某一处的作用域"></span>

#### 显式的引用某一处的作用域

正因为命名空间概念的加入，我们才迫切的需要关注这个问题，需要使用某个成员的前提则需要提前先引入它所在的作用域，在 cpp 中如果具体规划下来引入作用域的花样十分之多，但是从宏观来细分的话，这些十分之多的花样都是基于两种语法规则所演变而来的，我们对一些不常见的引用方式只需了解即可，重点需要关注的是常用的引用方式上面

- using namespace x

  - 在当前文件的范围内引入一个作用域:

  ```cpp
  namespace Number {
    int i = 10;
  }

  using namespace Number;
  int main(void) {
    int y = i + 10;
  }
  ```

  - 在局部范围内引入一个作用域: 

  ```cpp
  namespace Num_1 {
    int y = 10;
  }

  namespace Num_2 {
    using namespace Num_1;

    int i = 10;
    void foo() {
      int z = i + y;
    }
  }

  int main(void) {
    using namespace Num_2;
    foo();
  }
  ```

  - 引入某个命名空间下的具体某个成员:

  ```cpp
  namespace Number {
    int i = 10;
    int y = 20;
  }

  using Number::i;
  int main(void) {
    int z = i + 10;
    y++; /* Error: Can't found [y] symbol */
  }
  ```

- ::

  - namespace:: : 引用到某个命名空间下的作用域，该方式通常在一段代码中直接获取一个命名空间下某个成员的定义

  ```c
  #include <iostream>
  using namespace std;
  
  namespace Number {
    int i = 10;
  }
  
  int main(void) {
    cout << Number::i << endl;
  
    return EXIT_SUCCESS;
  }
  ```

  - class:: : 该方式用于对类中的某个成员的声明亦或者某个特殊声明的成员进行定义亦或者使用它来访问一个类中具有公共权限静态类型成员

  ```cpp

  ```

  - :: : 引用到全局空间下的作用域
  
    - 由于匿名命名空间空间下的成员会提升至全局作用域，所以该语法同样也适合对于匿名命名空间下成员的调用，但是我们需要[注意匿名命名空间下和全局命名空间下存在成员符号冲突的问题](#注意匿名命名空间下和全局命名空间下存在成员符号冲突的问题)
  
  ```cpp
  #include <iostream>
  using namespace std;

  namespace {
    void fun_test_anonymous(void) {
      cout << "anonymous scope" << endl;
    }
  }

  void fun_test_global(void) {
    cout << "global scope" << endl;
  }

  int main(void) {
    ::fun_test_global();
    ::fun_test_anonymous();

    return EXIT_SUCCESS;
  }
  ```

<br/>

<span id="命名空间下成员的声明和定义"></span>

### 命名空间下成员的声明和定义

---

这里着重介绍的是关于函数的声明和定义，对于一个命名空间下仅出现某个函数的声明的情况，我们还需对其进行重定义，重定义的方式只需要引用到具体某个命名空间然后针对该函数进行定义即可

```cpp
namespace foo {
  void foo_fun(void);
}

void foo::foo_fun(void) {
  int i = 10;
}

int main(void) {
  foo::foo_fun();
}
```

<br/>
<br/>

## 表达式和值类别

<span id="表达式和值类别"></span>

<span id = "表达式"></span>

### 表达式

---

<font color = "red">由运算符$(operator)$和运算对象$(operand)$ 构成的计算式(单独的运算对象也能够构成一个表达式)，在编程语言中，函数的返回值也被认定为一种表达式</font>

从宏观来说，表达式通常指的是一个算式的整体，但是从微观上来说，我们同样可以认为一个算式中的某一个单元也属于一种表达式，如下面的代码

```cpp
int fun_test(char *str) {     /* str 是一个表达式 */
  printf("%s\n",str);         /* printf("%s\n",str) 是一个表达式，"%s\n" 是一个表达式，str 是一个表达式 */
  return 0;                   /* 0 是一个表达式，result:int temp = 0 是一个表达式 */
}
int main(void) {
  int i = 10;                 /* 10 是一个表达式，i 是一个表达式 */
  char *str = "Hello,World!"; /* "Hello,World" 是一个表达式，str 是一个表达式 */
  int result = fun_test(str); /* str 是一个表达式，fun_test(str) 是一个表达式，result 是一个表达式 */
  return EXIT_SUCCESS;
}
```

表达式是可求值的，对表达式求值将得到一个结果$(result)$，这个结果有两个属性：类型和值类别$(value categories)$，也就是说上面代码中对于每一块所注释起来的表达式他都有属于它的类型和值类别这两种属性，对于类型属性来说，无非就是最终 $result$ 的类型，而对于值类别属性来说，就需要深入的进行探讨了

<br/>

<span id = "值类别"></span>

### 值类别

---

在 cpp11 以后，表达式按值类别分，必然属于以下三者之一: 
- 左值$(left \:\: value,lvalue)$
- 将亡值$(expiring \:\: value,xvalue)$
- 纯右值$(pure \:\: rvalue,pralue)$

其中，左值和将亡值合称泛左值$(generalized \:\: lvalue,glvalue)$，纯右值和将亡值合称右值$(right \:\: value,rvalue)$

在开始前需要重点强调的是，对于左值和右值一个最常见的误解就是 : 等号左边的就是左值，等号右边的就是右值。当然如果把这一点套用在c语言中是没有什么问题的，而cpp为了更具体的细化在c语言中所出现的 **_具名的变量_** 和 **_无名临时变量_** 的关系，所以引出了左值和右值的另一种概念

<br/>

<span id = "左值"></span>

#### 左值

<font color = "red">求值结果 $result$ 的类型是一个具名的对象则为存左值表达式，作为一个左值，其必定会存储在内存中的具体某个位置</font>，如下面常见的几种表达式则为左值表达式

- 具名变量(包括函数的形参)
- 函数指针
- 返回值类型为 **_左值引用_** 的函数调用
- 前置运算符
- 由赋值运算符或复合赋值运算符连接的表达式(a=b, a+=b, a%=b, etc)
- 解引用表达式
- 字符串字面值("abc")

由于左值表达式的求值结果都是以具名的变量所存在，故对于左值表达式而言，其<font color = "red">生命周期会延续到当前左值表达式最原始声明处的栈帧弹出(函数调用完毕)而随之被释放</font> ，但是这里有一个小小的不同，即 **_返回值类型为左值引用的函数调用_** 这一项

作为函数调用这一功能性质而言，它的确能够作为一个左值表达式而存在，但是其返回值同样还需要构造处一个 **_不具名的临时变量_** 以作为函数的返回值，既然是不具名的临时变量那不是符合一个 **_纯右值表达式_** 的定义吗？

其实当函数的返回值类型为一个 **_左值引用_** 的时候，编译器虽然能把该调用构造成一个左值表达式，但它只是作为<font color = "red">符合当前语境的一个左值而存在</font>，简而言之，<font color = "red">我们能够使用该函数调用的返回值所构造出来的无名的临时变量去绑定一个新的变量亦或者已经被实例化过的变量去构造出一个初始化变量的拷贝语境(使用左值去初始化一个对象或为一个已实例化好的对象进行赋值的时候，会调用所操作的对象类型的拷贝构造函数以完成初始化工作)</font>，当这个函数调用所构成的左值表达式在完成这项拷贝语境的使命工作后，其返回值所构造的临时变量同样也会作为一个临时变量本身被编译器认定为已是一个无效值，即函数调用完成后临时变量也就会随之进行释放

当我们使用一个左值表达式去绑定(初始化)一个新的变量亦或者一个已经经过实例化的变量时，会调用目标变量的拷贝构造函数亦或者拷贝赋值运算符(如没另外声明，则会调用默认自带的)以拷贝语义的方式把左值表达式在内存中的数据拷贝到目标变量身上

<br/>

<span id = "右值"></span>

#### 右值

<font color = "red">右值大多数情况下都会存储在寄存器当中，当然也有少数的情况会存储在内存当中</font>，具体来说，右值又能够细分出 **_纯右值_** 和 **_将亡值_**

<font color = "red">右值表达式的求值结果都是以无名的临时变量所存在</font>，故对于右值表达式而言，<font color = "red">其生命周期通常在右值表达式的诞生之初就需要面领着被销毁的风险</font>，除非在右值表达式即将要被销毁前，显式的把当前右值表达式把它在 寄存器/内存 中所存储的数据移动到具体某个变量身上(通过赋值运算符)，否则该右值表达式的存在则是毫无意义的，这里需要补充一下的是，<font color = "red">该销毁的机制其实是编译器所导致的，因为它会认为不管我们只是单纯的声明了这个无名的临时变量还是说用它来完成一次数据拷贝的工作，对于编译器而言他们在处理完这两项工作后还是没有继续存在的价值，故被销毁</font>，而 cpp 中由于新加入了 **_右值引用_** 的特性，故我们是有可能显式的把这个无名临时变量的地址绑定到一个可能长期需要使用到它的地方的，简而言之就是让编译器知道这个 无名的临时变量 在下面还有继续使用的价值，延长它的生命周期

当我们使用一个右值表达式去绑定一个新的变量亦或者一个已经经过实例化的变量时，会调用目标变量的移动构造函数亦或者移动赋值运算符(如没另外声明，则会调用默认自带的)以移动语义的方式把右值表达式在 寄存器/内存 中的数据移动到目标变量身上，当右值表达式完成了这项工作后，它也随之会被销毁(<font color = "red">除了显式的使用 move() 所构造的右值</font>)

_**纯右值 :**_

纯粹的字面值(不包含字符串)则为纯右值表达式，亦或者求值结果 $result$ 的类型是一个不具名的临时对象，如下面常见的几种表达式则为纯右值表达式
  - 不具名的变量

  - 字面值(1, false, etc)
  - 返回值类型为 **_非引用类型_** 的函数调用
  - 后置运算符
  - 算术表达式(a+b, a&b, a<<b, etc）
  - 逻辑表达式(a&&b, a||b, ~a, etc)
  - 比较表达式(a==b, a>=b, a<b, etc)
  - 取地址表达式(&a)
  - 匿名对象
  - $new$ 操作符所构造的对象
  - 强制类型转换表达式(强制类型转换的过程会产生一个新的、不具名的、当前强制转换类型的临时的变量，并把这个临时变量中的数据 **_"移动"_** 到目标变量的身上)

**_将亡值 :_**

值得一提的是，在 C++11之前的右值 和 C++11中的纯右值 是等价的，正因为 C++11 中的 **_右值引用_** 的加入才导致了将亡值诞生，也就是说，将亡值与右值引用息息相关，所以将亡值表达式也仅仅会出现在包含右值引用的上下文当中，如下面几种常见的表达式

  - 返回右值引用的函数的调用表达式

  - 转换为右值引用的转换函数的调用表达式(move函数)

<font color = "red">事实上，将亡值不过是 C++11 提出的一块晦涩的语法糖，它与纯右值在功能上及其相似</font>，如，都不能做操作符的左操作数，使用它们在条件允许的范围之内(非普通的左值引用类型的成员，因为普通的左值引用无法绑定右值)去初始化一个对象亦或者赋值一个已有的对象时都会调用所操作对象的移动构造函数或者移动赋值运算符(**_移动语义_**)来完成对象的初始化工作，并且由于它们的求值结果 $result$ 都为一个无名的变量，就意味着不管是 纯右值 也好还是 将亡值，它们都存在着一个将要被销毁的临界点，所以我们不必刻意区分一个右值到底是纯右值还是将亡值

<br/>

<span id = "值类别小结"></span>

### 小结

---

作为左值而言，其表达式求值是作为一个具名的变量所存在，它必定会存储在内存当中，而对于右值而言，其表达式求值是作为一个无名的临时变量所存在，它有可能会存储在寄存器当中也有可能是存储在内存当中，通过这一特性，我们可以通过一个很便捷的方式去快速区分一个表达式到底是左值还是右值，那就是: <font color = "red">如果一个表达式的求职结果能够取地址，则该表达式为一个左值表达式，否则为右值表达式</font>

上面所说的这么多的关于左值还是右值的判断依据其实是以一个宏观概念上来对一个表达式所做的判定的，考虑下面的代码，我们声明了一个函数 `foo` 返回值类型为右值引用，也就意味着该函数的调用其是作为一个右值(将亡值)表达式而存在，由于他所返回的是一个引用类型，其实也就是一个当前所引用的类型的指针，当我们在代码里通过 `return (Person &&)per` 的时候，其实也就意味着该函数返回值所构造出来的类型为 `Person && (Person *)` 的临时变量数据则为 `per` 在内存中的首地址(强制类型转换后会创建一个当前所转换类型的无名临时变量，又因为它是一个右值表达式并且需要绑定给返回值类型为 `Person &&` 无名临时变量，也就意味着强制类型转换所构造出来的临时变量的数据需要通过移动语义把数据移动到返回值所构造出来的临时变量身上，故，返回值所构造的临时变量其实最终就是 `per` 在内存中的首地址)，那么这时，当函数调用完毕后，由于其返回的临时变量为 `Person &&(Person *)`，当我们直接使用它的时候，编译器会为它做一次隐式的解引用操作，那么我们可以姑且认为这个解引用的代码为 : `*per_ret_temp`，那么问题来了，这里作解引用操作是判定一个左值的标准，但是否就意味着 `Person per_new = fun_test(per)` 的操作会调用 `Person` 类的拷贝构造以完成 `per_new` 的初始化操作呢？答案是否定的，<font color = "red">虽然编译器为我们所做的解引用操作是作为一个左值的判定标准，但是它本身就是通过一个右值表达式(函数的调用)所延伸出来的，故这里还是作为一个右值来看待，所以最终的结果是调用 `Person` 类的移动构造函数以完成 `per_new` 的初始化工作(当我们使用一个右值表达式去绑定一个新的变量亦或者一个已经经过实例化过的变量时，会调用目标变量的移动构造函数亦或者移动赋值运算符，以移动语义的方式把右值表达式在 寄存器/内存 中的数据移动到目标变量身上)</font>

```cpp
class Person {
public:
  /* Person constructor */
  Person(int age)
      : m_age(age) {
      cout << "Person constructor" << endl;
  };  
  /* Perosn copy constructor */
  Person(Person &per) {
      this->m_age = per.m_age;
      cout << "Person copy constructor" << endl;
  };  
  /* Person Move constructor */
  Person(Person &&per) {
      this->m_age = per.m_age;
      per.m_age = 0x0;
      cout << "Person move constructor" << endl;
  };  
  /* Person destructor */
  ~Person() {
      this->m_age = 0x0;
      cout << "Person destructor" << endl;
  };

public:
  int m_age;
};

Person &&foo(Person &per) {
  per.m_age = 0x100;
  return per;
}
int main(void) {
  Person per(0x400);
  Person per_new = foo(per);
}
```

其实通过这个例子，需要我们注意的就是一个问题，<font color = "red">我们判定一个表达式到底是右值还是左值的时候，需要以宏观的方式去看待，不能以微观，细分的方式去看待</font>，在上面，`foo(per)` 由于返回值类型为 `Person &&` 那么它的调用就必定是一个右值（亡值），而不能具体到在使用它所返回的临时变量做解引用操作(`*per_ret_temp`)的标准去看待

此外，还有重点强调一点的是，<font color = "red">区分一个表达式具体是左值还是右值我们不能单纯的以该表达式具体的类型来区分，可能外表看上去相同的一个表达式，但是它确在不同状态下都呈现着不同的值类别</font>，就拿 右值引用 来说，我们所声明并初始化好的右值引用的表达式在正常状态下都呈现着左值的性质，而当我们把这个右值引用用作于函数的返回值返回时，虽然返回值所构造出来的右值引用的声明和我们在刚刚所说的在通常状态下所声明的右值引用的表达式是一致，但是右值引用作为函数返回值的话，那么这个函数的调用就为

<br/>
<br/>

## 引用

<span id="引用"></span>

当一个类型的声明使用了 `&` 操作符进行修饰后，那么我们所声明的变量就是一种类型为(左值/右值/转发型)引用 的变量，作为一个引用变量而言，我们对它的使用完全可以当成该引用变量在初始化时所绑定的变量来使用，也就是说我们针对引用变量所做的修改都会映射到在初始化时作为绑定方变量的修改(<font color = "red">它们所指向的是同一块内存地址</font>)

声明一个具体的引用变量也是非常的简单，我们仅需要<font color = "red">构造一个预期所需要绑定的类型再配合 `&` 操作符去构造一个具体的引用类型变量，并让它去绑定一个该引用变量所需引用的成员即可，</font>，需要注意的是，<font color = "red">引用变量初始化的过程中，引用变量所绑定的成员类型必须为引用变量所引用的类型，否则会导致编译错误</font>，如下面的代码，其声明了一个 int 类型的 **_左值引用_** 以完成一个最基本的引用绑定操作

```cpp
int main(void) {
    int a = 0x400;
    int &a_ref = a;
}
```

引用变量是需要区分类型的，具体细分来说有两种类型
- 这个引用变量本身的类型
- 这个引用变量所引用的类型

比如我们我们初始化了一个右值引用变量为 : `int &&a_ref = 1024`，那么这个引用变量的类型则为 : `int &&`，它所引用的类型则为 : `int`

需要注意的是，<font color = "red">引用变量一经声明就必须进行人为的初始化定义</font>(除了函数形参)，我们无法像普通变量一样仅仅只是对一个引用变量做一个声明，而其定义交由编译器来完成，因为对于引用变量而言，编译器是无法知道这个引用变量具体是需要绑定哪个成员

<br/>

### 引用变量的本质

---

<span id = "引用变量的本质"></span>

引用的本质其实就是一个指向了所绑的成员在内存中的首地址的所引用类型的指针，当然这是编译器为我们隐式所做的工作，其存在目的是为了减少指针定义和频繁的解引用操作，我们完全可以把它当成是使用指针的一种语法糖形式

- 当我们声明一个引用变量的时候，作为该引用变量所绑定的成员(右操作数)，编译器都会为其添加一个取地址 `&` 操作符以取该成员的地址，相对的，我们所声明的引用变量会被编译器改写为当前所引用成员类型的指针变量

- 当我们使用一个已经经过初始化好的引用变量的时候，编译器都会为我们所使用的引用变量添加上解引用 `*` 操作符以对该引用变量实质的指针进行解引用操作

```cpp
int main(void) {
    int a = 10;
    int &a_ref = a; /* int * a_ref = &a; */
    a_ref = 1024;   /* *a_ref = 1024; */
}
```

一个很好的建议是，我们无需强塞指针的概念进到引入身上，我们大可将他当成是对于某一个变量的一个 **_别名_** ，我们完全可以把所声明的引用变量来作为引用所绑定的成员来使用，引用的本质的确是一个指向所引用变量在内存中首地址的指针，但是强加指针的概念进去引用只会导致代码的阅读困难，并且这种做法也违背了设计者最初的设计观念 : 创建引用最核心的一个目的就是简化对于指针操作的繁琐性

引用变量一经初始化好后，我们就无法在改变该引用最原始的绑定关系，即不能再改变该指针指向其他地址(不能再让引用变量再去引用去他变量在内存中的首地址)，原因是因为<font color = "red">没有语法支持我们做这种操作</font>，当我们直接使用一个已经定义好了的引用变量再去进行赋值操作的时候，这时候编译器都会为我们所使用的引用变量添加上 * 操作符以对该引用变量实质的指针进行解引用操作，也就是说我们实际上是无法真正的访问到该引用变量所绑定的成员在内存中的首地址的，既然无法访问到它的首地址那就意味着我们无法显式改变该引用变量的本质指针所存储的地址，为了更好理解，我们也可以姑且认为，一个引用变量在被定义好了以后，其真正的形态是一个 **_"指针常量"_** `int const * ref`，<font color = "red">需要注意的是，这里只是举个例子，并不是意味着引用变量在定义好了以后无法再去改变其所绑定的成员的原因是由于其本质是指针常量所导致的，而是因为本身的语法不支持我们做这种操作</font>

引用的本质就是一个指向当前所绑定成员的所引用的类型的指针，也就是说当我们的函数返回值类型为一个引用类型，并且我们也是正确的返回了一个所引用类型实例时，函数返回值所构造出来的引用类型(所引用类型的指针)的临时变量所存储的数据则为我们所返回的在 当前函数作用域内的某个变量的实例亦或者一个单纯的右值表达式(返回值的引用类型为右值引用)，即一个无名的临时变量在内存中所存储的首地址，由于该地址所指向的某个类型的实例是在当前栈帧内所被构造出来，也就意味着在函数调用完毕后，栈帧出栈后，该地址所指向的变量也会随之被释放掉，简而言之，返回值所构造出来的类型为引用类型的无名临时变量在最终会指向一个无效且不安全的地址，关于这个无效的地址在不同编译器上的实现会有所不同，就 `msvc` 而言，该临时变量内部所存储的还是作为函数返回值实例在内存中的首地址，只是该地址所指向的内存段已经是一个失效的状态，而对于 `gcc` 而言，`gcc` 会认为临时变量内部所存储的地址已经指向的是一个无效的数据，故使用 0 来替换掉临时变量内部所存储的数据，也就意味着作为左值引用所呈现出来的指针内部所存储的地址则变为 0 的无效地址，<font color = "red">简单而言就是，我们对于一个函数返回值是引用类型的时候需要格外注意，其安全程度和指针类型相同</font>


<br/>

<span id = "左值引用"></span>
### 左值引用

---

左值引用的出现是为了解决 **_拷贝语义_** 的问题，当引用变量的类型被声明为 : `Type &` 时，那么这个引用变量就是一个左值引用

<font color = "red">对于左值引用而言，它只能够绑定一个左值，并且无论其声明在任何地方，都是作为一个左值表达式而出现</font>

当一个左值引用添加了 `const` 关键字后就是一种特殊的左值引用，该<font color = "red">特殊左值引用除了可以绑定一个左值作为引用外，还可以绑定一个右值</font>

```cpp
#include <iostream>
using namespace std;

int main(void) {
  int a = 0x400;

  int &l_ref = a;
  l_ref = 0x100;
  cout << a << endl;

  const int &l_c_ref = move(l_ref);
  cout << l_c_ref << endl;

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "右值引用"></span>

### 右值引用

---

右值引用的出现是为了解决 **_移动语义_** 的问题，当引用变量的类型被声明为 : `Type &&` 时，那么这个引用变量就是一个右值引用

<font color = "red">对于一个右值引用而言，它只能够绑定一个右值</font>，需要注意的是，<font color = "red">右值引用没有像左值引用一样可以通过 `const` 关键字去修饰一个即可以绑定左值又可以绑定右值的右值引用</font>

<font color = "red">一个右值引用的变量可能会因为他所处的状态不同而呈现出不同的值类别</font>，就单纯的声明并初始化了一个 右值引用 来说，他是作为一个左值表达式而存在，即存在潜在的拷贝性，这种情况下我们可以称这个右值引用为一个 **_有名右值引用_**，而当一个右值引用作为函数参数返回亦或者执行了一个返回右值引用的类型转换时，它是作为一个右值表达式而存在，即存在潜在的移动性，我们也会称这种情况的右值引用为一个 **_无名右值引用_**

其实对于右值引用来说，不管有名还是无名也好，我们无需刻意的去区分它们，<font color = "red">因为本身是否有名的右值引用的特性是延续 左值/右值 的特性所诞生的</font>

最好还要说明一下，我们都知道，作为一个右值表达式通常都需要经历一个 无名的临时变量 的转换过程，即，这个无名的临时变量在被创建之初就需要面领着被释放的风险，除非在右值表达式即将要被销毁前，显式的把当前右值表达式所存储的数据移动到具体某个变量身上，使这个右值表达式变得有意义，而这种初始化的工作往往是调用目标变量所拥有的 移动构造/移动赋值运算符 来完成的，那么假设目标变量是一个非常庞大的变量，<font color = "red">虽然对于移动语义来说是能够一定程度上降低拷贝语义所带来的性能开销，但并不意味着就能够忽视掉使用了移动语义后也会带来的一定程度上的性能损耗，其实也就意味着每一次移动都会带来一定程度上的性能损失</font>，而由于 右值引用 是能够接受一个右值的，并且对于 引用初始化 来说，编译器都会隐式的帮我们取绑定目标实例在内存中的首地址以完成引用初始化的工作，那其实也就意味着，<font color = "red">我们使用一个右值引用去接收绑定一个右值表达式的时候，其性能开销仅仅存在于一个小字节的地址移动身上(编译器取绑定目标的地址，也就是意味着仅仅只是把地址的数据移动到右值引用其本质指针所存储的内存段当中)</font>

此外，更有意思的是，因为右值表达式的求值结果通常都为一个 无名的临时 变量，而我们使用右值引用由于能够接收一个右值的绑定，当我们使用一个右值引用去接收一个右值表达式的时候，编译器会取作为右值引用所绑定的成员在内存中的地址，而这个成员作为右值表达式其实其求值结果就是一个 无名的临时变量，当编译器意识到这个 临时无名的变量 的内存地址有另外的引用的情况下它就不会再去释放这个无名的临时变量，也就意味着这个临时变量的生命周期不再是自声明之初就需要面领着被销毁的风险，而是会延续到当前栈帧的弹出 ( 无名临时变量也是在当前栈帧中所构造 ) 而随之销毁，我们也可以简单地理解为<font color = "red">右值引用能够隐式的延续右值表达式的生命周期</font>

```cpp
int main(void) {
  int &a_ref = 0x400;
}
```

<br/>

<span id = "左右值引用的函数重载策略"></span>

### 左右值引用的函数重载策略

---

在函数重载的形参为 左值/右值引用 时候，当发生二义性调用，那么编译器会根据当前所录入的实参的值类别去匹配一个最符合的函数以完成调用，如下面的代码，一组函数的重载中，其一的形参为 常量左值引用 类型，其二函数的形参为 右值引用 类型，这时候就会出现二义性了，因为形参类型为 常量左值引用 的函数和形参类型为 右值引用 的函数同样都可以接受一个 右值表达式 实参的输入，但是我们真正的去输入一个右值表达式去调用该函数的时候，编译器会优先匹配至形参类型为 右值引用 的函数调用，因为形参类型为 右值引用 的函数才是最符合当前所录入的实参值类别的

<font color = "red">下面的代码虽然是以普通函数重载的形式所展现，但是这一特性更多的是应用在一个类中的 拷贝/移动构造 或者 拷贝/移动赋值运算符 当中</font>

```cpp
void foo(const int &a_ref) {
  cout << "const lvalue reference" << endl;
}
void foo(int &&a_ref) {
  cout << "rvalue reference" << endl;
}
int main(void) {
  foo(0x400);
  return 0;
}
```

<br/>

<span id = "数组引用"></span>

### 数组引用

---

数组引用的方式和数组指针的定义方式类似，也是通过 `()` 来提升 `&` 操作符的优先级，使引用变量的类型组合成一个数组类型

```cpp
#include <iostream>
using namespace std;

int main(void){
  int arrary[10] = { 0 };
  int (&arrary_ref)[10] = arrary;
  
  for (size_t i = 0; i < sizeof(arrary_ref) / sizeof(*arrary_ref); i++) {
      arrary_ref[i] = 10 + i;
  }

  for (size_t i = 0; i < sizeof(arrary) / sizeof(*arrary); i++) {
      cout << arrary[i] << endl;
  }

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "指针引用"></span>

### 指针引用

---

<font color = "red">指针引用的本质其实就是一个多级指针</font>，指针引用也是通过 `()` 来提升 `&` 号的作用域即可，其类型则为 _指针类型_，事实上，其实我们是不是用 `()` 来提升优先级都无所谓，因为 `&` 的优先级总是比 `*` 号要高，不过加上 `()` 后代码的可读性会更高一点

```cpp
#include <iostream>
using namespace std;

int main(void) {
  int a = 10;
  int *p = &a;

  int *(&p_ref) = p;
  *p_ref = 1024;

  cout << a << endl;

  return EXIT_SUCCESS;
}
```

<br/>
<br/>

## 常量的增强

<span id="常量的增强"></span>

在c语言中，对于声明在局部作用域的常量我们是可以通过指针来完成间接修改常量的值的，而在cpp中，对于常量的功能进行了增强，使某些情况下是禁止使用指针来完成间接修改的操作，以保证了该关键字的正确性

- 对于声明在全局作用域下抑或是某个命名空间但不是类的内部的常量是无法通过指针来完成间接修改的，因为他们都存储在内存的只读段当中

- 对于声明在局部作用域下的常量

  - 使用 **_字面值(立即数)_** 所初始化得常量(不包括自定义类型)，无法通过指针来完成间接修改的，原因是因为使用字面值所初始化的常量其实从头到尾都没有被分配过内存，它都由一张 **_键值对形式的符号表_** 来进行维护，每当这种类型常量声明过后会存储在这张符号表里，常量名为 **_键_**，以常量值为 **_值_**，当我们通过 `&` 去获取常量的地址的时候，编译器会额外分配一个无名的临时变量并把符号表中所存储的值拷贝至临时变量以完成初始化工作，然后 `&` 操作符所操作的成员会替换为刚刚所声明的那个无名的临时变量，也就意味着我们是永远无法取到使用字面值绑定的常量其在内存中真实的首地址的，也就意味着不能通过指针完成对它间接修改得目的，但是对于刚刚编译器所临时分配得那个变量还是可以修改的，原因是因为他存储在栈中，尝试以下代码

  ```cpp
  #include <iostream>
  using namespace std;

  int main(void) {
    const int a = 10;

    int *p = (int *)&a;
    *p = 1024;

    cout << a << endl;  // 没有被修改，因为指针所指向的地址并不是 a 真正的地址
    cout << *p << endl; // 被修改了，但是被修改的是编译器所临时分配的变量，我们看不见，但是它的确在编译后会存在

    return 0;
  }
  ```

  - 对于使用变量来完成局部作用域下的常量初始化亦或者是常量的类型为自定义类型的常量都和 c 中的常量的特性一致，我们都可以通过指针来完成对常量的简介修改

```cpp
#include <iostream>
using namespace std;

const int c_1 = 10;   /* Real const var */

namespace {
  const int c_2 = 10; /* Real const var */
}

int main(void) {
  const int c_3 = 10; /* Real const var */

  int c = 10;
  const int c_4 = c;  /* Fake const var */

  /* replace 1,2,3,4 to test */
  int *p = (int *)&::c_x; 
  *p = 0x400;
  cout << ::c_x << endl;

  return EXIT_SUCCESS;
}
```

<br/>
<br/>

## 类型赋值

<span id="类型赋值"></span>

在 CPP 中，细化了构造变量的方式


<span id="匿名对象"></span>
### 匿名对象

---

匿名对象的初始化通过语法 <font color = "red">type(value)</font> 来完成，其作为一个表达式中的右操作数存在

- 当匿名对象所指定的数据类型为 **_基础数据类型_** 时，`()` 内的值则直接录入到所创建的变量所处的内存空间当中

- 当匿名对象所指定的数据类型为 **_自定义对象_** 时，`()` 内的值则可以充当函数形参的录入列表(编译器会根据所录入的形参自动匹配一个最佳的构造函数以完成对象的实例化)

<font color = "red">匿名对象所开辟的内存空间默认在栈上，并且它是一种 **_右值表达式_**，也就是说，它会产生一个临时的无名变量，等待着被移动至具体实例上</font>，在具体的使用上，我们经常能够看到匿名对象会作为一个变量初始化表达式的右操作数而存在，这也正体现了其所构造的临时无名变量被移动到具体实例的情景

事实上，匿名对象的创建编译器做了一定的优化工作，当我们使用匿名对象初始化一个变量的时候，因为匿名对象是一种右值表达式，所以理应会调用目标变量的 移动构造函数 去把匿名对象所创建的 无名的临时变量 在内存中的数据移动到目标变量身上，但是<font color = "red">编译器通常会把我们通过匿名变量初始化一个目标变量的代码优化成仅仅是使用一个 **_括号法_** 来完成</font>，意味着我们这段代码实际上仅仅只是会调用目标的构造函数以完成对象的初始化工作，例如 : `Person per = Person(0x400)` 最终会转化为 `Person per(0x400)` 的构造方式

```cpp
class Person {
public:
  char *m_name;
  Person(char *name) : m_name(name) {}
};

int main(void) {
  Person per = Person((char *)"Hello");
  int a = int(20);
  char ch = char('A');
}
```

这里需要注意的是，尽量不要让匿名对象单独出现在一段代码表达式之中，就基础数据类型而言，其所创建的无名临时变量得不到一个适合的容器进行移动，那么这个创建的工作也成为了无用功 ; 次之，对于自定义对象的类型，单独出现则会导致编译时发生重定义的错误，如下面的代码情景 :

```cpp
class Person {
public:
  int age;
  Person(int _age) : age(_age) {};
};

int main(void) {
  Person per(10);

  Person(per); /* fault */
}
```

<br/>

<span id="定义法"></span>

### 定义法

---

定义法即变量的声明，对于基础数据类型来说再熟悉不过，而对于存在构造函数的类型来说，使用定义法对于会自动的调用当前类型无参的构造函数以完成类型的实例化操作

```cpp
class Person {
public:
  int age;
  Person() {};
  Person(int _age) : age(_age) {};
};

int main(void) {
  int i;
  char c;
  Person per;
}
```

<br/>

<span id="隐式法"></span>

### 隐式法

---

隐式法即使用一个具体的值亦或者实例去初始化一个变量，对于基础数据类型不进行探讨，而对于存在构造函数的类型来说，指定的 **_'值'_** 则会匹配到当前类型中构造函数的形参列表最相符的构造函数并调用(当有多个形参则用 `{ }` 来表示)

```cpp
class Person {
public:
  int age;
  char gender;
  Person() {};
  Person(int _age) : age(_age) {};
  Person(int _age, char _gender) : age(_age), gender(_gender) {};
};

int main(void) {
  int i = 0x400;

  Person per_1 = i;

  Person per_2 = { i, 'A' };
}
```

<br/>

<span id="括号法"></span>

### 括号法

---

括号法通过语法 <font color = "red">类型 变量名(值)</font> 来完成一个变量的初始化，它作为一段代码表达式中独立的存在

- 当所指定的数据类型为 **_基础数据类型_** 时，`()` 内的值则直接录入到所创建的变量所处的内存空间当中

- 当所指定的数据类型为 **_自定义对象_** 时，`()` 内的值则可以充当函数形参的录入列表(编译器会根据所录入的形参自动匹配一个最佳的构造函数以完成对象的实例化)

需要注意的是，<font color = "red">我们不要使用括号法来调用无参的构造函数来完成类的实例的创建</font>(应该使用 **_声明法_** 来完成)，因为这会让编译器误认为我们这段代码所做的是一次函数的声明，即一个返回值为具体类型函数名为变量名的无参函数声明

```cpp
class Person {
public:
  int age;
  char gender;
  Person() {};
  Person(int _age) : age(_age) {};
  Person(int _age, char _gender) : age(_age), gender(_gender) {};
};

int main(void) {
  int i(0x400);

  Person per_1(i);

  Person per_2(i, 'A');
}
```

<br/>

<span id="new"></span>

### new

---

new 是一个修饰语义，它是一种 **_运算符_**，其语义可以拆分为 : <font color = "red">new 类型声明方式</font>，它通常<font color = "red">用于修饰一个匿名对象亦或者一个具体的类型的创建</font>，并作为一段代码表达式中的右操作数而存在，一个完整的 new 表达式整体来说干了三件事情 :

- 根据它所修饰的 **_匿名对象亦或者具体类型_** 的长度(大小)在 **_自由存储区_** $(free \:\: store)$ 中创建一段相应长度的内存空间并判断是否成功创建，<font color = "red">当自由存储区的内存空间不足时，默认行为下的 new 语义则是抛出一个异常以供上层捕获</font>

- 依据 new 关键字所修饰的 **_类型声明方式_** 去初始化 ( <font color = "red">通过调用构造函数的方式</font> ) 刚刚所创建的内存空间 ( <font color = "red">new 关键字所修饰的表达式可以是仅仅作为一个类型而存在</font>，当 new 所修饰的表达式仅仅是作为一个类型存在的时候，我们要保证相应的类型是存在默认的构造函数以供 new 在申请了一块堆空间后可供调用以初始化这块堆空间，否则会造成编译失败，对于这个默认的构造函数，通常值得我们考虑的仅为自定义对象这类的复合类型，对于基础数据类型的默认构造函数看编译器实现的不同而不同，但是通常都是初始化为 0 )

- 最后它会返回在堆中所创建的内存空间段的首地址 ( <font color = "red">new 关键字所修饰类型的指针</font> )

!!! info

    上面提到了 **_自由存储区_**，该区域其实是 c++ 中的一种抽象的概念，<font color = "red">它具体所指代的位置需要看编译器对 new 关键字的实现，它可以存在于 **_堆_** 中也可以存在于 **_静态存储区_** 中</font>

```cpp
class Test {
public:
  int id;

  Test() {}
  Test(int _id) : id(_id) {}
};

int main(void) {
  Test *test_1 = new Test(1);
  Test *test_2 = new Test;

  int *i = new int(0x400);

  return 0;
}
```

<br/>

<span id = "语义使用时必须要注意的问题"></span>

#### new 语义使用时必须要注意的问题

使用 new 语义所创建的对象(拥有动态存储期的对象)，其生命周期持续到使用 `delete` 语义释放掉 new 表达式所返回的指针位置，<font color = "red">我们要 new 所声明的空间总会配对一个 `delete` 对其进行释放，否则会造成内存泄漏</font>

值得一提的是，<font color = "red">new 表达式是一种 **_右值表达式_**</font>，即其在声明之初就需要面领着要被销毁的风险，如果我们并没有对其所创建的临时无名变量在内存中所存储的数据(即堆中的内存地址)进行显式的移动亦或者引用的话，那么该声明是毫无意义的，更严重的是，由于其是存在自毁的特性，但是自毁仅仅是自毁 new 表达式所构造出来的、初始化在栈上的 临时无名变量 的内存，并不意味着那块在堆中所申请的内存也会随同一起销毁，简而言之就是会存在野内存出现的情况(无法再拿到那个在 堆 中的地址，即无法再使用 delete 去显式的单堆那块内存进行释放)，如下面的代码 :

```cpp
class Test {
public:
  int id;

  Test() {}
  Test(int _id) : id(_id) {}
};

int main(void) {
  new int[1024]; /* Fault */
  new int(20);   /* Fault */
  new Test(1);   /* Fault */
  new Test;      /* Fault */

  return 0;
}
```

<br/>

<span id = "语义用于修饰一个数组类型的构造"></span>

#### new 语义用于修饰一个数组类型的构造

使用 new 表达式构造数组只需要在所修饰的 **_类型声明方式_** 后面加上数组长度标识符 `[]` 以声明数组的长度即可在堆中依据这个类型创建一个指定长度的内存空间并返回其在内存中的首地址，即: <font color = "red">new []</font>

既然所构建的对象数组使用的是 `new []` 语义所修饰，那么相应的，这块在堆中所构造出来的内存同样要使用 `delete []` 语义进行释放才行，<font color = "red">如果单纯的仅使用 `delete` 语义来完成释放工作的话，那么其仅仅只会释放这个数组的首元素所使用的内存，而后面下标的元素所占用的内存则会成为野内存</font>

需要注意的是，<font color = "red">当我们使用 new [] 去构造一个对象的数组时，new [] 所修饰的不能是一个匿名表达式，只能够是一个具体的类型，**_这也就意味着我们无法通过匿名表达式来指定具体的值或构造函数以完成堆这段内存空间的初始化操作_**，编译器仅仅只会帮我们为数组中的每一个成员赋予一个默认值或者是调用数组中每个元素对象默认的无参构造函数以完成对这段内存空间的初始化工作</font>

```cpp
class Person {
public:
  int id;

  Person() {}
  Person(int _id) : id(_id) {}
};

int main(void) {
  int *int_arrary = new int[10];
  delete []int_arrary;

  Person *per = new Person[3];
  delete[] per;

  return 0;
}
```

<br/>

<span id = "布置-new"></span>

#### 布置 new (Placement new)

布置 new 的语义为 <font color = "red">new (地址) 类型声明方式</font>

前面说到 new 语义在背后其实为我们做了三件事: 
- 在自由存储区中开辟一个新的内存空间

- 根据 new 所修饰 **_类型声明方式_** 的去初始化这段内存空间

- 返回这段内存空间的地址

<font color = "red">而布置 new 可以的跳过第一个步骤，即人为的指定一块内存地址来进行初始化 ; 可用于对一个没有初始化过的内存依照 **_类型声明方式_** 进行一次初始化工作，那么相对的，也可以对原有内存中的数据进行一次覆盖</font>

需要注意的是，<font color = "red">布置 new 所构造的表达式是能够允许单独出现的</font>，并且我们在某些场合下是可以不用 delete 的，这和单独的 new 关键字不同，原因在于单独的 new 语义所构建内存的空间必须在 自由存储区 当中，并且我们在初始情况下是不知道其所构造的内存段的首地址到底是多少，而反观 布置new，如果我们所指定的地址是在栈中的话那我们就无需手动的进行 delete 了，并且所指定的地址是由开发人员自己指定，故我们是能够追索到地址的原址的，是否因为 new 表达式的单独出现而导致无法追朔到所创建的内存段的地址而导致无法 delete 的问题由开发人员来决定了

最后一提的是，<font color = "red">placement new 不支持数组式 ( `new []` ) 的构造</font>

```cpp
class Person {
public:
  int id;

  Person() {}
  Person(int _id) : id(_id) {}
};

int main(void) {
  /* assigned in stack */
  int i = 10;
  new (&i) int(0x400);

  /* assigned in heap */
  Person *pers = new Person[10];
  for (size_t i = 0; i < 10; ++i) {
    new (&pers[i]) Person(i + 10);
  }

  return 0;
}
```

<br/>

<span id = "关于内存不足时的错误处理动作"></span>

#### 关于内存不足时的错误处理动作

为了能够满足程序的进一步健壮性，<font color = "red">当一段 new 语义在自由存储区中构造新的内存空间时如遇到内存空间不足等问题并即将抛出一个异常以反映一个未获得满足的需求之前，会先调用一个错误处理函数</font>，它就是 `new-handler`；在标准库中，它被定义为一个函数指针

```cpp
namespace std {
  typedef void (*new_handler)();
}
```

这个函数指针指向了一个由编译器所实现的无参无返回值的函数地址，当然我们也可以通过 `set_new_handler` 来手动的去改变默认函数的实现行为

```cpp
namespace std {
  new_handler set_new_handler(new_handler p) throw();
}
```

该函数能够通过我们自定义的 `new_handler p` 来覆盖无法分配内存时所需调用的默认实现，其返回值为 `new-handler` 被替换前的默认函数实现


<br/>

<span id = "nothrow-new"></span>

#### 无异常 new (nothrow-new)

[默认行为下的 new 语义](#new) 在遇到无法无法满足的需求时 ( 内存空间不足 ) 会抛出一个异常以供上层进行捕获，而另一个版本的 new 语义则能够避免这一行为，<font color = "red">在任何无法满足需求的情况发生时仅会返回一个空指针以指示异常行为的发生，这种 new 语义则为 `nothorw-new`，其依赖于头文件 `<new>` 并用作为 **_new (std::nothrow) 类型声明方式_**</font>

```cpp
#include <iostream>
#include <new>

class base {
public:
};

int main() {
  int *p = new (std::nothrow) int(1024);
  if (p == nullptr) {
    std::cout << "memory alloc error" << std::endl;
  }

  base *b = new (std::nothrow) base();
  if (b == nullptr) {
    std::cout << "memory alloc error" << std::endl;
  }

  return EXIT_SUCCESS;
}
```


<br/>

<span id="delete"></span>

### delete

---

delete 是一种关键字，其语义为 : `delete address` ; <font color = "red">delete 能够释放掉由 new 所构造出来的在自由存储区中的空间，并在**这段内存空间即将被释放前，会调用所构造实体的析构函数已完成 $Full \:\: delete$ 的工作** ( 如果是数组式构造 `new []`，则使用数组式释放 `delete []` 则会挨个调用数组中每个元素的析构函数 )，我们要保证每一个 new 语义都拥有一个与之对应的 delete 语义</font>

<font color = "red">请不要 delete 存储于栈空间上的地址，该调用必定会产生运行时的错误</font>

我们要<font color = "red">保证 delete 语义所搭配的指针类型不属于 `void *`</font>，否则会 delete 失败 ( 只是单纯的无法完成内存空间的释放，并不会产生运行时的错误 )

需要说明的是，<font color = "red">如果需要释放掉使用 `new []` 构造出来的内存空间，那么该语义使用时则必须加上 `[]` 即 `delete []`</font>，原因是因为我们使用 new [] 所开辟的一块内存空间会有一个长度记录，只有我们指定 `delete []` 时才会去查找所记录的长度，并决定接下来 delete 语义需要释放的空间长度，当我们只是单一的指定 delete 的时候则只会释放掉这段数组空间的首元素的数据，即紧跟着的后面的元素都会产生内存泄漏的问题

```cpp
class Person {
public:
  int id;

  Person() {}
  Person(int _id) : id(_id) {}
};

int main(void) {
  int *i = new int(0x400);
  delete i;

  Person *pers = new Person[10];
  delete[] pers;

  return 0;
}
```

<br/>

<span id="newdeletevsmallocfree"></span>

### new/delete vs. malloc/free

---

针对 new/delete 和 malloc/free 可提供给程序进行内存空间动态扩容和释放这一机制而言，两者的所达到的目标式一致的

这种一致性，能够让我们所看到的效果便是 : <font color = "red">使用 `new` 所构造的内存空间(非数组型构造 `new []`)可以使用 `free` 来进行释放，反之，使用 `malloc` 所构造的内存空间我们同样可以使用 `delete` 来释放</font>

<font color = "red">即便如此，我们还是不应该保有这一 **_未定义_** 的行为，也不应该错误认为 new/delete 的底层实现由 malloc/free 来完成，因为 new 和 delete 所操作的内存空间是在 c++ 所抽象出来的 自由存储区 之上的，它可以由 堆 来实现但是也可以在其它地方，而 malloc 和 free 所操作的内存空间则必定存储于 堆 上，所以，这一未定义的行为即不能保证这一用法是否会发生内存崩溃的问题</font>

malloc 是 c 语言提供的 API，在 cpp 中使用该 API 来完成动态内存的扩容并不是一种程序健壮性的行为，并且 new 关键字本身还提供了诸多适用于 cpp 的功能，例如自动调用类型的构造函数来完成内存初始化工作等等，所以，在 cpp 中，我们应当避免使用 malloc/free 来完成内存空间的动态扩容和释放的工作

对于 malloc 和 new 而言，其不同总结如下 : 

| 特征                 | new/delete                            | malloc/free                          |
| -------------------- | ------------------------------------- | ------------------------------------ |
| 分配内存的位置       | 自由存储区                            | 堆                                   |
| 内存分配成功的返回值类型 | new 语义所修饰类型的指针                          | void *                                |
| 内存分配失败时的动作 | 调用 `new-handler` 默认动作为抛出异常以供上层处理；也可以通过 `nothrow` 来保有和 malloc 一样的行为                          | 返回 NULL                             |
| 分配内存的大小       | 由编译器根据类型计算得出              | 必须显式指定字节数                   |
| 处理数组             | new[] / delete[]              | 需要上层来完成精准的计算 |
| 已分配内存的扩充     | 不确定，估计无法直观地处理                        | 使用 `realloc`                  |
| 分配内存时内存不足   | 客户能够指定处理函数或重新制定分配器  | 无法通过用户代码进行处理             |
| 重载             | 允许运算符重载，以制定适合自己的 new/delete 的动作                                  | 不允许                               |
| 构造函数与析构函数   | new 会调用构造函数，new [] 不会；delete/delete [] 都会调用目标对象的析构函数                                  | 不调用                               |



<br/>
<br/>

## 类

<span id="类"></span>

类的一些基本性的概念不做阐述，这一节仅讨论类在 cpp 中的底层实现和一些功能使用，下面的代码展示了一个类的最基本定义形式

```cpp
class Person {
public:
  int id;

  Person() {}
  Person(int _id) : id(_id) {
  }
};
```

类和结构体一样，都属于是一种复合型的类型，所以，<font color = "red">类的存储结构同样需要享有[内存对齐的机制](#https://github.com/NGPONG/document/blob/master/C/2019/12_18/C_Programming_Language.md#%E5%85%B3%E4%BA%8E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E9%97%AE%E9%A2%98)</font>(所声明的函数不在当前类所存储的内存段当中，即不会纳入内存对齐的考量范围)

在 cpp 中是允许空类的存在的(即一个没有任何成员声明的类)，对于一个没有任何成员声明的类来说，其实例还是会在内存中占用 **_1 bytes_** 的空间大小，原因是<font color = "red">因为 cpp 需要保证每一个类的实例在内存中都会是独一无二的存在</font>

一个类在进行创建的过程中，其内部的成员初始化顺序永远都是承上启下来进行的，当完成了所有成员的初始化工作后，才开始初始化类的本身 ; 而在一个类的实例在被释放的过程中则为类的本身先进行释放，然后由下至上挨个释放类中的每个成员(单指类本身所占用的内存空间，而某些可能指向一块堆区的成员则需要自己进行手动的释放工作)

一件有意思的事是，<font color = "red">在一个类中所声明的成员函数和类中的非静态成员并不是存储在同一个内存段中的</font>，那么利用这一机制事实上可以完成一些比较骚的操作，即可以使用一个当前类类型的空指针以完成堆声明为公共权限的函数的调用的，需要注意的是，如果使用的是当前类型的空指针来调用当前类中的函数的话，我们需要确保函数的上下文中并没有引用到针对于当前类的实例中存储的成员，否则会报错(因为成员没有经过初始化)

<br/>

<span id="访问权限符"></span>

### 访问权限符

---

在 cpp 中所支持的访问修饰符仅三种
- public
  
- private

- protected

关于它们的各自所起到的功能这里不做赘述，它和其余的语言的设计是一致的，下面的代码展示了访问权限修饰符的使用方式，我们会发现，在 cpp 中声明一个成员的权限是呈一个 **_块_** 来完成的，并不是单独的针对某个成员去进行设置

```c
class Person {
  char gender;   /* none perssion */
public:
  char *name;    /* public perssion */
private:
  int id;        /* private perssion */
protected:
  char *address; /* protected perssion */
};
```

当某个成员并未指定任何权限时，正如上面代码中的 `gender`，那么其默认的访问修饰符则为 `private`

关于 private 权限，有意思的是，在当前类的作用域下所使用的变量(包括函数形参，局部变量，类中的成员)如果其类型属于当前类的话，那么该变量能够得到访问对象中的私有成员的权限

<br/>

<span id="this-和-base"></span>

### this 和 'base'

---

我们在一个类的上下文中，可以使用 **_this_** 关键字来获取到一个指向当前对象实例在内存中的首地址的指针，使用它来完成当前实例上下文成员信息的一些调度，具体来说该指针的类型为一个指针常量，即类型为 **_Type * const_** 的指针，我们不能改变该指针的指向

而关于 **_base_**，在其他语言中它通常指向当前类的基类，而本节中，对于 **_base_** 关键字故意使用了 **_'base'_** 是因为在 cpp 中并没有语法能够让我们直接使用 **_base_**，但是我们却可以通过 `::` 去引用其父级所在的作用域，以获取到父类中的成员信息，当然包括显式调用父级的构造函数也能够通过该符号来完成

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  int id;

  Person(int _id) : id(_id) { }
};

class Student : public Person {
public:
  const char *name;

  Student(const char *_name) : Person::Person(30), name(_name) {
    cout << "Person id = " << Person::id << endl;
    cout << "Student name = " << this->name << endl;
  }
};

int main(void) {
  Student stu("hello,world");
  cout << stu.name << endl;
  cout << stu.id << endl;

  return EXIT_SUCCESS;
}
```

<br/>

<span id="类中的成员的声明和定义"></span>

### 类中的成员的声明和定义

---

类中的成员允许存在声明和定义分开写(<font color = "red">这里不包括普通的成员</font>)，但并不意味着我们可以在一个类的上下文中存在同一个成员的定义和声明，因为这是编译器不支持的语法

为什么这里要区分开普通成员？原因是因为根本没必要将他们加入到考量的范围。类中的类型为 **_普通变量_** 的成员其在内存中的位置是跟随着这个类的实例的创建而创建，跟随着这个实例的释放而释放，也就意味着当一个类中的非静态成员变量的声明在我们构建好该类的一个具体的实例后，这些成员会在调用构造函数 **_之前_** 先按照编译器的实现去初始化一个初始值，当然我们也可以通过所显示指定的构造函数针对成员变量去进行一次再初始化的工作，简而言之，<font color = "red">对于类中的非静态成员变量的初始化过程都无需开发人员来进行关心，因为它们都会在一个类的实例被创建出来后，其所对应的内存也随着类本身的实例化而构建出来</font>

而对于类中的 **_成员函数_**，由于其在内存中的位置并不是跟随着这个实例的创建而创建，具体来说，每一个独特的类中所定义的函数都会在内存中只保有一份针对这个类的独有的内容(虽然其调用是需要依赖于某一个类的具体实例才能够完成，但这只是编译器在编译阶段的一种保护机制，因为对于普通的成员函数我们往往会在里面访问当前实例的一些成员信息，而这时候就可能会有一个问题，假设我们这个类是还未被实例化的状态，并且成员函数里面访问了一些类中的成员信息，这时候成员函数的调用则是不安全的)，也就是说一个普通的成员函数的声明并不会随着一个类的实例化后编译器为我们自动初始化一份默认的定义，所以<font color = "red">对于出现在一个类中的普通函数成员的声明，如要使用它，那么我们就必须还要在一个 **_全局命名空间(一个可被发现的命名空间)_** 下通过 `::` 关键字来引用到该成员函数所在的类的作用域，并以此去访问成员函数声明的符号，然后通过此链接符号来继续往下指定出该成员函数声明的具体定义</font>，如下面的代码，我们对于一个类中的普通函数声明完成了一次符号链接的定义，这里需要扩充一点的是，<font color = "red">我们对于一个类中的成员函数在进行链接定义的过程中是可以暂时可以无视掉为类中的成员所修饰的访问标识符的</font>

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  void hello();
};

void Person::hello() {
  cout << "hello,world" << endl;
}

int main(void) {
  Person per;
  per.hello();

  return EXIT_SUCCESS;
}
```

<font color = "red">在这里其实漏掉了一个角色，即 **_静态成员_**，关于它们的信息会附带更多额外的信息，所以我会在[其它节](#关于类中的静态成员)中赘述</font>

<br/>

<span id="成员函数和函数指针"></span>

### 成员函数和函数指针

---

!!! 
    <font color = "red">以下的玩法仅适用于 GCC 编译器</font>

某个类中的成员函数其所属的类型，对比普通全局函数的类型，成员函数的类型表示还需要通过 `::` 号引用至成员函数所在类型的作用域下并且通过 `()` 提升类型引用符的优先级才算一个类中成员函数类型的完整语义，例如如下面的代码，虽然两个函数的返回值和参数列表都是一致的，但是当它们站在整个函数类型的本身的视角上时，两者是存在区别的: 

```cpp
#include <iostream>
using namespace std;

bool foo(int _val) {       /* bool (int) */
  cout << _val << endl;
}

class TEST {
public:
  bool foo(int _val) {     /* bool (TEST::)(int) */
    cout << _val << endl;
  }
}
```

正因为此，当我们想使用一个函数指针去修饰一个成员函数时，也必须要保证，函数指针的类型是属于成员函数的原始类型才能够完成正确的定义，如下面的代码 :

```cpp
class TEST {
public:
  bool m_foo(int _val) {   
    cout << _val << endl;
  }
}

void foo() {
  /* 通过一个实例的依赖去获取成员函数在内存中的地址 */
  TEST t;
  bool (TEST::*invoker_instance)(int) = t.m_foo;

  /* 通过 :: 操作符去引用至具体某个类型下并拿到成员函数的名字同样也可以用作获取成员函数地址的一种方式 */
  bool (TEST::*invoker_none)(int) = TEST::m_foo;
}
```

需要补充的是，由于类中所声明的成员函数和类中的非静态成员并不是存储在同一个内存段中的，简而言之该成员函数的地址获取并一定需要依赖于一个类的实例，即，我们可以直接通过 :: 操作符去引用具体某个类下的成员函数也同样是能够用于函数指针的定义，这一点也具体到代码中 `invoker_none` 的声明

虽然成员函数和类的实例并不存储在一个内存段内，但并不意为着成员函数的调用就不需要依赖于类的实例本身了，正如前面声明了一个空的类指针也可以调用一个成员函数，但是它的调用的确是依赖了一个类的实例了，只不过它是空的，这就好比所谓的做做样子，我们可以简单地理解为 : <font color = "red">成员函数不管是在什么情境下，其调用是必须要依赖于函数所在类型的实例才能完成的</font>，那么对于我们在上面所修饰的一个关于类中成员函数类型的函数指针的调用，也需要依赖于一个类的实例，请查看下面的代码 : 

```cpp
class TEST {
public:
  bool m_foo(int _val) {   
    cout << _val << endl;
  }
}

void foo() {
  /* 通过一个实例的依赖去获取成员函数在内存中的地址 */
  TEST t;
  bool (TEST::*invoker_instance)(int) = t.m_foo;
  (t.*invoker_instance)(10);

  /* 通过 :: 操作符去引用至具体某个类型下并拿到成员函数的名字同样也可以用作获取成员函数地址的一种方式 */
  bool (TEST::*invoker_none)(int) = TEST::m_foo;
  (t.*invoker_none)(10);
}
```

这里要补充的是，我们查看 `invoker_none` 的声明方式，它是直接通过引用类的作用域去获取到需要指向的函数本身的，这或许可能会有疑问，既然它获取成员函数的方式对比 `invoker_instance` 来说，并不是通过一个已经初始化过的实例来获取的，那么它的调用如果内部访问了类内部的一些成员的话，是否会产生错误(访问了未被初始化的成员)？答案是否定的，因为虽然它的声明方式是如此，但是我们可以看到，它的调用实实在在的确是依赖了一个该类的实例来完成，也就是不存在上面所说的那种情况

<br/>

<span id = "构造函数"></span>

### 构造函数

---

构造函数的知识点我们快速过一遍即可，它和大多数语言都存在着共同性

- 构造函数无返回值，但是我们可以显示的指定构造函数的形参，并且还支持重载

- 构造函数必须声明为 public

- 构造函数名由 类名 所组成

- 当一个类中没有定义构造函数时，编译器再进行编译时会自动地为我们添加一个 空实现 的构造函数，否则不会添加

- <font color = "red">构造函数的调用发生在类实例创建之时，实例的创建依赖构造函数来完成</font>，也就是说我们可以显示的指定当前类中的具体某个构造函数来完成类的实例化的创建工作

<br/>

<span id = "拷贝构造函数"></span>

#### 拷贝构造函数

<font color = "red">当一个构造函数的形参只有一个，并且形参的类型为当前类型的 **_'常量左值引用'_** 的时候，那么这个构造函数更应该称为拷贝构造函数</font>，需要注意的是，如果形参类型虽然是类本身，但是去并不属于一个引用时，编译器会认为该构造函数属于一个不符合标准规范拷贝构造函数，故会导致编译失败

**_拷贝构造函数有什么用？_**

<font color = "red">我们可以使用拷贝构造函数去拷贝 **_一个相同类型不同实例中的成员_** 以创建一个新的实例</font>，需要重点强调的是，<font color = "red">它是一种形参类型特殊的构造函数，也就是说它的调用往往初始化一个实例前提下进行</font>，并且我们还要保证初始化实例时所指定的形参能够映射到拷贝函数中的形参定义(常量左值引用)，即需要一个求值 $result$ 结果为当前类型的 **_左值/右值表达式_**

需要注意的是，能够使用 **_右值表达式_** 去完成拷贝构造函数的调用是由于其形参类型为 **_常量左值引用_** 所导致的，<font color = "red">事实上，拷贝构造函数的调用仅仅只是针对于 左值表达式 的拷贝而不是右值表达式</font>，<font color = "red">对于右值表达式存在 **_将亡_** 的特性来说，我们往往需要使用的是 移动 而不是 拷贝</font>，如果我们把拷贝构造函数的形参类型改写为仅仅只是 **_'左值引用'_** 的情况下也能够构成一个拷贝函数的定义，但是通常在书写的时候往往都会加上 **_const_** 以修饰，其目的主要是为了在一个类没有定义 移动构造 函数的情况下，我们同样也可以使用一个 当前类型的右值表达式 去完成一个当前类型的新实例构造，而是否选择使用移动构造函数则由开发人员自己去定义了

```cpp
class Person {
public:
  int age;

  /* Constructor */
  Person(int _age): age(_age) {}

  /* Copy-constructor */
  Person(const Person &per) {
    this->age = per.age;
  }
};

int main(void) {
  Person per(0x400);

  Person cp_per_1 = per;
  Person cp_per_2(per);
  Person cp_per_3 = Person(per);
  Person *cp_per_4 = new Person(per);

  return 0;
}
```

**_拷贝语义_**

拷贝语义，即一个拷贝构造函数其上下文中需要承担的工作，对于拷贝构造而言，无非就是把 **_that_** 中的数据拷贝到 **_this_** 身上，其实，更加值得我们引起关注的其实是在堆中所分配的内存，对于某个需要在堆中分配内存的成员，我们需要做的是 : 
1. 如果该成员已拥有资源，则优先释放

2. 为该成员分配一块新的内存段

3. 将 **_that_** 中的该成员所指向的数据 **_'拷贝'_** 至刚刚为 **_this_** 所申请内存空间的成员身上

**_拷贝赋值运算符重载_**

关于运算符重载，请参考[这一节](#TODO)

拷贝构造函数的调用是需要和一个对象实例的初始化过程所绑定起来的，<font color = "red">当我们想使用一个当前类型的 **_左值/右值表达式_** 去绑定一个已经实例化好的变量时，则需要使用到 **_拷贝赋值运算重载_**</font>，需要重点强调的是，拷贝赋值运算重载其特性、所需遵守的规范和拷贝构造函数是一致的，只是对于拷贝赋值运算重载来说，其需要绑定的是一个已经初始化好的成员，而对于拷贝构造函数来说，它的绑定是一个成员的初始化开始的过程

```cpp
class Person {
public:
  int age;

  /* Constructor */
  Person(int _age): age(_age) {}

  /* Copy-constructor */
  Person(const Person &per) {
    this->age = per.age;
  }

  /* Copy-assignment-operator */
  Person &operator=(const Person &per) {
    this->age = per.age;
    return *this;
  }
};

int main(void) {
  Person per(0x400);
  Person cp_per(0x100);

  /* copy assignment operator */
  cp_per = per;

  return 0;
}
```

<br/>

<span id = "移动构造函数"></span>

#### 移动构造函数

<font color = "red">当一个构造函数的形参只有一个，并且形参的类型为当前类型的 **_'右值引用'_** 的时候，那么这个构造函数更应该称为移动构造函数</font>

**_移动构造函数有什么用？_**

在[拷贝构造函数](#拷贝构造函数)中提到过，拷贝构造函数能够依据一个已有的实例为基准，将其在内存中的数据拷贝至一个新的实例身上，但是现在考虑两个问题 :

1. 假设原始实例(**_that_**)所保存的数据过于庞大，那么拷贝到目标实例(**_this_**)身上是一件性能损耗较大的事情，那么我们是否可以仅仅只是对需要拷贝的数据做一次移动，即把原始数据源身上的数据直接移动到目标数据源身上而不进行拷贝，使目标数据源的实例能够重新开始管控原始数据源在内存中的生命周期

2. **_右值表达式_** 虽然也能够用于构成拷贝构造函数的调用，但是，就拷贝构造函数而言，它所服务的对象更应该是 左值表达式 而不是 右值表达式(能够支持 右值表达式 的特性仅仅是因为拷贝构造函数的 左值引用 通过 const 进行了修饰)，对于 右值表达式 而言，由于其存在着 将亡 的特性，那么再结合第一点要求，假设我们能够有一个构造函数，它能够专门的去使用 右值表达式 去初始化一个新的实例，并且其还能够享有在右值表达式(**_that_**)即将消亡前能够把其数据移动至目标实例(**_this_**)身上的特性(也就是不浪费右值表达式所创建的无名临时变量所占用的计算)，那么移动构造函数就是专门服务于此

<font color = "red">我们可以使用移动构造函数将原始实例 右值表达式(原始实例,**_that_**) 中的成员数据 **_'移动'_** 到目标实例身上，以完成目标实例的初始化构建工作</font>，需要重点强调的是，<font color = "red">它是一种形参类型特殊的构造函数，也就是说它的调用往往实在初始化一个实例的情况下进行的</font>，并且我们还要保证初始化实例时所指定的形参能够映射到移动函数中的形参定义(右值引用)，即需要一个求值 $result$ 结果为当前类型的 右值表达式，我们可以简单的理解为，<font color = "red">移动构造函数能够在某些特定情况下(**_采用右值来赋值或构造对象时_**)使用廉价的移动语义替换昂贵的拷贝语义的问题</font>

```cpp
class Person {
public:
  const char *name;

  /* Constructor */
  Person(const char *_name): name(_name) {}

  /* Copy-constructor */
  Person(const Person &per) { this->name = per.name; }

  /* Move-constructor */
  Person(Person &&per) {
    this->name = per.name;
    per.name = nullptr;
  }
};

Person foo() {
  Person per("hello,world");
  return per;
}

int main(void) {
  Person per = foo();

  return EXIT_SUCCESS;
}
```

**_移动语义_**

移动语义，即一个移动构造函数其上下文中需要承担的工作，对于移动构造而言，它所需要做的工作就是要把原始实例(**_that_**)身上的数据移动到目标实例(**_this_**)身上，并且把原始数据源身上的成员数据都置为空，我们可以理解为就是让目标实例(**_this_**)去重新接管原始实例(**_that_**)身上的成员数据，我们需要做的是: 

1. 如果该成员已拥有资源，则优先释放
   
2. 将原始实例中的成员数据移动(**_赋值_**)给目标实例中的具体成员
   
3. 将原始实例中已经进行过移动操作的成员都重新值为空(**_重新接管_**)


**_移动赋值运算符重载_**

关于运算符重载，请参考[这一节](#TODO)

拷贝构造函数的调用是需要和一个对象实例的初始化过程所绑定起来的，<font color = "red">当我们想使用一个当前类型的 **_左值/右值表达式_** 去绑定一个已经实例化好的变量时，则需要使用到 **_拷贝赋值运算重载_**</font>，需要重点强调的是，拷贝赋值运算重载其特性、所需遵守的规范和拷贝构造函数是一致的，只是对于拷贝赋值运算重载来说，其需要绑定的是一个已经初始化好的成员，而对于拷贝构造函数来说，它的绑定是一个成员的初始化开始的过程

移动构造函数的调用是需要和一个对象实例的初始化过程所绑定起来的，<fonr color = "red">当我们想使用一个当前类型的 **_右值表达式_** 去绑定一个已经实例化好的变量时，则需要使用到 **_移动赋值运算重载_**</font>，需要重点强调的是，移动赋值运算重载其特性、所需遵守的规范和移动构造函数是一致的，只是对于移动赋值运算重载来说，其需要绑定的是一个已经初始化好的成员，而对于移动构造函数来说，它的绑定是一个成员的初始化开始的过程

```cpp
class Person {
public:
  const char *name;

  /* Constructor */
  Person(const char *_name): name(_name) {}

  /* Copy-constructor */
  Person(const Person &per) { this->name = per.name; }

  /* Move-constructor */
  Person(Person &&per) {
    this->name = per.name;
    per.name = nullptr;
  }

  /* Move-assignment-operator */
  Person &operator=(Person &&per) {
    this->name = per.name;
    per.name = nullptr;

    return *this;
  }
};

Person foo() {
  Person per("hello,world");
  return per;
}

int main(void) {
  Person per = foo();
  per = foo();

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "编译器自动添加的拷贝构造函数和拷贝复制运算符"></span>

#### 编译器自动添加的拷贝构造函数和拷贝复制运算符

<font color = "red">对于一个能够声明构造函数的复合类型来说，编译器在我们并没有额外添加 **_拷贝构造函数/移动构造函数_** 的前提下(除非实现了任意一方)，都会为我们自动添加一个形参类型为 **_'常量左值引用'_** 的 **_拷贝构造函数和拷贝赋值运算符_** 以完成对于 左值/右值表达式 基本的初始化构造或者赋值的支持</font>，需要注意的是，<font color = "red">该拷贝构造函数和拷贝赋值运算符仅仅是做一次基础的逐字节拷贝工作，故该自动添加的拷贝构造函数和拷贝赋值运算符可能会在某些情况下会出现 **_深拷贝和浅拷贝_** 的问题</font>

<br/>

<span id = "拷贝移动消除"></span>

#### 拷贝/移动消除

该特性是 cpp11 起延伸至 cpp17 中所支持的一种特性，<font color = "red">它属于一种编译器的优化技术，能够在在一些特定情况下，在原本需要 复制/移动构造函数 的调用替换为 复制/移动构造函数 以避免可能出现的性能损失的问题</font>

- 以下统称 <font color = "red">具有自动生存期、非volatile、非函数形参、非 catch 捕捉</font> 的对象为 **_这类对象_**

- 当存在一个函数，返回值类型为自定义类，并且调用方使用这个函数的返回值去构造相应类型的对象，然后返回的是 **_这类对象_**，则会发生复制消除

- throw 了一个不超过最内层 try 的 **_这类对象_**，可能发生复制消除

- catch 了一个与 throw 相同类型的 **_这类对象_**，并且没有复用这个对象(即跳过该 catch 子句参数的复制构造函数和析构函数以外的原因更改可观察行为)

- 当返回了一个匿名的对象，并且有对象使用该函数返回的对象进行构造

- 常量表达式和常量初始化时(待定)

- 在不发生临时变量实质化时多次连环的复制/移动

```cpp
class Person {
public:
  const char *name;

  /* Constructor */
  Person(const char *_name): name(_name) {}

  /* Copy-constructor */
  Person(const Person &per) { this->name = per.name; }
  
  /* Move-constructor */
  Person(Person &&per) {
    this->name = per.name;
    per.name = nullptr;
  }

  /* Move-constructor */
  Person(Person &&per) {
    this->name = per.name;
    per.name = nullptr;
  }

  /* Move-assignment-operator */
  Person &operator=(Person &&per) {
    this->name = per.name;
    per.name = nullptr;
    return *this;
  }
};

Person foo(void) {
  /* call Person constructor & Person move constructor & Person destructor */
  Person per = Person((char *)"Hello,World", 1024);

  /**
   * By default, this step calls the copy constructor,
   * but due to the nature of move/copy elimination su
   * pported since CPP11,this step actually calls the m
   * ove constructor 
  */
  return per;
}

int main(void) {
  /* call Person move constructor */
  Person per = foo();
  return EXIT_SUCCESS;
}
```

<br/>

<span id = "explicit关键字"></span>

#### explicit 关键字

我们可以通过 隐式法 的方式去指定一个类中的某个构造函数来对完成该类的实例初始化工作，但是 隐式法 去对类进行实例化操作对于代码而言可读性会比较低，为了避免开发人员滥用隐式法来对一个类进行实例化，我们可以针对所需要隐藏的构造函数来添加上该关键字以来达到效果，当一个类中的某个构造函数使用了该关键字后，那么开发人员再也不能通过隐式法的方式去匹配到类中的具体某个构造函数以使用它来对类进行实例化(只能通过其它方式来匹配这个构造函数)

```cpp
class Person {
public:
  const char *name;

  /* Constructor */
  explicit Person(const char *_name): name(_name) {}
};

int main(void) {
  Person per = "hello,world"; /* fault */

  return 0;
}
```

<br/>

<span id = "构造函数中的初始化参数列表"></span>

#### 构造函数中的初始化参数列表

我们可以通过在构造函数中指定一个初始化参数列表，以让构造函数在调用的过程中可以使用构造函数中所指定的形参(也可以直接指定具体的值)来完成对类中的成员的初始化工作，具体语法则为 : <font color = "red">构造函数名(参数A) : 成员A(参数A),成员B(值) { }</font>

<font color = "red">初始化参数列表的定义类似于对类中的成员使用 **_括号法_** 的方式进行初始化</font>，诚然，如果初始化参数列表中的某个成员为一个存在构造函数类型的成员的话，那么 `()` 内所指定的值则权当该成员构造函数所对应的形参来使用(编译器会依据所录入的参数的不同自动匹配到最合适的构造函数以完成该成员的实例化操作)

<font color = "red">事实上，初始化列表不单单可用来初始化当前类身上的成员属性，我们还可以利用它来完成显式的调用父类中的构造函数</font>，需要注意的是，由于一个存在继承体系的类的初始化操作是由父类先初始化完毕再到子类的，也就意味着，<font color = "red">我们在初始化列表中显式调用父类的构造函数时，它的调用顺序理应放在最前</font>

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  int id;
  Person(int _id) : id(_id) { }
};

class Student : public Person {
public:
  const char *name;

  Student(const char *_name) : Person::Person(30), name(_name) {
    cout << "Person id = " << Person::id << endl;
    cout << "Student name = " << this->name << endl;
  }
};

int main(void) {
  Student stu("hello,world");

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "析构函数"></span>

### 析构函数

---

- 析构函数无参无返回值

- 析构函数必须声明为 public，对于定义为 private 虚构函数的类: 

  - 我们无法在栈中创建其自身的实例

  - 我们虽然可以通过 new 语义在自由存储区中构造一块该示例的内存，但是对于 delete 语义来说我们无法释放，该错误会在编译期间进行校验

  - 那么定义为 private 的析构函数真的无意义吗？这不一定，因为即便定义为 private 的析构函数，如果它是实现于上级父类中的虚析构，那么也同样可以完成继承语义中的正确释放顺序，请查看 [是否可以使用私有成员来实现虚函数或虚析构](#是否可以使用私有成员来实现虚函数或虚析构) 这一小节

- 析构函数名由 <font color = "red">~class_name</font> 所组成

- 当一个类中没有定义析构函数时，编译器在进行编译时会自动地为我们添加一个 空实现 的析构函数，否则不会添加

- <font color = "red">析构函数无需手动调用，当一个类的实例被释放时，析构函数自动由编译器来完成调用</font>，这个时机通常发生在栈帧的出栈亦或者手动 delete 的情景

```cpp
class Person {
  const char *name;
public:
    ~Person { 
      if(name != nullptr) {
        delete name;
      }
    }
}
```

<br/>

<span id = "关于类中的静态成员"></span>

### 关于类中的静态成员

---

一个类中的静态成员，按照类型来区分的话，我们可以划分为 : **_静态函数_** 和 **_静态变量_**

由于静态成员使用的是 **_'static'_** 关键字所修饰，也就是说，<font color = "red">它们存储在内存的静态存储区中而不是存储在一个类的实例所对应的内存段中，并且它们会在编译时就已分配好了内存</font>，需要注意的是，<font color = "red">类中的静态成员并不是一个内部链接符号，意味着它的使用和动态链接的作用域并不是只针对当前的编译单元之中</font>

类中的静态成员同样受类中的访问修饰符的限制，简而言之<font color = "red">就是说在调用的过程中受访问标识符的影响</font>

<font color = "red">对于类中的静态变量而言，编译器允许我们指定这个静态变量的类型为当前对象的类型</font>

需要注意的是，<font color = "red">类中静态函数虽然是声明在类中，但是却无法直接引用当前类中的非静态成员，只能够引用已经被正确定义过的静态成员，反之，同样定义在类中非静态函数是能够引用类中的静态成员的</font>，这是因为静态成员在内存中的存储段是独立于基于实例的非静态成员的，就类中静态函数而言，我们并不需要依赖于某个类的实例来完成它的调用(虽然是可以通过一个类的实例来调用声明在一个类中的静态成员，即使于此，它的调用还是不需要依赖于某个类的实例)，既无法访问到针对实例而言的非静态成员，而对于类中的非静态函数来说，由于静态成员是存储于内存的针对当前类型的独有的一份数据，故它在调用的时候是能够获取到当前类中的静态成员的内容的，我们也可以简单的理解为: <font color = "red">非静态成员在初始化之前，静态成员就已经初始化好了，而静态成员在初始化之前，非静态成员一定还没初始化好</font>

<br/>

<span id = "静态成员的声明和实现"></span>

#### 静态成员的声明和实现

**_静态变量_**

如果一个静态变量是直接声明在类中并赋予定义的情况，则必须添加 `cost` 关键词进行修饰，否则会编译报错，简而言之就是<font color = "red">静态变量如果是在类中进行定义的话，它必须是一个静态常量</font>

反之，<font color = "red">如果是在一个类的内部使用的是声明，而在外部对其进行额外定义的话则没有常量使用的限制</font>，但是针对这种情况，我们需要明白其实现，<font color = "red">静态成员变量的声明其实是一种 **_'不完整的类型'_** ，只有当我们对这个类中的静态变量在 **_全局命名空间下_** 进行了一次符号链接形式的定义后，才能使这个不完整的类型真正意义上的融入到编译器所需为其分配的内存空间中</font>，简而言之就是能够使编译器发现我们在这个类中所声明的不完整的类型了，否则我们就无法使用这个静态成员，如果使用则会造成无法编译通过，需要注意的是，<font color = "red">我们在全局命名空间下针对这个在类中的静态变量的声明并不一定需要完成一次完整的定义，我们只是单独的进行一次声明操作也是可以的，因为我们这么做的目的只是为了让原有的不完整的类型变成完整，以让编译器能够认识到该变量的完整性以至在使用它之前编译器能够自动的为其赋予一个含有默认值的定义(变量在使用前必须要有其定义，否则编译器会隐式的把该变量的声明转化为定义，并赋予一个默认值)</font>

**_静态函数_**

对于静态成员函数的定义没什么好说的，我们只需要知道它在调用时，和普通函数的区别即可

对于静态成员函数的声明其实也没什么好说的，因为我们对于静态函数声明所需进行的符号链接的定义的方式也好还是所需注意的事项，它都和普通函数是保持一致的

**_代码总结_**

下面的代码，我们对于静态变量的定义和声明做了一次归纳

```cpp
#include <iostream>
using namespace std;

class Person {
private:
  /* 仅有声明的静态变量 */
  static int Age;

public:
  /* 仅有声明的静态变量 */
  static char *Name;

  /* 静态变量直接在类的内部进行定义的话，必须要声明为常量 */
  const static char Gender = 'M';

  /* 直接在类中定义的静态函数，它和普通函数的定义方式无区别，更值得我们注意的是该函数上下文的使用方式 */
  static void Set_Age(int age) {
    Person::Age = age;
    Age = age;
  } 

  /* 仅有声明的静态函数 */
  static void Print();
};

/**
 * 这里只是对该静态变量做一个声明，但是同样也是可以使用，因为该声明能
 * 够把原来在类中的不完整类型归纳玩一个完整的声明了，即这里能够被编译
 * 器初始化到内存的静态存储区中去，即初始化默认值为 0 此外，由于我们
 * 对于类中的静态变量的定义的过程中是可以暂时的无视掉原有静态类型所修
 * 饰的访问标识符的，即该成员原本是修饰为 private 的但我们还是能够对
 * 其进行一次定义使之构造为一个完整的类型
*/
int Person::Age; 

/* 静态成员的定义，在外部定义的静态成员无需作为常量而存在 */
char *Person::Name = (char *)"NGPONG";

/* 静态函数的定义，其定义方式和注意事项和普通函数并无区别，值得我们关注的是该函数定义上下文的使用方式 */
void Person::Print() {
  cout << "Person name = " << Person::Name << endl;
  cout << "Person age = " << Person::Age << endl;
};

int main(void) {
  Person::Set_Age(23);
  Person::Print();

  return 0;
}
```

<br/>

<span id = "常函数和常对象"></span>

### 常函数和常对象

---

<span id = "常函数"></span>

#### 常函数

当一个对象中成员函数的末尾添加了 **_const_** 关键字后，则意为该函数为一个常函数

<font color = "red">常函数上下文中，不能 **_直接修改_** 在当前类中未使用 **_mutable_** 关键字所修饰的成员，并且无法调用除了常函数以外的其它函数</font>

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  int age;

  Person(int _age): age(_age) {}

  void speak() const {
    this->age = 10; /* fault */
    cout << this->age << endl;
  }
};

int main(void) {
  Person per(0x400);
  per.speak();

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "常对象"></span>

#### 常对象

当一个对象的实例的声明使用了 **_const_** 关键字修饰，则意为该对象为一个常对象

<font color = "red">我们无法通过 直接修改 的方式修改常对象类型中，未使用 mutable 所修饰的成员变量，并且无法调用除了常函数以外的其他函数</font>

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  int age;

  Person(int _age): age(_age) {}
};

int main(void) {
  const Person per(0x400);
  per.age = 100; /* fault */

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "mutable"></span>

#### mutable

该关键字能够用于修饰一个类中的成员变量，当某个成员变量使用了该关键字，那么 常函数/常对象 则可以通过 **_直接修改_** 的方式对其进行修改

```cpp
class Person {
public:
  mutable int age;

  Person(int _age): age(_age) {}

  void speak() const {
    this->age = 10; /* success */
    cout << this->age << endl;
  }
};

int main(void) {
  const Person per(0x400);
  per.speak();

  per.age = 0x100; /* success */

  return EXIT_SUCCESS;
}
```

值得引起注意的是，<font color = "red">上面对于未使用 **_mutable_** 关键字的成员变量在 **_常函数/常对象_** 中都不能修改的定义都采用的是 **_直接修改_**，意味着我们是可以通过指针的途径来完成对它的间接修改的</font>

<br/>

<span id = "类的前置声明"></span>

### 类的前置声明

---

类的前置声明主要作用于防止编译器由于代码呈上至下的编译方式导致某些时候对于一些类的使用无法访问的情况，<font color = "red">对于一段前置声明的类来说，如果在出现该类的具体定义之前的地方去使用它是无法访问里面的成员的，因为其只是作用于一段声明</font>，我们通常用它来声明一个该前置声明类型的指针

```cpp
#include <iostream>
using namespace std;

/* 前置声明 Person 类 */
class Person;

/* 利用前置声明构造一个 Person 类的指针 */
Person *per;

void foo() {
  /* error */
  /* 由于在出现 Person 的具体定义之前使用了该指针，故这里会导致编译报错 */
  per = new Person(100);
}

class Person {
public:
  int age;

  Person(int _age): age(_age) {}
};

int main(void) {
  /* success */
  /* 在使用 per 的时候已经出现了 Person 类的定义，故这里能够成功调用 */
  per = new Person(0x400);
  cout << per->age << endl;

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "继承"></span>

### 继承

---

c++ 的继承方式和其余的 OOP 语言一致，其语法为 : <font color = "red">class derived-class : access-specifier base-class</font>
- derived-class: 子类

- base-class : 基类

- access-specifier : 继承类别

在这里，其实重点需要说明的就是这个继承类别，一个基类可以被继承自 public, protected, private 这三种类别，不同的继承类别能够决定基类延伸至子类中的成员其访问保护性，简而言之就是可以间接的改变基类中成员的访问修饰符，<font color = "red">一般而言，我们使用继承都是用的 public 的形式来完成，因为这个形式是最直接的</font>

- 公有继承(public) : 当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问

- 保护继承(protected) : 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员

- 私有继承(private) : 当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员

<br/>

<span id = "继承的内存模型"></span>

#### 继承的内存模型

一个存在继承派生关系的派生类在实例化的过程中，会先初始化其父类的所有成员(**_无视访问修饰符_**)到一段内存中，然后再以这段内存为基础继续往下初始化上级基类往下所派生的子类的成员，直至初始化自己，<font color = "red">也就是说，一个类的实例如果存在基类，那么其在内存中的首地址往下所延伸的地址都是先由其基类中的成员所占用，然后以基类成员所占用的内存地址的结束为基准，继续往下才是子类的成员所存储的内存地址，如下面的代码</font>

```cpp
class person_base {
private:
    char m_gender = 1;
};

class student : public person_base {
public:
    int m_age;
    char m_id = 1;
};
```

其在内存中的模型如下图所示

```text
                                +---------+
                          +-----+0000 0000|
                          |     +-----------> 0x0000000B
                          |     |0000 0000|
        student::m_id <---+     +-----------> 0x0000000A
                          |     |0000 0000|
                          |     +-----------> 0x00000009
                          +-----+0000 0000|
                                +-----------> 0x00000008
                          +-----+0000 0000|
                          |     +-----------> 0x00000007
                          |     |0000 0000|
       student::m_age <---+     +-----------> 0x00000006
                          |     |0000 0000|
                          |     +-----------> 0x00000005
                          +-----+0000 0000|
                                +-----------> 0x00000004
                          +-----+0000 0000|
                          |     +-----------> 0x00000003
                          |     |0000 0000|
person_base::m_gender <---+     +-----------> 0x00000002
                          |     |0000 0000|
                          |     +-----------> 0x00000001
                          +-----+0000 0000|
                                +-----------> 0x00000000
```

通过 vs 开发人员工具输入 `cl /d1 reportSingleClassLayout(类型) (文件名)` 来查看的结果

```text
class student   size(12):
  +---
0 | +--- (base class person_base)
0 | | m_gender
  | +---
  | <alignment member> (size=3)
4 | m_age
8 | m_id
  | <alignment member> (size=3)
  +---
```

在这里由于内存对齐的问题，故原本存在于基类中的类型为 char 的成员(`m_gender`)的内存占用的为4个字节，不过这里不进行额外的展开，详情请参考 [这一篇文章](#https://github.com/NGPONG/document/blob/master/C/2019/12_18/C_Programming_Language.md#%E5%85%B3%E4%BA%8E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E9%97%AE%E9%A2%98)，需要额外说明一下的是，<font color = "red">基类是一个复合类型，而派生类继承自基类中的成员无非就是把基类中的成员初始化在派生类中所在的内存段当中，即，它们是一体的，所以我们在计算基类中的成员的偏移位置所需的 **_对齐单位_** 的参考并不是以派生类的视角为基准，而是以基类的视角所构成的 **_对齐单位_** 为准，这里要和直接声明在类中的类型为复合类型的成员不同，对于它们去计算在内存中的偏移单位时，对齐单位 的参考是以当前复合类型的视角为基准</font>

其实我们通过继承与派生在内存中的模型，我们可以总结为 : <font color = "red">子类派生自父类，实质上它是继承了父类中所有的成员(无视访问修饰符)(非实例构造型函数，如: 构造函数, 析构函数, 等号运算符重载函数)</font>，<font color = "red">一个子类在实例创建的过程中，会 **_优先_** 初始化其所继承的父类(默认情况下调用父类的默认构造函数)中的所有成员至以子类实例为基准所构建的内存段的起始位置上，然后在 以父类中的成员所构建的数据所在内存地址的结束位置 继续往下初始化子类中的成员数据</font>

<font color = "red">需要严格说明的是，派生类在实例创建的过程中并 **_不是_** 又在内存中创建了一份父类的实例，然后子类通过某种方式 **_'引用'_** 了这个在不同内存段中的基类以达到访问基类中的成员的目的</font>，继承只是一个语言在抽象上的概念，通过这种抽象的 **_'继承关系'_** 来把派生和基类区分开来，实质上基类在确定好其派生关系后，其所有的成员在内存中的数据都会在派生类创建的过程中把它们优先初始化在以子类为基准的内存段上，我们可以从 **_'派生类的视角'_** 理解为：派生类和基类是一体的

有了 cpp 中类的内存模型为基准，我们可以进行一个有趣的实验 : 我们都知道，派生类所继承自基类中的成员会受到基类中成员声明的访问修饰符的影响的，也就意味着基类中某个声明为私有的成员在其派生类中是无法通过直接的方式去访问的，当然这里重点强调的是 **_'直接'_**，上面对于继承的内存模型我们会发现，实际上基类中的所有成员是存储在派生类的实例其所对应的内存段当中，那么我们可以大胆的认为基类中声明为 `private` 的成员实际上并不是 `private` 的，因为我们完全可以通过一个派生类的内存首地址，通过地址偏移的方式找到那个声明为 `private` 的在基类的成员其在内存中的首地址，然后通过解引用的方式以操作它，事实的确如此，再次强调的是，<font color = "red">继承只是语言上的一个抽象的功能，是编译器层面上为了使我们更方便去编写 oop 的工程项目所提供的功能，实际上我们要怎么玩完全由开发人员来决定</font>

```cpp
class person_base {
private:
  char m_gender = 'K';
};

class student : public person_base {
public:
  int m_age;
  char m_id;

public:
  void printp(void) {
    printf("%c\n", *(char *)this);
  }
};
```

<br/>

<span id = "子类和父类实例的释放顺序(析构函数的调用顺序)"></span>

#### 子类和父类实例的释放顺序(析构函数的调用顺序)

子类的实例在被释放的时候，会先释放掉子类中的成员(调用子类的析构函数)，然后再去释放其所继承自父类中的成员(调用父类的析构函数)，<font color = "red">造成这种原因主要是因为 栈 的 FIFO 的机制所导致的</font>，前面在[继承的内存模型](#继承的内存模型)中提到，一个子类在进行实例化的过程中，会先初始化其父类中的成员至子类的内存段中，然后去初始化子类中的成员，也就是说子类的初始化顺序是在其父类中的成员初始化完毕后发生的，所以在子类即将被释放的时候，也会先释放掉子类中的成员然后再去释放掉其所继承下来的父类中的成员

我们可以把这个类的构造和析构的过程理解成一个盖房子的工作，再开始之前，我们往往需要设定一份蓝图，然后从外部开始建造，建造完毕后开始装填内部的装饰，而拆卸时的顺序则反之

<br/>

<span id = "当子类的析构函数被调用了后，它里面的内存是真的被清空了吗"></span>

#### 当子类的析构函数被调用了后，它里面的内存是真的被清空了吗？

上一小节阐明了，子类的析构调用顺序是由外向内进行逐层扩展的(仅单纯的定义一个子类的情况下，这里不讨论使用 new 来构建多态的情况)，这和编译器的调用顺序还有函数栈帧的出栈顺序都存在一定的关系，但现在我们思考一个问题，<font color = "red">当子类的析构函数被调用了后，它里面的内存是真的被清空了吗？</font>

我们可以查看以下代码

```cpp
#include <iostream>
#include <vector>
#include <deque>

class BASE {
public:
  virtual void foo() {
    std::cout << "BASE foo" << std::endl;
    std::cout << *(int *)((char *)this + 8) << std::endl;
  }

  virtual ~BASE() {
    foo();
    std::cout << "BASE destructor" << std::endl;
  }
};

class CHILD : public BASE {
int var = 1024;

public:
  void foo() override {
    std::cout << "CHILD foo" << std::endl;
  }

  ~CHILD() override {
    std::cout << "CHILD destructor" << std::endl;
  }
};

int main(void) {
  BASE *b = new CHILD();
  b->foo();

  delete b;

  return EXIT_SUCCESS;
}
```

在这里，我们可以通过 [继承的内存模型](#继承的内存模型) 中所学到的知识，在父类中通过字长位移以跳过 **_vfptr_** 的方式在父类中获取子类的成员，我们会发现，实际上即便是子类调用完了析构函数后，子类中的成员 var 并没有被释放掉

这其实和编译器所构造的汇编指令有关，我们可以把上面的关系来临摹一段伪汇编的代码

```asm
.main
  call CHILD_DESTROCTORY
  call BASE_DESTROCTORY
  call CLEAN_MEMORY_OF_CURRENT_STACK_FRAME
```

<br/>

<span id = "显示指定父类构造函数进行父类成员的初始化工作"></span>

#### 显示指定父类构造函数进行父类成员的初始化工作

子类在实例化的过程中会先初始化其所继承下来的父类中的成员，即调用父类中的构造函数，如在没有进行显式指定的情况下，编译器对此的调用都是父类中的 **_默认构造函数_**，那么，当我们在子类中并没有显式的指定父类初始化所需的构造函数，并且父类中有一个我们所自定义的构造函数时，子类在进行实例化时就会失败，原因在于当我们在父类中自定义了一个构造函数后，编译器就不会为其再去提供一个默认的构造函数，那么这个子类在进行实例化的过程中，由于编译器找不到其父类的默认构造函数所以报错了，解决这一办法只需要在其父类中添加一个默认的构造函数即可解决，当然更推荐的做法则为在子类的构造函数的 [初始化列表](#构造函数中的初始化参数列表) 中显示指定其父类初始化所需使用的构造函数即可解决 ： <font color = "red">basic(type1.type2,……)</font>，<font color = "red">在这里需要注意的是，我们尽量保证显式指定基类的构造函数调用要放在初始化列表的最前面，虽然不遵守这一规则也能够编译通过并正常使用，但是这样的话就不太符合派生类的实例在初始化的过程中会先初始化其父类然后再初始化派生类中的成员这一逻辑关系了(只是看着不像，并不意味着我们这们写会造成先初始化派生类内部的成员)</font>

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  int id;
  Person(int _id) : id(_id) { }
};

class Student : public Person {
public:
  const char *name;

  Student(const char *_name) : Person::Person(30), name(_name) {
    cout << "Person id = " << Person::id << endl;
    cout << "Student name = " << this->name << endl;
  }
};

int main(void) {
  Student stu("hello,world");

  return EXIT_SUCCESS;
}
```

<br/>

<span id = '引用父类中的成员'></span>

#### 引用父类中的成员

**_关于一段继承体系中，调用存在二义性的问题_**

在一个类所属的一段继承关系中，我们要保证成员之间的调度不会出现二义性的问题，对于 : 

- 派生类和基类中存在名字相同的成员的时候，调用会存在二义性，编译器会直接隐藏掉基类中会因为此次调用而造成二义性冲突的成员(如果是所冲突的成员为函数，则隐藏掉其包括所有重载的版本)，也就意味着可能我们本次针对该成员的调用是想访问在其基类实例中该成员的信息，但是实际上获取到的却是当前派生类实例中该成员的信息

- 派生类所继承的多个基类中存在同名成员时，调用会存在二义性，因为编译器并不知道该调用到底是针对派生类继承的基类 **basicA_** 中的成员亦或者说继承的基类 **basicB_** 中的成员，故针对这种情况下编译器会直接报错，导致编译不通过

- 当一个派生类中同时存在以上两种情况的继承关系时，第一种情景会优先覆盖掉第二种情景所发生的问题

**_显式的引用父类中的成员_**

为了解决上面所提到的 **_关于一段继承体系中，调用存在二义性的问题_** 问题，我们可以在调用时显示的指定当前所调用成员具体是在哪个所属基类的作用域下，如下面的代码所示 : 

```cpp
class person_base {
public:
  char m_gender = 'K';
  const static int s_id = 0x80;

public:
  void fun_test(void) {
    cout << "Hello,person_base" << endl;
  }
  void fun_test(int a) {
    cout << a << endl;
  }
};

class student : public person_base {
public:
  int m_age;
  char m_gender = 'o';
  const static int s_id = 0x400;

public:
    void fun_test(void) {
        cout << "Hello,student" << endl;
    }
};
int main(void) {
  student stu;

  stu.m_gender;
  stu.person_base::m_gender;      /* 显示的调用父类中的普通变量成员 */

  stu.s_id;
  student::s_id;
  stu.person_base::s_id;          /* 显示的调用父类中的静态变量成员 */
  student::person_base::s_id;     /* 显示的调用父类中的静态变量成员 */
  student::person_base::s_id;     /* 显示的调用父类中的静态变量成员 */
  person_base::s_id;          

  stu.fun_test();
  stu.person_base::fun_test();    /* 显示的调用父类中的函数成员 */
  stu.person_base::fun_test(1);   /* 显示的调用父类中的函数成员 */

   return EXIT_SUCCESS;
}
```

当然，对于 :: 操作符去引用具体基类作用域的作用并不单单只是通过子类的实例来完成显示调用其基类中的成员的目的，我们在子类的实例的上下文中，同样可以直接通过 :: 去引用其基类的作用域以达到在子类的上下文中使用 **_base_** 的效果(<font color = "red">cpp中并没有 **_base_** 指针，但是可以通过这种方式来达到 **_base_** 指针的效果</font>)

```cpp
class person_base {
public:
  char m_gender = 'K';
};

class student : public person_base {
public:
  int m_age;
  char m_gender = 'o';

public:
  student() {
    person_base::m_gender = 'Z';
    cout << person_base::m_gender << endl;

    this->m_gender = 'Q';
    cout << this->m_gender << endl;
  }
};
```

<br/>

<span id = "里式转换"></span>

#### 里式转换

里式转换这一概念其实并不陌生，我们在其它的 OOP 语言中也看到过这个概念，而 cpp 中同样遵循着这一规律，即 : 

- 基类的 **_指针_** 可用于接收一个子类实例的内存地址(<font color = "red">向上类型转换</font>)

- 当基类的 **_指针_** 所指向的是一个子类的实例在内存中的地址，那么这个基类指针可以强转为子类指针(<font color = "red">向下类型转换</font>)

上面所提到的都是 **_指针类型_** 可遵循，<font color = "red">其实也就是说 **_引用类型_** 同样也可以适用</font>，因为引用类型其实质就是一个指针

为什么指针类型为基类的指针可用于接收一个子类实例的地址？通过[继承的内存模型](#继承的内存模型)一节中，我们可以知道，基类中的成员数据会从其派生在内存中的首地址开始优先构建的，那么<font color = "red">当我们用一个基类类型的指针去接收一个子类实例在内存中的首地址的时候，是没有任何问题的，因为我们只是通过基类类型的指针去改变了指针解引用的步长限定在子类在内存段中，独属于基类成员数据的那段内存的范围内，即仅仅是操作针对于该派生的基类内部所保有的成员数据，反之，一个合法的指针(基类的指针所指向的地址是一个子类的实例)也同样是能够用于强转为子类指针，因为该操作同样也仅仅只是改变了指针的解引用方式，使之解引用的步长能够扩散到整个派生类所占用的范围，这是一种 **_安全的转换关系_**</font>，我们要明白的是，<font color = "red">指针的类型永远只是用来衡量解引用操作在内存段中所需的偏移量，并不意味着指针的类型就代表了整个实例的本身</font>，那么反过来，<font color = "red">一个派生类类型的指针是否可以接收其基类实例在内存中的地址呢？答案肯定是 **_不可以的_**，因为作为派生类所继承下来的基类中的成员这个是属于它们之间的共性，基类中的成员的数据往往能够且足够被包含在子类实例所指向的内存空间内，但是作为派生往往存在着它的一些特性，简而言之就是一个派生类在内存中的内存单元通常都是要比其基类要大的，那么当我们使用一个偏移步长为派生类的指针去对一个内存长度小于或者等于派生类步长的基类实例做解引用操作的时候，就会发生内存越界的情况，是一种 **_不安全的操作_**</font>

```cpp
#include <iostream>
using namespace std;

class person_base {
public:
  char m_gender = 'K';
};

class student : public person_base {
public:
  int m_age = 10;
};

int main(void) {
  student stu_stack;
  person_base *base_1 = &stu_stack;

  person_base *base_2 = new student();
  student *stu_heap = (student *)base_2;

  return EXIT_SUCCESS;
}
```

其实单纯的类类型也符合这一规律，即，基类可以接收一个子类的实例用于初始化，当基类的实例是通过子类来初始化完成，那么在子类 拥有符合条件的构造函数的情况下(由于需要构成对于子类的，故派生类中需要有一个基类引用作为形参的构造函数)可以完成基类强转为派生类，但是需要注意的是，这种转换关系所依赖的是基类中的 拷贝/移动构造(即形参为基类的引用)(基类接收一个子类的实例用于初始化)亦或者通过子类中 拥有符合条件的构造函数(基类强转为派生类)来完成的，即<font color = "red">该转换方式是会丢失掉子类中的成员数据的，那么在一个基类并不保有子类的成员数据的情况下，这种转换同样也是不符合多态的</font>，<font color = "red">在这种转换情境之下，真正符合多态的定义仅仅只是在把子类的实例用作于基类构造时，因为基类构造的形参是基类的引用并引用了一个派生类的实例</font>

```cpp
#include <iostream>
using namespace std;

class person_base {
public:
  char m_gender = 'K';

  person_base() {}

  person_base(person_base &per) {
    this->m_gender = per.m_gender;
  }

  person_base(person_base &&per) {
    this->m_gender = per.m_gender;
  }
};

class student : public person_base {
public:
  int m_age = 10;

  student() : person_base(*this){};

  student(person_base &per) {
    this->m_age = 10;
  }
};

int main(void) {
  person_base base = student();

  student stu = (student)base;

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "菱形继承"></span>

#### 菱形继承

菱形继承关系，即最下级派生类所继承的多个基类是共同派生自同一个最上级基类，这时候就会造成一些问题 : 

1. 由于最下级派生类所继承的多个基类都是继承自同一个最上级基类，故它们所继承自最上级基类中的属性其实以最下级派生类的眼光来看待的话，是存在 **_属性重复_** 的问题的，如下图，最上级基类保有一个 `SEX` 性别的成员，而其下级派生类中由于继承自 `ANIMAL` 最上级基类的关系，它们同样都拥有着 `SEX` 性别的成员，但是如果把继承的体系继续延伸到 ANIMAL 的二级派生类(最下级派生类) `BYBIRD` 时，`BYBIRD` 所继承自 `DOG` 和 `CAT` 身上的 `SEX` 成员属性(原始来源 ANIMAL)是存在重复的，因为即使是 杂交动物(`BYBIRD`) 也只能有一个性别的属性

2. 由于 `HYBIRD` 的直接上级父类 `DOG` 和 `CAT` 中都保有相同的属性 `SEX`，故当我们想通过 `HYBIRD` 的实例去获取其父类的属性 `SEX` 时就会造成二义性的问题，并且这种二义性问题的情景会直接导致编译失败

```cpp
class ANIMAL {
public:
  char SEX;
};

class DOG : public ANIMAL { };

class CAT : public ANIMAL { };

class HYBIRD : public DOG, public CAT { };
```

```text
                    ANIMAL
                 +----------+
+----------------+-> SEX <--+-----------------+
|                +----+-----+                 |
|                     |                       |
|                     |                       |
|                     |                       |
|                     |                       |
|        +------------+-------------+         |
|        |                          |         |
|        |                          |         |
|        v                          v         |
|       DOG                        CAT        |
|   +----------+               +----------+   |
+-----> SEX    |               |   SEX <------+
    +----+-----+               +----+-----+
         |                          |
         |                          |
         |                          |
         +------------+-------------+
                      |
                      |
                      v
                    HYBIRD
                 +----------+
                 |          |
                 +----------+

------------------------------------------------------+
                                                      |
class HYBIRD   size(2):                               |
   +---                                               |
 0 | +--- (base class DOG)                            |
 0 | | +--- (base class ANIMAL)                       |
 0 | | | SEX                                          |
   | | +---                                           |
   | +---                                             |
 1 | +--- (base class CAT)                            |
 1 | | +--- (base class ANIMAL)                       |
 1 | | | SEX                                          |
   | | +---                                           |
   | +---                                             |
   +---                                               |
------------------------------------------------------+
```

虽然我们可以采用 `::` 引用具体某个基类作用域的方式去解决 **_第二类导致编译失败的问题_**，但是这样做所导致的只是 '程序上' 没有问题，设计上却没有遵循 'OOP' 规范，故更好的做法是采用 <font color = "red">**_虚基类继承_**</font>

<br/>

<span id = "虚继承"></span>

#### 虚继承

在继承基类时通过关键字 `virtual` 来声明当前所继承的基类是一个 <font color = "red">**_虚基类_**</font>，而这种继承虚基类的继承方式则称为 <font color = "red">**_虚继承_**</font>

<font color = "red">一个派生类通过虚继承的方式继承了某个虚基类时，派生类所继承的虚基类中的成员是被 **_共享_** 的，当然这种共享关系的视角是由继承虚基类的派生类继续往下延生的派生才能得以体现</font>，也就是说，继承自虚基类的派生类往下所衍生到的派生其实例的内存模型仅有一份上级虚基类中的成员，区别于普通的多继承，对于普通的多继承体系，是无法保证最上级基类往后所延伸到的最终派生在内存中的模型仅保有一份该最上级基类中的成员信息，正如 **_菱形继承_** 所存在的问题，最上级派生中的成员 `SEX` 衍生至最下级派生 `HYBIRD` 中其实是有两份 `SEX` 成员信息的，它们分别继承自 `DOG` & `CAT`，而当 `CAT & DOG` 使用虚继承的方式继承自 `ANIMAL` 时，它们所向下衍生出的派生其内存模型是仅有一份来自于最上级基类中的成员 `SEX` 的信息的，其从根本上解决了多继承可能存在的成员重复的问题和成员二义性可能导致的 OOP 逻辑错误的问题

```cpp
class ANIMAL {
public:
  char SEX;
};

class DOG : public virtual ANIMAL { };
class CAT : public virtual ANIMAL { };

class HYBIRD : public DOG, public CAT { };
```

**_虚继承内部实现_**

我们都知道，一起存在着一段继承体系的类，其在实例时会 **_优先_** 初始化其所继承的最上级基类(默认情况下调用基类的默认构造函数)的所有成员至以子类实例为基准所构建的内存段上，然后再以父类中的成员所构建的数据所在内存地址的结束位置继续往下初始化子类中的成员数据，虚继承同样于此，但是放在其派生类的内存首段的数据并不再是虚基类中的成员数据，而是一个名为 **_vbptr_** 的指针，该指针指向了一个名为 **_vbtable_** 的表格，该表格维护了指向其的 **_vbptr_** 的指针在内存中的首地址到虚基类中的成员信息的偏移量，而<font color = "red">虚基类中的成员数据实际上被放到了派生类在初始化完毕内部成员后继续往下所延伸的地址上</font>，依据菱形继承中，`ANIMAL DOG CAT HYBIRD` 之间的继承关系，我们把 `DOG` 和 `CAT` 改用虚继承的方式继承自 `ANIMAL`，那么其内存模型图如下

```cpp
class ANIMAL {
public:
  char SEX;
};

class DOG : public virtual ANIMAL { };
class CAT : public virtual ANIMAL { };

class HYBIRD : public DOG, public CAT { 
public:
  char *name;    
};
```

```text
class HYBIRD   size(11):
   +---
 0 | +--- (base class DOG)
 0 | | {vbptr}
   | +---
 4 | +--- (base class CAT)
 4 | | {vbptr}
   | +---
 8 | name
   +---
   +--- (virtual base ANIMAL)
12 | SEX
   +---

HYBIRD::$vbtable@DOG@:
 0 | 0
 1 | 8 (HYBIRDd(DOG+0)ANIMAL)

HYBIRD::$vbtable@CAT@:
 0 | 0
 1 | 4 (HYBIRDd(CAT+0)ANIMAL)
```


我们会发现，原本 `HYBIRD` 的内存首段信息本该出现的 `DOG` 和 `CAT` 的数据都替换为 **_vbptr_** 的形式了，而本该出现的两个 `SEX` 成员变成����只有一个(共享机制)并被放在派生类成员��始化的数据往后延生的内存段上(virtual base ANIMAL)，<font color = "red">当我们想访问 `BYBIRD` 的基类所继承下来的 `SEX` 数时，会依据指针 **_vbptr_** 所指向的 **_vbtable_**，在里头找到该 **_vbptr_** 指针在内存中的首地址到虚基类中的成员信息的偏移量，然后再依据这个偏移量从派生类的首地址开始偏移，以找到仅有的 SEX 成员</font>，保证调用不会存在二义性，我们可以简单的理解为 : <font color = "red">不管采用什么样的方式去调用(直接通过子类的实例亦或者通过 :: 去引用具体某个基类的作用域)基类中的成员信息，所获取到的始终都是同一个最上级虚基类的成员信息</font>

稍微扩展一下的是，`DOG` 和 `CAT` 都是采用的虚继承的方式去继承了 `ANIMAL`，也就是说放在他们各自的角度来看，`CAT` 和 `DOG` 的实例都各自维护了各自的 **_vbptr_** 的指针和各自的 **_vbtable_**，而同时派生自 `DOG` 和 `CAT` 的派生类 `HYBIRD` 来说，由于继承的传递性那么它就分别拥有了 `DOG` 和 `CAT` 各自维护的 `vbptr` 和 `vbtable`，也就是说 `HYBIRD` 的最终内存模型是拥有两个 **_vbptr_** 和 **_vbtable_** 的，但是由于该 **_vbptr_** 所维护的都是同属于一个虚基类中的成员信息，所以就算最下级派生类中出现了重复的 **_vbptr_** 和 **_vbtable_** 也不会造成二义性的调用，因为其最终的调用都会依据当前 **_vbptr_** 所在的地址和不同的偏移量去找到共同的最上级虚基类中的成员信息

虚继承到底是 **_虚_** 在哪里？虚就虚在所继承的基类中的成员信息，<font color = "red">当一个类使用的是虚继承的方式继承了一个虚基类，那么其所衍生到的派生类真正继承下来的仅仅只是那个因为使用虚继承的关系而生成的 **_vbptr_** 的指针和所指向的 **_vbtable_**，真实的，其继承自虚基类的成员信息由 **_vbptr_** 和 **_vbtable_** 所共同维护着</font>

**_虚继承的构造顺序_**

<font color = "red">一个存在虚基类的继承体系中，虚基类的构造函数将交由 **_当前所初始化的、某个虚基类往下所派生的子类_** 来负责显式调用构造(如果当前类的上级基类也同样显式调用了虚基类的构造，则该调用失效)</font>，并且，<font color = "red">在构造的过程中，虚基类总是会被优先调用构造的(假设虚基类还存在基类的情况)(该优先构造的工作是用于初始化虚基类所衍生出来的 **_vbptr_** 指针和其所指向的 **_vbtable_**)，在完成虚基类的优先初始化工作后则按照正常的继承关系的初始化方式继续完成当前实例的构造，即从最上层基类逐层往下初始化直接基类(不包含虚基类)和直接基类往下所派生的子类</font>

如下面的代码所示，我们在虚基类的上层还增加了一个最终基类 `BIOLOGICAL(物种)`，它用于反馈一个存在虚基类的继承体系中，虚基类永远都是永远初始化的情况，其次，我们在 `DOG CAT HYBIRD` 都分别显式的调用了虚基类的构造，这用于反馈虚基类的显式构造的调用永远都是交由当前所实例化的类来完成这一情景

```cpp
#include <iostream>
using namespace std;

class BIOLOGICAL {
public:
  BIOLOGICAL(){
    cout << "BIOLOGICAL CONSTRUCTOR" << endl;
  };
  BIOLOGICAL(char _SPECIES)
    : SPECIES(_SPECIES) {};
public:
  char SPECIES = 'P';
};

class ANIMAL : public BIOLOGICAL {
public:
  ANIMAL() : BIOLOGICAL() {}
  ANIMAL(char _SEX)
    : SEX(_SEX) {
    cout << "ANIMAL CONSTRUCTOR" << endl;
  }
public:
  char SEX = 'K';
};


class DOG : public virtual ANIMAL {
public:
  DOG(char *name)
    : ANIMAL('D'), d_name(name) {
    cout << "DOG CONSTRUCTOR" << endl;
  }
public:
  char *d_name;
};


class CAT : public virtual ANIMAL {
public:
  CAT(char *name)
    : ANIMAL('C'), c_name(name) {
    cout << "CAT CONSTRUCTOR" << endl;
  }
public:
  char *c_name;
};


class HYBIRD : public DOG, public CAT {
public:
  HYBIRD(char *name, char _SEX)
    : ANIMAL(_SEX), DOG(name), CAT(name) {
    cout << "HYBIRD CONSTRUCTOR" << endl;
  }

public:
  int h_age = 0x400;
};


int main(void) {
  HYBIRD bird((char *)"hello,hybird", 'H');

  CAT cat((char *)"hello,cat");

  DOG dog((char *)"hello,dog");

  return EXIT_SUCCESS;
}
```

**_通过虚继承的方式实现多继承_**

<font color = "red">当一个类中继承了多个虚基类，该类的实例其内存模型也仅有一个 **_vbptr_** 的指针和 **_vbtable_**，但是，**_vbtable_** 中会保存多个相对于当前 **_vbptr_** 到来自于不同虚基类中的成员信息的偏移量</font>(以保证能够成功的获取到不同虚基类中的成员信息)，区别于上一小节，上一小节是由于一个类继承了两个不同的基类但是它们都继承自同一个虚基类，那么作为下级派生就应当拥有上级基类中各自的成员信息，也就是两个 **_vbptr_** 和 **_vbtable_**

```cpp
class DOG { 
public:
  char *d_name = (char *)"DOG!";
};

class CAT { 
public:
  char *c_name = (char *)"CAT!";
};

class HYBIRD : public virtual DOG, public virtual CAT { 
public:
  char *h_name;    
};
```

```text
class HYBIRD   size(16):
   +---
 0 | {vbptr}
 4 | name
   +---
   +--- (virtual base DOG)
 8 | d_name
   +---
   +--- (virtual base CAT)
12 | c_name
   +---

HYBIRD::$vbtable@:
 0 | 0
 1 | 8  (HYBIRDd(HYBIRD+0)DOG)
 2 | 12 (HYBIRDd(HYBIRD+0)CAT)
```

继上一段代码的情景，<font color = "red">我们要保证一个类所继承的多个虚基类中并不会出现同名的成员信息，否则同样会出现成员调用的二义性</font>，这里需要区别于[菱形继承](#菱形继承)中所造成二义性的情景，菱形继承造成的二义性的根本原因是因为最下级派生所继承的多个基类都用用着共同的成员属性(它们都继承自同一个最上级基类)而导致最下级派生中存在着多个同名的成员属性，这种情况之下我们对于最下级派生的基类都采用虚继承的方式使它们继承自同一个最上级基类，那么转换到最下级派生的视角来看，原有的继承下来的重名成员都会因为其上级基类是使用虚继承的关系，所以真正被继承下来的都是 **_vbptr_** 和 **_vbtable_**，我们可以理解为在这种情况下重名的成员转变成 **_vbptr_** 和 **_vbtable_**，但由于他们所继承下来的属性都同属于一个虚基类上的成员信息，故在这种情况下不管我们是对该理应被重名的成员采取任何的访问方式都不会造成二义性，那么假设我们对于当前类采用虚继承的方式继承了多个虚基类，并且 多个虚基类中存在着同名的成员，这时候就又会出现二义性的问题了，<font color = "red">该二义性的发生并不是由本身的继承关系而造成的，是因为虚继承本身继承下来的成员就存在二义性所产生的，即 **_vbptr_** 和 **_vbtable_** 本身就维护着同名的成员</font>，所以这种情况之下并不能依赖于 **_为了解决本身继承所产生的二义性关系的虚继承_** 来解决，只能在采用虚继承继承了多个虚基类的派生亦或者其下级派生在调用产生二义性成员时使用 :: 引用具体某个虚基类的作用域的方式来避免这一问题，下面的代码则展示了该问题

```cpp
class DOG {
public:
  char *name = (char *)"DOG!";
};

class CAT {
public:
  char *name = (char *)"CAT!";
};

class HYBIRD : public virtual dog, public virtual cat { };     
```

```text
class HYBIRD    size(12):
   +---
 0 | {vbptr}
   +---
   +--- (virtual base DOG)
 4 | name
   +---
   +--- (virtual base CAT)
 8 | name
   +---
                 
HYBIRD::$vbtable@:
 0 | 0
 1 | 4 (HYBIRDd(HYBIRD+0)DOG)
 2 | 8 (HYBIRDd(HYBIRD+0)CAT)    
```


<br/>

<span id = "虚函数"></span>

#### 虚函数

虚函数的存在并不陌生，即 : <font color = "red">如果一个基类的指针(引用)所指向的是其派生实例在内存中的首地址并且该派生对于基类中的虚函数进行了重写，那么我们在使用这个基类的指针(引用)在调用其虚函数时，所调用的是派生类中的重写实现</font>

<font color = "red">需要注意的是，是只有使用基类的类型的指针(引用类型)去指向了重写了基类中的虚函数的派生的实例在内存中的首地址，并通过该指针去对虚函数进行调用才能够符合虚函数重写覆盖调用的定义的，因为只有在这种情境之下的声明才符合多态的定义</font>，具体原因参照[里式转换](#里式转换)

<span id = "如何编写虚函数"></span>

**_如何编写虚函数_**

一个成员函数的生面前添加 **_virtual_** 关键字来完成能够完成虚函数的定义，当一个类中声明了一个虚函数，那么它所派生出来的子类亦或者子类往下继续延生的派生都可以 <font color = "red">**_选择性地_**</font> 完成对它的重写，对于虚函数的重写有两种方式 : 

- 在派生类中声明了一个相同函数签名(相同返回值、相同函数名、相同形参列表)的函数

- 在派生类中声明了一个相同函数签名(相同返回值、相同函数名、相同形参列表)的函数，并在结尾使用了 **_override_** 关键字进行修饰

两种重写虚函数的方式所达到的效果是一样的，意为该函数重写了上级基类的虚函数，不同的是，<font color = "red">第二种方法如果在其基类中并没有找到对应 函数签名的虚函数时，则会编译报错，反观第一种重写方案，当基类中并没有对应函数签名的虚函数时编译并不会报错</font>，该函数仅仅只是被当成是当前派生类中的一个成员函数，在 cpp 标准中规定，对于虚函数的重写更加推荐的方式则为第二种方案

<span id = "虚函数的内部实现"></span>

**_虚函数的内部实现_**

当一个类中声明了一个虚函数后，那么该实例的创建编译器会附带创建一个名为 **_vfptr_** 的指针，并插入到在其实例在内存中的首段位置，该指针指向了一个名为 **_vftable_** 的表格，该表格所维护的则为 <font color = "red">**_在基类中声明为虚的成员函数亦或者下级派生所重写的虚函数 在内存中的首地址_**</font>，当我们通过该类的实例去调用这个虚函数时，编译器并不会直接依照所调用函数的首地址进行调用，而是会根据 **_vfptr_** 指针所指向的 **_vftable_** 中，在其内部寻找所维护的函数地址并进行调用

<font color = "red">假设声明了虚函数的类进行了向下的派生，基类中的成员所衍生到的派生类随同一并继承下来的还会包括那个因为 虚函数 所生成的 **_vfptr_** 指针和其所指向的 **_vftable_**，如果在当前的派生中显示的指定了对于基类中的虚函数进行了重写，那么编译器会把当前派生中所重写至基类中的虚函数的成员函数在内存中的首地址 在 **_vftable_** 当中替换掉原本属于上级基类中的成员函数的首地址，故这时候 **_vftable_** 中所维护的函数地址其实为派生中所重写的虚函数，那么当我们使用一个指向派生类实例在内存中的首地址的基类类型的指针去调用虚函数时，所调用的则为在派生类中的重写实现</font>，如下面的代码 :

```cpp
class Animal {
public:
  Animal() {
    cout << "ANIMAL CONSTRUCTOR" << endl;
  }
public:
  virtual void speak() {
    cout << "ANIMAL SPEACKING!" << endl;
  }
public:
  int a_age;
};

class Cat : public Animal {
public:
  Cat() {
    cout << "CAT CONSTRUCTOR" << endl;
  }
public:
  void speak() override {
    cout << "CAT SPEAKING" << endl;
  }
public:
  int c_age;
};
```

```text
class Cat size(12):
   +---
 0 | +--- (base class Animal)
 0 | | {vfptr}
 4 | | a_age
   | +---
 8 | c_age
   +---

Cat::$vftable@:
   | &Cat_meta
   |  0
 0 | &Cat::speak
```

由于继承的延续性，**_vftable_** 会随着往下的派生而继续延生，也就是说，一段继承体系中，继续往下的某一个派生如果重写了上级基类中的虚函数，那么其重写的虚函数的首地址同样会覆盖掉 **_vftable_** 中所维护的函数地址，否则不会(**_可以选择性的进行重写_**)，其实简而言之，虚函数的调用依据永远都是依照 **_vftable_** 来进行的，而 **_vftable_** 则根据我们当前所实例化的类的重写依据的实现而实现，就上面的代码来说，我们实例化的是 `Cat` 并使用其 **_基类指针_** 去接收，那么 **_vftable_** 中最终所纳入的实现则为 `Cat` 中所重写的虚函数的首地址，假设 `Cat` 又往下衍生了一个派生，并且派生中重写了最上级基类中的虚函数，反之 `Cat` 并没有，那么我们在使用 **_基类指针_** 去接收最下级派生(Cat往下的派生)的实例的首地址的时候，**_vftable_** 则会依照 `Cat` 往下的派生所重写的函数而实现，反之在这种情境之下我们使用 **_基类指针_** 再去接收 `Cat` 实例的时候，这时候重写的依据就不再是 `Cat` 了，因为 `Cat` 中压根就没有进行过重写，那么 **_vftable_** 所维护的还是最上级基类中的实现

简而言之，<font color = "red">虚函数到底是使用当前继承体系中哪一个派生的重写，根据我们所具体实例化的对象来决定</font>


<br/>

<span id = "虚析构"></span>

#### 虚析构

对于一个存在着一段继承关系的类来说(最下级派生)，我们单纯的创建了针对于它的实例，那么当它即将被释放时，析构的调用惯例(这里仅仅讨论的是析构的调用顺序，并不是释放，对于释放而言自然是全都会被释放)是从内向外而进行的，即从最下层的派生中开始逐步往上层进行调用，但是对于需要进行多态操作的类来说，我们往往是使用一个基类去接收一个派生类的赋值，以通过最上级基类在保有派生类中的 **_'特性'_** 的情况下完成多态的操作

**_对于普通的在栈中所构建的多态而言_**，其释放顺序自然是标准的由内向外的顺序，因为在栈中所构建的多态，往往是需要我们在当前栈帧(函数)上下文中先去构建一个派生的实例，再使用上级基类类型的指针去接收这个下级派生实例在内存中的首地址，然后再通过这个类型为基类的指针去完成多态的操作，而这种操作之中，<font color = "red">重点的是，我们在当前栈帧上下文中先手动的构建了作为下级派生的实例，那么自然作为栈帧出栈时自然也会遵循着我们所构建的这个下级派生的实例，由内向外的进行析构的逐层调用</font>

**_但是对于在堆中所构建的多态而言_**，我们往往都是直接 `new` 一个派生类型实例并 **_直接_** 使用 **_基类类型的指针_** 去接收，那么当我们去 `delete` 释放这块内存的时候，<font color = "red">因为 `delete` 所释放的视角是以基类类型为开始的</font>，那么在这种情况之下，`delete` 虽然是能够释放掉所 `new` 的内存(确保所 `new` 出来的内存首地址是正确)，但是其继承体系的析构调用顺序仅仅只是从当前 **_基类类型_** 中开始，而不是标准的从内向外了，当然，如果我们把上面的情景转换为使用的是 **_当前所 new 的派生类型的指针做为接收_**，那么当我们在 delete 的时候，由于视角是从下级派生所开始，那么其析构的调用顺序也是由内向外的了

其实归根结底，仔细研究上面的两种情景我们会发现，<font color = "red">释放的顺序到底是由内向外还是仅仅只是作为自身往往都是由编译器在我们的代码中所看到的具体是由哪一层次的类来操作的视角来决定</font>，就拿情景一来说，由于我们在栈中显示的声明并使用了下级派生的变量，那么其在释放的时候，析构的调用顺序也自然依照这个下级派生开始由内向外进行释放，<font color = "red">而情景二中由于我们所声明的真正的变量是 **_基类类型_** (虽然内部的实现是其下级派生) 并且在 delete 的时候也是从 **_基类类型_** 这个层次的类作为视角而开始，故其即将被释放时，析构的调用顺序仅仅只是从 **_基类类型_** 这个上级基类开始，那么就有可能导致下级派生中的析构因为无法正常的调用但是下级析构却会维护着当前层次中声明在堆中的内存的生命周期而导致内存泄漏的问题，针对这种情景，我们这就需要引入 **_虚析构_** 的使用了</font>

虚析构，它能够保证我们所释放的成员以 **_上级基类_** 作为视角时，也能够在调用 **_上级基类_** 的虚构函数前会优先调用作为基类的派生并且重写了的虚析构的实现，作为基类中的 **_虚析构源_** 和其下级派生所 **_重写的虚析构_**，其同样也会由 **_vfptr_** 和 **_vftable_** 所维护着，如果在下一级派生中重写了上层的虚析构的话，则会在当前派生的上下文中替换掉 **_vftable_** 中关于上级虚析构在内存中的首地址，否则不会(可以选择性地进行重写，其原理和虚函数一致)，那么当我们释放的成员是以 **_上级基类_** 做为视角的情况下，则会依照 **_vftable_** 中所维护的当前继承体中的虚构函数的具体实现来决定由内向外的释放顺序

```cpp
#include <iostream>
using namespace std;

#include <string.h>

class Animal {
public:
  Animal(int _age)
    : a_age(_age) {
    cout << "ANIMAL CONSTRUCTOR" << endl;
  }
  virtual ~Animal() {
    cout << "ANIMAL DESCRTUCTOR" << endl;
  }

public:
  int a_age;
};


class Cat : public Animal {
public:
  Cat(int _age, char *_name)
    : Animal(_age) {
    cout << "CAT CONSTRUCTOR" << endl;
    this->name = new char[strlen(_name) + 1];
    strcpy(this->name, _name);
  }
  ~Cat() override {
    cout << "CAT DESTRUCTOR" << endl;
    delete[] this->name;
  }

public:
  char *name = nullptr;
};


class HEITAN : public Cat {
public:
  HEITAN(int _age, char *name)
    : Cat(_age, name) {
    cout << "HEITAN CONSTRUCTOR" << endl;
  }
  ~HEITAN() override {
    cout << "HEITAN DESTRUCTOR" << endl;
  }
};

int main(void) {
  Animal *animal = new HEITAN(1, (char *)"heitan");
  delete animal;

  return EXIT_SUCCESS;
}
```

```text
class HEITAN    size(12):
   +---
 0 | +--- (base class Cat)
 0 | | +--- (base class Animal)
 0 | | | {vfptr}
 4 | | | a_age
   | | +---
 8 | | name
   | +---
   +---
HEITAN::$vftable@:
   | &HEITAN_meta
   |  0
 0 | &HEITAN::{dtor} 
```

需要补充一点的是，虚析构同样是遵循着[虚函数](#虚函数)小节中所说明的特性，因为它本身就是一种虚函数，只是是一种虚构函数，我们无需把它想多过于复杂，只用把它理解为虚析构和虚析构的重写能够决定一段声明在堆中的多态继承体系的析构函数调用顺序和时机即可 

<br/>

<span id = "纯虚函数"></span>

#### 纯虚函数

<font color = "red">纯虚函数即声明的虚函数的实现赋值为 0，在这种情况之下，作为其下级派生则 **_必须_** 要对其进行重写，否则会导致编译不通过</font>，并且，<font color = "red">一个类中一旦出现了一个纯虚函数，那么这个类就被编译器认作为一个 抽象类</font>，在 cpp 中对于抽象类的特性有仅有一点，即无法使用该抽象类型作为一个声明，即包括: 普通的声明、函数的形参、返回值，<font color = "red">我们是可以理解为，出现抽象类的地方，它只能够以指针或引用的形式而存在</font>

对于纯虚函数而言，它其实和普通的虚函数是一样的，只是对于纯虚函数而言多了一条限制是其往下的派生必须要对该纯虚进行重写，否则会编译不通过

```cpp
#include <iostream>
using namespace std;

#include <string.h>

class Animal {
public:
  Animal() {
    cout << "animal constructor" << endl;
  }
  
  /* 纯虚函数 */
  virtual void speak() = 0;

  virtual ~Animal() {
    cout << "animal destructor" << endl;
  };
};

class Cat : public Animal {
public:
  Cat() {
    cout << "cat constructor" << endl;
  }

  void speak() override {
    cout << "hello,world!" << endl;
  }

  ~Cat() override {
    cout << "cat destructor" << endl;
  }
};

int main(void) {
  Animal *animal = new Cat();
  animal->speak();
  
  delete animal;

  return EXIT_SUCCESS;
}
```

<font color = "red">存在一条特例是，对于纯虚的析构函数(**_存虚析构_**)来说，虽然其实现也是赋值为 0，但是为了保证析构函数在一段存在继承体系的类的释放和调用顺序，所定义的纯虚析构自身还需要另外对其进行定义，否则同样会造成编译不通过</font>，这种语义对于纯虚函数本身的确看起来很别扭，似乎纯虚析构其实现赋值为 0 并无太大意义，的确如此，纯虚析构所保证的仅仅只是能够让当前所在类声明为一个抽象类，并且保证其下级派生必须对析构进行重写仅此而已

```cpp
#include <iostream>
using namespace std;

#include <string.h>

class Animal {
public:
  Animal() {
    cout << "animal constructor" << endl;
  }
  virtual ~Animal() = 0;
};

/* 定义 Animal 中的纯虚函数 */
Animal::~Animal() {
  cout << "animal destructor" << endl;
}

class Cat : public Animal {
public:
  Cat() {
    cout << "cat constructor" << endl;
  }

  ~Cat() override {
    cout << "cat destructor" << endl;
  }
};

int main(void) {
  Animal *animal = new Cat();
  delete animal;

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "是否可以使用私有成员来实现虚函数或虚析构"></span>

#### 是否可以使用私有成员来实现虚函数或虚析构

由 [继承的内存模型](#继承的内存模型) 中了解到，cpp 对于面向对象的处理是不严谨的，<font color = "red">**对于一切的成员信息，我们应该从内存本身的角度去触发考虑这些问题，而不是着重于面向对象特性本身**</font>，那么对于这个问题的解答，也是肯定的

即，虽然我们所实现的成员都属于 <font color = "red">私有的</font>，但是它在内存中还是可见的，那么我们就可以使用这块可见的内存，替换掉 **_vbtable_** 中的相关实现

```cpp
#include <iostream>
#include <vector>
#include <deque>

class BASE {
public:
  virtual void foo() {
    std::cout << "BASE foo" << std::endl;
  }

  virtual ~BASE() {
    foo();
    std::cout << "BASE destructor" << std::endl;
  }
};

class CHILD : public BASE {
private:
  void foo() override {
    std::cout << "CHILD foo" << std::endl;
  }

  ~CHILD() override {
    std::cout << "CHILD destructor" << std::endl;
  }
};

int main(void) {
  BASE *b = new CHILD();
  b->foo();
  delete b;

  return EXIT_SUCCESS;
}
```


<br/>

<span id = "友元成员"></span>

#### 友元成员

<font color = "red">当一个 类/结构体 中某一个成员使用了 **_friend_** 关键字进行修饰，那么它就是一个友元成员</font>，它用作与<font color = "red">修饰一个 **_成员变量(通常为复合类型的变量，基础类型无意义)的声明抑或是成员函数的声明或实现_**</font>，<font color = "red">**_当所修饰的成员属于一段声明时，我们要保证在全局作用于下有该实现所链接到的定义_**</font>

<font color = "red">友元用于修饰一段声明或定义，其意为友元成员其定义的上下文中(**_对于所修饰的是一个具体对象的友元成员，那么也就意味着该对象内部的所有成员函数都保有访问私有成员的权限_**)能够得到访问友元声明所处的类型中的私有成员的权限</font>

针对上面所提到的这点，我们是需要严格区分开来的，<font color = "red">友元成员只能够保证的是，在其定义的上下文中使用友元所声明的复合类型的实例时(函数形参, 局部变量)，我们通过该实例是能够获取到该复合类型中的私有成员的，但并不意味着我们可以通过直接的方式(this指针)访问到当前类中的私有成员</font>，简单而言，<font color = "red">友元成员虽然需要被 定义/声明 在一个类的内部，然而它并不属于这个类中的一个成员，具体来讲，**_友元的定义是作用于全局作用域之下的_**</font>

```cpp
using namespace std;

#include <string.h>

class Animal {
private:
  const static int age = 0x400;
  const char *name = "hello,world";

public:
  friend void take(Animal ani);
};

void take(Animal ani) {
  cout << ani.name << endl;
  cout << ani.age << endl;
}

int main(void) {
  Animal ani;
  take(ani);

  return EXIT_SUCCESS;
}
```

友元成员存在于全局作用域之下，那么是否就意味着，如果友元所修饰的是一段定义的话，我们在是可以通过直接的方式完成对其的调用呢，答案是否定的，<font color = "red">仅当友元成员(这里指的是成员函数类型的友元成员)的参数列表中出现了当前类型(友元成员所在的类型)的参数时，才能够通过直接的方式完成对该友元所修饰的定义的调用</font> ; <font color = "red">那么对于不存在 当前类型 的参数的定义的情况之下，我们想要通过直接的方式完成对其的调用还需要在全局命名空间之下对该定义做一次另外的声明才能够完成</font>，下面的代码展示了这一段解释中所说明的两种情况

```cpp
#include <iostream>
using namespace std;

#include <string.h>

class Animal {
private:
  const static int age = 0x400;
  const char *name = "hello,world";

public:
  friend void foo_01(int i, Animal ani) {
    cout << ani.age + i << endl;
  }

  friend void foo_02();
};

void foo_02() {
  Animal ani;
  cout << ani.name << endl;
}

int main(void) {
  Animal ani;

  foo_01(10, ani);
  foo_02();

  return EXIT_SUCCESS;
}
```

**_友元成员的特性_**

- 友元成员无传递性，比如说我们在类B中声明了类A为类B的友元成员，这时候我们又在类C中声明了类B为类C的友元成员，但是并不代表着类A是类C的友元成员

- 友元成员无互逆性，比如说我们在类B中声明了类A为类B的友元成员，但不代表这类B为类A的友元

- 访问修饰符对于友元成员的调用没有任何影响，因为其作用域根本就不属于当前类当中

**_友元成员的具体使用_**

- 普通函数

  - 对于普通函数而言，友元是可以用于修饰这个函数的定义亦或者声明的

  - 对于声明为友元的函数的定义始终会被编译器当作一个 内联函数 来看待

- 类或结构体

  - 友元所修饰的类或结构体只能够用于声明 

  - 所修饰的类或结构体其内部的所有成员函数都含有访问目标对象所有私有成员的权限

- 类或结构体中的成员函数

  - 友元所修饰的类或结构体的成员函数只能够用于声明

  - 友元如果想作用于针对于某个类中的成员函数进行修饰，我们还需要使用 `::` 关键字来引用具体某个类的作用域

```cpp
#include <iostream>
using namespace std;

/* 类的前置声明，为了方便在 Friend 函数中能够使用 House 的指针，原因是因为 House 的定义在 Friend 之后 */
class House; 
class Friend {
public:
  void VistBy_GoodFriend(House *host);
  void VistBy_NGPONG(House *host);
};


class House {
  /* 全局函数声明 */
  friend void foo(House *host);
  /* 类声明 */
  friend class Friend;
  /* 类中的成员函数声明 */
  friend void Friend::VistBy_GoodFriend(House *host);
private:
  void Go2_BedRoom(void) {
    cout << "Enter BedRoom" << endl;
  }
public:
  void Go2_Toliet(void) {
    cout << "Enter toliet" << endl;
  }
};


void Friend::VistBy_GoodFriend(House *host) {
  host->Go2_BedRoom();
}
void Friend::VistBy_NGPONG(House *host) { /* 事实上，这一段函数直接在 Friend 里头定义都是可以直接 */
                                          /* 访问到 House 中的私有成员的，因为在 House 中，已经 */
                                          /* 指定了 House 类为它的友元成员，意味着其内部中的所有 */
                                          /* 成员函数都能够直接访问到 House 内部的私有成员，但是因为 */
                                          /* House 类是在 Friend 类 之后定义的，也就意味着，如果我 */
                                          /* 们直接在 Friend 内部去访问 House 类的中的成员是访问不到 */
                                          /* 的，因为编译器遵循着由上至下的编译特性 */
  host->Go2_BedRoom();
}
void foo(House *host) {
  host->Go2_BedRoom();
}

int main(void) {
  House *house = new House();

  Friend *fre = new Friend();
  fre->VistBy_GoodFriend(house);
  fre->VistBy_NGPONG(house);

  foo(house);

  delete fre;
  delete house;

  return 0;
}
```

<br/>
<br/>

<span id = "函数的扩展"></span>

## 函数的扩展

<span id="内联函数"></span>

### 内联函数

---

在c语言中，我们通常会把一些短并且执行频繁的计算写成 **_宏函数_** 以此避免函数调用所存在的出入栈开销，宏函数能够在c语言中进行广泛的使用并不是说宏函数就一定是完美无缺的，而是在c语言中似乎找不到第二个相似的特性以代替宏函数的功能，而宏对于 cpp 这种面向对象的语言来说，其存在的本身还是会存在着一些问题，比如 : 

- 宏函数是属于预处理阶段供预处理器进行宏定义展开的工作，而<font color = "red">预处理器在 cpp 中是不允许访问类的成员(它们是运行时动态分配内存的)</font>，也就是说我们无法把某一个宏当作一个类中的成员来进行看待，简而言之，宏定义没有作用域的一个概念

- 宏函数在特定情况下进行使用时，所拿到的结果可能并不是我们所预期的一种结果

为了解决宏定义(宏函数)在c语言中所带来的一些历史性的遗留问题，cpp 中推出了 <font color = "red">$inline \:\: function$(内联函数)</font> 的概念

<font color = "red">内联函数本身也是一个真正的函数，它具有普通函数的所有行为</font>，对比宏函数来说，内联函数会在适当的地方像预定义宏一样展开(具体要查看编译器的行为)，也就是说，内联函数和宏函数一样同样能够避免函数调用时候的压栈、跳转、返回的开销问题，除此之外，<font color = "red">由于内联函数本身也是一种真正的函数，也就意味着我们能够在其上下文中访问存在动态分配内存性质的一些成员，并且能够指定它声明在我们所需要的命名空间内以防止命名冲突的问题的同时又提升了程序的 oop 性</font>

#### 内联函数的定义

<span id="内联函数的定义"></span>

内联函数的定义方式很简单，在所需要定义为内联函数的开头添加 `inline` 关键字即可，<font color = "red">需要注意的是，当我们函数把一个函数分为声明和定义来实现的时候，我们必须要在声明和定义中都要添加上 `inline` 关键字才算生效</font>

值得一提的是，对于在类中的成员函数编译器在编译的过程中都会自动添加上 `inline` 关键字

那么，当我们为一个函数添加上了 `inline` 关键字，那该函数就被声明为了内联函数，但是内联函数是一定会生效的吗？这不一定，编译器会在编译的阶段考量内联函数的有效性，当这个内联函数符合一定的条件后，那么该函数的调用将采用内联编译 : 

- 不能存在任何形式的循环语句

- 不能存在过多的条件判断语句

- 函数体不能过于庞大

- 不能对函数进行取址操作

<font color = "red">对于内联函数来说，其本身只是提供给编译器的一种意见</font>，那么具体是要把这个函数当成普通函数的方式来调用还是通过内联的方式来调用这都取决于编译器本身，可能一个我们所声明的内联函数符合一定的要求，但是编译器不会把它当成内联函数来看待，可能一个函数并没有声明为内联的形式，但是在它调用的过程中编译器都会对它做内联编译，其实对于开发人员来说，我们无需特地的去声明一个内联函数，这部分工作大多都是交给编译器来完成，我们只需要明白存在这一概念并遵循着内联编译前提条件的注意事项即可

<font color = "red">对于 GCC 来说，它仅会尝试在单个文件中所定义的函数进行内联，也就是说它无法适用于常见的情况，即一个函数在某个文件中被定义为内联，却在其他文件中被调用</font>，这时候其他文件所调用的那个内联函数实际上是无展开效果的

<font color = "red">在某些情况下，我们最好能够阻止编译器的内联优化。</font>如果一个函数已经经过了内联优化，那么调式器对于该函数的任何断点和追踪都会失败; 此外，我们常用的代码质量评估手段(grof)都无法很好的正常工作

```cpp
#include <iostream>
using namespace std;

inline void foo() {
  cout << "hello,world" << endl;
}
```

<br/>

### 函数的参数默认值

<span id="函数的参数默认值"></span>

---

```cpp
void foo(int i = 0, char c = 'A', const char *str) {

}
```

<br/>

<span id="函数的重载"></span>

### 函数的重载

---

<font color = "red">函数的重载，即同一个作用域下，我们可以额外定义不同参数个数、不同参数类型、不同参数顺序的同名函数</font>

由于 cpp 中需要对函数重载进行支持，故使用 cpp(g++, clang++) 的方式对源文件进行编译的过程中，会为我们所声明的定义亦或者所使用的函数额外添加一些其他的符号以区分函数重载的标识(根据不同编译器的实现不同而不同)，比方说我们在 cpp 文件中所定义的函数为 `foo()`，而在进行过编译后他可能就会重命名为 `_Z6Myfoo()`，对此就会存在一个问题，由于在c语言中是不支持函数的重载的，故函数的原名在使用c语言的方式(clang, gcc)进行编译后原名是不会发生改变的，假设我们目前我们有一个 cpp 的源文件 **_main.cpp_** 和 c语言 的源文件 **_test.c_** 还有一个源文件 test.c 所对应的头文件 **_test.h_**，如下面的代码 : 

```cpp
test.h-----------------------------
#include <stdio.h>
void fun_test(char *name);
-----------------------------------


test.c-----------------------------
#include "test.h"
void foo(char *name) {
  printf("Hello,World!%s\n",name);
} 
-----------------------------------



main.cpp---------------------------
#include <iostream>
#include "test.h"
using namespace std;

int main(void) {
  foo("NGPONG");
  cout << "OK!" << endl;
  return 0;
}     
-----------------------------------
```

可以看到，我们在 cpp 的源文件中引用了 c语言 源文件 **_test.c_** 所对应的头文件 **_test.h_**，借助头文件 test.h 以完成对 c 语言所编写的函数 `foo(char *name)` 的调用

但是这时候在进行编译时就会出现问题，因为我们是使用的 cpp(clang++, g++) 源文件工程进行编译的，也就是说编译器是以 cpp 的方式对文件进行编译和链接的，而头文件 test.h 虽然是对应着 c语言 源文件 test.c 的，但是它却在 cpp 源文件 main.cpp 被包含(#include)了进来的，也就意味着，当前头文件中的声明工作都要参与以 cpp 方式进行编译和链接的过程，前面提到过，cpp 由于需要对函数重载的支持，所以使用 cpp 的方式对文件进行编译的时候，都会把我们所声明定义的亦或者所使用的函数都会额外添加一些其他的符号以区分函数重载的标识，而这时候在头文件对于函数 `void foo(char *name)` 中的声明可能就会被改写成 `void _Z6foo(char *name)`，但是我们目前是没有任何一个函数的定义是 `_Z6foo` 的，所以函数 `void foo(char *name)` 在进行链接的过程中就无法找到这个函数的具体定义，提示无法找到外部符号

那么产生这种问题的原因是因为 c语言 的源文件 test.h 参与了 cpp 编译的方式从而导致函数名变更而无法找到其原本在 c语言 文件 test.c 中所对应的函数定义所导致的，那么解决这种问题其实很简单，只要让它不参与 cpp 的方式进行编译即可，故我们只需要<font color = "red">对需要以 c语言 方式进行编译的函数前缀添加上关键字 **_extern "C"_**，当一个成员添加上该关键字后，那么编译器其编译和链接的方式则遵循 c语言 的规范来进行</font>，需要注意的是，该关键字是 cpp 中独有的，在 c语言 中无法使用，也就是说我 对于函数的声明方式就需要从原来在头文件 test.h 中改写在 main.cpp 身上，并且我们还需要把原来在 cpp 源文件中所包括的头文件 test.h 去掉，以防止 cpp 编译器检测到两种不同形式(头文件中是 `void foo(char *name)`，源文件中是 `extern "C" void foo(char *name)` ) 的声明而无法进行编译的情况，通过这样的改造后，我们就能够成功的在 cpp 源文件中使用 c语言 源文件中所提供的一些功能实现了，代码结构改写为下面的形式 :

```cpp
test.h-----------------------------
#include <stdio.h>
void foo(char *name);
-----------------------------------



test.c-----------------------------
#include "test.h"
void foo(char *name) {
  printf("Hello,World!%s\n",name);
} 
-----------------------------------



main.cpp---------------------------
#include <iostream>
using namespace std;

extern "C" void foo(char *);

int main(void) {
  foo("NGPONG");
  cout << "OK!" << endl;
  return 0;
}
-----------------------------------
```

当我们在 cpp 中对于函数 foo 的声明引入了关键字后，它就不会再去参与 cpp 的编译和链接的方式，而是遵循 c 标准的编译和链接的方式来进行，那么在其进入链接的阶段，函数 foo 在 cpp 源文件中的声明就会尝试在其它文件中寻找其定义，并最终会在 test.c 中找到该函数的定义，并把在 main.cpp 中的声明隐式提升为定义，以让我们在 cpp 源文件中实现调用 c 源文件中的功能函数

这里可能会发现一个问题，首先第一点，当 c 源文件中的函数过多的话，那不是 cpp 源文件中对于函数的声明不久爆满了？而且原来的头文件 test.h 由于在 cpp 源文件中去掉以防止重复不同类型的声明所出现的错误，那么 test.h 不就没有任何实际价值了？是的，至少目前这段改造来说这个头文件的确是没用了，但是我们还能继续再改造下，其实<font color = "red">关键字 `extern "C"` 不单单只用于声明一个成员的编译定义，还可以通过它来使用 `{}` 来包含一整段代码对于编译方式的定义</font>，但是相应的我们还是不能把它放在 cpp 源文件当中，我们会把它放在头文件当中去，但是由于该关键字是 cpp 语言所支持的功能，故直接在头文件中使用会出现错误，所以这里我们还需要引入一个宏定义以区分编译当前文件的编译器使用的是 cpp 的功能还是 c 的功能，这个宏定义则叫做: `cplusplus`，我们来看下改造后的代码

```cpp
test.h-----------------------------
#ifdef cplusplus
extern "C" {
#endif

#include <stdio.h>
void foo(char *name);

#ifdef cplusplus
}
#endif
-----------------------------------



test.c-----------------------------
#include "test.h"
void foo(char *name) {
  printf("Hello,World!%s\n",name);
} 
-----------------------------------



main.cpp---------------------------
#include <iostream>
#include "test.h"
using namespace std;

int main(void) {
  foo("NGPONG");
  cout << "OK!" << endl;
  return 0;
}
-----------------------------------
```

通过预处理指令 `#ifdef` 来区分当前是编译器所编译的功能是遵循 c 的规范还是 cpp 的规范，由于目前所编译的是 main.cpp 是属于 cpp 的规范，故该条件表达式是能够成功执行并且还是以 cpp 标准规范来进行处理，这样就可以使用 `extern "C"` 关键字了，并且我们还通过该关键字所提供的 `{}` 来完成在对 `{}` 内所有所有的成员都遵循 c 标准编译链接规范的目的，也就是说通过上面改造的代码，在 `extern "C" {}` 内的所有成员都会依照着 c 语言的规范来进行编译

以上则为在 cpp 中实现调用 c 功能代码的方式，那么反过来可不可以呢？肯定是不行的，cpp 是对于 c 语言的扩展，故我们是能够在 cpp 中写入标准 c 的代码，但是 c 并不是 cpp 的扩展，故并不支持 cpp 中所扩展的关键字


<br/>
<br/>

<span id = "运算符重载"></span>

## 运算符重载

运算符重载$(operator \:\: overloading)$只是一种 cpp 中提供给函数调用的一种 "语法糖"(并不觉得是糖)，虽然看着非常别扭，并且代码可读性也不高，但是<font color = "red">实际上它就是另一种函数的调用形式</font>

<br/>

<span id = "什么是运算符重载函数"></span>

### 什么是运算符重载函数

---

运算符重载函数的类别可以总体区分为以下两类

   - 成员函数运算符重载

   - 全局函数运算符重载

定义重载的运算符就像定义函数，只是该函数的名字是 **_operator@_**，这里的 **_operator_** 是一个特殊的关键字，它和操作符 **_@_** 构成了针对于某个操作符下的一个运算符重载函数，<font color = "red">当我们定义好了一个运算符重载函数后，我们对于它的使用可以直接通过所定义的函数名来访问它(operator@)，当然如果还是通过这种方式来进行访问的话，那么所构建的运算符重载就无任何实际意义了</font>

更准确的做法是，<font color = "red">当我们定义好一个运算符重载函数后，我们就能根据所定义的运算符所构成的表达式，并根据该运算符表达式中所录入的参数类型和参数个数(**_在表达式中根据运算符所修饰的参数从左到右映射至所定义的运算重载函数的形参列表当中_**)去匹配相符签名的运算符重载函数，以通过一段运算符的表达式就能够达到调用目标运算符重载函数的目的</font>，这里，我们只有保证在运算符表达式中所录入的参数是符合某个运算符表达式的形参签名列表才能够完成目标函数的调用<font color = "red">通过一段运算符表达式能够达到调用目标运算符重载函数的方式主要核心是通过一点，那就是 **_参数匹配_**</font>，那么对于一个运算符重载函数来说，其<font color = "red">参数保持在 **_0 ~ 2_** 个，具体个数取决于两个根本的因素</font>

- 所重载的运算符(**_@_**)是属于 **_一元运算符(一个形参)_** 还是 **_二元运算符(两个形参)_**

- 运算符重载函数是声明在 **_全局作用域下(上一个因素的结果保持不变)_** 还是 **_作为成员(非友元)声明在具体的某个类或结构体的内部(上一个因素的结果减一)_**

在这里，<font color = "red">第二条因素依赖于第一条因素，原因是因为当我们把运算重载函数作为成员(非友元)定义在某个类或结构体的内部时，对应的运算符所构造的表达式其从左到右的第一个参数其实就是当前实例的本身</font>，故我们无需再去运算符重载函数的形参列表中又特定声明一个形参以映射至对应运算符(**_@_**)所构造的表达式其从左到右的第一个参数，举个例子，<font color = "red">当所重载的运算符是一个二元运算符(**_@_**)的时候，作为二元运算符表达式的左耳参数就是就是当前实例的本身，那么对应的，表达式中的右耳的参数则会映射到运算符重载函数中的形参列表中的第一个参数</font>，而当我们把一个运算符重载函数定义为全局，那么就意为该重载函数其实是不属于任何一个复合类型中的成员，所以这个运算符重载函数中的形参个数也需要依据着所重载的运算符(**_@_**)的元数来决定参数列表的个数，下面的代码展示了在一个二元运算符中，当我们把运算符重载函数声明在全局亦或者某个复合类型成员内部时的参数列表的不同体现

```cpp
#include <iostream>
using namespace std;

struct Person {
  friend void operator+(Person &per_src, Person &per_des) { /* 友元函数属于全局作用域下 */
    per_src.m_age += per_des.m_age;
    return;
  };

public:
  Person(int age)
    : m_age(age) {}

  Person(const Person &per) {
    this->m_age = per.m_age;
  }
  ~Person() {
    cout << "Person descturctor" << endl;
  }

public:
  Person &operator+(int age) {
    this->m_age += age;
    return *this;
  }

public:
  int m_age;
};

int main(void) {
  Person per_src(0);
  Person per_des(256);
  per_src + 1 + 2 + per_des;

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "运算符重载的使用事项"></span>

### 运算符重载的使用事项

---

- 对于声明为 **_成员函数运算符重载_** 受复合结构中的访问修饰符的间接调用限制

- 运算符重载函数允许进行函数重载

- 当运算符重载函数作为成员函数而出现时，不能声明为静态

- 运算符重载函数的形参列表中，必须具有复合类型(类或结构体)或者枚举类型作为形参，所以，如果我们想单纯的通过运算符重载函数去改变内置数据类型(int, char, etc)的运算规则是不可行的

- 保证在间接调用运算符重载函数时，保证运算符重载函数所在作用域的可被发现性

  - 运算符重载函数理论上来说是可以声明在任意地方，但是我们需要注意的是，我们使用运算符重载函数的过程通常都是通过其所重载的具体的运算符所构造的表达式以映射到具体的运算符重载函数来完成它的调用，也就是说，<font color = "red">当我们使用指定的运算符所构建的表达式的代码位置是无法通过直接的方式访问本该我们所预想的该表达式所对应的运算符重载函数所在的作用域的时候，我们直接通过运算符表达式以完成对应的运算符重载函数的调用就会失败，因为我们在构建运算符表达式的时候是不能单独引用具体某个作用域的</font>


- 尽量不要重载逻辑运算符 `&&, ||`

  - <font color = "red">当我们对于逻辑运算符进行了重载，那么该运算符原来所保有的 **_短路求值_** 的特性就会被取消</font>，什么是短路求值，就 `&&` 来说，如果一旦表达式的左耳是一个假值得话，那么 `&&` 所构成得表达式整体就是一个假值，即 `&&` 表达式得右耳是无需进行计算的，而当我们进行了重载后，不管左耳是否是一个已经能够确定整个逻辑运算表达式的标识值，作为右耳函数还是会参与进行计算以匹配所重载的运算符函数的调用，这可能并不是我们想要得结果，并且在<font color = "red">一定程度上能够带来性能得损失(进行了无关紧要的计算)</font>

- 保证运算符重载函数的定义在间接引用的时候不会产生二义性

  - 前面提到过，运算符重载函数可定义在全局作用域下亦或者具体到某个类或结构体当中，那么我们假设在同一个命名空间这个大的、运算符重载函数可被发现的作用域之下分别书写了两个相同重载符号的运算符重载函数的时候，我们要保证所构建出来的表达式映射到具体的运算符重载函数时并不会出现二义性，如下面的代码则是一个典型的二义性的例子，我们所书写的表达式编译器不知道其具体是映射到类中所定义的运算符重载函数，还是在全局作用域下所定义的运算符重载函数，因为两者都是符合我们所构建的表达式的匹配，这就会造成一个二义性

  ```cpp
  #include <iostream>
  using namespace std;

  struct Person {
    friend Person &operator+(Person &per, int age) {
      per.m_age += age;
      return per;
    };

  public:
    Person(int age)
      : m_age(age) {}
    Person(const Person &per) {
      this->m_age = per.m_age;
    }

  public:
    int m_age;

  public:
    Person &operator+(int age) {
      this->m_age += age;
      return *this;
    }
  };

  int main(void) {
    Person per(0);
    per + 1 + 2 + 3;

    system("pause");
    return EXIT_SUCCESS;
  }
  ```

- 运算符重载函数可以作为一个类中的友元成员

  - 当运算符重载函数作为一个类中的友元声明的时候，由于友元成员虽然需要被定义或声明在一个类的内部，但是它并不属于这个类中的一个成员，具体来讲，友元的定义是作用于全局作用域之下，故运算符重载函数中的形参个数要以声明在全局作用域下的运算符重载函数的角度来看待，相应的，和普通的运算符重载函数一样，对应的运算符表达式会在全局作用域下通过参数匹配的方式搜寻到该友元声明的具体定义
  - 
  ```cpp
  #include <iostream>
  using namespace std;

  struct Person {
    friend Person &operator+(Person &per, int age) {
      per.m_age += age;
      return per;
    };

  public:
    Person(int age)
      : m_age(age) {}
    Person(const Person &per) {
      this->m_age = per.m_age;
    }

  public:
    int m_age;
  };

  int main(void) {
    Person per(0);
    per + 1 + 2 + 3;

    system("pause");
    return EXIT_SUCCESS;
  }
  ```


<br/>

<span id = "各运算符重载时的约束"></span>

### 各运算符重载时的约束

---

- `+`

  - 返回值和形参没有特殊的条件限制

  - 可以声明为任意运算符重载函数类别

```cpp
#include <iostream>
using namespace std;

#include <string.h>

class Person {]
  /* Person operator+(Person &per) 所返回的是右值，故这里需要使用右值引用 */
  friend char *operator+(Person &&per, int num) {
    per.m_age += num;
    return (char *)"SUCCESS!";
  }

public:
  Person(int age) {
    this->m_age = age;
  };
  Person(const Person &per) {
    this->m_age = per.m_age;
  }
  Person(Person &&per) {
    this->m_age = per.m_age;
    per.m_age = 0x0;
  }

public:
  Person operator+(Person &per) {
    this->m_age += per.m_age;
    return *this;
  }

public:
  int m_age;
};

int main(void) {
  Person per_src = Person(4);
  Person per_des = Person(8);

  cout << ((per_src + per_des) + 10) << endl;

  return EXIT_SUCCESS;
}
```

- `<< >>`

  - 返回值和形参没有特殊的条件限制

  - 可以声明为任意运算符重载函数类别

```cpp
#include <iostream>
using namespace std;

#include <string.h>

class Person {
  friend ostream &operator<<(ostream &cout, Person *per) {
    cout << "Person name = " << per->m_name << " ,Person age  = " << per->m_age;
    return cout;
  }

public:
  Person(int age, const char *name = "DEFAULT") {
    this->m_age  = age;
    this->m_name = new char[strlen(name) + 1];
    strcpy(this->m_name, name);
  }
  Person(const Person &per) {
    this->m_age  = per.m_age;
    this->m_name = per.m_name;
  }
  ~Person() {
    cout << "Person destructor" << endl;
    delete[] this->m_name;
  }

public:
  ostream &operator<<(ostream &cout) {
    cout << "Person name = " << this->m_name << " ,Person age  = " << this->m_age;
    return cout;
  }

private:
  int m_age;
  char *m_name;
};

int main(void) {
  Person per_01(1024, "Hello,World!");
  Person per_02(256, "NGPONG!");

  per_01 << cout    /* call ostream &operator<<(ostream &cout) */
         << endl
         << &per_02 /* call friend ostream &operator<<(ostream &cout, Person *per) */
         << endl;

  system("pause");
  return EXIT_SUCCESS;
}
```

- `=`
  - 通常用于作为 [拷贝语义和移动语义](#构造函数) 的展开

  - 返回值和形参没有特殊的条件限制

  - 只能够声明为成员函数运算符重载

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  Person(int age) {
    this->m_age = age;
  }

public:
  /* Person copy assignment operator */
  Person &operator=(const Person &per) {
    this->m_age = per.m_age;
    return *this;
  }
  /* Person move assignment operator */
  Person &operator=(Person &&per) {
    this->m_age = per.m_age;
    per.m_age = 0x0;
    return *this;
  }
  /* Person assignment operator */
  Person &operator=(int age) {
    this->m_age = age;
    return *this;
  }

public:
  int m_age;
};

int main(void) {
  Person per_a(0);
  Person per_b(0);

  /** TODO
   * 
   * 1. 0x400 create a temporary unnamed variable, m_age is 0x400
   * 
   * 2. Person(0) create a temporary unnamed variable, m_age is 0, 
   * Then call the move assignment operator function to move the d
   * ata 0x400 to Person(0)
   * 
   * 3. Call copy assignment operator to copy (Person(0) = 0x400) 
   * data to per_a Because of move assignment operator function r
   * eturn value type is lvalue
   * 
   * 4. Call copy assignment operator to copy per_a data to per_b 
   * Because of per_a is lvalue
   */
  Person &per_b_ref = per_b = per_a = Person(0) = 0x400;

  per_b_ref = 0x100;

  cout << per_b_ref.m_age << endl;

  system("pause");
  return EXIT_SUCCESS;
}
```

- `++ --`

  - <font color = "red">如果是后置运算(i++, i--)，我们要保证形参列表中的保有一个 `int` 类型的 **_占位参数_** 并且其在参数列表中的最后的位置</font>，以告诉编译器该运算符重载函数是一个后置运算符重载函数 ; <font color = "red">对于前置运算符对于形参则无特殊的限制</font>

  - 返回值没有特殊的条件限制

  - 可以声明为任意运算符重载函数类别

```cpp
#include <iostream>
using namespace std;

class Person {
  friend ostream &operator<<(ostream &cout,const Person &per) {
    cout << per.m_age;
    return cout;
  }

public:
  Person(int age) {
    this->m_age = age;
  }

public:
  /* preload-value-increment assignment operator */
  Person &operator++() {
    ++this->m_age;
    return *this;
  }
  /** 
   * post-value-increment assignment operator
   *
   * Argument of type int is a placeholder-argument, 
   * It's designed to tell the compiler this function 
   * is a post-value-increment assignment operator function.
   */
  Person operator++(int) {
    Person temp(this->m_age);
    ++this->m_age;
    return temp;
  }

public:
  int m_age;
};


int main(void) {
  Person per(0x400);
  cout << per++ << endl;
  cout << per.m_age << endl;
  cout << ++per << endl;

  return EXIT_SUCCESS;
}
```

- `()`

  - 返回值和形参没有特殊的条件限制

  - 只能够声明为成员函数运算符重载

  - 该运算符所构造的重载调用更专业的名称为 : **_仿函数_**

```cpp
#include <iostream>
using namespace std;

class printer {
public:
  void operator()(char *str) {
    cout << str << endl;
  }
};

int main(void) {
  printer()((char *)"Hello,World!");

  return EXIT_SUCCESS;
}
```

- `== !=`

  - 形参必须保有一个 class 或 enumeration 类型的成员

  - 返回值没有特殊的条件限制

  - 可以声明为任意运算符重载函数类别

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  Person(int _age) : m_age(_age) {};

public:
  char *operator!=(Person &per_) {
    if (this->m_age == per_.m_age)
      return (char *)"!=:SUCCESS!";
    else 
      return (char *)"!=:FAILURE!";
  }

public:
  int m_age;
};

bool operator==(Person &per_, int age_) {
  return per_.m_age == age_;
}

int main(void) {
  Person per_src(0x400);
  Person per_des(0x80);

  cout << (per_src != per_des) << endl;

  if(per_src == 0x400) 
    cout << "==:SUCCESS!" << endl;
  else 
    cout << "==:FAILURE!" << endl;

  return EXIT_SUCCESS;
}
```

- `[]`

  - <font color = "red">[] 虽然是一个一元运算符，但是我们实际上需要把它当作一个二元表达式的形参格式来看待</font>

  - 返回值无特殊的限制

  - 只能够声明为成员函数

```cpp
#include <iostream>
using namespace std;

class Arrary {
private:
  int *data;

public:
  Arrary(int _size) {
    data = new int[_size];
  }
  ~Arrary() {
    delete[] data;
  }

public:
  int &operator[](int idx) {
    return data[idx];
  }
};

int main(void) {
  int size = 0x400;

  Arrary arrary(size);
  for (size_t i = 0; i < size; ++i) {
    arrary[i] = i;
  }

  cout << arrary[0x100] << endl;

  return EXIT_SUCCESS;
}
```

- `*`

  - 返回值和形参没有特殊的条件限制

  - 可以声明为任意运算符重载函数类别

```cpp
#include <iostream>
using namespace std;

class person {
public:
  person(int age, char *name) {
    this->m_age = age;
    this->m_name = name;
  }

public:
  void print() {
    cout << "person age = " << this->m_age << endl;
    cout << "person name = " << this->m_name << endl;
  }

public:
  int m_age;
  char *m_name;
};

class smart_pointer {
public:
  smart_pointer(person *ptr) {
    this->m_ptr = ptr;
  };
  ~smart_pointer() {
    delete this->m_ptr;
  }

public:
  person &operator*() {
    return *this->m_ptr;
  }

public:
  person *m_ptr;
};

int main(void) {
  smart_pointer sp(new person(1024, (char *)"hello,world"));
  (*sp).print();

  person &per_ref = *sp;
  per_ref.print();

  cout << (*sp).m_name << endl;

  return EXIT_SUCCESS;
}
```

- `->`
  - `->` 是一个一元运算符，故形参个数要按照一元表达式的形参格式来看待，但是它却不支持单独使用

  - 返回值必须是某个复合类型的指针

  - 既然 `->` 不支持单独使用，并且其返回值必须为某个对象的指针或引用，也就是说，它所构造出来的表达式在 `->` 之后必须使用该运算符重载函数所返回的某个对象的指针或引用来完成该对象内部成员的调用
  
  - 只能够声明为成员函数

```cpp
#include <iostream>
using namespace std;

class person {
public:
  person(int age, char *name) {
    this->m_age = age;
    this->m_name = name;
  }

public:
  void print() {
    cout << "person age = " << this->m_age << endl;
    cout << "person name = " << this->m_name << endl;
  }

public:
  int m_age;
  char *m_name;
};

class smart_pointer {
public:
  smart_pointer(person *ptr) {
    this->m_ptr = ptr;
  };
  ~smart_pointer() {
    delete this->m_ptr;
  }

public:
  person *operator->() {
    return this->m_ptr;
  }

public:
  person *m_ptr;
};

int main(void) {
  smart_pointer sp(new person(1024, (char *)"hello,world"));

  sp->print();
  cout << sp->m_name << endl;

  /* faild */
  /* Person *per = sp->; */
  return EXIT_SUCCESS;
}
```


- `new`
  - 针对不同的 new 语义需要使用不同的参数列表，但是<font color = "red">必须保有第一个参数类型为 size_t，其指示为某个需要分配内存的对象的长度</font>
    - void *operator new(std::size_t size) throw (std::bad_alloc);

    - void *operator new(std::size_t size, const std::nothrow_t& nothrow_value) throw();
  
    - void *operator new(std::size_t size, void *ptr) throw();

    - void *operator new[](std::size_t size) throw (std::bad_alloc);

    - void *operator new[](std::size_t size, const std::nothrow_t& nothrow_value) throw();
  
  - 返回值必须为 `void *`

  - 可以声明为任意运算符重载函数类别

```cpp
#include <iostream>

#define GIGABYTE (1024 * 1024 * 1024)

#define ALLOC                               \
  auto p = malloc(size);                    \
  if (p == nullptr) throw std::bad_alloc(); \
  return p;

class base {
public:
  char space[GIGABYTE] = { 0 };

  void *operator new[](std::size_t size) {
    ALLOC;
  }
};

void *operator new(std::size_t size) {
  ALLOC;
}

int main() {
  base *bs = new base[5];
  delete[] bs;

  int *p = new int(1024);
  delete p;

  return EXIT_SUCCESS;
}
```


<br/>
<br/>

<span id = "模板"></span>

## 模板

> 模板技术是 **_泛型编程_** 的基础，模板能够把 **_函数或类_** 的上下文中要处理的数据类型进行参数化，表现为参数的多态性，并且由于模板所保有的 **_类型参数化_** 的特点，模板我们又称 **_参数模板_**

<br/>

<span id = "模板的声明"></span>

### 模板的声明

---

<font color = "red">当一个 **_类或函数_** 的前置语义中出现了关键字 **_template<typename / class $T$>_** 的修饰，那么它就属于一种 **_模板成员_**，我们可以在模板成员的上下文中使用声明的 **_虚拟类型 $T$_** 来完成变量的声明以实现逻辑运算，并且编译器暂时放弃对使用到虚拟类型 $T$ 的地方做语法的检查，即暂时不考虑虚拟类型参数使用的有效性</font>

当我们在使用这个模板成员(调用这个函数或者声明这个类)的时候我们就可以 <font color = "red">**_显示或隐式_**</font> 的指定虚拟类型 $T$ 的具体类型，<font color = "red">编译器会依照我们 **_显示或隐式_** 指定的具体的类型替换至当前上下文中使用到虚拟类型 $T$ 的地方 **_并新生成一个不同副本的函数或类_**，然后再针对此新生成的成员结果针对性的做一次完整语法校验的编译性工作</font>

<font color = "red">我们是完全可以把 模板和宏联系在一起的，亦或者说模板是一种更加高级的宏</font>，因为对于模板来说，它并不是一种真实存在的成员，也就是说我们在不使用它的时候，他是不会编译进一个二进制文件当中的，而当我们真正的去使用这个定义好的模板成员并指定了其虚拟类型的具体类型时，编译器才会依照所指定的类型去新创建一个完全体的副本，而这个副本才会编译进一个二进制文件当中

额外扩充一点，我们会发现模板所声明的虚拟类型 $T$ 前面还使用了 **_typename / class_** 关键字来进行修饰，其实二者的使用并无任何区别，只是我们都会自立约束，<font color = "red">对于 **_函数模板_** 的声明使用 **_typename_**</font> ; <font color = "red">而对于 **_类模板_** 的声明则使用 **_class_**</font>

```cpp
#include <iostream>
using namespace std;

template<typename T> 
void foo(T value) {
  value += 1;
  cout << value << endl;
}

int main(void) {
  foo<int>(0x200);

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "指定模板的虚拟类型"></span>

### 指定模板的虚拟类型 $T$

---

模板成员是无法单独进行使用的，我们必须要在其使用前指定模板中的虚拟类型 $T$ 的具体类型才能够进行使用，cpp 中提供了两种方式去指定一个模板虚拟类型的具体类型

- 显示指定 : 在调用模板成员时通过操作符 `<Type>` 去显示的指定当前模板成员

```cpp
template<typename T>
void foo(T val) {
  cout << val << endl;
}

int main(void) {
  foo<const char *>("hello,world");
  return EXIT_SUCCESS;
}
```

- 隐式指定 : 隐式指定的方式只能够针对于函数模板的使用(类模板不可用)

  - 当在调用 函数模板 时，编译器会依照函数调用所录入的实参具体类型去 **_自动推导_** 出当前函数模板的虚拟类型的具体类型，即通过这种方式完成函数模板的调用是不需要显示的指定虚拟类型 $T$(`<Type>`)的具体类型的
  ```cpp
  template<typename _Func>
  void foo_automatch_function_pointer(_Func invoker) {
    cout << "Execute by foo_automatch_function_pointer" << endl;
    invoker(0x400);
  }

  template<typename T>
  void foo(T val) {
    cout << val << endl;
  }

  bool fun(int _val) {
    cout << _val << endl;
    return false;
  }

  int main(void) {
    foo_automatch_function_pointer(fun); /* _Func: [bool (*)(int)] */
    foo("hello,world");                    /*     T: [const char *] */

    return EXIT_SUCCESS;
  }
  ```

  - 需要注意的是，我们要保证同一个虚拟类型下所对应函数形参在进行调用时所录入的实参并不会对其产生一个 **_二义性访问_**，如下面的代码则为一个典型的二义性访问，这时候编译器所提供的自动类型推导则会失效

  ```cpp
  template<typename T>
  void foo(T var1, T var2) {
    cout << "template function" << endl;
    cout << var1 << endl;
    cout << var2 << endl;
  }

  int main(void) {
    foo(0x400, 'G');
    return EXIT_SUCCESS;
  }
  ```

  - 对于函数指针类型的自动推导上面的代码已经演示过，这种方式的推导能够把所传入的函数推导为一个完整的函数指针类型，事实上，对于函数指针而言其应用并不单单于此，<font color = "red">我们还可以通过拆分虚拟类型 $T$ 的方式来让编译器去自动推导出一个函数的返回值、形参的具体类型</font>，这种拆分推导函数指针中各个形参包括返回值的方式广泛被应用到 $STL$ 库当中

  ```cpp
  #include <iostream>
  using namespace std;

  template<typename _Arg, typename _Result>
  void foo(_Result (*_invoker)(_Arg)) {
    cout << "function result type = : " << typeid(_Result).name() << endl;
    cout << "function arg type = : " << typeid(_Arg).name() << endl;
    cout << "function type = : " << typeid(_invoker).name() << endl;
  }

  bool fun(int _val) {
    cout << _val << endl;
    return false;
  }

  int main(void) {
    foo(fun);

    return EXIT_SUCCESS;
  }
  ```


<br/>

<span id = "指定模板的虚拟类型"></span>

### 指定虚拟类型 $T$ 的默认类型

---

我们可以在指定虚拟类型 $T$ 的同时指定它的一个默认类型，它并不作为虚拟类型 T 的录入约束，而是作为编译器为模板进行虚拟类型自动推导的时候提供更加便利的条件

```cpp
#include <iostream>
using namespace std;

template<class T = int>
class Person {
public:
  Person(T _val)
    : val(_val) {
    cout << typeid(_val).name() << endl;
  };

  T val;
};

template<typename T = int>
void foo(T val) {
  cout << typeid(val).name() << endl;
}

int main(void) {
  Person<> per(20);
  foo(10);

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "类模板使用默认类型时存在的限制"></span>

#### 类模板使用默认类型时存在的限制

由于<font color = "red">类模板并不提供模板类型自动推导的功能</font>，故它和函数模板针对该功能的使用上存在着一点区别

- 类模板指定虚拟类型的默认类型时，存在默认类型的虚拟类型必须放在虚拟类型列表的末尾处，而函数模板无此限制

- 类模板由于并不支持模板类型的自动推导，故哪怕一个类模板中仅有一个虚拟类型且指定了其默认类型，类模板在使用的使用同样要配合 `<>` 进行修饰，而函数模板无此限制

```cpp
#include <iostream>
using namespace std;

template<typename T, typename U = int>
class cla_1 {
public:
  cla_1(T _t_val, U _u_val) {
    cout << "t=" << typeid(_t_val).name() << " u=" << typeid(_u_val).name() << endl;
  }
};

template<typename T = int>
class cla_2 {
public:
  cla_2(T _val) {
    cout << "t = " << typeid(_val).name() << endl;
  }
};

int main() {
  cla_1<int> c_1_1(1, 2);
  cla_1<int, char> c_1_2(1, 'a');

  cla_2<> c_2_1(1);
  cla_2<char> c_2_2('a');
}
```

值得一提的是，正因为<font color = "red">函数模板提供了自动推导的功能，所以搭配上函数参数的默认类型的功能那么该函数模板的使用则会呈现出多样化</font>

```cpp
#include <iostream>
using namespace std;

template<typename T, typename U = double>
void foo(T t = 0, U u = 0) {
  cout << "t=" << typeid(t).name() << " u=" << typeid(u).name() << endl;
}

int main() {
  foo(4, 'a');      /* foo<int,char>(4,'a') */
  foo(4);           /* foo<int,double>(4,0) */
  foo();			      /* fault */
  foo<int>();       /* foo<int,double>(0,0) */
  foo<int, char>(); /* foo<int,char>(0,0) */
}
```

<br/>

<span id = "模板成员的声明与实现"></span>

### 模板成员的声明与实现

---

我们无法在实现一个函数模板的声明亦或者说类模板内部的成员声明时就去指定模板成员的虚拟类型的具体类型，可以简单的理解为，我们永远只能够在使用模板成员的时候才可以去指定该模板成员的虚拟类型的具体类型

其次，就是关于模板成员的实现和声明 **_分文件编写_** 的问题，前面提到，对于模板成员来说，它并不是一个真实存在的成员，仅当我们真正的去使用使用了这个模板成员并指定了模板虚拟类型的具体类型后，编译器才会为我们生成一个真实存在的成员，那么<font color = "red">当一个模板成员的声明和实现并不是声明在同一个文件内亦或者被包含在一个文件内的情况下，编译时会报错，原因是因为编译器是属于独立单元进行的编译工作，当我们在一个编译单元内使用一个仅存在声明的模板成员时，由于对于模板成员来说，其符号链接仅仅只能够在当前编译单元中进行，无法扩展至其它的文件，故这时候我们在使用的时候就会出现错误</font>，解决方案则为把模板成员的声明和实现都写在同一个文件内，在 cpp 中针对这种需要被包含的，但是却存在实现的文件的后缀约定俗成的写为 **_*.hpp_**

```cpp
#include <iostream>
using namespace std;

/* Template class */
template<class T = int>
class Person {
public:
  Person(T _val)
    : val(_val){};

public:
  /* Declare function members of the template class */
  void p_print(T _plus);

public:
  T val;
};
/* Function member that implement the template class */
template<class T>
void Person<T>::p_print(T _plus) {
  cout << this->val + _plus << endl;
}


/* Declare template function */
template<typename T>
void foo(T &per);
/* Implement template function */
template<typename T>
void foo(T &var) {
  var.p_print(0x100);
}

int main(void) {
  Person<> per(0x200);
  foo(per);

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "模板机制"></span>

### 模板机制

---

<span id = "函数模板"></span>

#### 函数模板

函数模板即 `<template>` 所修饰的成员为一个函数

在隐式指定一个函数模板虚拟类型的具体类型的情况下(**_未使用 `<>` 语义进行修饰_**)，<font color = "red">如果函数模板的调用和现存上下文中的某个普通函数的调用存在二义性，则编译器会优先考虑普通函数</font>，除非更改为显示指定的方式亦或者在调用时声明空模板类型然后模板的虚拟参数类型则依照隐式方式去指定(**_使用 `<>` 语义进行修饰_**)，当然，如果函数模板对比普通函数的参数调用能够得到更适合的匹配，则编译器会优先调用函数模板

**_函数模板的重载_**

<font color = "red">函数模板可以存在重载</font>并且我们无需担心所重载的版本会和现存的普通函数会出现二义性冲突问题，因为编译器总会依照我们的代码去匹配最适合的函数的调用，<font color = "red">值得引起我们注意的是，在函数模板发生重载的情况，我们还是尽量注意配合模板默认类型的使用，否则可能会造成无法正确匹配的问题</font>

```cpp
#include <iostream>
using namespace std;

template<typename T, typename U>
void foo(T t, U u) {
  cout << "t=" << typeid(t).name() << " u=" << typeid(u).name() << endl;
}

template<typename T>
void foo(T t) {
  cout << typeid(t).name() << endl;
}

int main() {
  foo(10);
  foo(10, 'a');
}
```

**_函数模板的具体化_**

<font color = "red">在某些情况下，我们针对于某个 **_具体的类型_** 所引用的函数模板其内部实现可能不太满意，这时候我们可以针对这��� **_具体的类型_** 去提供该函数模板的另一个特殊的副本，这个副本就叫做 **_具体化函数模板_**</font>，即声明一个相同签名的函数，并使用空模板操作符 **_template<>_** 进行修饰，然后函数的形参列表由原有的所指定的虚拟类型直接替换为 **_具体的类型_** 即可，那么当我们在使用这个具体的类型去对函数模板进行调用时，所调用的实现则为我们所指定的具体化函数模板的实现

<font color = "red">对于一个具体化的函数模板而言，其调用的优先级要高于其最原始的函数模板的副本</font>

```cpp
#include <iostream>
using namespace std;

template<typename T>
void foo(T t) {
  cout << typeid(t).name() << endl;
}

template<>
void foo(int t) {
  cout << "hello,world" << endl;
}

int main() {
  foo(10);
}
```

<br/>

<span id = "类模板"></span>

#### 类模板

函数模板即 `<template>` 所修饰的成员为一个类

值得注意的是，<font color = "red">类模板的具体类型为 : `class_name<Type>`</font>

**_类模板的继承_**

类模板同样是可以用于继承的，需要注意的是，类模板所派生的子类需要在继承语句时就需要指定其上级基类(类模板)的虚拟类型 $T$ 的具体类型 ; 当然我们同样可以把这个具体的类型扩展至当前派生类的虚拟类型以代替(当前派生也声明为一个类模板)，然后指定虚拟类型 $T$ 的工作则放在该派生类的声明工作上

```cpp
#include <iostream>
using namespace std;

template<typename U, typename T = int>
class ANIMAL {
public:
  ANIMAL(U u_val ,T t_val) {
    cout << "ANIMAL: u = " << typeid(u_val).name() << " t = " << typeid(t_val).name() << endl;
  }
};

template<typename U, typename T>
class DOG : public ANIMAL<U, T> {
public:
  DOG(U u_val, T t_val) : ANIMAL<U, T>(u_val, t_val) {
    cout << "DOG: u = " << typeid(u_val).name() << " t = " << typeid(t_val).name() << endl;
  }
};

class LION : public DOG<int, char> {
public:
  LION(int u_val, char t_val) : DOG<int, char>(u_val, t_val) {
    cout << "LION" << endl;
  }
};

class CAT : public ANIMAL<char> {
public:
  CAT() : ANIMAL<char>('A', 10) {
    cout << "CAT" << endl;
  }
};

int main() {
  CAT cat;
  DOG<int, int>(1, 2);
  LION(1, 'a');

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "模板中使用友元"></span>

#### 模板中使用友元

**_普通类中的模板友元成员_**

一个普通类中友元函数能够赋以模板形式的声明而存在，对于一个声明为友元的模板函数来说，其同样需要遵循友元成员所需注意的要素，需要注意的一种情景时，<font color = "red">当该模板友元所修饰的是一段定义，并且其包含着当前类型的参数，那么我们在通过直接的方式去调用该友元成员的时候，我们是无法显示的指定模板虚拟类型的具体类型的，也就是说虚拟类型的匹配依赖至参数录入所触发的隐式指定机制上，除非我们在全局命名空间下对于该模板友元所修饰的成员做一次声明</font>，那么在这种情境之下我们才可以显示的指定模板友元虚拟类型的具体类型

```cpp
#include <iostream>
using namespace std;

class Person {
  template<typename T>
  friend void fun_test_01(Person &per, T var) {
    cout << "FUN_TEST_01" << endl;
    cout << per.m_age + var << endl;
  }

  template<typename T>
  friend void fun_test_02(Person &per, T var) {
    cout << "FUN_TEST_02" << endl;
    cout << per.m_age + var << endl;
  }

  template<typename T>
  friend void fun_test_03(Person &per, T var);

public:
  Person(int _age)
    : m_age(_age){};

private:
  int m_age;
};

template<typename T>
void fun_test_02(Person &per, T var);

template<typename T>
void fun_test_03(Person &per, T var) {
  cout << "FUN_TEST_03" << endl;
  cout << per.m_age + var << endl;
}

int main(void) {
  Person per(0x400);

  fun_test_01(per, 0x200);

  fun_test_02<int>(per, 0x200);

  fun_test_03<int>(per, 0x100);

  return EXIT_SUCCESS;
}
```

**_模板类中的友元函数_**

对于模板类中的友元函数，其形参列表中必须要包含当前模板类型的形参

由于对于模板类中的友元函数来说，其必须要包含着当前模板类型的形参，故对于一个 **_友元所修饰的定义_** 我们是可以直接在外部中进行调用的

```cpp
#include <iostream>
using namespace std;

template<class T>
class Person {
public:
  friend void fun_test(Person<T> &per,T var) {
    cout << "FUN_TEST" << endl;
    cout << var << endl;
  }
public:
  Person(T _age)
    : m_age(_age) {};
private:
  T m_age;
};

int main(void) {
  Person<int> per_int(0x400);
  fun_test(per_int, 0x400);
  system("pause");
  return EXIT_SUCCESS;
}
```

当 **_友元仅为声明的形式_** 而存在时，我们为其构建定义的方式较为复杂，一般来说分为以下两种方式 :

```cpp
#include <iostream>
using namespace std;

/** STEP 4
 * 由于 STEP 3 中使用了 Person<T>，但是 STEP 3 却定义在 Person<T> 之前，故还要在 STEP 3 之上为 Person<T> 做一次前置声明
*/
template<class T>
class Person;

/** STEP 3
 * 为 STEP 2 中的定义再做一次声明，该行代码应该出现在 STEP 1 和 STEP 2 之上
*/
template<typename T>
void fun_test(Person<T> &per, T var);

template<class T>
class Person {
public:
  /** STEP 1
   * 指定该声明使用空模板类型，目的是为了能够准确的链接到 STEP 2 中的模板定义
  */
  friend void fun_test<>(Person<T> &per, T var);

public:
  Person(T _age)
    : m_age(_age){};

private:
  T m_age;
};

/** STEP 2
 * 为模板类中的友元所修饰的声明构造一个即将链接到的定义
*/
template<typename T>
void fun_test(Person<T> &per, T var) {
  cout << "FUN_TEST" << endl;
  cout << per.m_age + var << endl;
}

int main(void) {
  Person<int> per_int(0x400);
  fun_test(per_int, 0x400);

  return EXIT_SUCCESS;
}
```

```cpp
#include <iostream>
using namespace std;

/** STEP 3
 * 由于 STEP 2 中使用了 Person<T>，但是 STEP 2 却定义在 Person<T> 之前，故还要在 STEP 2 之上为 Person<T> 做一次前置声明
*/
template<class T>
class Person;

/** STEP 2
 * 为模板类中的友元所修饰的声明构造一个即将链接到的定义，该行代码应该出现在 STEP 1 之上
*/
template<typename T>
void fun_test(Person<T> &per, T var) {
  cout << "FUN_TEST" << endl;
  cout << per.m_age + var << endl;
}

template<class T>
class Person {
public:
  /** STEP 1
   * 指定该声明使用空模板类型，目的是为了能够准确的链接到 STEP 2 中的模板定义
  */
  friend void fun_test<>(Person<T> &per, T var);

public:
  Person(T _age)
    : m_age(_age){};

private:
  T m_age;
};

int main(void) {
  Person<int> per_int(0x400);
  fun_test(per_int, 0x400);

  return EXIT_SUCCESS;
}
```

<br/>
<br/>

<span id = "类型转换"></span>

## 类型转换

值得一提的是，对于强制类型转换还是典型的非强制类型转换，即使转换失败也不会在运行时发生错误，仅有的错误只是会得到一个错误的转换结果亦或者是编译级别时所发生的错误，cpp 为了保证类型转换功能的更加安全，其引入了多种类型转换的方式

<br/>

<span id = "静态类型转换"></span>

#### 静态类型转换 : static_cast<type>(expression)

- 静态类型转换对于任何结果失败的转换都会在 **_编译时发生错误_**

- 它可用于内置数据类型的 **_窄化或典型的非强制_** 转换

- 它可用于内置数据类型的指针或引用的转换，除了 **_void *_** 类型的指针之间的转换，它都会针对表达式的指针类型与目标指针类型做匹配校验，如无法进行有效的匹配则转换失败

- 它不可用于 **_自定义类型(类或结构体)_** 的转换，但是可用于继承结构中类型指针的 **_上行转换_** 和 **_下行转换_**，但是不支持没有任何继承体系的类型的指针之间的转换

```cpp
#include <iostream>
using namespace std;

class BASE {};
class DERIVED : public BASE {};
class OTHER {};

int main(void) {
  /* 1. 基础数据类型转换 */
  int a = 0x400;
  long a_l = static_cast<long>(a); /* 典型的非强制转换 */
  int b = 364;
  char b_c = static_cast<char>(b); /* 窄化转换，可能会丢失精度 */

  /* 2. 无法应用于自定义数据类型的转换 */
  BASE base_01;
  DERIVED derived_01 = static_cast<BASE>(base_01);

  /* 3. 指针类型的转换，对于除了非 void * 的指针类型，对会 目标类型与表达式类型 之间的指针类型进行校验 */
  char *c_p = static_cast<char *>(&a);  /* 失败，int * 与 char * 不匹配 */
  void *p_01 = static_cast<void *>(&a); /* 成功，void * 指针类型不做检验 */
  int *p_02 = static_cast<int *>(p_01); /* 成功，void * 指针类型不做检验 */
  int *p_03 = static_cast<int *>(p_02); /* 成功，int * 与 int * 匹配 */

  /* 4. 类指针的静态定位 */
  BASE base;
  DERIVED derived;
  OTHER other;
  BASE *p_base = static_cast<BASE *>(&derived);        /* 上行转换 */
  DERIVED *p_derived = static_cast<DERIVED *>(p_base); /* 下行转换 */
  OTHER *p_other = static_cast<OTHER *>(p_base);       /* 失败，转换对象间不存在继承体系 */

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "动态类型转换"></span>

#### 动态类型转换 : dynamic_cast<type>(expression)

- 该转换在运行时需要一点额外的开销

- 不支持 **_基础内置数据类型或者是基础内置数据类型的指针或引用_** 的转换，对于这些类的转换会在编译时抛出错误

- 仅支持 **_存在虚成员_**(要保证 **_expression_** 是保有虚成员的表达式，否则会在编译时抛出错误) 的类的 **_指针或引用_** 之间的转换，<font color = "red">对于任何转换失败的结果并不会在编译时出现异常，仅仅会返回一个指向空的指针</font>

- 动态类型转换常用于一段存在继承体系的类的 **_向上类型_** 或 **_向下类型_** 转换，<font color = "red">对于向下类型转换来说，仅当类型转换是正确且成功时，返回值是一个指向所需类型的指针，否则它将返回指向空的指针来表示转换失败</font>(**_expression_** 的本身并不是指向 **_derived_**)，我们可以理解为<font color = "red">动态类型转换对于向下类型转换来说多了一个运行时的检测功能</font>

- 动态类型转换还可以用于存在 **_交叉继承体系的类_** 的转换

```cpp
#include <iostream>
using namespace std;

class BASE {
public:
  virtual ~BASE(){};
};

class DERIVED : public BASE { };

class OTHER {};

int main(void) {
  /* 基础类型的转换 */
  int *p_a = new int(0x400);
  long *p_b = dynamic_cast<long *>(p_a); /* 失败，动态类型转换不支持基础数据类型和基础数据类型指针间的转换 */


  /* 类的指针/引用的转换 */
  BASE *base_non_polymorphism = new BASE;
  DERIVED *der_non_polymorphism = dynamic_cast<DERIVED *>(base_non_polymorphism); /* 失败，expression 无法构成多态，故向下类型转换失败，并返回一个空指针 */

  BASE *base_polymorphism = new DERIVED();
  DERIVED *der_polymorphism = dynamic_cast<DERIVED *>(base_polymorphism); /* 成功，expression 可以构成多态 */
  BASE *base_more = dynamic_cast<BASE *>(der_polymorphism);               /* 成功，向上类型转换 */

  OTHER *other = dynamic_cast<BASE *>(der_polymorphism); /* 失败，OTHER 和 expression 并不存在于同一条继承体系当中 */

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "常量类型转换"></span>

#### 常量类型转换 : const_cast<type>(expression)

- 可以将 常量 转换为 非常量，非常量 转换为 常量

- 仅支持 指针或引用 间的转换，对于非指针或引用的转换会在编译时抛出错误

```cpp
#include <iostream>
using namespace std;

int main(void) {
  int a = 0x400;
  /* const int a_c = const_cast<const int>(a); */ /* 失败，仅支持指针类型的转换 */

  int *a_p = new int(0x400);
  const int *a_p_c = const_cast<const int *>(a_p);
  int *a_p_normal = const_cast<int *>(a_p_c);

  int &a_r = *a_p;
  const int &a_r_c = const_cast<const int &>(a_r);
  int &a_r_normal = const_cast<int &>(a_r_c);

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "重定义转换"></span>

#### 重定义转换 : reinterpret_cast<type>(expression)

- 重定义转换是一种不安全的转换，它可以把非指针类型转换为指针，又可以把指针类型转化为非指针类型，<font color = "red">不推荐使用</font>

```cpp
#include <iostream>
using namespace std;

int main(void) {
  int a = 0x400;
  int *a_p = reinterpret_cast<int *>(a); /* unsafe:a_p->0x400 */
  return EXIT_SUCCESS;
}
```

<br/>
<br/>

<span id = "异常"></span>

## 异常

```cpp
#include <iostream>
using namespace std;

class EXCEPTION {
public:
  EXCEPTION() {
    cout << "EXCEPTION CONSTRUCTOR" << endl;
  }
  EXCEPTION(const EXCEPTION &ex) {
    cout << "EXCEPTION COPY CONSTRUCTOR" << endl;
  }
  EXCEPTION(EXCEPTION &&ex) {
    cout << "EXCEPTION MOVE CONSTRUCTOR" << endl;
  }
  ~EXCEPTION() {
    cout << "EXCEPTION DESTRUCTOR" << endl;
  }
};

void fun_test() {
  try {
    throw EXCEPTION();
  } catch(EXCEPTION ex) {
    throw;
  }
}

int main(void) {
  try {
    fun_test();
  } catch (EXCEPTION ex) {
    cout << "HELLO,EXCE" << endl;
  } catch (int i) {
    cout << i << endl;
    cout << "HELLO,WORLD" << endl;
  }

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "异常捕获"></span>

#### 异常捕获 : try - catch(exception_type instance)

- 尝试执行 **_try_** 块中的代码，仅当可能出现亦或者显示抛出(**_throw_**)的异常则最终会被捕获到 **_catch_** 块的内部

- **_try_** 和 **_catch_** 必须是成对的出现，无法进行单独的使用，否则会造成编译级的报错

- catch 块开始前必须要声明一个异常类型 **_exception_type_**，所抛出(throw)的异常(expression)最终会映射至声明了对应 **_exception_type_** 类型的 catch 块的上下文当中，需要注意的是，所 throw 的 expression 的类型必须和 catch 的 **_exception_type_** 的类型进行严格匹配，举个例子，所 throw 的 expression 的类型为 int 类型时，那么 catch 所指定的异常类型也必须为 int 类型，<font color = "red">如果一段异常的上下文中所 throw 的 expression 并没有一个有效 **_expression_** 的 catch 进行匹配，则直接终止程序</font>

- <font color = "red">catch 块中可以指定 **_任意类型_** 的异常类型 exception_type</font>，当 exception_type 的类型为 *`...`* 时，则意味指定的异常类型为其它类型

- catch 块所声明的异常类型 **_exception_type_** 的实例在 catch 块结束前会释放掉其在栈中的内存数据，<font color = "red">如果所声明的异常类型在堆中存有数据则需要我们进行手动的释放工作，否则会出现内存泄漏的问题</font>

- 对于在一个 try 块中可能抛出的多种不同类型的异常，我们可以指定多种不同异常类型的 catch 块以匹配

<span id = "抛出异常"></span>

<br/>

#### 抛出异常 : throw expression

- **_throw expression_** 用于抛出一个异常，并指定一个异常类型为 **_exception_type_** 的实例 **_expression_**，异常实例可以是任意类型的值，我们要保证的是，一个 throw expression 最终都会有一个 try 进行异常侦测，相对应的，都会有一个声明了所 throw 的 **_exception_type_** 类型的 catch 块来完成 try 后的异常捕获工作，<font color = "red">如果 throw expression 所处的上下文中并没有一个合法的 try-catch 进行异常的捕获，那么会跳到其上级调用者的上下文中进行寻找，以此重复，直至找不到为止则程序终止</font>

- 当 throw 不指定 expression 并且它出现在一个拥有合法异常类型声明的 catch 块中时，则会延续当前 catch 块中所声明的异常类型继续向上抛出异常，我要们要注意<font color = "red">它不可以出现在其他上下文中(仅能出现在 catch 块当中)，否则程序会直接终止</font>

- catch 块中所声明的异常类型实例会依据所 throw 的对应类型的 expression 去进行构造，其实更细来讲的话，当我们 throw 一个 expression 时，编译器会根据这个 expression 为我们去构造一个<font color = "red">临时的、将亡的、左值变量</font>，没错，是一个临时、将亡的 左值 变量，然后对应 expression 类型的 catch 块的异常类型的声明则会根据这个左值变量去进行构造，并在当前 catch 上下文执行完毕后会显式的释放掉这个左值变量在栈中的内存，<font color = "red">如果 expression 所创建的临时的、无名的变量会在堆中存有数据(即一个指针)，由于该指针所指向的堆中的地址最终会映射至 catch 块中所声明的异常类型当中</font>(catch 块中的所声明的异常类型会依据所 throw 的 expression 去进行构造)，故在 catch 块结束时，编译器所构造的临时的、无名的、类型为左值的指针变量也仅仅会被释放掉其在栈中的数据，而在堆中的数据的生命周期则同步至 catch 块中所声明的异常类型去进行管控，也就是说我们要针对这个异常类型去进行手动的释放内存的工作，否则会出现内存泄漏的问题

  ```cpp
  #include <iostream>
  using namespace std;

  class EXCEPTION {
  public:
    EXCEPTION() {
      cout << "EXCEPTION CONSTRUCTOR" << endl;
    }
    EXCEPTION(const EXCEPTION &ex) {
      cout << "EXCEPTION COPY CONSTRUCTOR" << endl;
    }
    EXCEPTION(EXCEPTION &&ex) {
      cout << "EXCEPTION MOVE CONSTRUCTOR" << endl;
    }
    ~EXCEPTION() {
      cout << "EXCEPTION DESTRUCTOR" << endl;
    }
  };

  int main(void) {
    try {
      throw new EXCEPTION();
    } catch (EXCEPTION *ex) {
      cout << "HELLO,EXCE" << endl;
      delete ex;
    }

    return EXIT_SUCCESS;
  }
  ```

- <font color = "red">从 try 代码块开始，到 throw 抛出异常之前，所有栈上的数据都会被释放掉，这一过程又称为 **_栈解旋_**</font>，<font color = "red">栈解旋 所保证的内存有效性的工作也仅仅针对栈上，对于堆中分配的内存我们在 throw 之前需要对其进行手动的释放，否则会出现可能的内存泄露的问题</font>

- throw 可以写在构造函数当中

<br/>

<span id = "关于catch块中所声明的异常类型的效率问题"></span>

#### 关于 catch 块中所声明的异常类型的效率问题

我们都知道，throw expression 其实编译器会根据这个 expression 为我们构建一个临时、将亡的 左值 变量，并在最后，捕获到到这个异常的 catch 块中所声明的异常类型会依据这个 左值变量 去完成构造初始化工作，对于内置数据类型的异常类型而言似乎并无太大问题，但是对于一个自定义的异常类型的类来说，由于该类的构造是通过一个对应类型实例的左值变量来完成，故会调用该类型的拷贝构造函数来完成 catch 块中所声明的异常类型的初始化工作，由于在这里调用了拷贝构造函数，故可能会在某些程度上带来性能损失的问题，由于 throw 的 expression 虽然是一个临时的、将亡的变量，但是其实质是一个左值变量，故解决这一方案只需要把 catch 块中所声明的异常类型改为 **_左值引用_** 即可

```cpp
#include <iostream>
using namespace std;

class EXCEPTION {
public:
  EXCEPTION() {
    cout << "EXCEPTION CONSTRUCTOR" << endl;
  }
  EXCEPTION(const EXCEPTION &ex) {
    cout << "EXCEPTION COPY CONSTRUCTOR" << endl;
  }
  EXCEPTION(EXCEPTION &&ex) {
    cout << "EXCEPTION MOVE CONSTRUCTOR" << endl;
  }
  ~EXCEPTION() {
    cout << "EXCEPTION DESTRUCTOR" << endl;
  }
};

int main(void) {
  try {
    throw EXCEPTION();
  } catch (EXCEPTION &ex) {
    cout << "HELLO,EXCE" << endl;
  }

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "系统标准异常接口"></span>

#### 系统标准异常接口 exception

- exception : 所有标准异常类的父类

  - bad_alloc : 当 `operator new` 或 `operator new[]`，请求分配内存失败时

  - bad_exception : 这是个特殊的异常，如果函数的异常抛出列表里声明了 bad_exception 异常，当函数内部抛出了异常抛出列表中没有的异常，这是调用的unexpected函数中若抛出异常，不论什么类型，都会被替换为bad_exception类型
  
  - bad_typeid : 使用 `typeid` 操作符，操作一个NULL指针，而该指针是带有虚函数的类，这时抛出 `bad_typeid` 异常

  - bad_cast : 使用 `dynamic_cast` 转换引用失败的时候

  - ios_base::failure : I/0 操作过程出现错误

  - logic_error : 逻辑错误，可以在运行前检测的错误
    
    - length_error : 试图生成一个超出该类型最大长度的对象时，例如 `vector` 的 `resize` 操作

    - domain_error : 参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数

    - out_of_range : 超出有效范围

    - invalid_argument : 参数不合适。在标准库中，当利用 `` 对象构造 `bitset` 时，而 `string` 中的字符不是 '0' 或 '1' 的时候，抛出该异常string

    - runtime_error		运行时错误，仅在运行时才可以检测的错误

  - runtime_error
  
    - range_error : 计算结果超出了有意义的值域范围

    - overflow_error : 算术计算上溢

    - underflow_error : 算术计算下溢

    - invalid_argument : 参数不合适。在标准库中，当利用 `string` 对象构造 `bitset` 时，而 `string` 中的字符不是 '0' 或 '1' 的时候，抛出该异常


<br/>
<br/>

<span id = "lambda"></span>

## lambda

cpp11 为了简化回调函数定义时繁琐的工作，提供了 **_lambda_** 表达式去用于 **_定义并创建匿名的函数对象_**，<font color = "red">在编译时，编译器则会依据 lambda 表达式的声明形式去构建出一个匿名函数</font>

```cpp
#include <iostream>
using namespace std;

int main(void) {
  int (*invoker)(const char *) = [](const char *msg) mutable -> int {
    cout << msg << endl;
    return 0x400;
  };

  cout << invoker("hello,world") << endl;

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "lambda表达式的构成"></span>

#### lambda 表达式的构成

```csharp
[capture](parameters) mutable ->return_type {
  statement
}
```

**_[capture]_**

[capture] 为 **_函数对象参数_**，标识着 lambda 表达式的开始，它无法省略

一个 lambda 表达式虽然是支持写在一个函数体的上下文中，但是在<font color = "red">默认情况下，lambda 表达式内的上下文声明中是不可以显式的指定那些 **_从函数体开始到定义 lambda 为止范围内可见的局部变量_**(**_包括 lambda 表达式声明所在类的t his_**)</font>，因为 lamdba 表达式是编译器在编译时才会根据当前表达式的声明才创建的一种匿名函数，简而言之，lambda 表达式其内部上下文(**_statement_**)是根本就不被含纳在声明 lamdaba 本身所处的作用域内，除非我们<font color = "red">显式的指定 [capture]，以告诉编译器属于 lambda 本身所处的作用域内的变量需要以哪种形式去拷贝或引用到 lambda 表达式内部的上下文当中，以让 lambda 表达式内部的上下文中能够使用到非当前上下文作用域内的变量</font>

- [] : 不使用任何声明 lambda 本身所处的作用域内的任何变量，即 lambda 表达式内部的上下文和外部作用域(非全局)处于一种隔离的状态

- [=] : lambda 表达式内部上下文中 **_所使用到的_** 所有属于 lambda 表达式本身所处的作用域内的变量以 **_值拷贝的形式拷贝_** 到 lambda 表达式内部的上下文当中

- [&] : lambda 表达式内部的上下文中 **_所使用到的_** 所有属于 lambda 表达式本身所处的作用域内的变量 **_以地址引用的形式引用_** 到 lambda 表达式内部的上下文当中

- [this] : lambda 表达式内部的上下文中可以使用所处类的 this 指针去访问类中的成员

- [variable] : lambda 表达式本身所处的作用域内的变量 **_variable_** 以 **_值拷贝的形式拷贝到_** lambda 表达式内部的上下文当

- [&variable] : lambda 表达式本身所处的作用域内的变量 **_variable_** 以 **_地址引用的形式把它引用_** 到 lambda 表达式内部的上下文当中

lambda 能够通过 [capture] 所指定的 **_函数对象参数([capture])_** 来决定 **_是否含纳、如何含纳_** 声明 lambda 表达式本身所在作用域内的变量至 lambda 表达式内部上下文的声明中，这种机制称之为 **_捕获_**，而应用了这一机制的 lambda 表达式也称为 **_捕获 lambda 表达式_**，需要注意的是，<font color = "red">捕获 lambda 所捕获的外部作用域下的变量都是以 **_只读_** 的方式存在于 lambda 表达式内部上下文的声明当中的</font>，这就可能存在一个问题，<font color = "red">当以值传递(未添加 **_mutable_** 修饰)的方式所 **_捕获_** 的外部作用域下的变量时，**_一切的修改都无法映射至外部作用域上的具体变量_**，即我们对其的修改仅仅只在当前 lambda 表达式内部上下文声明的作用域之内进行，而就引用传递来说，同样也是无法修改，只是无法修改的仅是引用的指向，而不是所引用的对象在内存中的数据</font>

**_(parameters)_**

匿名函数的形参列表，如当前匿名函数并没有形参，则可以省略

**_mutable_**

当函数对象参数是以 **_值传递_** 的形式而存在时，编译器都会把它们设为只读的变量，那么当我们加了该关键字后，编译器就不会把它们设置为只读变量了，即可以修改按值传递进来的拷贝，需要注意的是，这个修改同样还是不能映射回外部作用域下的具体变量，如无特殊要求可以省略

**_return_type_**

显式的指定当前匿名函数的返回值类型，当无返回值时，可以不需要指定

**_{ statement }_**

指定 lambda 表达式内部上下文的声明


<br/>

<span id = "lambda表达式与函数指针"></span>

#### lambda 表达式与函数指针

在没有使用 **_函数对象参数_** 的lambda表达式可以返回一个对应函数类型(形参和返回值类型)并指向刚刚所构建出来的匿名函数地址的 **_函数指针_**

而使用了 **_函数对象参数_** 的 **_捕获 lambda 表达式_** 仅只能够隐式转换为一个 **_具体的、能够保存所捕获变量的状态的对象_**，在这里，更推荐的方式则为使用 `<functional>` 头文件下的 **_std::function<>_**，那么，为什么对于捕获lambda而言就需要使用这种特殊的存储方式而不仅仅只是一个单纯的函数指针，这就需要从捕获lambda的本质来谈起

捕获lambda它能够把外部作用域下的变量纳入到当前lambda上下文的声明中，这并不是什么黑科技，<font color = "red">编译器只是把它所使用到的一些外部作用域下的变量通过不同的形式(值或者引用)把它们的状态保存起来并结合着当前lambda上下文的声明一同放入一个 **_'容器'_** 里去(**_实现了函数调用运算符的匿名类_**)</font>，而对于 lambda 的调用则会依托着这个容器来进行，那么在 lambda 内部上下文中对于原本隶属外部作用域下的变量的调用则更改为仅仅针对容器内部所维护的从外部作用域下 **_捕获进来_** 的临时变量的状态来进行，需要注意的是，<font color = "red">如果以 **_[&]_** 的方式在容器中维护的那些映射至外部作用域下的变量的状态在容器本身未释放之前，原本隶属于外部作用域下本身应该被释放的变量都会呈现着一种 **_闭包_** 的状态</font>

需要扩充一点的是，我们都说使用 `[=]` 的 **_函数对象参数_** 不能改变外部作用域下的变量的值，因为这些变量放到lambda上下文的声明中仅仅只是以一个 **_值传递_** 的形式而存在，<font color = "red">虽然无法改变外部作用域下变量的值，**_但并不意味着在捕获lambda所构造的容器中内部所维护的对应的这个变量的值是无法改变的_**，即管理着这个lambda表达式和外部作用域下变量的状态的容器在其被释放前，所维护的变量的状态值一直都是一种有效值(这里指容器内部所维护的那个映射至外部作用域下变量状态的临时变量，**_它和外部作用域下的变量本身再无关系_**，仅仅只是维护它在被捕获前的状态，区别于 **_[&]_**)</font>

```cpp
#include <iostream>
#include <functional>
using namespace std;

int main(void) {
  int i = 10;

  function<bool(void)> invoker = [&](void) -> bool {
    i++;
    return true;
  };

  if(invoker()) {
    cout << "SUCCESS i = " << i << endl;
  }

  return EXIT_SUCCESS;
}
```

<br/>
<br/>

<span id = "自动推导类型"></span>

## 自动推导类型

<span id = "auto"></span>

### auto

---

#### C++98 auto

早在 **_C++98_** 标准中就存在了 auto 关键字，那时的 auto 用于声明变量为自动变量，自动变量意为拥有自动的生命期，但这是多余的，因为就算不使用 auto 声明，变量依旧拥有自动的生命期

```cpp
int a =10 ;        /* 拥有自动生命期 */
auto int b = 20 ;  /* 拥有自动生命期 */
static int c = 30; /* 延长了生命期 */
```

<br/>

#### C++11 auto

C++98 中的 auto 多余且极少使用，**_C++11_** 已经删除了这一用法，取而代之的是全新的功能 : **_变量的自动类型推断_**，auto 可以在<font color = "red">声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型</font>

这种用法就类似于 C# 中的 **_var_** 关键字，auto <font color = "red">的自动类型推断发生在编译期</font>，所以使用 auto 并不会造成程序运行时效率的降低，而<font color = "red">是否会造成编译期的时间消耗，我认为是不会的，在未使用 auto 时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换</font>

<br/>

#### auto 的具体使用_**

- 局部变量和全局变量

  ```cpp
  #include <iostream>
  using namespace std;

  auto a = 10; /* int */

  auto b = "hello,world"; /* const char * */

  int main(void) {
    auto c = 10.0; /* double */
    static auto d = 'a'; /* char */

    cout << typeid(a).name() << endl;
    cout << typeid(b).name() << endl;
    cout << typeid(c).name() << endl;
    cout << typeid(d).name() << endl;
  }
  ```

- lambda表达式声明类型, 参数类型, 返回值类型 (**_仅 c++14 支持_**)

  ```cpp
  #include <iostream>
  using namespace std;

  int main(void) {
    auto closure = [](auto x, auto y)->auto { 
      cout << typeid(x).name() << endl;
      cout << typeid(y).name() << endl;

      return 10.0;
    };

    auto var = closure(0x400, "hello,world");
    cout << typeid(var).name() << endl;

    return EXIT_SUCCESS;
  }
  ```

- 定义模板函数时，用于声明依赖模板参数的变量类型

  ```cpp
  #include <iostream>
  using namespace std;

  template<typename _Tx, typename _Ty>
  void multiply(_Tx x, _Ty y) {
    auto v = x * y;
    cout << typeid(v).name() << endl;
  }

  int main(void) {
    multiply(10.0, 0x400);

    return EXIT_SUCCESS;
  }
  ```

- 模板函数依赖于模板参数的返回值

  在 **_c++11_** 时(auto 标准刚出现的版本)，针对于模板函数的返回值类型亦然无法使用 auto 在编译代码前确定模板参数的类型，除非结合 **_decltype_** 关键字来显式的声明返回值类型，当然，<font color = "red">这一标准在 c++14 时已经改进了，在 c++14 时就可以直接通过 auto 在编译期间确定模板函数的返回值类型</font>

  ```cpp
  template <typename _Tx, typename _Ty>
  auto multiply(_Tx x, _Ty y)->decltype(_Tx*_Ty) {
      return x*y;
  }
  ```

<br/>

#### 使用 auto 时的注意事项

- auto 变量必须在定义时初始化，这类似于const关键字

- 定义在一个 auto 序列的变量必须始终推导成同一类型

```cpp
auto a4 = 10, a5 = 20, a6 = 30;    /* 正确 */
auto b4 = 10, b5 = 20.0, b6 = 'a'; /* 错误,没有推导为同一类型 */
```

- 无法在普通函数中使用 auto 作为函数的形参类型和返回值类型(**_但是可以用于 lambda 表达式_**)

- <font color = "red">不要滥用 auto！</font>
  
  - 其一可能会降低代码的可读性
  
  - 其二，对于含有 **_proxy class_** 的 class，auto 可能无法正确的获取到正确的用意，正如 **_vector<bool>_**，这是一个特殊的类型，它的返回值并不是 **_bool_** 而是一个 **_proxy bool_**，指示使用的时候只是做了一次强制类型转换所以我们无法发现，那么对其返回值使用 auto 推导，将会得到一个表示单独 **_bool_** 引用的 **_proxy class_**

```cpp
#include <iostream>
#include <vector>
using namespace std;


int main(void) {
  vector<bool> v;
  v.push_back(true);

  /* class std::_Vb_reference<struct std::_Wrap_alloc<class std::allocator<unsigned int> > > */
  auto var = v[0];
  cout << typeid(var).name() << endl;

  return EXIT_SUCCESS;
}
```

- 使用auto关键字做类型自动推导时，依次施加一下规则

  1. 如果初始化表达式是引用，则去除引用语义

  ```cpp
  #include <iostream>
  using namespace std;

  int main(void) {
    int a = 10;
    printf("0x%p\n", &a);

    int &b = a;
    printf("0x%p\n", &b);

    auto c = b;   /* c -> int */
    printf("0x%p\n", &c);

    auto &d = b;  /* d -> int & */
    printf("0x%p\n", &d);

    return EXIT_SUCCESS;
  }
  ```

  2. 如果初始化表达式为 const 或 volatile(或者两者兼有)，则除去 const/volatile 语义

  ```cpp
  #include <iostream>
  using namespace std;

  int main(void) {
    const int a = 10;
    auto b = a;        /* b -> int */
    const auto c = a;  /* c -> const int */
    b = 100;           //合法
    c = 100;           //非法

    return EXIT_SUCCESS;
  }
  ```

  3. 如果 auto 关键字带上 & 号，则不去除 const 语意

  ```cpp
  #include <iostream>
  using namespace std;

  int main(void) {
    const int a = 10;
    auto &b = a; /* b -> const int & */

    return EXIT_SUCCESS;
  }
  ```

  4. 初始化表达式为数组时，auto 关键字推导类型为指向数组首元素的指针

  ```cpp
  #include <iostream>
  using namespace std;

  int main(void) {
    int a[3] = { 1, 2, 3 };
    auto b = a; /* b -> int * */
    cout << typeid(b).name() << endl;

    return EXIT_SUCCESS;
  }
  ```

  5. 若表达式为数组且 auto 带上 &，则推导类型为 **_数组类型_**，这相当于对整个数组取地址(&)

  ```cpp
  #include <iostream>
  using namespace std;

  int main(void) {
    int a[3] = { 1, 2, 3 };
    auto &b = a; /* b -> int[3] */
    cout << typeid(b).name() << endl;

    return EXIT_SUCCESS;
  }
  ```

<br/>

<span id = "decltype"></span>

### decltype

---

decltype 与 auto 关键字一样，用于进行编译时类型推导，不过它与 auto 还是有一些区别的，decltype 的类型推导并不是像 auto 一样是从变量声明的初始化表达式获得变量的类型，<font color = "red">而是总是以一个普通表达式作为参数，返回该表达式的类型,而且 decltype 并不会对表达式进行求值</font>

#### decltype 的使用

- 推导出表达式类型

```cpp
int i = 4;
decltype(i) a; /* a -> int */
```

- 与 using / typedef 合用，用于定义类型

```cpp
using size_t = decltype(sizeof(0));//sizeof(a)的返回值为size_t类型
using ptrdiff_t = decltype((int*)0 - (int*)0);
using nullptr_t = decltype(nullptr);
```
```cpp
vector<int >vec;
typedef decltype(vec.begin()) vectype;
for (vectype i = vec.begin; i != vec.end(); i++) {
}
```

- 重用匿名类型

```cpp
#include <iostream>
#include <vector>
using namespace std;

struct {
  int d ;
  doubel b;
} anon_s;

int main(void) {
  decltype(anon_s) as;

  return EXIT_SUCCESS;
}
```

- 更多信息参考[这里](#https://www.cnblogs.com/QG-whz/p/4952980.html)


<br/>
<br/>

<span id = "智能指针"></span>

## 智能指针

> 智能指针的作用是管理一个指针，因为存在以下这种情况 : 申请的内存空间在堆中并且在函数结束时忘记显式的释放，造成内存泄漏，使用智能指针可以很大程度上的避免这个问题，因为<font color = "red">智能指针是一个类，当超出了类的实例对象的作用域并无结束时的显式引用(**_作为函数返回值类型并以右值的形式将其生命周期延续到上一个栈帧中_**)时，会自动调用对象的析构函数，析构函数会自动释放资源</font>
> 
> C++ 里提供了四种智能指针 : **_auto_ptr_**, **_unique_ptr_**, **_shared_ptr_**, **_weak_ptr_**，就其为我们管理指针的释放时机而言，都大同小异，简单来说，都回依赖于栈帧结束后自动释放栈上的内存以管理，而就使用方式而言，也是大相径庭，都是可以通过其示例的 `get()` 函数获取该容器所管理的指针(<font color = "red">部分指针重载了 **_->_** 和 **_*_** 操作符</font>)，但是它们就实现和使用场景来说还是存在着很大的区别

<br/>

<span id = "auto_ptr"></span>

### auto_ptr

---

auto_ptr 是一种 <font color = "red">**拥有严格对象所有权语义的智能指针**</font>，虽说采用的是 **_所有权_**，但事实上，其所有权仅在运行时能够体现，<font color = "red">在编译期不做任何校验</font>，这就在运行时会产生潜在的内存崩溃问题，就如转移所有权来说，当一个智能指针的所有权转移给了一个新的智能指针的实例，那么旧的将不再使用(留下悬挂的指针)，但是如果再显式引用的话，则会导致内存崩溃，所以<font color = "red">这种智能指针的方案再 **_c++11_** 标准时已被抛弃</font>

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main(void) {
  auto_ptr<string> ap_1(new string("hello,world"));

  /**
   * 使用 auto_ptr 内部的移动构造语义，将 ap_1 容器内部
   * 所维护的指针生命周期的所有权转移至 ap_2，那么 ap_1 此
   * 时则作为一个非法内存访问的存在
  */
  auto_ptr<string> ap_2 = ap_1;

  cout << *ap_1 << endl; /* runtim error: Segmentation fault */

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "unique_ptr"></span>

### unique_ptr

---

unique_ptr 由 c++11 中引进，其作为替换 auto_ptr 的存在，它实现了独占式拥有或严格拥有概念，即在运行时<font color = "red">保证同一时间内只有一个智能指针可以指向该对象</font>，它对于避免资源泄露特别有用

既然 unique_ptr 在运行时提供了这一保障，那么对于独占是拥有的保证就需要在编译期做功夫了，是的，该指针提供了编译期完成 auto_ptr 原先在运行时可能产生的错误的校验，即显式的将一个智能指针的所有权转移给了一个新的智能指针的实例，使旧的智能指针成为了一个悬挂指针，在调用它时则必定会产生内存崩溃的风险

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main(void) {
  unique_ptr<string> ap_1(new string("hello,world"));

  /* 编译时产生错误，无法将左值转移至新的智能指针实例，避免产生悬挂指针的风险 */
  unique_ptr<string> ap_2 = ap_1;

  return EXIT_SUCCESS;
}
```

unique_ptr 提供一个更加人性化的地方就是，<font color = "red">对于源操作数是将亡右值的存在，编译期是允许新操作数对原操作的所有权转移的</font> ; <font color = "red">而对于源操作数可能会存在一定时间的情况(左值)，编译期是不允许这种操作的，这也就映射了上面代码所反馈的情景，也就是可能会产生悬挂指针的情况</font>

对于源操作数是将亡右值的存在就允许所有权转移这一特性是合理的，因为一个右值在诞生之初就需要存在一个容器(新实例)来将其在内存中的数据显式的移动到容器内部，那么对于智能指针而言，随同移动的也就包括其原本所管理的指针在内存中的生命周期，这只是换了个人暂时管理而已

那么对于使用 `move()` 语义来完成左值所有权的转移其实也是允许的，但是这种方式同样会造成源操作数会产生悬挂指针的情景，但是就这一点而言，我们使用 `move()` 语义是我们自己所决定的(避免了 auto_ptr 隐式完成)，所以这点风险也应当由负责这段代码的编写人员来承担

```cpp
#include <iostream>
#include <memory>
using namespace std;

class test {
  int idx;

public:
  test(int _idx) {
    this->idx = _idx;
  };

  test(const test &te) {
    this->idx = te.idx;
  }

  test(test &&te) {
    this->idx = te.idx;
    te.idx = 0;
  }

  ~test() {
    printf("test destructor\n");
  }
  
};

unique_ptr<test> foo() {
  test *p = new test(1024);
  printf("0x%p\n", p);

  return unique_ptr<test>(p);
}

int main(void) {
  unique_ptr<test> up_1 = foo();

  unique_ptr<test> up_2(new test(1024)); /* 悬挂指针 */
  unique_ptr<test> up_3 = move(up_2);    /* 显式的将 up_2 的所有权移动至 up_3 */

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "shared_ptr"></span>

### shared_ptr

---

shared_ptr 实现 **_共享式拥有_** 概念，多个 shared_ptr 可以共同引用至同一个资源，仅当 **_最后一个引用该资源的 shared_ptr 被销毁_** 时，该资源才真正被释放

为了维持智能指针对于资源的引用计数的关系，每个 shared_ptr 内部除了管理着一块内存(地址)的生命周期外，还拥有着一个引用计数，<font color = "red">**_当一个新的 shared_ptr 使用一个源 shared_ptr 完成了构造_**，那就意味着这个新的 shared_ptr 和源 shared_ptr 内部共同维护着同一块内存生命周期，并且两者间其内部对于该资源的引用计数就会 +1(默认是 1 的话那构造完毕后，引用计数则为 2)，这也表示着，这块内存生命周期目前由两个 shared_ptr 所维护着，当某一方放弃了对该资源的引用(**_shared_ptr 被释放亦或者显式调用_** `reset()`)，则该引用计数则会 -1，仅当引用计数为 0 时，这块资源才真正的被释放</font>

```cpp
#include <iostream>
#include <memory>
using namespace std;

class test {
public:
  int idx;

  test(int _idx) : idx(_idx){};
 
  ~test() {
    printf("0x%p\n", this);
    cout << "test destructor" << endl;
  }
};

void foo() {
  /*
  +-----+
  | ps1 |
  +--+--+
     |
     |
     |
     |  +----+
     +--> t1 |
        +----+
  */
  shared_ptr<test> ps_1 = make_shared<test>(0x400);

  /*
  +-----+    +-----+
  | ps1 |    | ps2 |
  +--+--+    +--+--+
     |          |
     |          |
     |          |
     |  +----+  |
     +--> t1 <--+
        +----+
  */
  shared_ptr<test> ps_2 = ps_1;

  /*
  +-----+    +-----+               +-----+
  | ps1 |    | ps2 |               | ps3 |
  +--+--+    +--+--+               +--+--+
     |          |                     |
     |          |                     |
     |          |                     |
     |  +----+  |             +----+  |
     +--> t1 <--+             | t2 <--+
        +----+                +----+
  */
  shared_ptr<test> ps_3 = make_shared<test>(0x200);

  /*
  +-----+    +-----+               +-----+
  | ps3 |    | ps2 |               | ps1 |
  +--+--+    +--+--+               +--+--+
     |          |                     |
     |          |                     |
     |          |                     |
     |  +----+  |             +----+  |
     +--> t1 <--+             | t2 <--+
        +----+                +----+
  */
  swap(ps_1, ps_3);

  /*
       +-----+    +-----+    +-----+
       | ps3 |    | ps2 |    | ps1 |
       +--+--+    +--+--+    +--+--+
          |          |          |
          |          |          |
          |          |          |
  +----+  |          |  +----+  |
  | t1 <--+          +--> t2 <--+
  +----+                +----+
  */
  ps_2 = ps_1;

  /*
       +-----+    +-----+    
       | ps3 |    | ps2 |    
       +--+--+    +--+--+    
          |          |        
          |          |        
          |          |        
  +----+  |          |  +----+
  | t1 <--+          +--> t2 |
  +----+                +----+
  */
  ps_1.reset();

  /**
   * 由于栈帧的特性，故该函数的栈帧在出栈时，其释放顺序是从下到上来完成，
   * 也就是说，释放的时候先释放的 ps_3，这时候检查 ps_3 内部的引用计数
   * 为 1，这时候就会把 ps_3 内部所维护的资源也一起释放，然后再释放 ps_2
   * 检查 ps_2 内部的引用计数为 1，这时候就会释放掉 ps_2 内部所维护的资源，
   * 最后释放 ps_1，由于 ps_1 已经经过了 reset，故其内部没有维护任何内存的
   * 生命周期，故它只是完成了其自身的释放工作
  */
}

int main(void) {
  foo();

  return EXIT_SUCCESS;
}
```

这里要重点强调的是这个引用计数，<font color = "red">引用计数的增加需要一个新的 shared_ptr 使用一个源 shared_ptr 完成了构造后才会增加的，单纯新的 shared_ptr 在构造时只是使用了和源 shared_ptr 内部所维护的相同资源是无法完成 shared_ptr 内部的引用计数的正确计算的</font>，虽然该方式称之为资源被多少个智能指针所引用，但这只是一个抽象的概念，真正完成引用计数的计量还是要依靠 shared_ptr 自身，那么反过来，<font color = "red">对于引用计数的减少也是需要依赖于 shared_ptr 实例本身的释放才能够完成引用计数的减少，单纯的去释放掉所引用的资源是无法完成引用计数的减少的</font>

如下面的代码，由于新的 shared_ptr 的构造仅仅只是使用具体的资源来完成而不是使用源 shared_ptr 来完成，那么这两个智能指针虽然会共同维护着一块资源，但是它们内部对于该资源的引用计数都是 1，也就意味着，函数退出后则会产生资源被重复释放的问题

```cpp
#include <iostream>
#include <memory>
using namespace std;

class test {
public:
  ~test() {
    cout << "test destructor" << endl;
  }
};

void foo() {
  test *p = new test();

  shared_ptr<test> sp_1(p);
  shared_ptr<test> sp_2(p);

  cout << sp_1.use_count() << endl;
  cout << sp_2.use_count() << endl;
}

int main(void) {
  /* 重复释放 */
  foo();

  return EXIT_SUCCESS;
}
```

需要注意的是，<font color = "red">当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏</font>，正如下面的例子，当函数在出栈后，pa 和 pb 得到了释放，故其内部所维护的引用计数都各自 -1，但是由于 pa 和 pb 内部所维护的内存其内部又各自维护了一个指向对方的 shared_ptr，故这时候由于 pa 和 pb 所维护的资源其引用计数还是 1，所以这两个资源无法释放，故产生内存泄露

```cpp
#include <iostream>
#include <memory>
using namespace std;

class B;

class A {
public:
  shared_ptr<B> pb_;

  ~A() {
    cout << "A destructor\n";
  }
};

class B {
public:
  shared_ptr<A> pa_;

  ~B() {
    cout << "B destructor\n";
  }
};

void foo() {
  shared_ptr<B> pb(new B());
  shared_ptr<A> pa(new A());
  cout << pb.use_count() << endl; /* 1 */
  cout << pa.use_count() << endl; /* 1 */
  pb->pa_ = pa;
  pa->pb_ = pb;
  cout << pb.use_count() << endl; /* 2 */
  cout << pa.use_count() << endl; /* 2 */
}

int main(void) {
  foo();

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "weak_ptr"></span>

### weak_ptr

---

在 shared_ptr 一节的最后还提到了一种内存泄漏的例子，这是由于 shared_ptr 拥有着 **_强引用资源_** 的特性所导致的，即 : 只要一个新的 shared_ptr 使用源 shared_ptr 进行构造，那么其 "内部所维护的资源的引用计数就必定会 +1"(抽象概念来说)

在这里，c++11 还提供了一种支持 **_弱引用资源_** 的指针，即 weak_ptr，weak_ptr 是一种不控制对象生命周期的智能指针, 它指向了一个 shared_ptr 管理的对象，对于该对象进行内存管理的还是 shared_ptr(<font color = "red">**_weak_ptr 可以通过特殊手段来获取 shared_ptr 以完成内存的管理工作_**</font>)， weak_ptr 只是提供了对管理对象的一个访问手段(<font color = "red">**_其内部并没有重载 * 和 ->_**</font>)

weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, <font color = "red">它的构造和析构不会引起引用记数的增加或减少</font>，具体来说，不会引起减少的仅仅只是属于 shared_ptr 的引用计数，而对于 weak_ptr 其内部自成一套引用计数的体系，也就是说，增加或者减少的仅仅只是 weak_ptr 内部的那个引用计数，而对于 shared_ptr 无影响

weak_ptr 是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它也可以通过调用 `lock()` 来获得 shared_ptr 以完成管理内存的操作

下面的代码使用了 weak_ptr 进行了改进就避免了 shared_ptr 由于循环引用导致的内存泄漏的问题，我们声明了 pb_ 的类型为 weak_ptr，那么当 `pa->pb_ = pb;` 时，并不会引起 pb 其内部的引用计数的减少，也就是在函数栈帧出栈时，pb 的引用计数为 1，这时候就会引起 class B 的释放，随着 class B 的释放，其内部所维护的的 pa 的引用计数就会 -1，再加上函数栈帧出栈时，pa 的引用计数又 -1，所以会引起 class A 的释放，因为 class A 的释放，连同的还带着 pb_ 的释放，又由于 pb_ 在前面已经是放过，故该 weak_ptr 其内部的 shared_ptr 的引用计数已经是 0，故不会进行任何操作(不会重复释放内存)

```cpp
#include <iostream>
#include <memory>
using namespace std;

class B;

class A {
public:
  weak_ptr<B> pb_;

  ~A() {
    cout << "A destructor\n";
  }
};

class B {
public:
  shared_ptr<A> pa_;

  ~B() {
    cout << "B destructor\n";
  }
};

void foo() {
  shared_ptr<B> pb(new B());
  shared_ptr<A> pa(new A());
  cout << pb.use_count() << endl; /* 1 */
  cout << pa.use_count() << endl; /* 1 */
  pb->pa_ = pa;
  pa->pb_ = pb;
  cout << pb.use_count() << endl; /* 1 */
  cout << pa.use_count() << endl; /* 2 */
}

int main(void) {
  foo();

  return EXIT_SUCCESS;
}
```

<br/>
<br/>

<span id = "STL"></span>

## STL


> STL 是 cpp 标准的一部分，是 $Standard \:\: template \:\: library$ 的简称
> 
> STL 从广义上分为了容器$(container)$, 算法$(algorithm)$, 迭代器$(iterator)$，其中，容器和算法之间通过迭代器进行了无缝的链接 ; 如果需要进一步的细分，具体来说 STL 其实提供了六大组件，彼此之间可以组合套用，这六大组件分别是
> 
> - 容器 : 各种数据结构，如 vector, list, deque, set, map 等，用来存放数据 ; 从实现角度来看，STL容器是一种 class template
> 
> - 算法 : 各种常用的算法，如 sort, find, copy, for_each ; 从实现的角度来看，STL算法是一种 function tempalte
> 
> - 迭代器 : 扮演了容器与算法之间的 **胶合剂**，共有五种类型，从实现角度来看，迭代器是一种重载指针操作符的的 class template ; 所有STL容器都附带有自己专属的迭代器，只有容器的设计者(拥有者)才知道如何遍历自己的元素
> 
> - 仿函数 : 行为类似函数，可作为算法的某种策略 ; 从实现角度来看，仿函数是一种重载了函数调用操作符的 class template
> 
> - 适配器 : 一种用来修饰容器或者仿函数或迭代器接口的部件
> 
> - 空间配置器 : 负责空间的配置与管理 ; 从实现角度看，配置器是一个实现了 动态空间配置、空间管理、空间释放 的 class tempalte
> 
> STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数


<br/>

<span id = "容器"></span>

### 容器

---

> STL 针对不同的数据结构提供了不同的容器，根据不同的数据结构的排列特性，划分为了 **_序列式容器_** 和 **_关联式容器_**
> 
> - 序列式容器 : 元素排列强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置(vector, deque, list, ... )
> 
> - 关联式容器 : 元素排列是非线性的树结构，各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序，关联式容器另一个显著特点是 : 在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找 (set, multiset, map, multimap )
> 
> <font color = "red">STL 所提供的所有容器内部所维护的数据结构使用的内存都是在 堆 的基准上进行扩展</font>，虽然牺牲了线程栈上快速的存取速度但是换来更加灵活的内存空间的使用，<font color = "red">作为容器的使用者，我们无需关心当前容器内部所维护的元素在堆中开辟内存，它们都由容器本身来进行管控其在内存中的生命周期，也就是说这些在堆中的元素会随着容器本身的释放也一并释放掉他们所占用的内存</font>

<br/>

<span id = "string"></span>

#### string

STL 针对原始在 c 语言中操作字符串 ( char * ) 时所存在的诸多痛点，提供了 string 容器以替代

string 是一个类，其隶属于头文件 `<string>` 当中，其内部自维护了一个字符串数组并自管理该字符串数组内存的动态扩容和释放，即开发人员使用 string 去操作字符串时并不需要关心内存的释放和溢出的问题

**_CONSTRUCTOR_**

- `string()`
  
  默认构造，构建一个空的 string 容器

- `string(const string &str)`
  
  拷贝构造函数，依据已有的 string 实例内部所管控的字符串去构造新的 string 容器的实例

- `string(const char *str)`
  
  使用 char * 类型的字符串进行构造

- `string(int n, char _ch)`
  
  使用 n 个字符 _ch 进行构造

```cpp
#include <iostream>
#include <string>

int main(void) {
    std::string str_01;
    std::string str_02("HELLO,WORLD!");
    std::string str_03 = "HELLO,WORLD!";
    std::string str_04 = str_03;
    std::string str_05(str_04);
    std::string str_06(5, 'A');

    return EXIT_SUCCESS;
}
```

**_ASSIGNMENT_**

- `string &operator=(const char *str)`
  
  根据字符指针 str 去重新构造新的 string 实例内部所管控的字符串

- `string &operator=(const string &str)`
  
  根据拷贝语义去重新构造新的 string 实例内部所管控的字符串

- `string &operator=(char ch)`
  
  根据字符 ch 去重新构造新的 string 实例内部所管控的字符串

- `string &assign(const char *str)`
  
  根据字符指针 str 去重新构造当前 string 实例内部所管控的字符串

- `string &assign(const char *str, int n)`
  
  截取字符指针 str 的前 n 个字符去重新构造当前 string 实例内部所管控的字符串

- `string &assign(const string &str)`
  
  根据 string 实例 str 内部所管控的字符串去重新构造新当前例内部所管控的字符串

- `string &assign(int n, char ch)`
  
  使用 n 个字符 ch 去重新构造当前 string 实例内部所管控的字符串

- `string &assign(const string &str, int start, int n)`
  
  根据 string 实例 str 内部所管控的字符串从 start 下标开始的 n 个字符去重新构造当前实例内部所管控的字符串

```cpp
#include <iostream>
#include <string>

int main(void) {
  std::string str_source;
  std::string str_dest = "HELLO,WORLD";
  std::str_source = "NGPONG!";
  std::str_source = str_dest;
  std::str_source = 'A';
  std::str_source.assign("HELLO,NGPONG!");
  std::str_source.assign("HELLO,NGPONG!", 2);
  std::str_source.assign(str_dest);
  std::str_source.assign(10, 'A');
  std::str_source.assign(str_dest, 6, 5);
  std::return EXIT_SUCCESS;
}
```

**_ACQUIRE_**

- `char &operator[](int n)`
  
  返回字符串 string 下标为 n 的字符的引用，<font color = "red">当 n 超出当前字符串最大长度时，程序会直接结束</font>

- `char &at(int n)`
  
  获取字符串 string 下标为 n 的字符的引用，<font color = "red">当 n 超出当前字符串最大长度时，则抛出 **out_of_range** 的异常</font>

!!! NOTE

    通过下标获取 API 去获取 string 内部所管控字符串中的具体某个 **_字符_** 是属于对该字符的一个 **_引用_**，<font color = "red">当 string 容器内部所维护的字符串所占用的内存背重新分配后，原有的引用则会失效</font>

```cpp
#include <iostream>
#include <string>

int main(void) {
  std::string str = "HELLO,WORLD";

  std::cout << str[5] << std::endl;

  try {
    str.at(0x400);
  } catch (out_of_range ex) {
    cout << ex.what() << endl;
  }

  return EXIT_SUCCESS;
}
```

**_APPEND_**

- `string &operator+=(const string &str)`
  
  将已有 string 实例 str 内部所管控的字符串追加到当前 string 实例内部所管控的字符串的末尾处

- `string &operator+=(const char *str)`
  
  将字符指针 str 追加到当前 string 实例内部所管控的字符串的末尾处
  
- `string &operator+=(const char ch)`
  
  将字符 ch 追加到当前 string 实例内部所管控的字符串的末尾处
  
- `string &append(const char *str)`

  将字符指针 str 追加到当前 string 实例内部所管控的字符串的末尾处
  
- `string &append(const char *str, int n)`

  将字符指针 str 的前 n 个字符追加到 string 实例内部所管控的字符串的末尾处
  
- `string &append(const string &str)`

  将已有 string 实例 str 内部所管控的字符串追加到当前 string 实例内部所管控的字符串的末尾处
  
- `string &append(const string &str, int start, int n)`

  将已有 string 实例 str 内部所管控的字符串的 start 下标开始的 n 个字符追加到当前 string 实例内部所管控的字符串的末尾处
  
- `string &append(int n, char ch)`

  在当前 string 实例内部所管控的字符串的末尾处追加 n 个字符 ch

```cpp
#include <iostream>
#include <string>

int main(void) {
  std::string str_src = "HELLO,WORLD";
  std::string str_dest = "NGPONG";

  str_src += ",";
  str_src += str_dest;
  str_src += '!';

  str_src.append(1, ',');
  str_src.append("hahaha");
  str_src.append(",GET,UP!", 5);
  str_src.append(str_dest);
  str_src.append(str_dest, 0, 2);

  return EXIT_SUCCESS;
}
```

**_FIND_**

- `int find(const string &str, int pos = 0) const`

  在当前 string 实例内部所管控的字符串的的 pos 下标开始，**从左到右** 查找 str 第一次出现下标，如未找到则返回 -1

- `int find(const char *str, int pos = 0) const`

  在当前 string 实例内部所管控的字符串的的 pos 下标开始，**从左到右** 查找 str 第一次出现下标，如未找到则返回 -1

- `int find(const char *str, int pos, int n) const`

  在当前 string 实例内部所管控的字符串的的 pos 下标开始，**从左到右** 查找字符串 str 的前 n 个字符第一次出现的下标，如未找到则返回 -1

- `int find(const char ch, int pos = 0) const`

  在当前 string 实例内部所管控的字符串的 pos 下标开始，**从左到右** 查找字符 ch 第一次出现下标，如未找到则返回 -1

- `int rfind(const string &str, int pos = str_size) const`
  
  在在当前 string 实例内部所管控的字符串的的 pos 下标开始，**从右到左** 查找字符 ch 第一次出现下标，如未找到则返回 -1

- `int rfind(const char *str, int pos = str_size) const`

  在当前 string 实例内部所管控的字符串中的 pos 下标开始，**从右到左** 查找 str 第一次出现下标，如未找到则返回 -1

- `int rfind(const char *str, int pos, int n) const`

  当前 string 实例内部所管控的字符串中的 pos 下标开始，**从右到左** 查找字符串 str 的前 n 个字符第一次出现的下标，如未找到则返回 -1

- `int rfind(const char ch, int pos = str_size) const`

  在当前 string 实例内部所管控的字符串的 pos 下标开始，**从右到左** 查找字符 ch 第一次出现下标，如未找到则返回 -1


```cpp
#include <iostream>
#include <string>

int main(void) {
  std::string str_src = "HELLO,WORLOD";
  std::string str_fi = "WOR";

  std::cout << str_src.find(str_fi, 0) << std::endl;
  std::cout << str_src.find("LO", 0) << std::endl;
  std::cout << str_src.find("LO", 5, 2) << std::endl;
  std::cout << str_src.find('E', 0) << std::endl;

  std::cout << str_src.rfind(str_fi, str_src.size()) << std::endl;
  std::cout << str_src.rfind("LK", str_src.size()) << std::endl;
  std::cout << str_src.rfind("LO", 5, 2) << std::endl;
  std::cout << str_src.rfind('E', str_src.size()) << std::endl;
      
  return EXIT_SUCCESS;
}
```

**_REPLACE_**
- `string &replace(int pos, int n, const string &str)`
  
  将当前 string 实例内部所管控的字符串的 pos 下标开始的前 n 个字符，替换为字符串 str

- `string &replace(int pos, int n, const char* str)`
  
  将当前 string 实例内部所管控的字符串的 pos 下标开始的前 n 个字符，替换为字符串 str

```cpp
#include <iostream>
#include <string>

int main(void) {
  std::string str_src = "HELLO,WORLD";
  std::string str_rep = "NGPONG!";

  str_src.replace(str_src.find(',') + 1, str_src.size() - (str_src.find(',') + 1),  str_rep);
  str_src.replace(6, 7, "wupeng!");

  return EXIT_SUCCESS;
}
```

**_COMPARE_**

- `int compare(const string &str) const`
  
  当前 string 实例内部所管控的字符串与字符串 str，进行比较

- `int compare(const char *str) const`
  
  当前 string 实例内部所管控的字符串与字符串 str，进行比较

- `比较结果`
  - 原始 < 目标 : -1

  - 原始 > 目标 :  1

  - 原始 = 目标 :  0

```cpp
#include <iostream>
#include <string>

int main(void) {
  std::string str_cp_01 = "BCDEFG";
  std::string str_cp_02 = "AWERT";

  std::cout << str_cp_01.compare(str_cp_02) << std::endl;

  return EXIT_SUCCESS;
}
```

**_SUBSTRING_**

- `string substr(int pos = 0, int n = str_size) const`
  
  截取当前 string 实例内部所管控的字符串从 pos 下标开始的前 n 个字符，并返回新 string 容器的实例，需要注意的是，<font color = "red">新容器实例内部所维护的字符串数组其内存空间并不是以旧字符串的内存空间为基准的，而是创建了一块新的内存空间，并将截取结果拷贝到这块新的内存空间当中</font>

```cpp
#include <iostream>
#include <string>

int main(void) {
  std::string str = "HELLO,WORLD";

  std::string str_sub = str.substr(0, str.find(','));

  std::cout << str_sub << std::endl;

  return EXIT_SUCCESS;
}
```

**_INSERT_**

- `string &insert(int pos, const char *str)`
  
  从当前 string 实例内部所管控的字符串的下标 pos 处插入字符串 str

- `string &insert(int pos, const string &str)`
  
  从当前 string 实例内部所管控的字符串的下标 pos 处插入字符串 str

- `string &insert(int pos, int n, char ch)`    
  
  从当前 string 实例内部所管控的字符串的下标 pos 处插入 n 个字符 ch


```cpp
#include <iostream>
#include <string>

int main(void) {
  std::string str_src = "HELLO,WORLD";
  std::string str_des = "NGPONG,";

  str_src.insert(str_src.find(',') + 1, str_des);
  str_src.insert(2, "OO");
  str_src.insert(0, 3, 'A');

  /* AAAHEOOLLO,NGPONG,WORLD */
  std::cout << str_src << std::endl;

  return EXIT_SUCCESS;
}
```

**_DELETE_**

- `string &erase(int pos, int n = str_size)`
  
  删除当前当前实例内部所管控的字符串从下标 pos 开始的 n 个字符

```cpp
#include <iostream>
#include <string>

int main(void) {
  std::string str = "HELLO,WORLD";

  str.erase(0, 6);

  std::cout << str << std::endl;

  return EXIT_SUCCESS;
}
```

**_COMMON_**

- `size_t size()`
  
  获取字符串的真实长度

- `size_t length()`
  
  获取字符串的真实长度

- `const char *c_str()`
  
  获取 string 容器内部所维护的字符指针 char *

```cpp
#include <iostream>
#include <string>

int main() {
  std::string str = "hello";

  auto p = str.c_str();

  std::cout << str.length() << std::endl;
  
  std::cout << str.size() << std::endl;

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "vector"></span>

#### vector


需要强调的是，<font color = "red">使用 vector 作为存储媒介时无需关心 vector 内部所使用的那一段在 自由存储区 中的内存的生命周期，因为 vector 本身提供了内存管理的功能</font>

<font color = "red">vector 容器的设计是一种 **_单端数组_**</font>，为符合常数项时间复杂度的新增和删除，vector 容器内部所提供的新增和删除元素的 API 都是仅针对数组中的尾元素所进行的，当然这并不代表着我们无法对该数组进行随机性的插入和删除操作，作为容器本身也提供了这些 API 用于支持，由于 vector 内部所维护的动态数组是真正意义上的连续性的存储空间，那么对于长度越长并且越接近于首部元素下标的新增和删除操作，所带来的性能损耗的确是灾难性的，当我们理解了这一点，自然也明白为什么 vector 会被抽象为一种单端型的数组了

<font color = "red">vector 所谓的动态扩容并不会在原空间的基础上延续新空间</font> ( 因为无法保证旧空间之后尚有可配置的空间 ) ，而是会另外申请一块更大的内存空间，然后将原数据拷贝至新的内存空间，最后再释放掉旧内存空间中的数据，因此，<font color = "red">对 vector 的任何操作，一旦引起空间的重新配置，任何由原始空间所延伸出来的部件都将会失效</font>

<font color = "red">一个 vector 的 "容量" 永远大于或等于其 "大小"，一旦容量等于大小，便是满载，下一个元素的新增将会导致整个 vector 容器另觅居所</font>

vector 所提供的迭代器是一种 **_随机访问迭代器_**，它们总是会指向容器数组阵列的首元素和尾元素的位置


**_关于 vector 迭代器失效的问题_**

1. 当 vector 第一次插入元素时，在插入前所获取的 `begin` 和 `end` 迭代器将失效

2. 当 vector 随机 ( 非尾部 ) 插入元素时，插入点之后 ( 包括插入点 ) 的所有元素延伸出的 [iterator] [poiner] [reference] 都将失效

3. 当 vector 在尾部 ( push_back ) 插入元素时，`end` 迭代器将失效

4. 一旦 vector 发生了内存空间的重新配置(动态扩容)，那么在空间重新配置前所获取到的关于 vector 的 [iterator] [poiner] [reference] 都将失效，<font color = "red">该动作需要考虑的优先级高于 1, 2, 3 条</font>

5. 当 vector 随机 ( 非尾部 ) 删除元素时，删除点之后 ( 包括删除点 ) 的所有元素延伸出的 [iterator] [poiner] [reference] 都将失效

6. 当 vector 删除尾部元素时，`end` 迭代器将失效，尾元素延伸出的 [iterator] [poiner] [reference] 都将失效

7. <font color = "red">如果 2, 5 条所指明的 "失效" 动作未发生 vector 内存空间的重新配置，则该 "失效" 并不是真正意义上关于内存释放所引发的失效</font>，而是由于元素的位置发生了偏移而无法再通过旧的位置获取到相同元素的值的失效，既然无法获取到，那么再去通过旧元素的位置去获取旧元素时就属于一个 **_未定义_** 的行为，故归纳为 "失效"


**_CONSTRUCTOR_**

- `vector<T>()`

  默认构造，构建一个空的 vector 容器

- `vector<T>(V begin, V end)`
  
  该构造函数是一个存在虚拟类型为 V 的模板函数，V 的具现化于所接受的能够指示一段线性数组 $[ \: begin, \: end \: )$ 开闭区间的迭代器 ( 隶属于容器的 ) 亦或者地址所指示的类型，并使用它来完成当前容器内部所管控的动态数组的初始化工作

- `vector<T>(int n, T element)`
  
  该构造函数使用 n 个 _element 用于容器内部动态数组的初始化构造工作

- `vector(const vector &vec)`
  
  拷贝语义，将已有容器实例内部所管控的动态数组中的 "有效元素" 拷贝至当前容器实例内部所管控的动态数组中


```cpp
#include <iostream>
#include <vector>

int main() {
  /* vector<T>() */
  vector<int> ve_empty;

  /* vector<T>(V begin, V end) */
  vector<int> ve_01(ve_empty.begin(), ve_empty.end());
  int nums[5] = { 1, 2, 3, 4, 5 };
  vector<int> ve_02(nums, nums + (sizeof(nums) / sizeof(int)));

  /* vector<T>(n, T _element) */
  vector<int> ve_03(10, 23);

  /* vector(const vector &_vec) */
  vector<int> ve_04(ve_02);

  return EXIT_SUCCESS;
}
```

**_ASSIGNMENT_**

- `void assign(V begin, V end)`
                
  该函数是一个存在虚拟类型为 V 的模板函数，V 的具现化于所接受的能够指示一段线性数组 $[ \: begin, \: end \: )$ 开闭区间的迭代器 ( 隶属于容器的 ) 亦或者地址所指示的类型，并使用它来完成当前 vector 容器实例内部所管控的动态数组的重新赋值的工作
  
- `void assign(int n, element)`
  
  该函数使用 n 个 element 用于容器内部动态数组的重新赋值的工作

- `vector &operator=(const vector &vec)`
  
  拷贝赋值运算符，依据已有 vector 的实例内部所管控的动态数组中的 "有效元素" 去重新构造当前容器实例本身内部所管控的动态数组

- `void swap(vector &vec)`
  
  交换目标 vector 容器 vec 与当前 vector 容器其内部指向动态数组的指针，并重新更新双方容器内部所管控的关于动态数组的 `size` 和 `capacity`

```cpp
#include <iostream>
#include <vector>

int main() {
  int nums_src[5] = { 1, 2, 3, 4, 5 };
  vector<int> ve_src;

  /* void assign(V _begin, V _end) */
  ve_src.assign(nums_src, nums_src + (sizeof(nums_src) / sizeof(int)));

  /* void assign(n, _element) */
  ve_src.assign(10, 1024);

  vector<int> ve_des;

  /* vector& operator=(const vector &_vec) */
  ve_des = ve_src;

  /* void swap(vector &_vec) */
  ve_des.swap(ve_src);
}
```

**_ITERATOR_**

- 正序迭代器  

  ```text
  +---+---+---+---+---+
  | 1 | 2 | 3 | 4 | 5 |
  +-+-+---+---+---+---+
    ^                    ^
    |                    |
  begin                 end
  ```
  
  - `vector<int>::iterator begin()`
  
    获取 vector 容器的正序起始迭代器，正序起始迭代器所指向的是 vector 内部所管控的动态数组中的首元素的位置

  - `vector<int>::iterator end()`
  
    获取 vector 容器的正序结束迭代器，正序结束迭代器所指向的是 vector 内部所管控的动态数组中的最后一个元素的下一个位置，该迭代器通常也称为 `off-the-end`

- 逆序迭代器

  ```text
      +---+---+---+---+---+
      | 1 | 2 | 3 | 4 | 5 |
      +---+---+---+---+-+-+
    ^                   ^
    |                   |
  rend                rbegin
  ```

  - `vector<int>::reverse_iterator rbegin()`
  
    获取 vector 容器的逆序起始迭代器，逆序起始迭代器所指向的是 vector 内部所管控的动态数组中的最后一个元素的位置

  - `vector<int>::reverse_iterator rend()`

    获取 vector 容器的逆序结束迭代器，逆序结束迭代器所指向的是 vector 内部所管控的动态数组中的首元素的上一个位置


```cpp
#include <iostream>
#include <vector>

int main() {
  std::vector<int> v;
  for (size_t i = 0; i < 10; ++i) {
    v.push_back(i);
  }
  
  /* begin / end */
  for (std::vector<int>::iterator i = v.begin(); i != v.end(); ++i) {
    printf("[0x%p] %d\n", &*i, *i);
  }

  /* rbegin / rend */
  for (std::vector<int>::reverse_iterator i = v.rbegin(); i != v.rend(); ++i) {
    printf("[0x%p] %d\n", &*i, *i);
  }

  return EXIT_SUCCESS;
}
```

**_CAPACITY_**
- `size_t size()`
  
  返回 vector 容器内部动态数组的 "有效元素" 个数

- `bool empty()`
  
  判断是否是一个空容器 ( 无任何 "有效元素" 的录入 )

- `size_t capacity()`
  
  获取 vector 容器内部动态数组的 "真实容量"

- `void resize(int n)`
  
  重新指定 vector 容器内部动态数组的 有效元素 的个数 ( 长度 ) 为 n，如果 n 较调用前的长度大，则以默认值填充超出的位置；如果 n 较调用前的长度小，则末尾超出数组长度的元素被删除 ( 所删除的仅仅只是 "有效元素"，并无法缩减内部动态数组的 "真实容量" )

- `void resize(int n, T element)`
  
  重新指定 vector 容器内部动态数组的 有效元素 的个数 ( 长度 ) 为 n，如果 n 较调用前的长度大，则以拷贝所指定的 element 去填充超出的位置；如果 n 较调用前的长度小，则末尾超出数组长度的元素被删除 ( 所删除的仅仅只是 "有效元素"，并无法缩减内部动态数组的 "真实容量" )

- `void reserve(int len)`
  
  调整 vector 容器内部动态数组的 "真实容量" 至 len，所新增出来的预留位置并未进行过初始化，即不可被访问，也不可执行随机插入操作 ( 仅仅允许插入有效元素至当前动态数组尾元素的下一个元素的位置 )，简而言之，它们都不是 "有效元素"；当 len 所指定的长度要小于当前 vector 容器内部动态数组的 "真实容量" 时，则该函数调用无任何结果

```cpp
#include <iostream>
#include <vector>

int main() {
  int nums[5] = { 1, 2, 3, 4, 5 };
  vector<int> _ve(nums, nums + (sizeof(nums) / sizeof(int)));

  /* size_t size() */
  size_t _ve_size = _ve.size();

  /* size_t capacity() */
  size_t _ve_capacity = _ve.capacity();

  /* bool empty() */
  bool is_empty = _ve.empty();

  /* void resize(int n) */
  _ve.resize(10);

  /* void resize(int n, T _element) */
  _ve.resize(7, 0x400);

  /* void reserve(int len) */
  _ve.reserve(0x400);
}
```

**_INDEX_**

- `T &at(int _idx)`
  
  返回 vector 容器内部所维护的动态数组的下标为 _idx 的元素的引用，如果 _idx 超出内部数组的有效元素个数，则抛出 `out_of_range` 异常

- `T &operator[_idx]`
  
  返回 vector 容器内部所维护的动态数组的下标为 _idx 的元素的引用，如果 _idx 超出内部数组的有效元素个数，则程序崩溃

- `T &front()`
  
  返回 vector 容器内部所维护的动态数组的首元素的引用

- `T &back()`
  
  返回 vector 容器内部所维护的动态数组的尾元素的引用

```cpp
#include <iostream>
#include <vector>

int main() {
  int nums[5] = { 1, 2, 3, 4, 5 };
  vector<int> _ve(nums, nums + (sizeof(nums) / sizeof(int)));

  int &num_01 = _ve.at(0);
  int &num_02 = _ve[1];
  int &num_03 = _ve.front();
  int &num_04 = _ve.back();
}
```

**_INSERT_**

- void insert(const_iterator pos,T _element)
  
  根据迭代器 pos 所指向的元素的下标往 vector 容器内部的动态数组插入一个元素 _elemenet，如果迭代器 pos 所指向的元素下标超出了动态数组的真实容量，则程序崩溃

- void push_back(T _element)
  
  往 vector 容器内部的动态数组的尾部插入元素 _element

```cpp
#include <iostream>
#include <vector>

int main() {
  int nums[5] = { 1, 2, 3, 4, 5 };
  vector<int> _ve(nums, nums + (sizeof(nums) / sizeof(int)));

  /* void insert(const_iterator pos,T _element) */
  _ve.insert(_ve.begin() + 2, 0x400);

  /* void push_back(T _element) */
  _ve.push_back(0x200);
}
```

**_DELETE_**

- `void pop_back()`
  
  删除 vector 容器内部的动态数组中的尾元素

- `iterator erase(const_iterator start, const_iterator end)`
  
  删除 vector 容器内部的动态数组中，迭代器 start 和 迭代器 end 所指向的下标之间的所有的 "真实元素"，并返回下一个可用元素位置的迭代器

- `iterator erase(const_iterator pos)`
  
  删除 vector 容器内部的动态数组中，迭代器 pos 所指向的 "真实元素"，并返回距离删除点下一个可用元素位置的迭代器

- `void clear()`
  
  删除 vector 容器内部的动态数组中的所有的 "真实元素"

```cpp
#include <iostream>
#include <vector>

int main() {
  int nums[5] = { 1, 2, 3, 4, 5 };
  vector<int> _ve(nums, nums + (sizeof(nums) / sizeof(int)));

  /* void pop_back() */
  _ve.pop_back();

  /* void erase(const_iterator start, const_iterator end) */
  _ve.erase(_ve.begin(), _ve.begin() + 2);

  /* void erase(const_iterator pos) */
  _ve.erase(_ve.begin() + 1);

  /* void clear() */
  _ve.clear();
}
```

**_降低 vector 内部所管控的动态数组的扩容次数_**

vector 容器内部的数组的动态扩容机制总是琢磨不定的，因为其由 vector 内置的一套算法来完成，那么在一个高额新增操作的时候，动态数组就需要不断地经历销毁内存、构建新的内存、拷贝旧内存中的数据至新内存当中，这就会造成较大的性能损失，解决办法就是在有效的范围内先通过 `reserve` 函数来调整更多的动态数组的真实容量，并在此基础上再进行元素的插入操作即可

```cpp
#include <iostream>
#include <vector>

int main() {
  /* 记录两次不同的处理方式，vector 内部的动态数组的扩容次数 */

  int num_01 = 0;
  vector<int> _ve_01;
  int *p_temp_01 = nullptr;
  for (size_t i = 0; i < 1000000; ++i) {
    _ve_01.push_back(i);

  /**
   * 每一次 vector 内部所管控的动态数组的扩容都会使用一块新的内存地址，
   * 故通过此机制来判断下一次插入数据后的元素首地址是否等于上一次元素的首地址来判断
   * 当前插入操作是否引起了动态数组的扩容操作
  */
    if (p_temp_01 != &_ve_01.at(0)) {
      p_temp_01 = &_ve_01.at(0);
      ++num_01;
    }
  }
  cout << num_01 << endl;

  int num_02 = 0;
  vector<int> _ve_02;
  int *p_temp_02 = nullptr;
  _ve_02.reserve(1000000); /* 在可控范围内，预先调整 vector 内部动态数组的长度 */
  for (size_t i = 0; i < 1000000; ++i) {
    _ve_02.push_back(i);
    if (p_temp_02 != &_ve_02.at(0)) {
      p_temp_02 = &_ve_02.at(0);
      ++num_02;
    }
  }
  cout << num_02 << endl;
}
```

**_缩减 vector 的真实容量，避免空间的浪费_**

vector 容器能够保证其内部所管控的数组在长度不足的情况下提供动态扩容的机制以防止内存长度溢出的问题，但是却无法提供动态数组的 "真实容量" 的动态收缩的策略吗；在某些情况我们需要缩减动态数组的 "真实容量" 以保证内存空间的足够性

```cpp
#include <iostream>
#include <vector>

void main() {
  vector<int> _ve;
  for (size_t i = 0; i < 100000; ++i) {
    _ve.push_back(i);
  }

  /** 
   * resize 函数仅仅只能够缩减 vector 内部动态数组中的真实元素的长度，
   * 但是动态数组的真实容量却并不会缩减，简而言之，我们虽然把它的真实元素的长度缩减至 5 个，
   * 但是动态数组其真实容量还是在进行了 100000 新增操作后的容量，这里就会造成内存空间浪费的问题
  */
  _ve.resize(10);
  cout << _ve.capacity() << endl;

  /** 
   * 通过匿名对象调用 vector 容器的拷贝构造函数，把已有 vector 实例 _ve 内部的动态数组的真实元素（5个）拷贝至
   * 匿名对象内部所构造的动态数组中，由于仅仅指示拷贝的原始动态数组中的 真实元素，故该匿名对象 vector 内部所管控
   * 的动态数组的长度也仅仅是以元素动态数组的真实元素的个数为单位，这时候我们再通过 swap() 函数来交换匿名对象内部
   * 所管控的动态数组和元素动态数组之间在内存动态存储区中的地址，以让原始 vector 内部指向的数组为 匿名对象 所构造
   * 出来的动态数组，并且被交换后的、长度更长的动态数组由于匿名对象在调用完毕后就会进行销毁，故其也进行了销毁，以此
   * 来完成了 静态缩减 容量的目的
  */
  vector<int>(_ve).swap(_ve);
  cout << _ve.capacity() << endl;

  /* 清空内容，且释放内存 */
  _ve.clear();
  _ve.shrink_to_fit();
}
```

<br/>

<span id = "deque"></span>

#### deque

deque 是 STL 提供的一种支持任意类型存储的 **_序列式容器_**，和 vector 一样，deque 同样也可以作为一种 动态数组 使用，其所使用的存储区域同样也是以 自由存储区 作为基准，作为容器本身，它在 自由存储区 中所使用的内存自然也由 deque 容器自身来进行管理和释放

<font color = "red">deque 其内部所维护的其实并不是一段真正意义上的 连续性 存储空间，它的真正的存储模型是以不同区域段的内存空间所组合而成，一旦 deque 需要对所维护的存储空间进行动态扩容时，便会申请出一段在自由存储区中的内存空间，并把它串接在 deque 所维护的 **_中控器_** 的首端亦或者尾端</font>

<font color = "red">所谓中控器，其实是一个使用着一小块连续内存空间的 `map`，其中每个元素都是一个指针，分别指向了刚刚所提到的不同区域段的内存空间，deque 以这块真正连续性存储空间 map 为基准，把这些不同区域段的内存空间延续起来</font>，带给使用者误认为所使用的是一种连续性内存空间的假象

![2021-01-02-22-44-55](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2021-01-02-22-44-55.gif)

不可否认的是，<font color = "red">这种数据结构能够带来的最大的好处就是，对于内存空间的动态扩容机制就可以巧妙的避开了像 vector 那样总需要经历 [ 申请一块更大的内存空间、旧内存空间的数据拷贝至新内存空间当中、释放掉旧内存空间 ] 的轮回</font>，但是相对的，<font color = "red">由于该数据结构的复杂性，所以 deque 需要更多的工作在这个复杂的数据结构的上位置分段连续的内存空间连续性的假象，这就造成了其所内置的迭代器相较于 vector 所内置的迭代器其复杂度根本不是一个量级的，这当然也会影响到了使用 deque 进行运算时的各个层面</font>，因此，除非有必要，我们应该尽可能的使用 vector，而不是 deque，就如对 deque 进行的排序操作，为了最高效率，可将 deque 先完整的复制到一个 vector 中，对 vector 容器进行排序，再复制回 deque

也正因为 deque 数据结构的这一特性，所以 deque 和 vector 有一点更大的区别是，<font color = "red">deque 本身并没有 "容量" 这一概念</font>，值得一提的是，这个 容量 的概念是上升至整个容器所维护的内存段本身的，对于 vector 而言，由于其使用的是一个真正的延续性的内存空间，故这段空间是存在容量的，而对于 deque 来说，它的内存的都是以段式进行存储，它随时可以增加一段新的空间并通过中控器链接起来，故没有完整意义上的 "容量" 的概念

<font color = "red">deque 的这种数据结构所带来的另一种特性就是，它能够被抽象为一种 **_双端式的数组_**</font>，deque 容器内部所提供的新增和删除元素的 API 既可以针对数组中的首元素进行，也可以针对尾元素进行的，相较于 vector，由于是线性存储空间的特性，故对于首部元素的插入和删除的操作会带来较大的性能损失，反观 deque，由于它所使用的是分段式内存存储的机制，所以对于数组首部元素的新增和删除的操作较 vector 来说会更容易实现，换句话说，deque 允许使用常数项时间的方式对头端进行元素的插入和删除操作，这也是为什么它会被抽象为一种 双端式数组 的原因

deque 所提供的迭代器是一种 **_随机访问迭代器_**，它们总是会指向容器数组阵列的首元素和尾元素的位置


**_关于 deque 迭代器失效的问题_**

1. 当 deque 第一次插入元素时，在插入前所获取的 `begin` 和 `end` 迭代器将失效

2. 当插入点位于首元素附近时，则插入点之前的所有元素延伸出的 [iterator] [poiner] [reference] 都将失效；当插入点位于尾元素附近时，则插入点之后 ( 包括插入点 ) 的所有元素延伸出的 [iterator] [poiner] [reference] 都将失效

3. 当 deque 在尾部 ( push_back ) 插入元素时，`end` 迭代器将失效；当 deque 在首部 ( push_front ) 插入元素时，`start` 迭代器将失效

4. 当 deque 删除尾部元素 ( pop_back ) 时，`end` 迭代器将失效，尾元素延伸出的 [iterator] [poiner] [reference] 都将失效；当 deque 删除首部元素 ( pop_front ) 时，首元素延伸出的 [iterator(start)] [poiner] [reference] 都将失效

5. 当删除点位于首元素附近时，则删除点之前 ( 包括删除点 ) 的所有元素延伸出的 [iterator] [poiner] [reference] 都将失效；当删除点位于尾元素附近时，则删除点之后 ( 包括删除点 ) 的所有元素延伸出的 [iterator] [poiner] [reference] 都将失效


**_CONSTRUCTOR_**

- `deque<T>()`
  
  默认构造，构建一个空的 deque 容器

- `deque<T>(V _begin, V _end)`
  
  该构造函数是一个存在虚拟类型为 V 的模板函数，V 的具现化于所接受的能够指示一段线性数组 $[ \: begin, \: end \: )$ 开闭区间的迭代器 ( 隶属于容器的 ) 亦或者地址所指示的类型，并使用它来完成当前 deque 容器内部所维护的动态数组的初始化工作

- `deque<T>(int n, T _element)`
  
  该构造函数使用 n 个 _element 用于 deque 容器内部动态数组的初始化构造工作

- `deque(const vector &_vec)`
  
  拷贝构造函数，将已有 deque 容器实例内部所维护的动态数组中的元素拷贝至当前 deque 容器实例内部所维护的动态数组中

```cpp
#include <iostream>
#include <deque>

void main() {
  /* deque<T>() */
  std::deque<int> dq_empty;

  /* deque<T>(V _begin, V _end) */
  std::deque<int> dq_01(dq_empty.begin(), dq_empty.end());
  int nums[5] = { 1, 2, 3, 4, 5 };
  std::deque<int> dq_02(nums, nums + (sizeof(nums) / sizeof(int)));

  /* deque<T>(int n, T _element) */
  std::deque<int> dq_03(10, 23);

  /* deque(const vector &_vec) */
  std::deque<int> dq_04(dq_02);
}
```

**_ASSIGNMENT_**

- `void assign(V _begin, V _end)`
  
  该构造函数是一个存在虚拟类型为 V 的模板函数，V 的具现化于所接受的能够指示一段线性数组 $[ \: begin, \: end \: )$ 开闭区间的迭代器 ( 隶属于容器的 ) 亦或者地址所指示的类型，并使用它来完成当前 deque 容器实例内部所维护的动态数组的重新赋值的工作

- `void assign(int n, _element)`
  
  该函数使用 n 个 _element 用于 deque 容器内部所维护的动态数组的重新赋值的工作

- `deque &operator=(const deque &_deq)`
  
  拷贝赋值运算符，依据已有 deque 的实例内部所维护的动态数组中的元素去重新构造当前 deque 容器实例本身内部所维护的动态数组

- `void swap(deque &_deq)`
  
  交换目标 deque 容器与当前 deque 容器内部指向着用于管控分段式内存区域的中控器的指针，并重新更新双方容器内部所维护的动态数组的 size

```cpp
#include <iostream>
#include <deque>

void main() {
  int nums_src[5] = { 1, 2, 3, 4, 5 };
  deque<int> dq_src;

  /* void assign(V _begin, V _end) */
  dq_src.assign(nums_src, nums_src + (sizeof(nums_src) / sizeof(int)));

  /* void assign(int n, _element) */
  dq_src.assign(10, 1024);

  deque<int> dq_des;

  /* deque &operator=(const deque &_deq) */
  dq_des = dq_src;

  /* void swap(vector &_vec) */
  dq_des.swap(dq_src);
}
```

**_CAPACITY_**

- `size_t size()`
  
  返回 deque 容器内部动态数组的元素个数
  
- `bool empty()`
  
  判断是否是一个空容器（无任何有效元素的录入）

- `void resize(int n)`
  
  重新指定 deque 容器内部所维护的动态数组的长度为 n，如果 n 较调用前的长度大，则以默认值填充超出的位置，如果 n 较调用前的长度小，则末尾超出数组长度的元素被删除

- `void resize(int n, T _element)`
  
  重新指定 deque 容器内部动态数组的长度为 n，如果 n 较调用前的长度大，则以拷贝所指定的 _element 去填充超出的位置，如果 n 较调用前的长度小，则末尾超出数组长度的元素被删除

```cpp
#include <iostream>
#include <deque>

void main() {
  int nums[5] = { 1, 2, 3, 4, 5 };
  deque<int> _dq(nums, nums + (sizeof(nums) / sizeof(int)));

  /* size_t size() */
  size_t _dq_size = _dq.size();

  /* bool empty() */
  bool is_empty = _dq.empty();

  /* void resize(int n) */
  _dq.resize(10);

  /* void resize(int n, T _element) */
  _dq.resize(7, 0x400);
}
```

**_INDEX_**

- `T &at(int _idx)`
  
  返回 deque 容器内部所维护的动态数组的下标为 _idx 的元素的引用，如果 _idx 超出内部数组的有效元素个数，则抛出out_of_range异常

- `T &operator[_idx]`
  
  返回 deque 容器内部所维护的动态数组的下标为 _idx 的元素的引用，如果 _idx 超出内部数组的有效元素个数，则程序崩溃

- `T &front()`
  
  返回 deque 容器内部所维护的动态数组的首元素的引用

- `T &back()`
  
  返回 deque 容器内部所维护的动态数组的尾元素的引用

```cpp
#include <iostream>
#include <deque>

void main() {
  int nums[5] = { 1, 2, 3, 4, 5 };
  deque<int> _dq(nums, nums + (sizeof(nums) / sizeof(int)));

  int &num_01 = _dq.at(0);
  int &num_02 = _dq[1];
  int &num_03 = _dq.front();
  int &num_04 = _dq.back();
}
```

**_INSERT_**

- `void insert(const_iterator pos,T _element)`
  
  根据迭代器 pos 所指向的元素的下标往 deque 容器内部所维护的动态数组中插入一个元素 _elemenet，如果迭代器 pos 所指向的元素下标超出了动态数组的真实容量，则程序崩溃
  
- `void push_back(T _element)`
  
  往 deque 容器内部的动态数组的尾部插入元素 _element

- `void push_front(T _element)`
  
  往 deque 容器内部的动态数组的首部插入元素 _element

```cpp
#include <iostream>
#include <deque>

void main() {
  int nums[5] = { 1, 2, 3, 4, 5 };
  deque<int> _dq(nums, nums + (sizeof(nums) / sizeof(int)));

  /* void insert(const_iterator pos,T _element) */
  _dq.insert(_dq.begin() + 2, 0x400);

  /* void push_back(T _element) */
  _dq.push_back(0x200);

  /* void push_front(T _element) */
  _dq.push_front(0x100);
}
```

**_DELETE_**

- `void pop_back()`
  
  删除 deque 容器内部的动态数组中的尾元素

- `void pop_front()`
  
  删除 deque 容器内部的动态数组中的首元素

- `iterator erase(const_iterator start, const_iterator end)`
  
  deque 容器内部所维护的动态数组中删除迭代器 start 和 迭代器 end 所指向的下标之间的所有的元素，并返回下一个可用元素位置的迭代器

- `iterator erase(const_iterator pos)`
  
  deque 容器内部所维护的动态数组中删除迭代器 pos 所指向的元素，并返回距离删除点下一个可用元素位置的迭代器

- `void clear()`
  
  删除 deque 容器内部的动态数组中的所有的元素

```cpp
#include <iostream>
#include <deque>

void main() {
  int nums[5] = { 1, 2, 3, 4, 5 };
  deque<int> _dq(nums, nums + (sizeof(nums) / sizeof(int)));

  /* void pop_back() */
  _dq.pop_back();

  /* void pop_front() */
  _dq.pop_front();

  /* void erase(const_iterator start, const_iterator end) */
  _dq.erase(_dq.begin(), _dq.begin() + 2);

  /* void erase(const_iterator pos) */
  _dq.erase(_dq.begin() + 1);

  /* void clear() */
  _dq.clear();
}
```

<br/>

<span id = "stack"></span>

#### stack

stack 是 STL 所提供的一种支持任意类型的存储的 **_序列式容器_**，该容器的内部设计非常简单，其遵循 栈 的 FILO 的存储结构而进行设计，我们的对于该容器中元素的访问和插入永远只能从 栈顶 开始，<font color = "red">**_并且 STL 并没有提供针对此容器的迭代器_**，换言之，stack 容器是不允许存在遍历的型为的</font>

为保证最大内存的可用性，该容器所使用的内存区域是以 自由存储区 作为基准，并且作为容器本身，它在 自由存储区 中所使用的内存也由 stack 自身来进行管理和释放

**_CONSTRUCTOR_**

- `stack<T>()`
  
  默认构造，构建一个空的 stack 容器

- `stack(const stack &_st)`
  
  拷贝构造函数，将已有 stack 容器实例内部所维护的元素拷贝至当前 stack 容器实例内部

```cpp
#include <iostream>
#include <stack>

void main() {
  /* stack<T>() */
  std::stack<int> st;

  /* stack(const stack &_st) */
  std::stack<int> st_cpy(st);
}
```

**_ASSIGNMENT_**

- `stack &operator=(const stack &_st)`
  
  拷贝赋值运算符，依据已有 stack 的实例内部所维护的元素去重新构造当前 stack 实例

```cpp
#include <iostream>
#include <stack>

void main() {
  std::stack<int> st_src;
  std::stack<int> st_cpy;

  st_src = st_cpy;
}
```

**_OPERATION_**

- `void push(T _element)`
  
  向栈顶添加元素 _element

- `void pop()`
  
  从栈顶移除第一个元素

- `T &top()`
  
  返回栈顶元素的引用

```cpp
#include <iostream>
#include <stack>

void main() {
  std::stack<int> st;

  /* void push(T _element) */
  st.push(0x100);
  st.push(0x200);
  st.push(0x300);

  /* T &top() */
  int _val = st.top();
  std::cout << _val << std::endl;

  /* void pop() */
  st.pop();
}
```

**_CAPACITY_**
- `bool empty()`
  
  判断 stack 容器内部是否为空

- `size_t size()`
  
  获取 stack 容器内部所维护的元素的个数

```cpp
#include <iostream>
#include <stack>

void main() {
  std::stack<int> st;

  /* bool empty() */
  bool flag = st.empty();

  /* size_t size() */
  size_t cout = st.size();
}
```


<br/>

<span id = "queue"></span>

#### queue

queue 是 STL 所提供的一种支持任意类型的存储的 **_序列式容器_**，该容器的内部设计非常简单，其遵循 队列 的 FIFO 的存储结构而进行设计，我们的对于该容器中元素的访问永远只能从 队头 开始而对于元素的插入操作永远只能从 队尾 进行，<font color = "red">**_并且 STL 并没有提供针对此容器的迭代器_**，换言之，queue 容器是不允许存在遍历的型为的</font>

为保证最大内存的可用性，该容器所使用的内存区域是以 自由存储区 作为基准，并且作为容器本身，它在 自由存储区 中所使用的内存也由 queue 自身来进行管理和释放

**_CONSTRUCTOR_**

- `queue<T>()`
  
  默认构造，构建一个空的 queue 容器

- `queue(const queue &_qe)`
  
  拷贝构造函数，将已有 queue 容器实例内部所维护的元素拷贝至当前 queue 容器实例内部

```cpp
#include <iostream>
#include <queue>

void main() {
  /* queue<T>() */
  std::queue<int> qe;

  /* queue(const queue &_qe) */
  std::queue<int> qe_cpy(qe);
}
```

**_ASSIGNMENT_**

- `queue &operator=(const queue &_qe)`
  
  拷贝赋值运算符，依据已有 queue 的实例内部所维护的元素去重新构造当前 queue 实例

```cpp
#include <iostream>
#include <queue>

void main() {
  std::queue<int> qe_src;
  std::queue<int> qe_cpy;  

  /* queue &operator=(const queue &_qe) */
  qe_src = qe_cpy;
}
```

**_OPERATION_**
- `void push(T _element)`
  
  向队尾添加元素 _element

- `void pop()`
  
  从队头移除第一个元素

- `T &back()`
  
  返回对尾的元素的引用

- `T &front()`
  
  返回队头的元素的引用

```cpp
#include <iostream>
#include <queue>

void main() {
  std::queue<int> qe;

  /* void push(T _element) */
  qe.push(0x100);
  qe.push(0x200);
  qe.push(0x300);

  /* T &back() */
  int val_back = qe.back();

  /* T &front() */
  int val_front = qe.front();
            
  /* void pop() */
  qe.pop();
}
```

**_CAPACTIY_**
- `bool empty()`
  
  判断 queue 容器内部是否为空

- `size_t size()`
  
  获取 queue 容器内部所维护的元素的个数

```cpp
#include <iostream>
#include <queue>

void main() {
  std::queue<int> qe;

  /* bool empty() */
  bool flag = qe.empty();

  /* size_t size() */
  size_t cout = qe.size();
}
```

<br/>

<span id = "list"></span>

#### list

list 是 STL 所提供的一种支持任意类型存储的 **_序列式容器_**，其内部所维护的是一张以 自由存储区 作为内存基础去进行节点的动态扩展的 **_双向循环链表_**，开发人员使用 list 时无需节点的内存管理和释放的工作，其都转交 list 容器本身来进行管控

作为一张链表，list 对比相同长度的数组其查询元素所消耗的空间复杂度要大得多，好处在于使用 list 去执行新增和删除操作时，其总是能够通过常数项时间来完成，因为对于 list 来说，其新增和删除元素仅仅只需要改变两端节点的指针指向即可完成，反观数组，对于元素的随机性删除或新增往往需要大量的 向后 / 向前 移动元素，这就造成了较大的性能损失，并且对于 list 来说，因为每一个节点都是一块新的内存空间，故其新增结点时所使用的内存总是那么针对性的，反观数组，list 在内存空间的利用率体现了绝对的优势

<font color = "red">**_list 所提供的迭代器并不是一种随机访问迭代器_**，这由于 链表 本身的特性所导致的，所提供的迭代器仅仅只能够完成单步自增 / 自减的操作</font>

除此之外，由于 链表 本身的特性还让使用 list 执行插入操作和删除操作时都不会造成原有 list 迭代器的失效，因为对于链表来说其新增和删除节点时总是针对那一块独立的内存空间，并不会因为当前操作而导致整个 链表 维护的所有节点所使用的内存空间需要一次全局的置换，即便会发生变化，也仅仅只是针对当前操作所指定的节点所在的迭代器而言

**_关于 list 迭代器失效的问题_**

1. 当 list 第一次插入元素时，在插入前所获取的 `start` 迭代器将失效

2. 当 list 插入首部元素 ( push_front ) 时，`start` 迭代器将失效

3. 当 list 随机删除元素时，`start` 迭代器将失效，删除点元素延伸出的 [iterator] [poiner] [reference] 都将失效


**_CONSTRUCTOR_**

- `list<T>()`
  
  默认构造，构建一个空的 list 容器

- `list<T>(V _begin, V _end)`
  
  该构造函数是一个存在虚拟类型为 V 的模板函数，V 的具现化于所接受的能够指示一段线性数组 $[ \: begin, \: end \: )$ 开闭区间的迭代器 ( 隶属于容器的 ) 亦或者地址所指示的类型，并使用它来完成当前 list 容器内部所维护的双向循环链表的初始化工作

- `list(int n, T _element)`
  
  该构造函数使用 n 个 _element 用于 list 容器内部双向循环链表的初始化构造工作

- `list(const list &_li)`
  
  拷贝构造函数，将已有 list 容器实例内部所维护的双向循环链表中的节点拷贝至当前 list 容器实例内部所维护的双向循环链表中

```cpp
#include <iostream>
#include <queue>

void main() {
  /* list<T>() */
  std::list<int> li_empty;

  /* list<T>(V _begin, V _end) */
  std::list<int> li_01(li_empty.begin(), li_empty.end());
  int nums[5] = { 1, 2, 3, 4, 5 };
  std::list<int> li_02(nums, nums + (sizeof(nums) / sizeof(int)));

  /* list<T>(int n, T _element) */
  std::list<int> li_03(10, 23);

  /* list(const list &_li) */
  std::list<int> li_04(li_02);
}
```

**_ASSIGNMENT_**
- `void assign(V _begin, V _end)`
  
  该构造函数是一个存在虚拟类型为 V 的模板函数，V 的具现化于所接受的能够指示一段线性数组 $[ \: begin, \: end \: )$ 开闭区间的迭代器 ( 隶属于容器的 ) 亦或者地址所指示的类型，并使用它来完成当前 list 容器实例内部所维护的双向循环链表的重新赋值的工作
  
- `assign(int n, _element)`
  
  该函数使用 n 个 _element 用于 list 容器内部所维护的双向循环链表的重新赋值的工作
  
- `list &operator=(const list &_li)`
  
  拷贝赋值运算符，依据已有 list 的实例内部所维护的双向循环链表中的节点去重新构造当前 list 容器实例本身内部所维护的双向循环链表
  
- `void swap(list &_li)`
  
  交换目标 list 容器与当前 list 容器内部指向着存在于堆中的双向循环链表的指针，并重新更新双方容器内部所维护的双向循环链表的 size

```cpp
#include <iostream>
#include <queue>

void main() {
  int nums_src[5] = { 1, 2, 3, 4, 5 };
  std::list<int> li_src;

  /* void assign(V _begin, V _end) */
  li_src.assign(nums_src, nums_src + (sizeof(nums_src) / sizeof(int)));

  /* void assign(int n, _element) */
  li_src.assign(10, 1024);

  std::list<int> li_des;

  /* list &operator=(const list &_li) */
  li_des = li_src;

  /* void swap(list &_li) */
  li_des.swap(li_src);
}
```

**_CAPACITY_**

- `size_t size()`
  
  返回 list 容器内部双向循环链表的节点个数

- `bool empty()`
  
  判断是否是一个空容器（无任何节点的链接）

- `void resize(int n)`
  
  重新指定 list 容器内部所维护的双向循环链表的节点链接长度为 n，如果 n 较调用前的长度大，则以默认值填充超出的位置，如果 n 较调用前的长度小，则删除超出链表长度 n 的节点

- `void resize(int n, T _element)`
  
  重新指定 list 容器内部所维护的双向循环链表的节点链接长度为 n，如果 n 较调用前的长度大，则拷贝所指定的 _element 去填充超出的位置，如果 n 较调用的长度小，则删除超出链表长度 n 的节点

```cpp
#include <iostream>
#include <queue>

void main() {
  int nums[5] = { 1, 2, 3, 4, 5 };
  std::list<int> _li(nums, nums + (sizeof(nums) / sizeof(int)));

  /* size_t size() */
  size_t _li_size = _li.size();

  /* bool empty() */
  bool is_empty = _li.empty();

  /* void resize(int n) */
  _li.resize(10);

  /* void resize(int n, T _element) */
  _li.resize(7, 0x400);
}
```

**_INSERT_**
- `void push_back(T _element)`
  
  从 list 容器内部的双向循环链表的尾处新增数据域为 _element 的节点

- `void push_front(T _element)`
  
  从 list 容器内部的双向循环链表的首处新增数据域为 _element 的节点

- `void insert(const_iterator pos,T _element)`
  
  根据迭代器 pos 所指向的节点的下标往 list 容器内部所维护的双向循环链表中插入一个数据域为 _elemenet 的节点，如果迭代器 pos 所指向的元素下标超出了双向循环链表的长度，则程序崩溃

```cpp
#include <iostream>
#include <queue>

void main() {
  int nums[5] = { 1, 2, 3, 4, 5 };
  std::list<int> _li(nums, nums + (sizeof(nums) / sizeof(int)));

  /* void insert(const_iterator pos,T _element) */
  _li.insert(++_li.begin(), 0x400);

  /* void push_back(T _element) */
  _li.push_back(0x200);

  /* void push_front(T _element) */
  _li.push_front(0x100);
}
```

**_DELETE_**

- `void pop_back()`
  
  删除 list 容器内部的双向循环链表中的尾节点

- `void pop_front()`
  
  删除 list 容器内部的双向循环链表中的首节点

- `void clear()`
  
  删除 list 容器内部的双向循环链表中的所有的节点

- `iterator erase(list<T>::const_iterator start, list<T>::const_iterator end)`
  
  list 容器内部所维护的双向循环链表中删除迭代器 start 和 迭代器 end 所指向的下标之间的所有的节点，并返回下一个可用元素位置的迭代器

- `iterator erase(list<T>::const_iterator pos)`
  
  list 容器内部所维护的双向循环链表中删除迭代器 pos 所指向的节点，并返回距离删除点下一个可用元素位置的迭代器

```cpp
#include <iostream>
#include <queue>

void main() {
  int nums[5] = { 1, 2, 3, 4, 5 };
  std::list<int> _li(nums, nums + (sizeof(nums) / sizeof(int)));

  /* void pop_back() */
  _li.pop_back();

  /* void pop_front() */
  _li.pop_front();

  /* void erase(const_iterator start, const_iterator end) */
  _li.erase(_li.begin(), ++_li.begin());

  /* void erase(const_iterator pos) */
  _li.erase(++_li.begin());

  /* void clear() */
  _li.clear();
}
```

**_FUNCTIONAL_**
- `T &front()`
  
  返回 list 容器内部所维护的双向链表的首节点数据域的引用

- `T &back()`
  
  返回 list 容器内部所维护的双向链表的尾节点数据域的引用


```cpp
#include <iostream>
#include <queue>

bool sort(int &num_01, int &num_02) {
  return num_01 < num_02;
}

void main() {
  int nums[5] = { 1, 2, 3, 4, 5 };
  std::list<int> _li(nums, nums + (sizeof(nums) / sizeof(int)));
  int &num_03 = _li.front();
  int &num_04 = _li.back();

  /* sort(T fu) */
  _li.sort(sort);

  /* reverse() */
  _li.reverse();
}
```

<br/>

<span id = "pair"></span>

#### pair

pair 又称为对组，它可以将一对可具有不同类型的值，组合为一个值，并将它们分别映射到 pair 的公共属性 frist 和 second 的访问上

pair 所使用的内存是以 自由存储区 作为基准，并由 pair 本身来负责管理在堆中所使用的内存和其释放，开发人员无需关心会产生内存泄漏亦或者超出的问题

**_USEAGE_**

```cpp
/** 
 * constructor
 *   pair<T,V>(T _t, V _v)                指定 pair 所需维护的两个具体的值来进行 pair 实例的初始化构造
 *   pair<T,V>(const pair<T,V> &p)      拷贝构造函数，依据已有的 pair 实例内部所维护的两个可存在不同类型的值去构造当前 pair 的实例
 * 
 * function
 *   pair<T,V> make_pair<T,V>(T _t, V_v)  该函数用于接受两个可存在不同类型的值，并返回相应类型的 pair
 * 
 * member
 *   first                                获取 pair 所维护的第一个值
 *   second                               获取 pair 所维护的第二个值                                     
*/
void foo(void) {
  /* pair<T,V>(T _t, V _v) */
  pair<string, int> p_1("HELLO,WORLD", 0x400);     

  /* pair<T,V> make_pair<T,V>(T _t, V_v) */
  pair<char, string> p_2 = make_pair('A', "NGPONG!");   

  /* pair<T,V>(const pair<T,V> &p) */
  pair<string, int> p_3 = p_1;     

  /* first  */
  cout << p_1.first << endl;    

  /* second */
  cout << p_1.second << endl;
}
```


<br/>

<span id = "set/multiset"></span>

#### set / multiset / unorder_set

set 是 STL 所提供的一种支持任意类型存储的 **_关联式容器_**，其内部采用 **_红黑树_** 作为实现，其拥有一个十分重要的特性即是，<font color = "red">set 内部维护的树所新增的节点，由于二叉树排序树的特性，它都会依据该节点的 键值 进行自动的排序(**_默认是正序排序，也可手动指定排序规则_**)</font>；这里需要扩充一下的是，set 中的节点内部所存有的数据既可作为 键 也可以作为 值，二者放在 set 中的节点元素而言并不是分开的一种概念；并且<font color = "red"> set 不允许元素内部出现重复的键值，对于用户重复插入的键值，set 会保证此次的插入操作是一个无效操作，简而言之就是插入失败</font>

set 内部所维护的这颗 红黑树 和其它容器一样，都是存储在 自由存储区 中的，并且由容器本身去负责管理这棵树在堆中所使用内存的申请和释放

set 由于使用的是 红黑树 作为存储模型，故使用 set 去针对节点进行插入、删除、查找时所消耗的时间复杂度都接近 $O(logN)$，其中，$N$ 与树的高度相关

set 并不提供针对节点的键值进行修改的操作，具体体现则为其对外仅提供了 只读性质的迭代器，需要 补充的是，set 所提供的并不是一种提供随机访问性的迭代器，其只能够完成单步自增/减的操作，那么我们不妨在总结一下，<font color = "red">set 所提供的迭代器是一种只读单步自增/减的迭代器</font>

set 对于节点进行插入或者删除操作时，所操作的元素永远都是存在针对性的，即这些新增和删除的操作并不会引起整棵树的内存置换

相对 set 而言还有另一种容器跟它相呼应，那就是 `multiset` 和 `unorder_set`

- <font color = "red">作为 multiset 而言，它和 set 所存在的唯一的区别就是 multiset 允许节点的键值重复</font>，其余相较于 set 不管是功能性而言还是内置结构都是一模一样的

- <font color = "red">而 unorder_set 虽然也能够保有不允许元素重复的特性</font>，但是其内部实现对比 set / multiset 而言可谓是大相径庭，unorder_set 其内部实现采用了 <font color = "red">**_哈希表_**</font>，既然采用了 哈希表，那么它该数据结构所耗费的时间复杂度就要高出红黑树许多，并且还<font color = "red">无法满足元素自动排序的特性</font>，但是相对的，<font color = "red">对于元素的查找、删除和新增所消耗的时间复杂度都能够在常数阶(最好 $O(1)$，最坏需要处理哈希冲突，即 $O(N)$)去完成</font>

**_关于 set 迭代器失效的问题_**

1. 当 set 每个新节点的插入，在插入前所获取的 `start` 迭代器将失效
   
2. 当 set 随机删除元素时，删除点元素延伸出的 [iterator] [poiner] [reference] 都将失效

**_CONSTRUCTOR_**

- `set<T, F = less<T>>()`
  
  默认构造，构建一个空的 set 容器；虚拟类型 $F$ 的默认值为一个提供了 **正序排序** 的功能的二元仿函数 `less<K>`，如有需要，我们可以显示的指定它

- `set<T, F = less<T>>(V, V _end)`
  
  该构造函数是一个存在虚拟类型为 V 的模板函数，V 的具现化于所接受的能够指示一段线性数组 $[ \: begin, \: end \: )$ 开闭区间的迭代器 ( 隶属于容器的 ) 亦或者地址所指示的类型，并使用它来完成当前 set 容器内部所维护的红黑树的初始化工作；虚拟类型 $F$ 的默认值为一个提供了 **正序排序** 的功能的二元仿函数 `less<K>`，如有需要，我们可以显示的指定它
  
- `set(const set &s)`
  
  拷贝构造函数，将已有 set 容器实例内部所维护的红黑树的节点拷贝至当前 set 容器实例内部所维护的红黑树当中

```cpp
#include <iostream>
#include <set>

/* binary functor */
template<class _Ty>
struct DESC {
  constexpr bool operator()(const _Ty &left, const _Ty &right) {
    return left > right;
  }
};

int main(void) {
  /* set<T,F = less<T>>() */
  std::set<int> s_nor;

  /* set<T,F = less<T>>((V _begin, V _end) */
  int nums[5] = { 3, 1, 5, 2, 4 };
  std::set<int, DESC<int>> s(nums, nums + sizeof(nums) / sizeof(int));

  /* set(const set &s) */
  std::set<int, DESC<int>> s_des(s);
}
```

**_ASSIGNMENT_**

- `set &operator=(const set &s)`

  拷贝赋值运算符，依据已有 set 的实例内部所维护的红黑书的节点去重新构造当前 set 容器实例本身内部所维护的红黑树

- `void swap(set &s)`
  
  交换目标 set 容器与当前 set 容器内部指向着存在于堆中的红黑树的指针，并重新更新双方容器内部所维护的红黑树的 size

```cpp
#include <iostream>
#include <set>

int main(void) {
  int nums_01[5] = { 3, 1, 5, 2, 4 };
  std::set<int> s_01(nums_01, nums_01 + sizeof(nums_01) / sizeof(int));

  int nums_02[5] = { 9, 6, 10, 8, 7 };
  std::set<int> s_02(nums_02, nums_02 + sizeof(nums_02) / sizeof(int));

  /* void swap(set &s) */
  s_01.swap(s_02);

  /* set &operator=(const set &s) */
  s_01 = s_02;
}
```

**_CAPACITY_**
- `size_t size()`
  
  返回 set 容器内部所维护的红黑树的节点个数

- `bool empty()`
  
  判断是否是一个空容器（无任何节点的链接）

```cpp
#include <iostream>
#include <set>

int main(void) {
  int nums[5] = { 3, 1, 5, 2, 4 };
  std::set<int> s(nums, nums + sizeof(nums) / sizeof(int));

  /* size_t size() */
  int cout = s.size();

  /* bool empty() */
  bool flag = s.empty();
}
```

**_INSERT_**

- `pair<set<T>::iterator, bool> insert(T _key)`
  
  向 set 容器内部所维护的红黑树中新增一个节点，并赋予该节点的键值为 _key，最后返回能够标识当前所插入的节点在整个数中的位置的迭代器和是否插入成功所结合而成的 pair

```cpp
#include <iostream>
#include <set>

int main(void) {
  int nums[5] = { 3, 1, 5, 2, 4 };
  std::set<int> s(nums, nums + sizeof(nums) / sizeof(int));

  /* pair<set<T>::iterator, bool> insert(T _key) */
  std::pair<set<int>::iterator, bool> result = s.insert(0x400);
}
```

**_DELETE_**

- `void clear()`
  
  删除 set 容器内部所维护的红黑树的所有的节点

- `set<T>::const_iterator erase(set<T>::const_iterator start, set<T>::const_iterator end)`
  
  set 容器内部所维护的红黑树中删除迭代器 start 和 迭代器 end 所指向的下标之间的所有的节点，并返回下一个可用元素位置的迭代器

- `set<T>::const_iterator erase(set<T>::const_iterator pos)`
  
  set 容器内部所维护的双向循环链表中删除迭代器 pos 所指向的节点，并返回距离删除点下一个可用元素位置的迭代器

- `size_type erase(T _key)`
  
  set 容器内部所维护的红黑树中删除对应键值 _key 的节点，并返回删除元素的个数


```cpp
#include <iostream>
#include <set>

int main(void) {
  int nums[5] = { 3, 1, 5, 2, 4 };
  std::set<int> s(nums, nums + sizeof(nums) / sizeof(int));

  /* void erase(set<T>::const_iterator pos) */
  s.erase(s.begin(), ++s.begin());

  /* void erase(set<T>::const_iterator start, set<T>::const_iterator end) */
  s.erase(s.begin());

  /* void erase(T _key) */
  s.erase(5);

  /* void clear() */
  s.clear();
}
```

**_FIND_**
- `set<T>::const_iterator find(T _key)`
  
  在 set 内部所维护的红黑树中查找相符合键值 _key 的结点并返回第一次找到该结点所在下标的迭代器，若不存在匹配键值 _key 的节点，则返回指向最后一个元素的后一个位置的迭代器，即 `set<int>.end()` 的调用结果

- `size_t count(T _key)`
  
  在 set 内部所维护的红黑树中查找相符合键值 _key 的结点的个数

- `set<T>::const_iterator lower_bound(T _key)`
  
  在 set 内部所维护的红黑树中查找相符合 `目标节点键值 >= _key` 的结点并返回该结点所在下标的迭代器，若不存在，则返回指向最后一个元素的后一个位置的迭代器，即 `set<int>.end()` 的调用结果

- `set<T>::const_iterator upper_bound(T _key)`
  
  在 set 内部所维护的红黑树中查找相符合 `目标节点键值 > _key` 的结点并返回该结点所在下标的迭代器，若不存在，则返回指向最后一个元素的后一个位置的迭代器，即 `set<int>.end()` 的调用结果

- `pair<set<int>::const_iterator, set<int>::const_iterator> equal_range(T _key)`
  
  依据指定的键值 _key 返回 lower_bound 和 upper_bound 调用所获取到的 迭代器 的组合值 pair，其中 first 为 lower_bound 调用结果所获取到的迭代器，second 为 upper_bound 调用结果所获取到的迭代器

```cpp
#include <iostream>
#include <set>

int main(void) {
  int nums[5] = { 3, 1, 5, 2, 4 };
  std::set<int> s(nums, nums + sizeof(nums) / sizeof(int));
                
  /* set<T>::const_iterator find(T _key) */
  std::set<int>::const_iterator it_find = s.find(2);
                
  /* size_t count(T _key) */
  size_t count = s.count(3);
                
  /* set<T>::const_iterator lower_bound(T _key) */
  std::set<int>::const_iterator it_lower = s.lower_bound(3);
                
  /* set<T>::const_iterator upper_bound(T _key) */
  std::set<int>::const_iterator it_uppler = s.upper_bound(3);
                
  /* pair<set<int>::const_iterator, set<int>::const_iterator> equal_range(T _key) */
  std::pair<set<int>::const_iterator, set<int>::const_iterator> _res = s.equal_range(3);
}
```

<br/>

<span id = "map"></span>

#### map / multimap / unorder_map

map 是 STL 所提供的一种支持任意类型存储的 **_关联式容器_**，和 set 一样，其内置的数据模型也是根据 **_红黑树_** 来进行实现的；虽然 map 和 set 的内置的数据模型的实现使用的都是红黑树，但是存在较大不同的是，对于<font color = "red"> map 来说是能够细分出来当前节点的 **键** 和 **值**，具体来说，每一个节点其实都是一个 $\:\:pair<const \: K, \:\: V>\:$ 类型，以 K 作为该节点的键$(First)$，以 V 作为该节点的实值$(Second)$，而红黑树的搜索依据就是根据 键$(K)$ 来完成</font>，并且我们每次为 map 内部所维护的树<font color = "red">新增的节点，都会遵循二叉排序树的特性，根据该节点的 键$(K)$ 进行自动的排序(**_默认是正序排序，也可认为的指定排序的规则_**)</font>

<font color = "red">map 为了保证内部所维护的红黑树的完好，每个节点 $\:\:pair<const \: K, \:\: V>\:$ 中作为 键 而存在的模板虚拟类型 $k$ 都使用了 `const` 修饰符进行修饰，以保证我们无法修改每个节点中的键</font>，但是对于值而言，我们是可以进行任意修改的，因为它并不作为这颗二叉树的排序依据而存在

<font color = "red">map 中每个节点是不允许出现重复的键的，对于用户重复插入相同的键，map 会保证此次的插入操作是一个无效操作(对于数组式的插入操作，如果树中已存在相同的键，则会更新当前键所对应的值)，简而言之就是插入失败</font>

map 内部所维护的这颗 红黑树 和其它容器一样，都是存储在 自由存储区 中的，并且由容器本身去负责管理这棵树在堆中所使用内存的申请和释放

和 set 存在区别的是，<font color ="red">map 所提供迭代器并不是一种存粹的只读访问迭代器，map 对于其 键 的只读体现仅在于每个节点的 键$(K)$ 类型使用了 `const` 关键字进行了修饰(pair<const K, V>)，并且它也不是一种提供随机访问性的迭代器，其只能够完成单步自增/自减的操作</font>

当对 map 中的节点进行插入或者删除操作时，所操作的元素永远都是存在针对性的，即这些新增和删除的操作并不会引起整棵树的内存置换

相对 map 而言还有另一种容器跟它相呼应，那就是 `multimap` 和 `unorder_map`

- <font color = "red">作为 multimap 而言，它和 map 所存在的唯一的区别就是 multimap 允许节点的键重复</font>，其余相较于 map 不管是功能性而言还是内置结构都是一模一样的

- <font color = "red">而 unorder_map 虽然也能够保有不允许元素重复的特性</font>，但是其内部实现对比 map / multimap 而言可谓是大相径庭，unorder_map 其内部实现采用了 <font color = "red">**_哈希表_**</font>，既然采用了 哈希表，那么它该数据结构所耗费的时间复杂度就要高出红黑树许多，并且还<font color = "red">无法满足元素自动排序的特性</font>，但是相对的，<font color = "red">对于元素的查找、删除和新增所消耗的时间复杂度都能够在常数阶(理想情况下为 $O(1)$，最坏情况需要考虑哈希碰撞的处理，即 $O(N)$)去完成</font>


- `map<K, V, F = less<K>>()`
  
  默认构造，构建一个空的 map 容器；虚拟类型 $F$ 的默认值为一个提供了 **正序排序** 的功能的二元仿函数 `less<K>`，如有需要，我们可以显示的指定它

- `map(const set &m)`
  
  拷贝构造函数，将已有 map 容器实例内部所维护的红黑树的节点拷贝至当前 map 容器实例内部所维护的红黑树当中

```cpp
#include <iostream>
#include <map>

template<class _Ty>
struct DESC {
  constexpr bool operator()(const _Ty &left, const _Ty &right) {
    return left > right;
  }
};

int main(void) {
  /* map<K, V, F = less<K>>() */
  std::map<std::string, int, DESC<string>> m_nor;
      
  /* set(const set &s) */
  std::map<std::string, int, DESC<string>> m_des(m_nor);
}
```
  
**_ASSIGNMENT_**

- `map &operator=(const map &m)`

  拷贝赋值运算符，依据已有 map 的实例内部所维护的红黑书的节点去重新构造当前 map 容器实例本身内部所维护的红黑树

- `void swap(map &m)`
  
  交换目标 map 容器与当前 map 容器内部指向着存在于堆中的红黑树的指针，并重新更新双方容器内部所维护的红黑树的 size

```cpp
#include <iostream>
#include <map>

template<class _Ty>
struct DESC {
  constexpr bool operator()(const _Ty &left, const _Ty &right) {
    return left > right;
  }
};

int main(void) {
  std::map<string, int> m_src;
  m_src["C"] = 3;
  m_src.insert(std::make_pair("A", 1));
  m_src.insert(std::map<std::string, int>::value_type("B", 2));

  std::map<string, int> m_des;

  /* void swap(set &s) */
  m_src.swap(m_des);

  /* set &operator=(const set &s) */
  m_src = m_des;
}
```

**_CAPACITY_**

- `size_t size()`
  
  返回 map 容器内部所维护的红黑树的节点个数

- `bool empty()`

  判断是否是一个空容器(无任何节点的链接)

```cpp
#include <iostream>
#include <map>

int main(void) {
  std::map<string, int> m;
                
  /* size_t size() */
  int cout = m.size();
                
  /* bool empty() */
  bool flag = m.empty();
}
```

**_INSERT_**

- `pair<map<K,V>::iterator, bool> insert(pair<const K,V> p)`

  向 map 容器内部所维护的红黑树中新增一个节点，并赋予该节点的键为对组 p 的第一元素，该节点的值为对组 p 的第二元素，最后返回能够标识当前所插入的节点在整个数中的位置的迭代器和是否插入成功所结合而成的对组

- `V &operator[](const K &_key)`
  
  向 map 容器内部所维护的红黑树中依据所指定的 键 _key 搜索是否存在该节点，如不存在，则依据 map 所指定的 值 的类型并调用其默认构造去创建一个默认的 值 并与键 _key 进行绑定，然后往树种新增一个节点，最后返回该 值 的引用

```cpp
#include <iostream>
#include <map>

int main(void) {
  using namespace std;

  map<string, int> m;

  /* pair<map<K,V>::iterator, bool> insert(pair<const K,V> p) */
  pair<map<string, int>::iterator, bool> result_01 = m.insert(pair<string, int>("C", 3));
  pair<map<string, int>::iterator, bool> result_02 = m.insert(make_pair("A", 1));
  pair<map<string, int>::iterator, bool> result_03 = m.insert(map<string, int>::value_type("D", 4));

  /* V &operator[](const K &_key) */
  m["B"] = 2;
}
```

**_DELETE_**

- `void clear()`

  删除 map 容器内部所维护的红黑树的所有的节点

- `map<K,V>::iterator erase(map<K,V>::iterator start, map<K,V>::iterator end)`

  map 容器内部所维护的红黑树中删除迭代器 start 和 迭代器 end 所指向的下标之间的所有的节点，并返回下一个可用元素位置的迭代器

- `map<K,V>::iterator erase(map<K,V>::iterator pos)`

  map 容器内部所维护的红黑树中删除迭代器 pos 所指向的节点，并返回距离删除点下一个可用元素位置的迭代器

- `size_type erase(T _key)`
  
  set 容器内部所维护的红黑树中删除对应键值 _key 的节点，并返回删除元素的个数

```cpp
#include <iostream>
#include <map>

int main(void) {
  std::map<string, int> m;
  m["C"] = 3;
  m["A"] = 1;
  m["D"] = 4;
  m["B"] = 2;

  /* map<K,V>::iterator erase(map<K,V>::iterator pos) */
  m.erase(m.begin(), ++(++m.begin()));

  /* map<K,V>::iterator erase(map<K,V>::iterator start, map<K,V>::iterator end) */
  m.erase(m.begin());

  /* void erase(K _key) */
  m.erase("C");

  /* void clear() */
  m.clear();
}
```

**_FIND_**

- `map<K,V>::iterator find(K _key)`

  在 map 内部所维护的红黑树中查找相符合键值 _key 的结点并返回第一次找到该结点所在下标的迭代器，若不存在匹配键值 _key 的节点，则返回指向最后一个元素的后一个位置的迭代器，即 map<K,V>.end() 的调用结果

- `size_t count(K _key)`

  在 map 内部所维护的红黑树中查找相符合键值 _key 的结点的个数

- `map<K,V>::iterator lower_bound(K _key)`

  在 map 内部所维护的红黑树中查找相符合 `目标节点键 >= _key` 的结点并返回该结点所在下标的迭代器，若不存在，则返回指向最后一个元素的后一个位置的迭代器，即 `map<K,V>.end()` 的调用结果

- `map<K,V>::iterator upper_bound(K _key)`

  在 map 内部所维护的红黑树中查找相符合 `目标节点键 > _key` 的结点并返回该结点所在下标的迭代器，若不存在，则返回指向最后一个元素的后一个位置的迭代器，即 `map<K,V>.end()` 的调用结果

- `pair<map<K,V>::iterator, map<K,V>::iterator> equal_range(K _key)`

  依据指定的键值 _key 返回 lower_bound 和 upper_bound 调用所获取到的迭代器对组 pair，其中 first 为 lower_bound 调用结果所获取到的迭代器，second 为 upper_bound 调用结果所获取到的迭代器

```cpp
#include <iostream>
#include <string>
#include <map>

int main(void) {
  using namespace std;

  map<string, int> m;
  m["C"] = 3;
  m["A"] = 1;
  m["D"] = 4;
  m["B"] = 2;
                
  /* map<K,V>::iterator find(K _key) */
  map<string, int>::iterator it_find = m.find("B");
                
  /* size_t count(K _key) */
  size_t count = m.count("A");
                
  /* map<K,V>::iterator lower_bound(K _key) */
  map<string, int>::iterator it_lower = m.lower_bound("C");
                
  /* map<K,V>::iterator upper_bound(T _key) */
  map<string, int>::iterator it_uppler = m.upper_bound("C");
                
  /* pair<map<K,V>::iterator, map<K,V>::iterator> equal_range(K _key) */
  pair<map<string, int>::iterator, map<string, int>::iterator> _res = m.equal_range("C");
}
```

<br/>

<span id = "仿函数"></span>

### 仿函数

---

> <font color = "red">重载了函数调用操作符的类，其使用方式类似于一个函数调用，针对拥有此特性的类，我们通常也称它们为 : **函数对象**、**仿函数**</font>；仿函数的定义通常有一条并不成文的规定，我们在定义仿函数的时候通常是不需要去定义该类的构造和析构
> 
> <font color = "red">函数调用操作符所重载的函数其形参列表中的形参个数能够划分仿函数的**元级**</font>，即该仿函数是一个几元仿函数；对于大多数情况而言，我们更多使用的是 **一元仿函数$(unary \:\: functor)$** 和 **二元仿函数$(binary \:\: functor)$**
> 
> 如果仿函数的返回值为 bool 类型，那么我们也可以称这个仿函数为 : **谓词**，并且根据仿函数的具体元数来划分这个谓词的元数
> 
> 仿函数更多的和 STL 绑定起来使用，在 STL 中，通过仿函数可以非常方便的去为某一种**容器**亦或者**算法**去提供我们所自定义的操作逻辑
> 
> 由于仿函数的真正核心是属于一个类中的成员函数，故对于仿函数的使用其实都能够享有 **内联函数** 所带来的好处的，对比一般的函数调用而言可能在某些情况下仿函数会更显示出性能优势；除此之外，使用仿函数能够把一个函数的调用也进行抽象化，即增强了代码的通用性，并且也是因为 类 的本身，如有需要的话，仿函数是可以拥有属于自己的状态的
> 
> ```cpp
> #include <iostream>
> 
> class adder {
> public:
>   int operator()(int x, int y) {
>     return x + y;
>   }
> };
> 
> struct comparer {
>   bool operator()(int x, int y) {
>     return x < y;
>   }
> };
> 
> template<class A, class C>
> void foo(int x, int y) {
>   std::cout << C()(A()(x, y), 1024) << std::endl;
> }
> 
> int main(void) {
>   foo<adder, comparer>(10, 10000);
> 
>   return EXIT_SUCCESS;
> }
> ```

STL 为了保证统一性，其内建了一些仿函数，它们大致划分为 : 算数类函数对象、关系运算类函数对象、逻辑运算类函数对象，这些由 STL 内建的仿函数都划分在 `functional` 这个头文件当中

- 算数类函数对象

  - 加法仿函数 : `template<class T> T plus<T>`

  - 减法仿函数 : `template<class T> T minus<T>`

  - 乘法仿函数 : `template<class T> T multiplies<T>`

  - 除法仿函数 : `template<class T> T divides<T>`

  - 取模仿函数 : `template<class T> T modulus<T>`
  
  - 取反仿函数 : `template<class T> T negate<T>`

- 关系运算类函数对象

  - 等于 : `template<class T> bool equal_to<T>`
  
  - 不等于 : `template<class T> bool not_equal_to<T>`
  
  - 大于 : `template<class T> bool greater<T>`
  
  - 大于等于 : `template<class T> bool greater_equal<T>`
  
  - 小于 : `template<class T> bool less<T>`
  
  - 小于等于 : `template<class T> bool less_equal<T>`

- 逻辑运算类运算函数

  - 逻辑与 : `template<class T> bool logical_and<T>`
  
  - 逻辑或 : `template<class T> bool logical_or<T>`
  
  - 逻辑非 : `template<class T> bool logical_not<T>`

```cpp
#include <set>
#include <vector>
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

template<class T>
class set_printer {
public:
  void operator()(const T &_val) {
    cout << _val << endl;
  }
};

void foo(void) {
  set<int, greater<int>> s;
  s.insert(4);
  s.insert(2);
  s.insert(5);
  s.insert(1);
  s.insert(3);
              
  vector<int> v;
  v.push_back(3);
  v.push_back(5);
  v.push_back(1);
  v.push_back(4);
  v.push_back(2);
  sort(v.begin(), v.end(), less<int>());
              
  for_each(s.begin(), s.end(), set_printer<int>());
  for_each(v.begin(), v.end(), set_printer<int>());
}
```

<br/>

<span id = "适配器"></span>

### 适配器

---


<span id = "仿函数适配器"></span>

#### 仿函数适配器

在某些 API 需要指定一个一元仿函数但是现有只有二元仿函数时，亦或者反之，这时候可以使用函数适配器针对仿函数进行适配工作

`binder2nd bind2nd(const _Function &f_binary, const _Type &val)`

- PARAMETER

  - f_binary ： 需要是一个继承自 `binary_function<T1 arg_01, T2 arg_02, R ret>` 二元仿函数(重载的函数调用操作符的函数需要声明为 **常函数**，因为最终会通过一个常函数来调用仿函数)

  - val : 需要和 f_binary 进行绑定的值

- RETURN

  - binder2nd : 一个一元仿函数，所实现的重载函数调用操作符的函数的返回值同步至所指定的仿函数 f_binary，形参列表接收所指定的二元仿函数 f_binary 的第一个形参的类型的形参 val_src 的输入，并在其内部实现中又调用了我们所录入的仿函数 f_binary，并在调用 f_binary 时会输入两个参数，它们分别是 val_src 和 bind2nd 构造时所录入的实参 val


```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class print_m : public binary_function<int, int, void> {
public:
  void operator()(int _val_01, int _val_02) const {
    cout << _val_01 + _val_02 << endl;
  }
};

void foo(void) {
  int nums[5] = { 1, 2, 3, 4, 5 };
  vector<int> v(nums, nums + (sizeof(nums) / sizeof(int)));

  for_each(v.begin(), v.end(), bind2nd(print_m(), 1000));
}

int main(void) {
  foo();

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "取反适配器"></span>

#### 取反适配器

当我们针对某种返回 bool 类型的仿函数的真实取值结果并不满意时，我们可以通过取反适配器的适配结果，在不更改原仿函数的源代码的前提下完成对其取值结果的取反工作

`unary_negate not1(const _Function &f_unary)`

- PARAMETER

  - f_unary：需要一个继承自 `unary_function<T1 arg, R ret>` 返回值为 bool 类型的一元仿函数

- RETURN

  - unary_negate : 一个一元仿函数，重载的函数调用操作符的函数的返回值和形参列表同步至所指定的仿函数 f_unary，其内部实现中会调用所录入的一元仿函数 f_unary 的取反结果并返回

`binary_negate not2(const _Function &f_unary)`

- PARAMETER

  - f_unary：需要一个继承自 `binary_function<T1 arg_01, T2 arg_02, R ret>` 返回值为 bool 类型的二元仿函数

- RETURN

  - binary_negate : 一个二元仿函数，重载的函数调用操作符的函数的返回值和形参列表同步至所指定的仿函数 f_binary，其内部实现中会调用所录入的二元仿函数 f_binary 的取反结果并返回

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void foo(void) {
  int nums[5] = { 3, 2, 4, 1, 5 };
  vector<int> v(nums, nums + (sizeof(nums) / sizeof(int)));

  sort(v.begin(), v.end(), not2(less<int>()));

  auto result = find_if(v.begin(), v.end(), not1(bind2nd(greater<int>() , 2)));
  cout << *result << endl;
}

int main(void) {
  foo();

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "函数适配器"></span>

#### 函数适配器

将一个普通的函数转换为声明为 const 的仿函数

`pointer_to_unary_function ptr_fun(unary_function invoker)`

- PARAMETER

  - invoker : 接收一个返回值为任意类型，但是只有一个任意类型形参的函数指针

- RETURN

  - pointer_to_unary_function : 一个 一元仿函数，重载函数调用操作符的函数是一个形参列表和返回值类型同步至函数指针并且声明为 cost 的常函数，其内部实现中会调用函数指针 invoker

`pointer_to_binary_function ptr_fun(binary_function invoker)`

- PARAMETER

  - invoker : 接收一个返回值为任意类型，但是有两个任意类型形参的函数指针

- RETURN

  - pointer_to_binary_function : 一个 二元仿函数，重载函数调用操作符的函数是一个形参列表和返回值类型同步至函数指针并且声明为 cost 的常函数，其内部实现中会调用函数指针 invoker

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool f_sort(int &_left,int &_right) {
  return _left > _right;
}
void foo(void) {
  int nums[5] = { 3, 2, 4, 1, 5 };
  vector<int> v(nums, nums + (sizeof(nums) / sizeof(int)));

  sort(v.begin(), v.end(), ptr_fun(::f_sort));
}

int main(void) {
  foo()

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "成员函数适配器"></span>

#### 成员函数适配器

该适配器能够将一个成员函数适配为仿函数，其内部实现依赖于成员函数和函数指针之间的转换关系来完成，简而言之该函数的调用还是要依赖于成员函数所在类型实例的本身才能够完成调用

`mem_fun_ref_t mem_fun_ref(member_function_none invoker)`

- PARAMETER

  - invoker : 接受一个任意类型返回值但是无形参的属于某个类的成员函数

- RETURN

  - mem_fun_ref_t : 一个 一元仿函数，重载函数调用操作符的函数其返回值同步至成员函数 invoker，形参列表接收一个 成员函数 所在类的类型的形参 src，所指定的成员函数 invoker 依赖形参 src 的实例化完成其调用操作

`mem_fun1_ref_t mem_fun_ref(member_function_unary invoker)`

- PARAMETER

  - invoker : 接受一个任意类型返回值但是只有一个形参的属于某个类的成员函数

- RETURN

  - mem_fun1_ref_t : 一个 二元仿函数，重载函数调用操作符的函数其返回值同步至成员函数 invoker，形参列表接收 成员函数 所在类的类型的形参 src 和 成员函数 第一个形参的类型的形参 arg，所指定的成员函数 invoker 依赖形参 src 的实例化并在调用时录入形参 arg 完成其调用操作

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Person {
public:
  Person(int _age)
    : m_age(_age){};
public:
  void speak(string _words) {
    cout << _words << " age = " << this->m_age << endl;
  }
  void Do() {
    cout << "DO! AGE = " << this->m_age << endl;
  }
            
public:
  int m_age;
};

void foo(void) {
  vector<Person> v;
  v.push_back(Person(1));
  v.push_back(Person(2));
  v.push_back(Person(3));
  v.push_back(Person(4));
  v.push_back(Person(5));
            
  for_each(v.begin(), v.end(), bind2nd(mem_fun_ref(Person::speak), "HELLO,WORLD"));

  for_each(v.begin(), v.end(), mem_fun_ref(Person::Do));
}

int main(void) {
  foo()

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "算法"></span>

### 算法

---

> STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等；特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成

<br/>

<span id = "遍历算法"></span>

#### 遍历算法

- `_Function for_each(_InputIterator start, _InputIterator end, _Function _fn)`

  遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至所指定的 一元仿函数或者函数指针 当中，最后会返回所指定的 一元仿函数或者函数指针

  ```cpp
  void printer_for_each(const int &_val) {
    cout << _val << endl;
  }

  void foo_for_each(void) {
    vector<int> v;
    for (size_t i = 0; i < 10; ++i) {
      v.push_back(i + 1);
    }

    void (*invoker)(const int &) = for_each(v.begin(), v.end(), printer_for_each);
  }
  ```

- `void transform(_InputIterator start, _InputIterator end, _OutputIterator start_des, _UnaryOperation unary_op)`

  遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至所指定的 返回值和形参类型为容器元素类型的一元仿函数或者函数指针 unary_op 当中，并把此次遍历的结果输入至迭代器 start_des 所指向的目标容器中

  该函数的调用必须要保证目标迭代器 start_des 所指向的容器中是含有 **有效元素** 的，否则会调用失败

  ```cpp
  int f_transform(int &_val) {
    return _val + 1;
  }

  void foo_transform(void) {
    vector<int> v_src;
    for (size_t i = 0; i < 10; ++i) {
      v_src.push_back(i + 1);
    }

    vector<int> v_des;
    v_des.resize(v_src.size());
    transform(v_src.begin(), v_src.end(), v_des.begin(), f_transform);
  }
  ```

<br/>

<span id = "查找算法"></span>

#### 查找算法

- `iterator_pos find(iterator start, iterator end, T _val)`
  
  在容器指定范围(迭代器 start 和 end 划分的范围)内的元素中查找值为 _val 的元素并返回第一次找到该元素所在下标的迭代器，若不存在，则返回 `end` 迭代器

  ```cpp
  void foo_find(void) {
    vector<int> v;
    for (size_t i = 0; i < 10; ++i) {
      v.push_back(i);
    }

    vector<int>::iterator _pos = find(v.begin(), v.end(), 4);
    if (_pos != v.end()) cout << *_pos << endl;
  }
  ```

- `iterator_pos find_if(iterator start, iterator end, _Function _fn)`

  遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至返回值为bool类型的一元仿函数或者函数指针 _fn 当中，当 _fn 所返回的结果为 true 时，则该函数返回当前元素所在下标的迭代器，若不存在，则返回 `end` 迭代器

  ```cpp
  void foo_find_if(void) {
    vector<int> v;
    for (size_t i = 0; i < 10; ++i) {
      v.push_back(i);
    }

    vector<int>::iterator _result = find_if(v.begin(), v.end(), [](int &_val) { return _val > 3; });

    if (_result != v.end()) 
      cout << *_result << endl;
  }
  ```

- `iterator_pos adjacent_find(iterator start, iterator end)`
  
  遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，并寻找间隔相邻且值重复的元素，如果存在，则返回所重复元素的上一个元素所在下标的迭代器，若不存在，则返回 end 迭代器

  ```cpp
  void foo_adjacent_find(void) {
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(3);
    v.push_back(4);

    vector<int>::iterator _result = adjacent_find(v.begin(), v.end());
    if (_result != v.end()) cout << *_result << endl;
  }
  ```

- `bool binary_search(iterator start, iterator end, const T &_val)`

  使用 **二分查找法** 查找容器指定范围(迭代器 start 和 end 划分的范围)内的元素，并判断是否存在值为 _val 的元素，如果存在则返回 true，如果不存在则返回false

  由于该算法使用的是二分查找法，为了该算法的运行不会失效，我们需要保证指定的容器内部所存储的元素是一个 有序序列

  ```cpp
  void foo_binary_search(void) {
    vector<int> v;
    for (size_t i = 0; i < 10; ++i) {
      v.push_back(i);
    }

    bool _result = binary_search(v.begin(), v.end(), 3);
    cout << _result << endl;
  }
  ```

- `int binary_search(iterator start, iterator end, const T &_val)`

  遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，并统计值为 _val 的元素所出现的次数并返回

  ```cpp
  void foo_count(void) {
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(3);
    v.push_back(4);

    int _count = count(v.begin(), v.end(), 3);
  }
  ```

- `int count_if(iterator start, iterator end, _Function _fn)`
  
  遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入返回值为 bool 类型的一元仿函数或者函数指针 _fn 当中，并统计 _fn 返回值为 true 的次数，最后返回所统计的结果

  ```cpp
  void foo_count_if(void) {
    vector<int> v;
    for (size_t i = 0; i < 10; ++i) {
      v.push_back(i);
    }

    int _count = count_if(v.begin(), v.end(), [](int &_val) { 
      return _val > 5; 
    });
    cout << _count << endl;
  }
  ```

<br/>

<span id = "排序算法"></span>

#### 排序算法

- `void sort(iterator start, iterator end, _Function _fn)`

  对容器内指定范围(迭代器 start 和 end 划分的范围)内的元素，依照二元仿函数或函数指针 _fn 所指定的规则去进行排序

  ```cpp
  void foo_sort(void) {
    vector<int> v;
    v.push_back(4);
    v.push_back(1);
    v.push_back(5);
    v.push_back(2);
    v.push_back(3);

    sort(v.begin(), v.end(), [](int &_left, int &_right) { return _left > _right; });
  }
  ```

- `void random_shuffle(iterator start, iterator end)`
  
  随机置乱容器指定范围(迭代器 start 和 end 划分的范围)内的元素的原始次序
  
  ```cpp
  void foo_random_shuffle(void) {
    vector<int> v;
    for (size_t i = 0; i < 5; ++i) {
      v.push_back(i);
    }

    random_shuffle(v.begin(), v.end());

    for_each(v.begin(), v.end(), [](int &_val) { cout << _val << endl; });
  }
  ```

- `void reverse(iterator start, iterator end)`

  反转容器中指定范围(迭代器 start 和 end 划分的范围)内的元素的次序

  ```cpp
  void foo_reverse(void) {
    vector<int> v;
    for (size_t i = 0; i < 5; ++i) {
      v.push_back(i);
    }

    reverse(v.begin(), v.end());
  }
  ```

<br/>

<span id = "拷贝替换合并算法"></span>

#### 拷贝/替换/合并算法

- `void merge(iterator src_start_1, iterator src_end_1, iterator src_start_2, iterator src_end_2, iterator des_start)`

  合并指定范围内(两个容器的开始和起始迭代器 src_start_1、src_end_1、src_start_2、src_end_2)的两个容器的元素，并重新赋值给目标容器(迭代器 des_start 所指向的容器)当中

  尽量要保证原始合并的两个数据源是有序序列，否则合并后的结果将可能会出现相较之前的乱序
  
  目标容器在合并前要保证其内部元素中是含有 **有效元素** 的，否则会调用失败

  ```cpp
  void foo_merge(void) {
    vector<int> v_src_1;
    v_src_1.push_back(1);
    v_src_1.push_back(2);
    v_src_1.push_back(3);
    v_src_1.push_back(4);
    v_src_1.push_back(5);

    vector<int> v_src_2;
    v_src_2.push_back(6);
    v_src_2.push_back(7);

    vector<int> v_des;
    v_des.resize(v_src_1.size() + v_src_2.size());
    merge(v_src_1.begin(), v_src_1.end(), v_src_2.begin(), v_src_2.end(), v_des.begin());
  }
  ```

- `void copy(iterator src_start, iterator src_end, iterator des_start)`
  
  拷贝原始容器中指定范围(迭代器 start 和 end 划分的范围)内的元素并重新赋值给目标容器(迭代器 des_start 所指向的容器)当中
  
  目标容器在拷贝前要保证其内部元素中是含有 **有效元素** 的，否则会调用失败

  ```cpp
  void foo_copy(void) {
    vector<int> v_src;
    for (size_t i = 0; i < 5; ++i) {
      v_src.push_back(i);
    }
  
    vector<int> v_des;
    for (size_t i = 5; i < 10; ++i) {
      v_des.push_back(i);
    }
    copy(v_src.begin(), v_src.end(), v_des.begin());
  
    copy(v_des.begin(), v_des.end(), ostream_iterator<int>(cout, " "));
  }
  ```

- `void replace(iterator start, iterator end, const T &_old_val, const T &_new_val)`

  查找容器中指定范围(迭代器 start 和 end 划分的范围)内值为 _old_val 的元素，并修改其值为 _new_val

  ```cpp
  void foo_replace(void) {
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);

    replace(v.begin(), v.end(), 2, 0x400);
  }
  ```

- `void replace_if(iterator start, iterator end, function _fn, const T &_new_val)`

  遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入返回值为 bool，形参类型为容器中的元素的类型的一元仿函数或者函数指针 _fn 当中，当该 _fn 返回 true 时，则当前所操作的元素的值替换为 _new_val

  ```cpp
  bool m_replace(int &_old_val) {
    return _old_val > 2;
  }
  void foo_replace_if(void) {
    vector<int> v;
    for (size_t i = 0; i < 5; ++i) {
      v.push_back(i);
    }

    replace_if(v.begin(), v.end(), m_replace, 0x400);
  }
  ```

- `void swap(Container c_src, Container c_des)`
  
  交换两个容器(相同容器类型)的内部用于管控数据空间的指针所指向的地址

  ```cpp
  void foo_swap(void) {
    vector<int> v_1;
    for (size_t i = 0; i < 5; ++i) {
      v_1.push_back(i);
    }

    vector<int> v_2;
    for (size_t i = 5; i < 10; ++i) {
      v_2.push_back(i);
    }

    swap(v_1, v_2);
  }
  ```

<br/>

<span id = "算数生成算法"></span>

#### 算数生成算法


- `T accumulate(iterator start, iterator end, const T &_init_val)`
  
  以 _init_val 作为初始化数据，在此基础上累加容器指定范围(迭代器 start 和 end 划分的范围)内的元素的值，最后返回累加后的结果

  ```cpp
  void foo_accumulate(void) {
    vector<int> v;
    for (size_t i = 0; i < 5; ++i) {
      v.push_back(i);
    }

    int num = accumulate(v.begin(), v.end(), 100);
    cout << num << endl;
  }
  ```

- `void fill(iterator start, iterator end, const T &_val)`
  
  容器指定范围(迭代器 start 和 end 划分的范围)内的元素的值替换为 _val

  ```cpp
  void foo_fill(void) {
    vector<int> v;
    for (size_t i = 0; i < 5; ++i) {
      v.push_back(i);
    }

    fill(v.begin(), v.begin() + 2, 0x400);
  }
  ```

<br/>

<span id = "集合算法"></span>

#### 集合算法

- `iterator set_intersection(iterator src_start_1, iterator src_end_1, iterator src_start_2, iterator src_end_2, iterator des_start)`

  该算法提供查找 **并集** 的功能
  
  查找指定范围内(两个容器的开始和起始迭代器 src_start_1、src_end_1、src_start_2、src_end_2)的两个容器的元素中元素的值相同的元素，并把它重新赋值给目标容器(迭代器 des_start 所指向的容器)当中，最后会返回目标容器的 end 迭代器
  
  我尽量要保证原始的两个容器的数据源是有序序列，否则目标容器所获取到的结果将可能会出现乱序
  
  目标容器在赋值前要保证其内部元素中是含有 **有效元素** 的，否则会调用失败

  ```cpp
  void foo_set_intersection(void) {
    vector<int> v_src_1;
    vector<int> v_src_2;
    for (size_t i = 0; i < 10; ++i) {
      v_src_1.push_back(i);
      v_src_2.push_back(i + 5);
    }

    vector<int> v_des;
    v_des.resize(v_src_1.size(), v_src_2.size());

    vector<int>::iterator i_end = set_intersection(v_src_1.begin(), v_src_1.end(), v_src_2.begin(), v_src_2.end(), v_des.begin());
  }
  ```

- iterator set_union(iterator src_start_1, iterator src_end_1, iterator src_start_2, iterator src_end_2, iterator des_start)
  
  该算法提供查找 **交集** 的功能
  
  去除掉，指定范围内(两个容器的开始和起始迭代器 src_start_1、src_end_1、src_start_2、src_end_2) 的两个容器中，值重复的元素并进行合并，并把合并后的结果重新赋值给目标容器(迭代器 des_start 所指向的容器)当中，最后会返回目标容器的 结束迭代器(end())
  
  我尽量要保证原始的两个容器的数据源是有序序列，否则目标容器所获取到的结果将可能会出现乱序
  
  目标容器在合并前要保证其内部元素中是含有 有效元素 的，否则会调用失败

  ```cpp
  void foo_set_union(void) {
    vector<int> v_src_1;
    vector<int> v_src_2;
    for (int i = 0; i < 10; i++) {
      v_src_1.push_back(i);
      v_src_2.push_back(i + 5);
    }

    vector<int> v_des;
    v_des.resize(v_src_1.size() + v_src_2.size());

    vector<int>::iterator i_end = set_union(v_src_1.begin(), v_src_1.end(), v_src_2.begin(), v_src_2.end(), v_des.begin());
  }
  ```

- `iterator set_difference(iterator src_start_1, iterator src_end_1, iterator src_start_2, iterator src_end_2, iterator des_start)`
                
  
  该算法提供查找差集的功能
  
  查找容器指定范围(迭代器 src_start_1 和 src_end_1 划分的范围)内相较于容器指定范围(迭代器 src_start_2 和 src_end_2 划分的范围)内，值不同的元素，并把结果重新赋值给目标容器(迭代器 des_start 所指向的容器)当中，最后会返回目标容器的 end 迭代器
  
  我尽量要保证原始的两个容器的数据源是有序序列，否则目标容器所获取到的结果将可能会出现乱序
  
  目标容器在赋值前要保证其内部元素中是含有 **有效元素** 的，否则会调用失败

  ```cpp
  void foo_set_difference(void) {
    vector<int> v_src_1;
    vector<int> v_src_2;

    for (int i = 0; i < 10; i++) {
      v_src_1.push_back(i);
      v_src_2.push_back(i + 5);
    }

    vector<int> v_des;
    v_des.resize(max(v_src_1.size(), v_src_2.size()));

    vector<int>::iterator i_end = set_difference(v_src_1.begin(), v_src_1.end(), v_src_2.begin(), v_src_2.end(), v_des.begin());

    /* vector<int>::iterator i_end = set_difference(v_src_2.begin(), v_src_2.end(), v_src_1.begin(), v_src_1.end(), v_des.begin()); */
  }
  ```


<br/>

<span id = "迭代器"></span>

### 迭代器

---

> 迭代器 $(iterator)$ 提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式
> 
> 迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器 $(container)$ 和算法 $(algorithms)$ 分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起
> 
> 每一种容器的每一种不同的模板类型都由其对应着的迭代器
> 
> 
> |迭代器|权限|操作|
> |:---|---:|:---:|
> |输入迭代器|提供对数据的只读访问|++, ==, !=|
> |输出迭代器|提供对数据的只写访问|++|
> |前向迭代器|提供读写操作，并能向前推进迭代器|++, ==, !=|
> |双向迭代器|提供读写操作，并能向前和向后操作|++, --|
> |随机访问迭代器|提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器|++, --, [n], -n, <, <=, >, >=|

