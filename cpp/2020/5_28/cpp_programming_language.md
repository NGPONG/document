# *Cpp Programming language*


<br/>


## 目录

- [Namespace](#namespace)
  - [命名空间的定义](#命名空间的定义)
  - [匿名命名空间](#匿名命名空间)
  - [匿名命名空间中的 extern](#匿名命名空间中的-extern)
  - [作用域](#作用域)
    - [显式的引用某一处的作用域](#显式的引用某一处的作用域)
  - [命名空间下成员的声明和定义](#命名空间下成员的声明和定义)
- [表达式和值类别](#表达式和值类别)
  - [表达式](#表达式)
  - [值类别](#值类别)
    - [左值](#左值)
    - [右值](#右值)
    - [值类别小结](#值类别小结)
- [引用](#引用)
  - [引用变量的本质](#引用变量的本质)
  - [左值引用](#左值引用)
  - [右值引用](#右值引用)
  - [左右值引用的函数重载策略](#左右值引用的函数重载策略)
  - [数组引用](#数组引用)
  - [指针引用](#指针引用)
- [常量的增强](#常量的增强)
- [类型赋值](#类型赋值)
  - [匿名对象](#匿名对象)
  - [定义法](#定义法)
  - [隐式法](#隐式法)
  - [括号法](#括号法)
  - [new](#new)
    - [语义使用时必须要注意的问题](#语义使用时必须要注意的问题)
    - [语义用于修饰一个数组类型的构造](#语义用于修饰一个数组类型的构造)
    - [布置-new](#布置-new)
  - [delete](#delete)
- [类](#类)
  - [访问权限符](#访问权限符)
  - [this-和-base](#this-和-base)
  - [类中的成员的声明和定义](#类中的成员的声明和定义)
  - [成员函数和函数指针](#成员函数和函数指针)
  - [构造函数](#构造函数)
    - [拷贝构造函数](#拷贝构造函数)
    - [移动构造函数](#移动构造函数)
    - [编译器自动添加的拷贝构造函数和拷贝复制运算符](#编译器自动添加的拷贝构造函数和拷贝复制运算符)
    - [拷贝移动消除](#拷贝移动消除)
    - [explicit关键字](#explicit关键字)
    - [构造函数中的初始化参数列表](#构造函数中的初始化参数列表)
    - [构造函数中的初始化参数列表](#构造函数中的初始化参数列表)
  - [析构函数](#析构函数)
  - [关于类中的静态成员](#关于类中的静态成员)
    - [静态成员的声明和实现](#静态成员的声明和实现)
  - [常函数和常对象](#常函数和常对象)
    - [常函数](#常函数)
    - [常对象](#常对象)
    - [mutable](#mutable)
  - [类的前置声明](#类的前置声明)
  - [继承](#继承)
    - [继承的内存模型](#继承的内存模型)
    - [子类和父类实例的释放顺序(析构函数的调用顺序)](#子类和父类实例的释放顺序(析构函数的调用顺序))
    - [显示指定父类构造函数进行父类成员的初始化工作](#显示指定父类构造函数进行父类成员的初始化工作)
    - [引用父类中的成员](#引用父类中的成员)
    - [里式转换](#里式转换)
    - [菱形继承](#菱形继承)
    - [虚继承](#虚继承)
    - [虚函数](#虚函数)
    - [虚析构](#虚析构)
    - [纯虚函数](#纯虚函数)
    - [友元成员](#友元成员)
- [函数的扩展](#函数的扩展)

<br/>

!!!
    <font color = "red">cpp 是对于 c 语言的一项扩展工作</font>，故其基本特性是直接沿用 c 语言而进行扩展的，这也就意味着，在 cpp 项目中，我们是可以书写 c 语言的代码(需要经过特殊的声明处理) ; 但是反过来却不行，在 c 语言的源文件中是无法使用 cpp 中的特性
    
    本篇文档主要是针对 cpp 所额外衍生出来的特性进行讲解，关于一些基本概念可以参考 [C-Programming-language](#https://github.com/NGPONG/document/blob/master/C/2019/12_18/C_Programming_Language.md)


<br/>

## Namespace

<span id="Namespace"></span>

<span id="命名空间的定义"></span>

### 命名空间的定义

---

cpp 引入了命名空间的概念以为了解决在 c 语言中所存在的成员命名重复的问题，其概念和其余的 OOP 语言类似，<font color = "red">一个命名空间下所声明的成员其所属的作用域范围则在该命名空间当中，需要使用它们，则需要显式的引入它们所在的命名空间</font>

```cpp
#include <iostream>
using namespace std;

namespace Number {
  int i = 10;
}

int main(void) {
  using namespace Number;
  cout << i << endl;
  
  cout << Number::i << endl;

  return EXIT_SUCCESS;
}
```

值得一提的是，<font color = "red">命名空间是允许嵌套命名空间而存在的</font>，那么相应的，作为内部被嵌套的命名空间其内部成员的作用域范围也仅在被嵌套的命名空间内部，我们对它的引用也同样需要经过多层的解析才能够完成

```cpp
#include <iostream>
using namespace std;

namespace Number {
  namespace Number_sub {
    int j = 40;
  }
  int i = 10;
}

int main(void) {
  using namespace Number::Number_sub;
  cout << j << endl;
  
  cout << Number::Number_sub::j << endl;

  return EXIT_SUCCESS;
}
```

此外，我们还可以<font color = "red">为命名空间添加别名，我们可以将该声明处置在任何作用域内，以组成我们所需要的作用域声明使用方式</font>

```cpp
#include <iostream>
using namespace std;

namespace Number {
  int i = 10;
}

namespace MyFunction {
  void foo_1(){
    namespace t_number = Number;
    cout << t_number::i << endl;
  };
}

namespace t_number = Number;
int main(void) {
  MyFunction::foo_1();
  
  cout << t_number::i << endl;

  return EXIT_SUCCESS;
}
```

<br/>

<span id="匿名命名空间"></span>

### 匿名命名空间

---

<font color = "red">匿名命名空间中的标识符只能在本文件内访问，其内部下所声明的所有东西(包括命名空间)都会扩展至当前编译单元基础上的全局作用域内，而不再是当前命名空间的作用域内</font>，这就<font color = "red">相当于为当前命名空间下的所有成员添加 'static' 关键字，_**并沿用其特性**_</font>

```cpp
namespace {
  int i = 10;
}
int main(void) {
  int z = i + 10;
  int y = ::i + 20;
}
```

<span id = "注意匿名命名空间下和全局命名空间下存在成员符号冲突的问题"></span>

需要注意的是，当匿名命名空间内存在某个成员的符号和全局命名空间下的某个成员一致，则在对该成员的调用过程中，会隐藏掉属于匿名命名空间下该成员的定义，并且，我们要保证对该成员的调用必须通过 :: 来完成(即引用全局命名空间)，否则会出现编译错误，因为直接使用成员名的时候引用的作用域会直接扩展至全局作用域，而全局作用域下由于这两个符号名是相同的，这时候就会出现二义性的情况，那么如果我们使用 :: 符号进行调用的话，会优先匹配匿名命名空间外的成员，虽然匿名命名空间外的成员和匿名命名空间内的成员同属一个全局作用域下，但是由于 :: 会优先匹配命名空间外的成员，故这里编译器会把它们两个暂时看作不同属一个作用域下，借助此机制我们可以完成对于声明在命名空间外的那个函数的调用工作

```cpp
#include <iostream>
using namespace std;

namespace {
  void fun_test(void) {
    cout << "anonymous scope" << endl;
  }
}

void fun_test(void) {
  cout << "global scope" << endl;
}

int main(void) {
  ::fun_test();

  return EXIT_SUCCESS;
}
```

<br/>

<span id="匿名命名空间中的-extern"></span>

### 匿名命名空间中的 extern

---

由于匿名命名空间内的所有成员都会添加上 'static' 关键字，所以当我们我们想对其中的某个成员的声明引入 'extern' 关键字，使之声明扩展至其他的编译单元内的定义是无效的，并且，该成员即便使用了该关键字并且在找不到该声明所对应的定义时不会产生链接失败的问题(当在链接阶段在当前编译单元中如果找不到相符的定义，则以 static 的特性初始化这个变量的内存区)，唯一的作用可能就是能够通过该关键字把当前变量的声明修饰为能够在当前编译单元中寻找链接定义的符号

那么，假设一个匿名命名空间下存在某一个成员的声明，并且通过了 extern 关键字使之声明能够扩展至当前编译单元内寻找相符的符号定义时，我们要<font color = "red">保证对于该成员的调用使用了 :: 去引用全局作用域下的该成员的名字，否则会出现该成员的调用出现二义性的情况</font> ； <font color = "red">除此之外，我们要保证对于该成员调用之前，能够出现该声明所即将链接到的定义，否则会出现该声明未定义的情况</font>

```cpp
namespace {
  extern int i;
}

static int i = 0x400; /* static 关键字可加也可以不加 */

int main(void) {
  int y = ::i + 10;
}
```

<br/>

<span id="作用域"></span>

### 作用域

---

cpp 中更加深化了作用域的概念，<font color = "red">实际上这些概念也仅仅是作为在c语言中所出现的情景的一种更进一步的补充说明</font>(没有太多新的概念)，具体来说，cpp 把作用域划分了以下三种类型 : 

- 声明域$(declaration \:\: region)$: 声明标识符的区域，如在函数外面声明的全局变量，它的声明域为声明所在的文件 ; 在函数内声明的局部变量，它的声明域为声明所在的代码块
- 潜在作用域$(potential \:\: scope)$: 从声明点开始，到声明域的末尾的区域，简而言之就是对成员声明之前使用情况的一种说明，规范化了具体的这个潜在范围
- 作用域$(scope)$: 标识符对程序可见的范围，标识符在其潜在作用域内，并非在任何地方都是可见的。例如，局部变量可以屏蔽全局变量、嵌套层次中的内层变量可以屏蔽外层变量，从而被屏蔽的全局或外层变量在其倍屏蔽的区域内是不可见的,所以，一个标识符的作用域可能小于其潜在作用域
- 全局作用域和局部作用域: 这一点可以延续该[文档](#https://github.com/NGPONG/document/blob/master/C/2019/12_18/C_Programming_Language.md)的说明，这里不做过多的赘述

值得再次强调的是，<font color = "red">cpp同样需要遵循着编译器对代码段由上至下进行编译的规律</font>，举个例子，当我们在一个函数内使用了在全局作用域下的成员，当这个成员声明的位置在使用该成员的代码段的下面的话，那么编译的时候就会报错，如下面的代码

```cpp
int main(void){
  cout << a << endl; /* failure */
  cout << b << endl; /* failure */
  cout << c << endl; /* failure */
}
namspace TEST {
  int a = 1024;
}
namspace {
  int b = 256;
}
int c = 64;
```

<br/>

<span id = "显式的引用某一处的作用域"></span>

#### 显式的引用某一处的作用域

正因为命名空间概念的加入，我们才迫切的需要关注这个问题，需要使用某个成员的前提则需要提前先引入它所在的作用域，在 cpp 中如果具体规划下来引入作用域的花样十分之多，但是从宏观来细分的话，这些十分之多的花样都是基于两种语法规则所演变而来的，我们对一些不常见的引用方式只需了解即可，重点需要关注的是常用的引用方式上面

- using namespace x

  - 在当前文件的范围内引入一个作用域:

  ```cpp
  namespace Number {
    int i = 10;
  }

  using namespace Number;
  int main(void) {
    int y = i + 10;
  }
  ```

  - 在局部范围内引入一个作用域: 

  ```cpp
  namespace Num_1 {
    int y = 10;
  }

  namespace Num_2 {
    using namespace Num_1;

    int i = 10;
    void foo() {
      int z = i + y;
    }
  }

  int main(void) {
    using namespace Num_2;
    foo();
  }
  ```

  - 引入某个命名空间下的具体某个成员:

  ```cpp
  namespace Number {
    int i = 10;
    int y = 20;
  }

  using Number::i;
  int main(void) {
    int z = i + 10;
    y++; /* Error: Can't found [y] symbol */
  }
  ```

- ::

  - namespace:: : 引用到某个命名空间下的作用域，该方式通常在一段代码中直接获取一个命名空间下某个成员的定义

  ```c
  #include <iostream>
  using namespace std;
  
  namespace Number {
    int i = 10;
  }
  
  int main(void) {
    cout << Number::i << endl;
  
    return EXIT_SUCCESS;
  }
  ```

  - class:: : 该方式用于对类中的某个成员的声明亦或者某个特殊声明的成员进行定义亦或者使用它来访问一个类中具有公共权限静态类型成员

  ```cpp

  ```

  - :: : 引用到全局空间下的作用域
  
    - 由于匿名命名空间空间下的成员会提升至全局作用域，所以该语法同样也适合对于匿名命名空间下成员的调用，但是我们需要[注意匿名命名空间下和全局命名空间下存在成员符号冲突的问题](#注意匿名命名空间下和全局命名空间下存在成员符号冲突的问题)
  
  ```cpp
  #include <iostream>
  using namespace std;

  namespace {
    void fun_test_anonymous(void) {
      cout << "anonymous scope" << endl;
    }
  }

  void fun_test_global(void) {
    cout << "global scope" << endl;
  }

  int main(void) {
    ::fun_test_global();
    ::fun_test_anonymous();

    return EXIT_SUCCESS;
  }
  ```

<br/>

<span id="命名空间下成员的声明和定义"></span>

### 命名空间下成员的声明和定义

---

这里着重介绍的是关于函数的声明和定义，对于一个命名空间下仅出现某个函数的声明的情况，我们还需对其进行重定义，重定义的方式只需要引用到具体某个命名空间然后针对该函数进行定义即可

```cpp
namespace foo {
  void foo_fun(void);
}

void foo::foo_fun(void) {
  int i = 10;
}

int main(void) {
  foo::foo_fun();
}
```

<br/>
<br/>

## 表达式和值类别

<span id="表达式和值类别"></span>

<span id = "表达式"></span>

### 表达式

---

<font color = "red">由运算符$(operator)$和运算对象$(operand)$ 构成的计算式(单独的运算对象也能够构成一个表达式)，在编程语言中，函数的返回值也被认定为一种表达式</font>

从宏观来说，表达式通常指的是一个算式的整体，但是从微观上来说，我们同样可以认为一个算式中的某一个单元也属于一种表达式，如下面的代码

```cpp
int fun_test(char *str) {     /* str 是一个表达式 */
  printf("%s\n",str);         /* printf("%s\n",str) 是一个表达式，"%s\n" 是一个表达式，str 是一个表达式 */
  return 0;                   /* 0 是一个表达式，result:int temp = 0 是一个表达式 */
}
int main(void) {
  int i = 10;                 /* 10 是一个表达式，i 是一个表达式 */
  char *str = "Hello,World!"; /* "Hello,World" 是一个表达式，str 是一个表达式 */
  int result = fun_test(str); /* str 是一个表达式，fun_test(str) 是一个表达式，result 是一个表达式 */
  return EXIT_SUCCESS;
}
```

表达式是可求值的，对表达式求值将得到一个结果$(result)$，这个结果有两个属性：类型和值类别$(value categories)$，也就是说上面代码中对于每一块所注释起来的表达式他都有属于它的类型和值类别这两种属性，对于类型属性来说，无非就是最终 $result$ 的类型，而对于值类别属性来说，就需要深入的进行探讨了

<br/>

<span id = "值类别"></span>

### 值类别

---

在 cpp11 以后，表达式按值类别分，必然属于以下三者之一: 
- 左值$(left \:\: value,lvalue)$
- 将亡值$(expiring \:\: value,xvalue)$
- 纯右值$(pure \:\: rvalue,pralue)$

其中，左值和将亡值合称泛左值$(generalized \:\: lvalue,glvalue)$，纯右值和将亡值合称右值$(right \:\: value,rvalue)$

在开始前需要重点强调的是，对于左值和右值一个最常见的误解就是 : 等号左边的就是左值，等号右边的就是右值。当然如果把这一点套用在c语言中是没有什么问题的，而cpp为了更具体的细化在c语言中所出现的 **_具名的变量_** 和 **_无名临时变量_** 的关系，所以引出了左值和右值的另一种概念

<br/>

<span id = "左值"></span>

#### 左值

<font color = "red">求值结果 $result$ 的类型是一个具名的对象则为存左值表达式，作为一个左值，其必定会存储在内存中的具体某个位置</font>，如下面常见的几种表达式则为左值表达式

- 具名变量(包括函数的形参)
- 函数指针
- 返回值类型为 **_左值引用_** 的函数调用
- 前置运算符
- 由赋值运算符或复合赋值运算符连接的表达式(a=b, a+=b, a%=b, etc)
- 解引用表达式
- 字符串字面值("abc")

由于左值表达式的求值结果都是以具名的变量所存在，故对于左值表达式而言，其<font color = "red">生命周期会延续到当前左值表达式最原始声明处的栈帧弹出(函数调用完毕)而随之被释放</font>，但是这里有一个小小的不同，即 **_返回值类型为左值引用的函数调用_** 这一项

作为函数调用这一功能性质而言，它的确能够作为一个左值表达式而存在，但是其返回值同样还需要构造处一个 **_不具名的临时变量_** 以作为函数的返回值，既然是不具名的临时变量那不是符合一个 **_纯右值表达式_** 的定义吗？

其实当函数的返回值类型为一个 **_左值引用_** 的时候，编译器虽然能把该调用构造成一个左值表达式，但它只是作为<font color = "red">符合当前语境的一个左值而存在</font>，简而言之，<font color = "red">我们能够使用该函数调用的返回值所构造出来的无名的临时变量去绑定一个新的变量亦或者已经被实例化过的变量去构造出一个初始化变量的拷贝语境(使用左值去初始化一个对象或为一个已实例化好的对象进行赋值的时候，会调用所操作的对象类型的拷贝构造函数以完成初始化工作)</font>，当这个函数调用所构成的左值表达式在完成这项拷贝语境的使命工作后，其返回值所构造的临时变量同样也会作为一个临时变量本身被编译器认定为已是一个无效值，即函数调用完成后临时变量也就会随之进行释放

当我们使用一个左值表达式去绑定(初始化)一个新的变量亦或者一个已经经过实例化的变量时，会调用目标变量的拷贝构造函数亦或者拷贝赋值运算符(如没另外声明，则会调用默认自带的)以拷贝语义的方式把左值表达式在内存中的数据拷贝到目标变量身上

<br/>

<span id = "右值"></span>

#### 右值

<font color = "red">右值大多数情况下都会存储在寄存器当中，当然也有少数的情况会存储在内存当中</font>，具体来说，右值又能够细分出 **_纯右值_** 和 **_将亡值_**

<font color = "red">右值表达式的求值结果都是以无名的临时变量所存在</font>，故对于右值表达式而言，<font color = "red">其生命周期通常在右值表达式的诞生之初就需要面领着被销毁的风险</font>，除非在右值表达式即将要被销毁前，显式的把当前右值表达式把它在 寄存器/内存 中所存储的数据移动到具体某个变量身上(通过赋值运算符)，否则该右值表达式的存在则是毫无意义的，这里需要补充一下的是，<font color = "red">该销毁的机制其实是编译器所导致的，因为它会认为不管我们只是单纯的声明了这个无名的临时变量还是说用它来完成一次数据拷贝的工作，对于编译器而言他们在处理完这两项工作后还是没有继续存在的价值，故被销毁</font>，而 cpp 中由于新加入了 **_右值引用_** 的特性，故我们是有可能显式的把这个无名临时变量的地址绑定到一个可能长期需要使用到它的地方的，简而言之就是让编译器知道这个 无名的临时变量 在下面还有继续使用的价值，延长它的生命周期

当我们使用一个右值表达式去绑定一个新的变量亦或者一个已经经过实例化的变量时，会调用目标变量的移动构造函数亦或者移动赋值运算符(如没另外声明，则会调用默认自带的)以移动语义的方式把右值表达式在 寄存器/内存 中的数据移动到目标变量身上，当右值表达式完成了这项工作后，它也随之会被销毁(<font color = "red">除了显式的使用 move() 所构造的右值</font>)

_**纯右值 :**_

纯粹的字面值(不包含字符串)则为纯右值表达式，亦或者求值结果 $result$ 的类型是一个不具名的临时对象，如下面常见的几种表达式则为纯右值表达式
  - 不具名的变量

  - 字面值(1, false, etc)
  - 返回值类型为 **_非引用类型_** 的函数调用
  - 后置运算符
  - 算术表达式(a+b, a&b, a<<b, etc）
  - 逻辑表达式(a&&b, a||b, ~a, etc)
  - 比较表达式(a==b, a>=b, a<b, etc)
  - 取地址表达式(&a)
  - 匿名对象
  - $new$ 操作符所构造的对象
  - 强制类型转换表达式(强制类型转换的过程会产生一个新的、不具名的、当前强制转换类型的临时的变量，并把这个临时变量中的数据 **_"移动"_** 到目标变量的身上)

**_将亡值 :_**

值得一提的是，在 C++11之前的右值 和 C++11中的纯右值 是等价的，正因为 C++11 中的 **_右值引用_** 的加入才导致了将亡值诞生，也就是说，将亡值与右值引用息息相关，所以将亡值表达式也仅仅会出现在包含右值引用的上下文当中，如下面几种常见的表达式

  - 返回右值引用的函数的调用表达式

  - 转换为右值引用的转换函数的调用表达式(move函数)

<font color = "red">事实上，将亡值不过是 C++11 提出的一块晦涩的语法糖，它与纯右值在功能上及其相似</font>，如，都不能做操作符的左操作数，使用它们在条件允许的范围之内(非普通的左值引用类型的成员，因为普通的左值引用无法绑定右值)去初始化一个对象亦或者赋值一个已有的对象时都会调用所操作对象的移动构造函数或者移动赋值运算符(**_移动语义_**)来完成对象的初始化工作，并且由于它们的求值结果 $result$ 都为一个无名的变量，就意味着不管是 纯右值 也好还是 将亡值，它们都存在着一个将要被销毁的临界点，所以我们不必刻意区分一个右值到底是纯右值还是将亡值

<br/>

<span id = "值类别小结"></span>

### 小结

---

作为左值而言，其表达式求值是作为一个具名的变量所存在，它必定会存储在内存当中，而对于右值而言，其表达式求值是作为一个无名的临时变量所存在，它有可能会存储在寄存器当中也有可能是存储在内存当中，通过这一特性，我们可以通过一个很便捷的方式去快速区分一个表达式到底是左值还是右值，那就是: <font color = "red">如果一个表达式的求职结果能够取地址，则该表达式为一个左值表达式，否则为右值表达式</font>

上面所说的这么多的关于左值还是右值的判断依据其实是以一个宏观概念上来对一个表达式所做的判定的，考虑下面的代码，我们声明了一个函数 `foo` 返回值类型为右值引用，也就意味着该函数的调用其是作为一个右值(将亡值)表达式而存在，由于他所返回的是一个引用类型，其实也就是一个当前所引用的类型的指针，当我们在代码里通过 `return (Person &&)per` 的时候，其实也就意味着该函数返回值所构造出来的类型为 `Person && (Person *)` 的临时变量数据则为 `per` 在内存中的首地址(强制类型转换后会创建一个当前所转换类型的无名临时变量，又因为它是一个右值表达式并且需要绑定给返回值类型为 `Person &&` 无名临时变量，也就意味着强制类型转换所构造出来的临时变量的数据需要通过移动语义把数据移动到返回值所构造出来的临时变量身上，故，返回值所构造的临时变量其实最终就是 `per` 在内存中的首地址)，那么这时，当函数调用完毕后，由于其返回的临时变量为 `Person &&(Person *)`，当我们直接使用它的时候，编译器会为它做一次隐式的解引用操作，那么我们可以姑且认为这个解引用的代码为 : `*per_ret_temp`，那么问题来了，这里作解引用操作是判定一个左值的标准，但是否就意味着 `Person per_new = fun_test(per)` 的操作会调用 `Person` 类的拷贝构造以完成 `per_new` 的初始化操作呢？答案是否定的，<font color = "red">虽然编译器为我们所做的解引用操作是作为一个左值的判定标准，但是它本身就是通过一个右值表达式(函数的调用)所延伸出来的，故这里还是作为一个右值来看待，所以最终的结果是调用 `Person` 类的移动构造函数以完成 `per_new` 的初始化工作(当我们使用一个右值表达式去绑定一个新的变量亦或者一个已经经过实例化过的变量时，会调用目标变量的移动构造函数亦或者移动赋值运算符，以移动语义的方式把右值表达式在 寄存器/内存 中的数据移动到目标变量身上)</font>

```cpp
class Person {
public:
  /* Person constructor */
  Person(int age)
      : m_age(age) {
      cout << "Person constructor" << endl;
  };  
  /* Perosn copy constructor */
  Person(Person &per) {
      this->m_age = per.m_age;
      cout << "Person copy constructor" << endl;
  };  
  /* Person Move constructor */
  Person(Person &&per) {
      this->m_age = per.m_age;
      per.m_age = 0x0;
      cout << "Person move constructor" << endl;
  };  
  /* Person destructor */
  ~Person() {
      this->m_age = 0x0;
      cout << "Person destructor" << endl;
  };

public:
  int m_age;
};

Person &&foo(Person &per) {
  per.m_age = 0x100;
  return per;
}
int main(void) {
  Person per(0x400);
  Person per_new = foo(per);
}
```

其实通过这个例子，需要我们注意的就是一个问题，<font color = "red">我们判定一个表达式到底是右值还是左值的时候，需要以宏观的方式去看待，不能以微观，细分的方式去看待</font>，在上面，`foo(per)` 由于返回值类型为 `Person &&` 那么它的调用就必定是一个右值（亡值），而不能具体到在使用它所返回的临时变量做解引用操作(`*per_ret_temp`)的标准去看待

此外，还有重点强调一点的是，<font color = "red">区分一个表达式具体是左值还是右值我们不能单纯的以该表达式具体的类型来区分，可能外表看上去相同的一个表达式，但是它确在不同状态下都呈现着不同的值类别</font>，就拿 右值引用 来说，我们所声明并初始化好的右值引用的表达式在正常状态下都呈现着左值的性质，而当我们把这个右值引用用作于函数的返回值返回时，虽然返回值所构造出来的右值引用的声明和我们在刚刚所说的在通常状态下所声明的右值引用的表达式是一致，但是右值引用作为函数返回值的话，那么这个函数的调用就为

<br/>
<br/>

## 引用

<span id="引用"></span>

当一个类型的声明使用了 `&` 操作符进行修饰后，那么我们所声明的变量就是一种类型为(左值/右值/转发型)引用 的变量，作为一个引用变量而言，我们对它的使用完全可以当成该引用变量在初始化时所绑定的变量来使用，也就是说我们针对引用变量所做的修改都会映射到在初始化时作为绑定方变量的修改(<font color = "red">它们所指向的是同一块内存地址</font>)

声明一个具体的引用变量也是非常的简单，我们仅需要<font color = "red">构造一个预期所需要绑定的类型再配合 `&` 操作符去构造一个具体的引用类型变量，并让它去绑定一个该引用变量所需引用的成员即可，</font>，需要注意的是，<font color = "red">引用变量初始化的过程中，引用变量所绑定的成员类型必须为引用变量所引用的类型，否则会导致编译错误</font>，如下面的代码，其声明了一个 int 类型的 **_左值引用_** 以完成一个最基本的引用绑定操作

```cpp
int main(void) {
    int a = 0x400;
    int &a_ref = a;
}
```

引用变量是需要区分类型的，具体细分来说有两种类型
- 这个引用变量本身的类型
- 这个引用变量所引用的类型

比如我们我们初始化了一个右值引用变量为 : `int &&a_ref = 1024`，那么这个引用变量的类型则为 : `int &&`，它所引用的类型则为 : `int`

需要注意的是，<font color = "red">引用变量一经声明就必须进行人为的初始化定义</font>(除了函数形参)，我们无法像普通变量一样仅仅只是对一个引用变量做一个声明，而其定义交由编译器来完成，因为对于引用变量而言，编译器是无法知道这个引用变量具体是需要绑定哪个成员

<br/>

### 引用变量的本质

---

<span id = "引用变量的本质"></span>

引用的本质其实就是一个指向了所绑的成员在内存中的首地址的所引用类型的指针，当然这是编译器为我们隐式所做的工作，其存在目的是为了减少指针定义和频繁的解引用操作，我们完全可以把它当成是使用指针的一种语法糖形式

- 当我们声明一个引用变量的时候，作为该引用变量所绑定的成员(右操作数)，编译器都会为其添加一个取地址 `&` 操作符以取该成员的地址，相对的，我们所声明的引用变量会被编译器改写为当前所引用成员类型的指针变量

- 当我们使用一个已经经过初始化好的引用变量的时候，编译器都会为我们所使用的引用变量添加上解引用 `*` 操作符以对该引用变量实质的指针进行解引用操作

```cpp
int main(void) {
    int a = 10;
    int &a_ref = a; /* int * a_ref = &a; */
    a_ref = 1024;   /* *a_ref = 1024; */
}
```

一个很好的建议是，我们无需强塞指针的概念进到引入身上，我们大可将他当成是对于某一个变量的一个 **_别名_** ，我们完全可以把所声明的引用变量来作为引用所绑定的成员来使用，引用的本质的确是一个指向所引用变量在内存中首地址的指针，但是强加指针的概念进去引用只会导致代码的阅读困难，并且这种做法也违背了设计者最初的设计观念 : 创建引用最核心的一个目的就是简化对于指针操作的繁琐性

引用变量一经初始化好后，我们就无法在改变该引用最原始的绑定关系，即不能再改变该指针指向其他地址(不能再让引用变量再去引用去他变量在内存中的首地址)，原因是因为<font color = "red">没有语法支持我们做这种操作</font>，当我们直接使用一个已经定义好了的引用变量再去进行赋值操作的时候，这时候编译器都会为我们所使用的引用变量添加上 * 操作符以对该引用变量实质的指针进行解引用操作，也就是说我们实际上是无法真正的访问到该引用变量所绑定的成员在内存中的首地址的，既然无法访问到它的首地址那就意味着我们无法显式改变该引用变量的本质指针所存储的地址，为了更好理解，我们也可以姑且认为，一个引用变量在被定义好了以后，其真正的形态是一个 **_"指针常量"_** `int const * ref`，<font color = "red">需要注意的是，这里只是举个例子，并不是意味着引用变量在定义好了以后无法再去改变其所绑定的成员的原因是由于其本质是指针常量所导致的，而是因为本身的语法不支持我们做这种操作</font>

引用的本质就是一个指向当前所绑定成员的所引用的类型的指针，也就是说当我们的函数返回值类型为一个引用类型，并且我们也是正确的返回了一个所引用类型实例时，函数返回值所构造出来的引用类型(所引用类型的指针)的临时变量所存储的数据则为我们所返回的在 当前函数作用域内的某个变量的实例亦或者一个单纯的右值表达式(返回值的引用类型为右值引用)，即一个无名的临时变量在内存中所存储的首地址，由于该地址所指向的某个类型的实例是在当前栈帧内所被构造出来，也就意味着在函数调用完毕后，栈帧出栈后，该地址所指向的变量也会随之被释放掉，简而言之，返回值所构造出来的类型为引用类型的无名临时变量在最终会指向一个无效且不安全的地址，关于这个无效的地址在不同编译器上的实现会有所不同，就 `msvc` 而言，该临时变量内部所存储的还是作为函数返回值实例在内存中的首地址，只是该地址所指向的内存段已经是一个失效的状态，而对于 `gcc` 而言，`gcc` 会认为临时变量内部所存储的地址已经指向的是一个无效的数据，故使用 0 来替换掉临时变量内部所存储的数据，也就意味着作为左值引用所呈现出来的指针内部所存储的地址则变为 0 的无效地址，<font color = "red">简单而言就是，我们对于一个函数返回值是引用类型的时候需要格外注意，其安全程度和指针类型相同</font>


<br/>

<span id = "左值引用"></span>
### 左值引用

--- 

左值引用的出现是为了解决 **_拷贝语义_** 的问题，当引用变量的类型被声明为 : `Type &` 时，那么这个引用变量就是一个左值引用

<font color = "red">对于左值引用而言，它只能够绑定一个左值，并且无论其声明在任何地方，都是作为一个左值表达式而出现</font>

当一个左值引用添加了 `const` 关键字后就是一种特殊的左值引用，该<font color = "red">特殊左值引用除了可以绑定一个左值作为引用外，还可以绑定一个右值</font>

```cpp
#include <iostream>
using namespace std;

int main(void) {
  int a = 0x400;

  int &l_ref = a;
  l_ref = 0x100;
  cout << a << endl;

  const int &l_c_ref = move(l_ref);
  cout << l_c_ref << endl;

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "右值引用"></span>

### 右值引用

--- 

右值引用的出现是为了解决 **_移动语义_** 的问题，当引用变量的类型被声明为 : `Type &&` 时，那么这个引用变量就是一个右值引用

<font color = "red">对于一个右值引用而言，它只能够绑定一个右值</font>，需要注意的是，<font color = "red">右值引用没有像左值引用一样可以通过 `const` 关键字去修饰一个即可以绑定左值又可以绑定右值的右值引用</font>

<font color = "red">一个右值引用的变量可能会因为他所处的状态不同而呈现出不同的值类别</font>，就单纯的声明并初始化了一个 右值引用 来说，他是作为一个左值表达式而存在，即存在潜在的拷贝性，这种情况下我们可以称这个右值引用为一个 **_有名右值引用_**，而当一个右值引用作为函数参数返回亦或者执行了一个返回右值引用的类型转换时，它是作为一个右值表达式而存在，即存在潜在的移动性，我们也会称这种情况的右值引用为一个 **_无名右值引用_**

其实对于右值引用来说，不管有名还是无名也好，我们无需刻意的去区分它们，<font color = "red">因为本身是否有名的右值引用的特性是延续 左值/右值 的特性所诞生的</font>

最好还要说明一下，我们都知道，作为一个右值表达式通常都需要经历一个 无名的临时变量 的转换过程，即，这个无名的临时变量在被创建之初就需要面领着被释放的风险，除非在右值表达式即将要被销毁前，显式的把当前右值表达式所存储的数据移动到具体某个变量身上，使这个右值表达式变得有意义，而这种初始化的工作往往是调用目标变量所拥有的 移动构造/移动赋值运算符 来完成的，那么假设目标变量是一个非常庞大的变量，<font color = "red">虽然对于移动语义来说是能够一定程度上降低拷贝语义所带来的性能开销，但并不意味着就能够忽视掉使用了移动语义后也会带来的一定程度上的性能损耗，其实也就意味着每一次移动都会带来一定程度上的性能损失</font>，而由于 右值引用 是能够接受一个右值的，并且对于 引用初始化 来说，编译器都会隐式的帮我们取绑定目标实例在内存中的首地址以完成引用初始化的工作，那其实也就意味着，<font color = "red">我们使用一个右值引用去接收绑定一个右值表达式的时候，其性能开销仅仅存在于一个小字节的地址移动身上(编译器取绑定目标的地址，也就是意味着仅仅只是把地址的数据移动到右值引用其本质指针所存储的内存段当中)</font>

此外，更有意思的是，因为右值表达式的求值结果通常都为一个 无名的临时 变量，而我们使用右值引用由于能够接收一个右值的绑定，当我们使用一个右值引用去接收一个右值表达式的时候，编译器会取作为右值引用所绑定的成员在内存中的地址，而这个成员作为右值表达式其实其求值结果就是一个 无名的临时变量，当编译器意识到这个 临时无名的变量 的内存地址有另外的引用的情况下它就不会再去释放这个无名的临时变量，也就意味着这个临时变量的生命周期不再是自声明之初就需要面领着被销毁的风险，而是会延续到当前栈帧的弹出 ( 无名临时变量也是在当前栈帧中所构造 ) 而随之销毁，我们也可以简单地理解为<font color = "red">右值引用能够隐式的延续右值表达式的生命周期</font>

```cpp
int main(void) {
  int &a_ref = 0x400;
}
```

<br/>

<span id = "左右值引用的函数重载策略"></span>

### 左右值引用的函数重载策略

---

在函数重载的形参为 左值/右值引用 时候，当发生二义性调用，那么编译器会根据当前所录入的实参的值类别去匹配一个最符合的函数以完成调用，如下面的代码，一组函数的重载中，其一的形参为 常量左值引用 类型，其二函数的形参为 右值引用 类型，这时候就会出现二义性了，因为形参类型为 常量左值引用 的函数和形参类型为 右值引用 的函数同样都可以接受一个 右值表达式 实参的输入，但是我们真正的去输入一个右值表达式去调用该函数的时候，编译器会优先匹配至形参类型为 右值引用 的函数调用，因为形参类型为 右值引用 的函数才是最符合当前所录入的实参值类别的

<font color = "red">下面的代码虽然是以普通函数重载的形式所展现，但是这一特性更多的是应用在一个类中的 拷贝/移动构造 或者 拷贝/移动赋值运算符 当中</font>

```cpp
void foo(const int &a_ref) {
  cout << "const lvalue reference" << endl;
}
void foo(int &&a_ref) {
  cout << "rvalue reference" << endl;
}
int main(void) {
  foo(0x400);
  return 0;
}
```

<br/>

<span id = "数组引用"></span>

### 数组引用

---

数组引用的方式和数组指针的定义方式类似，也是通过 `()` 来提升 `&` 操作符的优先级，使引用变量的类型组合成一个数组类型

```cpp
#include <iostream>
using namespace std;

int main(void){
  int arrary[10] = { 0 };
  int (&arrary_ref)[10] = arrary;
  
  for (size_t i = 0; i < sizeof(arrary_ref) / sizeof(*arrary_ref); i++) {
      arrary_ref[i] = 10 + i;
  }

  for (size_t i = 0; i < sizeof(arrary) / sizeof(*arrary); i++) {
      cout << arrary[i] << endl;
  }

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "指针引用"></span>

### 指针引用

---

<font color = "red">指针引用的本质其实就是一个多级指针</font>，指针引用也是通过 `()` 来提升 `&` 号的作用域即可，其类型则为 _指针类型_，事实上，其实我们是不是用 `()` 来提升优先级都无所谓，因为 `&` 的优先级总是比 `*` 号要高，不过加上 `()` 后代码的可读性会更高一点

```cpp
#include <iostream>
using namespace std;

int main(void) {
  int a = 10;
  int *p = &a;

  int *(&p_ref) = p;
  *p_ref = 1024;

  cout << a << endl;

  return EXIT_SUCCESS;
}
```

<br/>
<br/>

## 常量的增强

<span id="常量的增强"></span>

在c语言中，对于声明在局部作用域的常量我们是可以通过指针来完成间接修改常量的值的，而在cpp中，对于常量的功能进行了增强，使某些情况下是禁止使用指针来完成间接修改的操作，以保证了该关键字的正确性

- 对于声明在全局作用域下抑或是某个命名空间但不是类的内部的常量是无法通过指针来完成间接修改的，因为他们都存储在内存的只读段当中

- 对于声明在局部作用域下的常量

  - 使用 **_字面值(立即数)_** 所初始化得常量(不包括自定义类型)，无法通过指针来完成间接修改的，原因是因为使用字面值所初始化的常量其实从头到尾都没有被分配过内存，它都由一张 **_键值对形式的符号表_** 来进行维护，每当这种类型常量声明过后会存储在这张符号表里，常量名为 **_键_**，以常量值为 **_值_**，当我们通过 `&` 去获取常量的地址的时候，编译器会额外分配一个无名的临时变量并把符号表中所存储的值拷贝至临时变量以完成初始化工作，然后 `&` 操作符所操作的成员会替换为刚刚所声明的那个无名的临时变量，也就意味着我们是永远无法取到使用字面值绑定的常量其在内存中真实的首地址的，也就意味着不能通过指针完成对它间接修改得目的，但是对于刚刚编译器所临时分配得那个变量还是可以修改的，原因是因为他存储在栈中，尝试以下代码

  ```cpp
  #include <iostream>
  using namespace std;

  int main(void) {
    const int a = 10;

    int *p = (int *)&a;
    *p = 1024;

    cout << a << endl;  // 没有被修改，因为指针所指向的地址并不是 a 真正的地址
    cout << *p << endl; // 被修改了，但是被修改的是编译器所临时分配的变量，我们看不见，但是它的确在编译后会存在

    return 0;
  }
  ```

  - 对于使用变量来完成局部作用域下的常量初始化亦或者是常量的类型为自定义类型的常量都和 c 中的常量的特性一致，我们都可以通过指针来完成对常量的简介修改

```cpp
#include <iostream>
using namespace std;

const int c_1 = 10;   /* Real const var */

namespace {
  const int c_2 = 10; /* Real const var */
}

int main(void) {
  const int c_3 = 10; /* Real const var */

  int c = 10;
  const int c_4 = c;  /* Fake const var */

  /* replace 1,2,3,4 to test */
  int *p = (int *)&::c_x; 
  *p = 0x400;
  cout << ::c_x << endl;

  return EXIT_SUCCESS;
}
```

<br/>
<br/>

## 类型赋值

<span id="类型赋值"></span>

在 CPP 中，细化了构造变量的方式


<span id="匿名对象"></span>
### 匿名对象

--- 

匿名对象的初始化通过语法 <font color = "red">类型(值)</font> 来完成，其作为一个表达式中的右操作数存在

- 当匿名对象所指定的数据类型为 **_基础数据类型_** 时，`()` 内的值则直接录入到所创建的变量所处的内存空间当中

- 当匿名对象所指定的数据类型为 **_自定义对象_** 时，`()` 内的值则可以充当函数形参的录入列表(编译器会根据所录入的形参自动匹配一个最佳的构造函数以完成对象的实例化)

<font color = "red">匿名对象所开辟的内存空间默认在栈上，并且它是一种 **_右值表达式_**，也就是说，它会产生一个临时的无名变量，等待着被移动至具体实例上</font>，在具体的使用上，我们经常能够看到匿名对象会作为一个变量初始化表达式的右操作数而存在，这也正体现了其所构造的临时无名变量被移动到具体实例的情景

事实上，匿名对象的创建编译器做了一定的优化工作，当我们使用匿名对象初始化一个变量的时候，因为匿名对象是一种右值表达式，所以理应会调用目标变量的 移动构造函数 去把匿名对象所创建的 无名的临时变量 在内存中的数据移动到目标变量身上，但是<font color = "red">编译器通常会把我们通过匿名变量初始化一个目标变量的代码优化成仅仅是使用一个 **_括号法_** 来完成</font>，意味着我们这段代码实际上仅仅只是会调用目标的构造函数以完成对象的初始化工作，例如 : `Person per = Person(0x400)` 最终会转化为 `Person per(0x400)` 的构造方式

```cpp
class Person {
public:
  char *m_name;
  Person(char *name) : m_name(name) {}
};

int main(void) {
  Person per = Person((char *)"Hello");
  int a = int(20);
  char ch = char('A');
}
```

这里需要注意的是，尽量不要让匿名对象单独出现在一段代码表达式之中，就基础数据类型而言，其所创建的无名临时变量得不到一个适合的容器进行移动，那么这个创建的工作也成为了无用功 ; 次之，对于自定义对象的类型，单独出现则会导致编译时发生重定义的错误，如下面的代码情景 :

```cpp
class Person {
public:
  int age;
  Person(int _age) : age(_age) {};
};

int main(void) {
  Person per(10);

  Person(per); /* fault */
}
```

<br/>

<span id="定义法"></span>

### 定义法

---

定义法即变量的声明，对于基础数据类型来说再熟悉不过，而对于存在构造函数的类型来说，使用定义法对于会自动的调用当前类型无参的构造函数以完成类型的实例化操作

```cpp
class Person {
public:
  int age;
  Person() {};
  Person(int _age) : age(_age) {};
};

int main(void) {
  int i;
  char c;
  Person per;
}
```

<br/>

<span id="隐式法"></span>

### 隐式法

---

隐式法即使用一个具体的值亦或者实例去初始化一个变量，对于基础数据类型不进行探讨，而对于存在构造函数的类型来说，指定的 **_'值'_** 则会匹配到当前类型中构造函数的形参列表最相符的构造函数并调用(当有多个形参则用 `{ }` 来表示)

```cpp
class Person {
public:
  int age;
  char gender;
  Person() {};
  Person(int _age) : age(_age) {};
  Person(int _age, char _gender) : age(_age), gender(_gender) {};
};

int main(void) {
  int i = 0x400;

  Person per_1 = i;

  Person per_2 = { i, 'A' };
}
```

<br/>

<span id="括号法"></span>

### 括号法

---

括号法通过语法 <font color = "red">类型 变量名(值)</font> 来完成一个变量的初始化，它作为一段代码表达式中独立的存在

- 当所指定的数据类型为 **_基础数据类型_** 时，`()` 内的值则直接录入到所创建的变量所处的内存空间当中

- 当所指定的数据类型为 **_自定义对象_** 时，`()` 内的值则可以充当函数形参的录入列表(编译器会根据所录入的形参自动匹配一个最佳的构造函数以完成对象的实例化)

需要注意的是，<font color = "red">我们不要使用括号法来调用无参的构造函数来完成类的实例的创建</font>(应该使用 **_声明法_** 来完成)，因为这会让编译器误认为我们这段代码所做的是一次函数的声明，即一个返回值为具体类型函数名为变量名的无参函数声明

```cpp
class Person {
public:
  int age;
  char gender;
  Person() {};
  Person(int _age) : age(_age) {};
  Person(int _age, char _gender) : age(_age), gender(_gender) {};
};

int main(void) {
  int i(0x400);

  Person per_1(i);

  Person per_2(i, 'A');
}
```

<br/>

<span id="new"></span>

### new

---

new 是一个修饰语义，其语义可以拆分为 : <font color = "red">new 类型声明方式</font>，它通常<font color = "red">用于修饰一个匿名对象亦或者一个具体的类型的创建</font>，并作为一段代码表达式中的右操作数而存在，一个完整的 new 表达式整体来说干了三件事情 :

- 根据它所修饰的 **_匿名对象亦或者具体类型_** 的长度(大小)在 **_堆_** 中创建一段相应长度的内存空间并判断是否成功创建

- 依据 new 关键字所修饰的 **_类型声明方式_** 去初始化刚刚所创建的内存空间(new 关键字所修饰的表达式可以是仅仅作为一个类型而存在，当 new 所修饰的表达式仅仅是作为一个类型存在的时候，我们要保证相应的类型是存在默认的构造函数以供 new 在申请了一块堆空间后可供调用以初始化这块堆空间，否则会造成编译失败，对于这个默认的构造函数，通常值得我们考虑的仅为自定义对象这类的复合类型，对于基础数据类型的默认构造函数看编译器实现的不同而不同，但是通常都是初始化为 0)

- 最后它会返回在堆中所创建的内存空间段的首地址(new 关键字所修饰类型的指针)

需要提及的是，对于 new 来说它和 `malloc()` 的作用似乎很相似，其实不然，<font color = "red">new 所做的工作就是属于 malloc 上的延伸</font>，对于单独使用 malloc 而言虽然也能够完成动态内存的管理，但是我们都知道 malloc 本身也是存在着许许多多的让开发人员不爽的问题，诸如 : 每次申请内存都需要具体指定一个申请内存空间的大小，并且申请完成后我们还需手动点判断下是否内存申请失败，最重要的是，由于 cpp 引入了 OOP 的概念和开发模式，<font color = "red">故单纯的使用 malloc 申请内存并不支持指定一个我们所需要的构造函数(如果存在的话)去完成 malloc 后的内存空间的初始化工作(编译器并没有提供)</font>，故在 cpp 中对于内存的管理方式官方更加的推荐我们使用 new 去完成

```cpp
class Test {
public:
  int id;

  Test() {}
  Test(int _id) : id(_id) {}
};

int main(void) {
  Test *test_1 = new Test(1);
  Test *test_2 = new Test;

  int *i = new int(0x400);

  return 0;
}
```


<span id = "语义使用时必须要注意的问题"></span>

#### new 语义使用时必须要注意的问题

使用 new 语义所创建的对象(拥有动态存储期的对象)，其生命周期持续到使用 delete 语义释放掉 new 表达式所返回的指针位置，<font color = "red">我们要保证 new 所返回的的内存地址总会有一个相对应的 delete 进行释放，否则会造成内存泄漏</font>

值得一提的是，new 表达式是一种 **_右值表达式_**，即其在声明之初就需要面领着要被销毁的风险，如果我们并没有对其所创建的临时无名变量在内存中所存储的数据(即堆中的内存地址)进行显式的移动亦或者引用的话，那么该声明是毫无意义的，更严重的是，由于其是存在自毁的特性，但是自毁仅仅是自毁 new 表达式所构造出来的、初始化在栈上的 临时无名变量 的内存，并不意味着那块在堆中所申请的内存也会随同一起销毁，简而言之就是会存在野内存出现的情况(无法再拿到那个在 堆 中的地址，即无法再使用 delete 去显式的单堆那块内存进行释放)，如下面的代码 :

```cpp
class Test {
public:
  int id;

  Test() {}
  Test(int _id) : id(_id) {}
};

int main(void) {
  new int[1024]; /* Fault */
  new int(20);   /* Fault */
  new Test(1);   /* Fault */
  new Test;      /* Fault */

  return 0;
}
```

<span id = "语义用于修饰一个数组类型的构造"></span>

#### new 语义用于修饰一个数组类型的构造

使用 new 表达式构造数组只需要在所修饰的 **_类型声明方式_** 后面加上数组长度标识符 `[]` 以声明数组的长度即可在堆中依据这个类型创建一个指定长度的内存空间并返回其在内存中的首地址，即: <font color = "red">new []</font>

既然所构建的对象数组使用的是 `new []` 语义所修饰，那么相应的，这块在堆中所构造出来的内存同样要使用 `delete []` 语义进行释放才行，<font color = "red">如果单纯的仅使用 `delete` 语义来完成释放工作的话，那么其仅仅只会释放这个数组的首元素所使用的内存，而后面下标的元素所占用的内存则会成为野内存</font>

需要注意的是，<font color = "red">当我们使用 new [] 去构造一个对象的数组时，new [] 所修饰的不能是一个匿名表达式，只能够是一个具体的类型</font>，这也就意味着我们无法通过匿名表达式来指定具体的值或构造函数以完成堆这段内存空间的初始化操作，<font color = "red">编译器仅仅只会帮我们为数组中的每一个成员赋予一个默认值或者是调用数组中每个元素对象默认的无参构造函数以完成对这段内存空间的初始化工作</font>

```cpp
class Person {
public:
  int id;

  Person() {}
  Person(int _id) : id(_id) {}
};

int main(void) {
  int *int_arrary = new int[10];
  delete []int_arrary;

  Person *per = new Person[3];
  delete[] per;

  return 0;
}
```

<span id = "布置-new"></span>

#### 布置 new (Placement new)

布置 new 的语义为 <font color = "red">new (地址) 类型声明方式</font>

前面说到 new 语义在背后其实为我们做了三件事: 
- 在堆中开辟一个新的内存空间

- 根据 new 所修饰 **_类型声明方式_** 的去初始化这段内存空间

- 返回这段内存空间的地址

<font color = "red">而布置 new 可以的跳过第一个步骤，即人为的指定一块内存地址来进行初始化 ; 可用于对一个没有初始化过的内存依照 **_类型声明方式_** 进行一次初始化工作，那么相对的，也可以对原有内存中的数据进行一次覆盖</font>

需要注意的是，布置 new 所构造的表达式是能够允许单独出现的，并且我们在某些场合下是可以不用 delete 的，这和单独的 new 关键字不同，原因在于单独的 new 语义所构建内存的空间必须在 堆 当中，并且我们在初始情况下是不知道其所构造的内存段的首地址到底是多少，而反观 布置new，如果我们所指定的地址是在栈中的话那我们就无需手动的进行 delete 了，并且所指定的地址是由开发人员自己指定，故我们是能够追索到地址的原址的，是否因为 new 表达式的单独出现而导致无法追朔到所创建的内存段的地址而导致无法 delete 的问题由开发人员来决定了

```cpp
class Person {
public:
  int id;

  Person() {}
  Person(int _id) : id(_id) {}
};

int main(void) {
  /* assigned in stack */
  int i = 10;
  new (&i) int(0x400);

  /* assigned in heap */
  Person *pers = new Person[10];
  for (size_t i = 0; i < 10; ++i) {
    new (&pers[i]) Person(i + 10);
  }

  return 0;
}
```

<br/>

<span id="delete"></span>

### delete

---

delete 的实现其实就是 free 函数，简而言之，它是 free 函数的一种语法糖形式，<font color = "red">通常我们使用它取释放掉依据 new 语义所构造的在堆中的内存空间</font>(这块内存空间使用 malloc 所构造出来的同样能够适用，因为 delete 的实现就是 free 函数)

因为 delete 语义的底层实现使用的 free 函数来完成，如果所指定的地址其内存占用实在栈上，那么该调用必定会报错

我们要保证 delete 语义所搭配的指针类型不属于 `void *`，否则会 delete 失败(只是单纯的无法完成内存空间的释放)

需要说明的是，如果需要释放掉使用 `new []` 构造出来的内存空间，那么该语义使用时则必须加上 `[]` 即 `delete []`，原因是因为我们使用 new [] 所开辟的一块内存空间会有一个长度记录，只有我们指定 `delete []` 时才会去查找所记录的长度并决定接下来要根据 delete 表达式所指定的地址决定接下来要释放的长度，当我们只是单一的指定 delete 的时候则只会释放掉这段数组空间的首元素的数据

```cpp
class Person {
public:
  int id;

  Person() {}
  Person(int _id) : id(_id) {}
};

int main(void) {
  int *i = new int(0x400);
  delete i;

  Person *pers = new Person[10];
  delete[] pers;

  return 0;
}
```

<br/>
<br/>

## 类

<span id="类"></span>

类的一些基本性的概念不做阐述，这一节仅讨论类在 cpp 中的底层实现和一些功能使用，下面的代码展示了一个类的最基本定义形式

```cpp
class Person {
public:
  int id;

  Person() {}
  Person(int _id) : id(_id) {
  }
};
```

类和结构体一样，都属于是一种复合型的类型，所以，<font color = "red">类的存储结构同样需要享有[内存对齐的机制](#https://github.com/NGPONG/document/blob/master/C/2019/12_18/C_Programming_Language.md#%E5%85%B3%E4%BA%8E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E9%97%AE%E9%A2%98)</font>(所声明的函数不在当前类所存储的内存段当中，即不会纳入内存对齐的考量范围)

在 cpp 中是允许空类的存在的(即一个没有任何成员声明的类)，对于一个没有任何成员声明的类来说，其实例还是会在内存中占用 **_1 bytes_** 的空间大小，原因是<font color = "red">因为 cpp 需要保证每一个类的实例在内存中都会是独一无二的存在</font>

一个类在进行创建的过程中，其内部的成员初始化顺序永远都是承上启下来进行的，当完成了所有成员的初始化工作后，才开始初始化类的本身 ; 而在一个类的实例在被释放的过程中则为类的本身先进行释放，然后由下至上挨个释放类中的每个成员(单指类本身所占用的内存空间，而某些可能指向一块堆区的成员则需要自己进行手动的释放工作)

一件有意思的事是，<font color = "red">在一个类中所声明的成员函数和类中的非静态成员并不是存储在同一个内存段中的</font>，那么利用这一机制事实上可以完成一些比较骚的操作，即可以使用一个当前类类型的空指针以完成堆声明为公共权限的函数的调用的，需要注意的是，如果使用的是当前类型的空指针来调用当前类中的函数的话，我们需要确保函数的上下文中并没有引用到针对于当前类的实例中存储的成员，否则会报错(因为成员没有经过初始化)

<br/>

<span id="访问权限符"></span>

### 访问权限符

---

在 cpp 中所支持的访问修饰符仅三种
- public
  
- private

- protected

关于它们的各自所起到的功能这里不做赘述，它和其余的语言的设计是一致的，下面的代码展示了访问权限修饰符的使用方式，我们会发现，在 cpp 中声明一个成员的权限是呈一个 **_块_** 来完成的，并不是单独的针对某个成员去进行设置

```c
class Person {
  char gender;   /* none perssion */
public:
  char *name;    /* public perssion */
private:
  int id;        /* private perssion */
protected:
  char *address; /* protected perssion */
};
```

当某个成员并未指定任何权限时，正如上面代码中的 `gender`，那么其默认的访问修饰符则为 `private`

关于 private 权限，有意思的是，在当前类的作用域下所使用的变量(包括函数形参，局部变量，类中的成员)如果其类型属于当前类的话，那么该变量能够得到访问对象中的私有成员的权限

<br/>

<span id="this-和-base"></span>

### this 和 'base'

---

我们在一个类的上下文中，可以使用 **_this_** 关键字来获取到一个指向当前对象实例在内存中的首地址的指针，使用它来完成当前实例上下文成员信息的一些调度，具体来说该指针的类型为一个指针常量，即类型为 **_Type * const_** 的指针，我们不能改变该指针的指向

而关于 **_base_**，在其他语言中它通常指向当前类的基类，而本节中，对于 **_base_** 关键字故意使用了 **_'base'_** 是因为在 cpp 中并没有语法能够让我们直接使用 **_base_**，但是我们却可以通过 `::` 去引用其父级所在的作用域，以获取到父类中的成员信息，当然包括显式调用父级的构造函数也能够通过该符号来完成

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  int id;

  Person(int _id) : id(_id) { }
};

class Student : public Person {
public:
  const char *name;

  Student(const char *_name) : Person::Person(30), name(_name) {
    cout << "Person id = " << Person::id << endl;
    cout << "Student name = " << this->name << endl;
  }
};

int main(void) {
  Student stu("hello,world");
  cout << stu.name << endl;
  cout << stu.id << endl;

  return EXIT_SUCCESS;
}
```

<br/>

<span id="类中的成员的声明和定义"></span>

### 类中的成员的声明和定义

---

类中的成员允许存在声明和定义分开写(<font color = "red">这里不包括普通的成员</font>)，但并不意味着我们可以在一个类的上下文中存在同一个成员的定义和声明，因为这是编译器不支持的语法

为什么这里要区分开普通成员？原因是因为根本没必要将他们加入到考量的范围。类中的类型为 **_普通变量_** 的成员其在内存中的位置是跟随着这个类的实例的创建而创建，跟随着这个实例的释放而释放，也就意味着当一个类中的非静态成员变量的声明在我们构建好该类的一个具体的实例后，这些成员会在调用构造函数 **_之前_** 先按照编译器的实现去初始化一个初始值，当然我们也可以通过所显示指定的构造函数针对成员变量去进行一次再初始化的工作，简而言之，<font color = "red">对于类中的非静态成员变量的初始化过程都无需开发人员来进行关心，因为它们都会在一个类的实例被创建出来后，其所对应的内存也随着类本身的实例化而构建出来</font>

而对于类中的 **_成员函数_**，由于其在内存中的位置并不是跟随着这个实例的创建而创建，具体来说，每一个独特的类中所定义的函数都会在内存中只保有一份针对这个类的独有的内容(虽然其调用是需要依赖于某一个类的具体实例才能够完成，但这只是编译器在编译阶段的一种保护机制，因为对于普通的成员函数我们往往会在里面访问当前实例的一些成员信息，而这时候就可能会有一个问题，假设我们这个类是还未被实例化的状态，并且成员函数里面访问了一些类中的成员信息，这时候成员函数的调用则是不安全的)，也就是说一个普通的成员函数的声明并不会随着一个类的实例化后编译器为我们自动初始化一份默认的定义，所以<font color = "red">对于出现在一个类中的普通函数成员的声明，如要使用它，那么我们就必须还要在一个 **_全局命名空间(一个可被发现的命名空间)_** 下通过 `::` 关键字来引用到该成员函数所在的类的作用域，并以此去访问成员函数声明的符号，然后通过此链接符号来继续往下指定出该成员函数声明的具体定义</font>，如下面的代码，我们对于一个类中的普通函数声明完成了一次符号链接的定义，这里需要扩充一点的是，<font color = "red">我们对于一个类中的成员函数在进行链接定义的过程中是可以暂时可以无视掉为类中的成员所修饰的访问标识符的</font>

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  void hello();
};

void Person::hello() {
  cout << "hello,world" << endl;
}

int main(void) {
  Person per;
  per.hello();

  return EXIT_SUCCESS;
}
```

<font color = "red">在这里其实漏掉了一个角色，即 **_静态成员_**，关于它们的信息会附带更多额外的信息，所以我会在[其它节](#关于类中的静态成员)中赘述</font>

<br/>

<span id="成员函数和函数指针"></span>

### 成员函数和函数指针

---

!!! 
    <font color = "red">以下的玩法仅适用于 GCC 编译器</font>

某个类中的成员函数其所属的类型，对比普通全局函数的类型，成员函数的类型表示还需要通过 `::` 号引用至成员函数所在类型的作用域下并且通过 `()` 提升类型引用符的优先级才算一个类中成员函数类型的完整语义，例如如下面的代码，虽然两个函数的返回值和参数列表都是一致的，但是当它们站在整个函数类型的本身的视角上时，两者是存在区别的: 

```cpp
#include <iostream>
using namespace std;

bool foo(int _val) {       /* bool (int) */
  cout << _val << endl;
}

class TEST {
public:
  bool foo(int _val) {     /* bool (TEST::)(int) */
    cout << _val << endl;
  }
}
```

正因为此，当我们想使用一个函数指针去修饰一个成员函数时，也必须要保证，函数指针的类型是属于成员函数的原始类型才能够完成正确的定义，如下面的代码 :

```cpp
class TEST {
public:
  bool m_foo(int _val) {   
    cout << _val << endl;
  }
}

void foo() {
  /* 通过一个实例的依赖去获取成员函数在内存中的地址 */
  TEST __t;
  bool (TEST::*invoker_instance)(int) = __t.m_foo;

  /* 通过 :: 操作符去引用至具体某个类型下并拿到成员函数的名字同样也可以用作获取成员函数地址的一种方式 */
  bool (TEST::*invoker_none)(int) = TEST::m_foo;
}
```

需要补充的是，由于类中所声明的成员函数和类中的非静态成员并不是存储在同一个内存段中的，简而言之该成员函数的地址获取并一定需要依赖于一个类的实例，即，我们可以直接通过 :: 操作符去引用具体某个类下的成员函数也同样是能够用于函数指针的定义，这一点也具体到代码中 `invoker_none` 的声明

虽然成员函数和类的实例并不存储在一个内存段内，但并不意为着成员函数的调用就不需要依赖于类的实例本身了，正如前面声明了一个空的类指针也可以调用一个成员函数，但是它的调用的确是依赖了一个类的实例了，只不过它是空的，这就好比所谓的做做样子，我们可以简单地理解为 : <font color = "red">成员函数不管是在什么情境下，其调用是必须要依赖于函数所在类型的实例才能完成的</font>，那么对于我们在上面所修饰的一个关于类中成员函数类型的函数指针的调用，也需要依赖于一个类的实例，请查看下面的代码 : 

```cpp
class TEST {
public:
  bool m_foo(int _val) {   
    cout << _val << endl;
  }
}

void foo() {
  /* 通过一个实例的依赖去获取成员函数在内存中的地址 */
  TEST __t;
  bool (TEST::*invoker_instance)(int) = __t.m_foo;
  (__t.*invoker_instance)(10);

  /* 通过 :: 操作符去引用至具体某个类型下并拿到成员函数的名字同样也可以用作获取成员函数地址的一种方式 */
  bool (TEST::*invoker_none)(int) = TEST::m_foo;
  (__t.*invoker_none)(10);
}
```

这里要补充的是，我们查看 `invoker_none` 的声明方式，它是直接通过引用类的作用域去获取到需要指向的函数本身的，这或许可能会有疑问，既然它获取成员函数的方式对比 `invoker_instance` 来说，并不是通过一个已经初始化过的实例来获取的，那么它的调用如果内部访问了类内部的一些成员的话，是否会产生错误(访问了未被初始化的成员)？答案是否定的，因为虽然它的声明方式是如此，但是我们可以看到，它的调用实实在在的确是依赖了一个该类的实例来完成，也就是不存在上面所说的那种情况

<br/>

<span id = "构造函数"></span>

### 构造函数

---

构造函数的知识点我们快速过一遍即可，它和大多数语言都存在着共同性

- 构造函数无返回值，但是我们可以显示的指定构造函数的形参，并且还支持重载

- 构造函数必须声明为 public

- 构造函数名由 类名 所组成

- 当一个类中没有定义构造函数时，编译器再进行编译时会自动地为我们添加一个 空实现 的构造函数，否则不会添加

- <font color = "red">构造函数的调用发生在类实例创建之时，实例的创建依赖构造函数来完成</font>，也就是说我们可以显示的指定当前类中的具体某个构造函数来完成类的实例化的创建工作

<br/>

<span id = "拷贝构造函数"></span>

#### 拷贝构造函数

<font color = "red">当一个构造函数的形参只有一个，并且形参的类型为当前类型的 **_'常量左值引用'_** 的时候，那么这个构造函数更应该称为拷贝构造函数</font>，需要注意的是，如果形参类型虽然是类本身，但是去并不属于一个引用时，编译器会认为该构造函数属于一个不符合标准规范拷贝构造函数，故会导致编译失败

**_拷贝构造函数有什么用？_**

<font color = "red">我们可以使用拷贝构造函数去拷贝 **_一个相同类型不同实例中的成员_** 以创建一个新的实例</font>，需要重点强调的是，<font color = "red">它是一种形参类型特殊的构造函数，也就是说它的调用往往初始化一个实例前提下进行</font>，并且我们还要保证初始化实例时所指定的形参能够映射到拷贝函数中的形参定义(常量左值引用)，即需要一个求值 $result$ 结果为当前类型的 **_左值/右值表达式_**

需要注意的是，能够使用 **_右值表达式_** 去完成拷贝构造函数的调用是由于其形参类型为 **_常量左值引用_** 所导致的，<font color = "red">事实上，拷贝构造函数的调用仅仅只是针对于 左值表达式 的拷贝而不是右值表达式</font>，<font color = "red">对于右值表达式存在 **_将亡_** 的特性来说，我们往往需要使用的是 移动 而不是 拷贝</font>，如果我们把拷贝构造函数的形参类型改写为仅仅只是 **_'左值引用'_** 的情况下也能够构成一个拷贝函数的定义，但是通常在书写的时候往往都会加上 **_const_** 以修饰，其目的主要是为了在一个类没有定义 移动构造 函数的情况下，我们同样也可以使用一个 当前类型的右值表达式 去完成一个当前类型的新实例构造，而是否选择使用移动构造函数则由开发人员自己去定义了

```cpp
class Person {
public:
  int age;

  /* Constructor */
  Person(int _age): age(_age) {}

  /* Copy-constructor */
  Person(const Person &per) {
    this->age = per.age;
  }
};

int main(void) {
  Person per(0x400);

  Person cp_per_1 = per;
  Person cp_per_2(per);
  Person cp_per_3 = Person(per);
  Person *cp_per_4 = new Person(per);

  return 0;
}
```

**_拷贝语义_**

拷贝语义，即一个拷贝构造函数其上下文中需要承担的工作，对于拷贝构造而言，无非就是把 **_that_** 中的数据拷贝到 **_this_** 身上，其实，更加值得我们引起关注的其实是在堆中所分配的内存，对于某个需要在堆中分配内存的成员，我们需要做的是 : 
1. 如果该成员已拥有资源，则优先释放

2. 为该成员分配一块新的内存段

3. 将 **_that_** 中的该成员所指向的数据 **_'拷贝'_** 至刚刚为 **_this_** 所申请内存空间的成员身上

**_拷贝赋值运算符重载_**

关于运算符重载，请参考[这一节](#TODO)

拷贝构造函数的调用是需要和一个对象实例的初始化过程所绑定起来的，<font color = "red">当我们想使用一个当前类型的 **_左值/右值表达式_** 去绑定一个已经实例化好的变量时，则需要使用到 **_拷贝赋值运算重载_**</font>，需要重点强调的是，拷贝赋值运算重载其特性、所需遵守的规范和拷贝构造函数是一致的，只是对于拷贝赋值运算重载来说，其需要绑定的是一个已经初始化好的成员，而对于拷贝构造函数来说，它的绑定是一个成员的初始化开始的过程

```cpp
class Person {
public:
  int age;

  /* Constructor */
  Person(int _age): age(_age) {}

  /* Copy-constructor */
  Person(const Person &per) {
    this->age = per.age;
  }

  /* Copy-assignment-operator */
  Person &operator=(const Person &per) {
    this->age = per.age;
    return *this;
  }
};

int main(void) {
  Person per(0x400);
  Person cp_per(0x100);

  /* copy assignment operator */
  cp_per = per;

  return 0;
}
```

<br/>

<span id = "移动构造函数"></span>

#### 移动构造函数

<font color = "red">当一个构造函数的形参只有一个，并且形参的类型为当前类型的 **_'右值引用'_** 的时候，那么这个构造函数更应该称为移动构造函数</font>

**_移动构造函数有什么用？_**

在[拷贝构造函数](#拷贝构造函数)中提到过，拷贝构造函数能够依据一个已有的实例为基准，将其在内存中的数据拷贝至一个新的实例身上，但是现在考虑两个问题 :

1. 假设原始实例(**_that_**)所保存的数据过于庞大，那么拷贝到目标实例(**_this_**)身上是一件性能损耗较大的事情，那么我们是否可以仅仅只是对需要拷贝的数据做一次移动，即把原始数据源身上的数据直接移动到目标数据源身上而不进行拷贝，使目标数据源的实例能够重新开始管控原始数据源在内存中的生命周期

2. **_右值表达式_** 虽然也能够用于构成拷贝构造函数的调用，但是，就拷贝构造函数而言，它所服务的对象更应该是 左值表达式 而不是 右值表达式(能够支持 右值表达式 的特性仅仅是因为拷贝构造函数的 左值引用 通过 const 进行了修饰)，对于 右值表达式 而言，由于其存在着 将亡 的特性，那么再结合第一点要求，假设我们能够有一个构造函数，它能够专门的去使用 右值表达式 去初始化一个新的实例，并且其还能够享有在右值表达式(**_that_**)即将消亡前能够把其数据移动至目标实例(**_this_**)身上的特性(也就是不浪费右值表达式所创建的无名临时变量所占用的计算)，那么移动构造函数就是专门服务于此

<font color = "red">我们可以使用移动构造函数将原始实例 右值表达式(原始实例,**_that_**) 中的成员数据 **_'移动'_** 到目标实例身上，以完成目标实例的初始化构建工作</font>，需要重点强调的是，<font color = "red">它是一种形参类型特殊的构造函数，也就是说它的调用往往实在初始化一个实例的情况下进行的</font>，并且我们还要保证初始化实例时所指定的形参能够映射到移动函数中的形参定义(右值引用)，即需要一个求值 $result$ 结果为当前类型的 右值表达式，我们可以简单的理解为，<font color = "red">移动构造函数能够在某些特定情况下(**_采用右值来赋值或构造对象时_**)使用廉价的移动语义替换昂贵的拷贝语义的问题</font>

```cpp
class Person {
public:
  const char *name;

  /* Constructor */
  Person(const char *_name): name(_name) {}

  /* Copy-constructor */
  Person(const Person &per) { this->name = per.name; }

  /* Move-constructor */
  Person(Person &&per) {
    this->name = per.name;
    per.name = nullptr;
  }
};

Person foo() {
  Person per("hello,world");
  return per;
}

int main(void) {
  Person per = foo();

  return EXIT_SUCCESS;
}
```

**_移动语义_**

移动语义，即一个移动构造函数其上下文中需要承担的工作，对于移动构造而言，它所需要做的工作就是要把原始实例(**_that_**)身上的数据移动到目标实例(**_this_**)身上，并且把原始数据源身上的成员数据都置为空，我们可以理解为就是让目标实例(**_this_**)去重新接管原始实例(**_that_**)身上的成员数据，我们需要做的是: 

1. 如果该成员已拥有资源，则优先释放
   
2. 将原始实例中的成员数据移动(**_赋值_**)给目标实例中的具体成员
   
3. 将原始实例中已经进行过移动操作的成员都重新值为空(**_重新接管_**)


**_移动赋值运算符重载_**

关于运算符重载，请参考[这一节](#TODO)

拷贝构造函数的调用是需要和一个对象实例的初始化过程所绑定起来的，<font color = "red">当我们想使用一个当前类型的 **_左值/右值表达式_** 去绑定一个已经实例化好的变量时，则需要使用到 **_拷贝赋值运算重载_**</font>，需要重点强调的是，拷贝赋值运算重载其特性、所需遵守的规范和拷贝构造函数是一致的，只是对于拷贝赋值运算重载来说，其需要绑定的是一个已经初始化好的成员，而对于拷贝构造函数来说，它的绑定是一个成员的初始化开始的过程

移动构造函数的调用是需要和一个对象实例的初始化过程所绑定起来的，<fonr color = "red">当我们想使用一个当前类型的 **_右值表达式_** 去绑定一个已经实例化好的变量时，则需要使用到 **_移动赋值运算重载_**</font>，需要重点强调的是，移动赋值运算重载其特性、所需遵守的规范和移动构造函数是一致的，只是对于移动赋值运算重载来说，其需要绑定的是一个已经初始化好的成员，而对于移动构造函数来说，它的绑定是一个成员的初始化开始的过程

```cpp
class Person {
public:
  const char *name;

  /* Constructor */
  Person(const char *_name): name(_name) {}

  /* Copy-constructor */
  Person(const Person &per) { this->name = per.name; }

  /* Move-constructor */
  Person(Person &&per) {
    this->name = per.name;
    per.name = nullptr;
  }

  /* Move-assignment-operator */
  Person &operator=(Person &&per) {
    this->name = per.name;
    per.name = nullptr;

    return *this;
  }
};

Person foo() {
  Person per("hello,world");
  return per;
}

int main(void) {
  Person per = foo();
  per = foo();

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "编译器自动添加的拷贝构造函数和拷贝复制运算符"></span>

#### 编译器自动添加的拷贝构造函数和拷贝复制运算符

<font color = "red">对于一个能够声明构造函数的复合类型来说，编译器在我们并没有额外添加 **_拷贝构造函数/移动构造函数_** 的前提下(除非实现了任意一方)，都会为我们自动添加一个形参类型为 **_'常量左值引用'_** 的 **_拷贝构造函数和拷贝赋值运算符_** 以完成对于 左值/右值表达式 基本的初始化构造或者赋值的支持</font>，需要注意的是，<font color = "red">该拷贝构造函数和拷贝赋值运算符仅仅是做一次基础的逐字节拷贝工作，故该自动添加的拷贝构造函数和拷贝赋值运算符可能会在某些情况下会出现 **_深拷贝和浅拷贝_** 的问题</font>

<br/>

<span id = "拷贝移动消除"></span>

#### 拷贝/移动消除

该特性是 cpp11 起延伸至 cpp17 中所支持的一种特性，<font color = "red">它属于一种编译器的优化技术，能够在在一些特定情况下，在原本需要 复制/移动构造函数 的调用替换为 复制/移动构造函数 以避免可能出现的性能损失的问题</font>

- 以下统称 <font color = "red">具有自动生存期、非volatile、非函数形参、非 catch 捕捉</font> 的对象为 **_这类对象_**

- 当存在一个函数，返回值类型为自定义类，并且调用方使用这个函数的返回值去构造相应类型的对象，然后返回的是 **_这类对象_**，则会发生复制消除

- throw 了一个不超过最内层 try 的 **_这类对象_**，可能发生复制消除

- catch 了一个与 throw 相同类型的 **_这类对象_**，并且没有复用这个对象(即跳过该 catch 子句参数的复制构造函数和析构函数以外的原因更改可观察行为)

- 当返回了一个匿名的对象，并且有对象使用该函数返回的对象进行构造

- 常量表达式和常量初始化时(待定)

- 在不发生临时变量实质化时多次连环的复制/移动

```cpp
class Person {
public:
  const char *name;

  /* Constructor */
  Person(const char *_name): name(_name) {}

  /* Copy-constructor */
  Person(const Person &per) { this->name = per.name; }
  
  /* Move-constructor */
  Person(Person &&per) {
    this->name = per.name;
    per.name = nullptr;
  }

  /* Move-constructor */
  Person(Person &&per) {
    this->name = per.name;
    per.name = nullptr;
  }

  /* Move-assignment-operator */
  Person &operator=(Person &&per) {
    this->name = per.name;
    per.name = nullptr;
    return *this;
  }
};

Person foo(void) {
  /* call Person constructor & Person move constructor & Person destructor */
  Person per = Person((char *)"Hello,World", 1024);

  /**
   * By default, this step calls the copy constructor,
   * but due to the nature of move/copy elimination su
   * pported since CPP11,this step actually calls the m
   * ove constructor 
  */
  return per;
}

int main(void) {
  /* call Person move constructor */
  Person per = foo();
  return EXIT_SUCCESS;
}
```

<br/>

<span id = "explicit关键字"></span>

#### explicit 关键字

我们可以通过 隐式法 的方式去指定一个类中的某个构造函数来对完成该类的实例初始化工作，但是 隐式法 去对类进行实例化操作对于代码而言可读性会比较低，为了避免开发人员滥用隐式法来对一个类进行实例化，我们可以针对所需要隐藏的构造函数来添加上该关键字以来达到效果，当一个类中的某个构造函数使用了该关键字后，那么开发人员再也不能通过隐式法的方式去匹配到类中的具体某个构造函数以使用它来对类进行实例化(只能通过其它方式来匹配这个构造函数)

```cpp
class Person {
public:
  const char *name;

  /* Constructor */
  explicit Person(const char *_name): name(_name) {}
};

int main(void) {
  Person per = "hello,world"; /* fault */

  return 0;
}
```

<br/>

<span id = "构造函数中的初始化参数列表"></span>

#### 构造函数中的初始化参数列表

我们可以通过在构造函数中指定一个初始化参数列表，以让构造函数在调用的过程中可以使用构造函数中所指定的形参(也可以直接指定具体的值)来完成对类中的成员的初始化工作，具体语法则为 : <font color = "red">构造函数名(参数A) : 成员A(参数A),成员B(值) { }</font>

<font color = "red">初始化参数列表的定义类似于对类中的成员使用 **_括号法_** 的方式进行初始化</font>，诚然，如果初始化参数列表中的某个成员为一个存在构造函数类型的成员的话，那么 `()` 内所指定的值则权当该成员构造函数所对应的形参来使用(编译器会依据所录入的参数的不同自动匹配到最合适的构造函数以完成该成员的实例化操作)

<font color = "red">事实上，初始化列表不单单可用来初始化当前类身上的成员属性，我们还可以利用它来完成显式的调用父类中的构造函数</font>，需要注意的是，由于一个存在继承体系的类的初始化操作是由父类先初始化完毕再到子类的，也就意味着，<font color = "red">我们在初始化列表中显式调用父类的构造函数时，它的调用顺序理应放在最前</font>

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  int id;
  Person(int _id) : id(_id) { }
};

class Student : public Person {
public:
  const char *name;

  Student(const char *_name) : Person::Person(30), name(_name) {
    cout << "Person id = " << Person::id << endl;
    cout << "Student name = " << this->name << endl;
  }
};

int main(void) {
  Student stu("hello,world");

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "析构函数"></span>

### 析构函数

---

- 析构函数无参无返回值

- 析构函数必须声明为 public

- 析构函数名由 <font color = "red">~类名</font> 所组成

- 当一个类中没有定义析构函数时，编译器在进行编译时会自动地为我们添加一个 空实现 的析构函数，否则不会添加

- <font color = "red">析构函数无需手动调用，当一个类的实例被释放时，析构函数自动由编译器来完成调用</font>，这个时机通常发生在栈帧的出栈亦或者手动 delete 的情景

```cpp
class Person {
  const char *name;
public:
    ~Person { 
      if(name != nullptr) {
        delete name;
      }
    }
}
```

<br/>

<span id = "关于类中的静态成员"></span>

### 关于类中的静态成员

---

一个类中的静态成员，按照类型来区分的话，我们可以划分为 : **_静态函数_** 和 **_静态变量_**

由于静态成员使用的是 **_'static'_** 关键字所修饰，也就是说，<font color = "red">它们存储在内存的静态存储区中而不是存储在一个类的实例所对应的内存段中，并且它们会在编译时就已分配好了内存</font>，需要注意的是，<font color = "red">类中的静态成员并不是一个内部链接符号，意味着它的使用和动态链接的作用域并不是只针对当前的编译单元之中</font>

类中的静态成员同样受类中的访问修饰符的限制，简而言之<font color = "red">就是说在调用的过程中受访问标识符的影响</font>

<font color = "red">对于类中的静态变量而言，编译器允许我们指定这个静态变量的类型为当前对象的类型</font>

需要注意的是，<font color = "red">类中静态函数虽然是声明在类中，但是却无法直接引用当前类中的非静态成员，只能够引用已经被正确定义过的静态成员，反之，同样定义在类中非静态函数是能够引用类中的静态成员的</font>，这是因为静态成员在内存中的存储段是独立于基于实例的非静态成员的，就类中静态函数而言，我们并不需要依赖于某个类的实例来完成它的调用(虽然是可以通过一个类的实例来调用声明在一个类中的静态成员，即使于此，它的调用还是不需要依赖于某个类的实例)，既无法访问到针对实例而言的非静态成员，而对于类中的非静态函数来说，由于静态成员是存储于内存的针对当前类型的独有的一份数据，故它在调用的时候是能够获取到当前类中的静态成员的内容的，我们也可以简单的理解为: <font color = "red">非静态成员在初始化之前，静态成员就已经初始化好了，而静态成员在初始化之前，非静态成员一定还没初始化好</font>

<br/>

<span id = "静态成员的声明和实现"></span>

#### 静态成员的声明和实现

**_静态变量_**

如果一个静态变量是直接声明在类中并赋予定义的情况，则必须添加 `cost` 关键词进行修饰，否则会编译报错，简而言之就是<font color = "red">静态变量如果是在类中进行定义的话，它必须是一个静态常量</font>

反之，<font color = "red">如果是在一个类的内部使用的是声明，而在外部对其进行额外定义的话则没有常量使用的限制</font>，但是针对这种情况，我们需要明白其实现，<font color = "red">静态成员变量的声明其实是一种 **_'不完整的类型'_** ，只有当我们对这个类中的静态变量在 **_全局命名空间下_** 进行了一次符号链接形式的定义后，才能使这个不完整的类型真正意义上的融入到编译器所需为其分配的内存空间中</font>，简而言之就是能够使编译器发现我们在这个类中所声明的不完整的类型了，否则我们就无法使用这个静态成员，如果使用则会造成无法编译通过，需要注意的是，<font color = "red">我们在全局命名空间下针对这个在类中的静态变量的声明并不一定需要完成一次完整的定义，我们只是单独的进行一次声明操作也是可以的，因为我们这么做的目的只是为了让原有的不完整的类型变成完整，以让编译器能够认识到该变量的完整性以至在使用它之前编译器能够自动的为其赋予一个含有默认值的定义(变量在使用前必须要有其定义，否则编译器会隐式的把该变量的声明转化为定义，并赋予一个默认值)</font>

**_静态函数_**

对于静态成员函数的定义没什么好说的，我们只需要知道它在调用时，和普通函数的区别即可

对于静态成员函数的声明其实也没什么好说的，因为我们对于静态函数声明所需进行的符号链接的定义的方式也好还是所需注意的事项，它都和普通函数是保持一致的

**_代码总结_**

下面的代码，我们对于静态变量的定义和声明做了一次归纳

```cpp
#include <iostream>
using namespace std;

class Person {
private:
  /* 仅有声明的静态变量 */
  static int Age;

public:
  /* 仅有声明的静态变量 */
  static char *Name;

  /* 静态变量直接在类的内部进行定义的话，必须要声明为常量 */
  const static char Gender = 'M';

  /* 直接在类中定义的静态函数，它和普通函数的定义方式无区别，更值得我们注意的是该函数上下文的使用方式 */
  static void Set_Age(int age) {
    Person::Age = age;
    Age = age;
  } 

  /* 仅有声明的静态函数 */
  static void Print();
};

/**
 * 这里只是对该静态变量做一个声明，但是同样也是可以使用，因为该声明能
 * 够把原来在类中的不完整类型归纳玩一个完整的声明了，即这里能够被编译
 * 器初始化到内存的静态存储区中去，即初始化默认值为 0 此外，由于我们
 * 对于类中的静态变量的定义的过程中是可以暂时的无视掉原有静态类型所修
 * 饰的访问标识符的，即该成员原本是修饰为 private 的但我们还是能够对
 * 其进行一次定义使之构造为一个完整的类型
*/
int Person::Age; 

/* 静态成员的定义，在外部定义的静态成员无需作为常量而存在 */
char *Person::Name = (char *)"NGPONG";

/* 静态函数的定义，其定义方式和注意事项和普通函数并无区别，值得我们关注的是该函数定义上下文的使用方式 */
void Person::Print() {
  cout << "Person name = " << Person::Name << endl;
  cout << "Person age = " << Person::Age << endl;
};

int main(void) {
  Person::Set_Age(23);
  Person::Print();

  return 0;
}
```

<br/>

<span id = "常函数和常对象"></span>

### 常函数和常对象

---

<span id = "常函数"></span>

#### 常函数

当一个对象中成员函数的末尾添加了 **_const_** 关键字后，则意为该函数为一个常函数

<font color = "red">常函数上下文中，不能 **_直接修改_** 在当前类中未使用 **_mutable_** 关键字所修饰的成员，并且无法调用除了常函数以外的其它函数</font>

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  int age;

  Person(int _age): age(_age) {}

  void speak() const {
    this->age = 10; /* fault */
    cout << this->age << endl;
  }
};

int main(void) {
  Person per(0x400);
  per.speak();

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "常对象"></span>

#### 常对象

当一个对象的实例的声明使用了 **_const_** 关键字修饰，则意为该对象为一个常对象

<font color = "red">我们无法通过 直接修改 的方式修改常对象类型中，未使用 mutable 所修饰的成员变量，并且无法调用除了常函数以外的其他函数</font>

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  int age;

  Person(int _age): age(_age) {}
};

int main(void) {
  const Person per(0x400);
  per.age = 100; /* fault */

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "mutable"></span>

#### mutable

该关键字能够用于修饰一个类中的成员变量，当某个成员变量使用了该关键字，那么 常函数/常对象 则可以通过 **_直接修改_** 的方式对其进行修改

```cpp
class Person {
public:
  mutable int age;

  Person(int _age): age(_age) {}

  void speak() const {
    this->age = 10; /* success */
    cout << this->age << endl;
  }
};

int main(void) {
  const Person per(0x400);
  per.speak();

  per.age = 0x100; /* success */

  return EXIT_SUCCESS;
}
```

值得引起注意的是，<font color = "red">上面对于未使用 **_mutable_** 关键字的成员变量在 **_常函数/常对象_** 中都不能修改的定义都采用的是 **_直接修改_**，意味着我们是可以通过指针的途径来完成对它的间接修改的</font>

<br/>

<span id = "类的前置声明"></span>

### 类的前置声明

---

类的前置声明主要作用于防止编译器由于代码呈上至下的编译方式导致某些时候对于一些类的使用无法访问的情况，<font color = "red">对于一段前置声明的类来说，如果在出现该类的具体定义之前的地方去使用它是无法访问里面的成员的，因为其只是作用于一段声明</font>，我们通常用它来声明一个该前置声明类型的指针

```cpp
#include <iostream>
using namespace std;

/* 前置声明 Person 类 */
class Person;

/* 利用前置声明构造一个 Person 类的指针 */
Person *per;

void foo() {
  /* error */
  /* 由于在出现 Person 的具体定义之前使用了该指针，故这里会导致编译报错 */
  per = new Person(100);
}

class Person {
public:
  int age;

  Person(int _age): age(_age) {}
};

int main(void) {
  /* success */
  /* 在使用 per 的时候已经出现了 Person 类的定义，故这里能够成功调用 */
  per = new Person(0x400);
  cout << per->age << endl;

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "继承"></span>

### 继承

---

c++ 的继承方式和其余的 OOP 语言一致，其语法为 : <font color = "red">class derived-class : access-specifier base-class</font>
- derived-class: 子类

- base-class : 基类

- access-specifier : 继承类别

在这里，其实重点需要说明的就是这个继承类别，一个基类可以被继承自 public, protected, private 这三种类别，不同的继承类别能够决定基类延伸至子类中的成员其访问保护性，简而言之就是可以间接的改变基类中成员的访问修饰符，<font color = "red">一般而言，我们使用继承都是用的 public 的形式来完成，因为这个形式是最直接的</font>

- 公有继承(public) : 当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问

- 保护继承(protected) : 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员

- 私有继承(private) : 当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员

<br/>

<span id = "继承的内存模型"></span>

#### 继承的内存模型

一个存在继承派生关系的派生类在实例化的过程中，会先初始化其父类的所有成员(**_无视访问修饰符_**)到一段内存中，然后再以这段内存为基础继续往下初始化上级基类往下所派生的子类的成员，直至初始化自己，<font color = "red">也就是说，一个类的实例如果存在基类，那么其在内存中的首地址往下所延伸的地址都是先由其基类中的成员所占用，然后以基类成员所占用的内存地址的结束为基准，继续往下才是子类的成员所存储的内存地址，如下面的代码</font>

```cpp
class person_base {
private:
    char m_gender = 1;
};

class student : public person_base {
public:
    int m_age;
    char m_id = 1;
};
```

其在内存中的模型如下图所示

```text
                                +---------+
                          +-----+0000 0000|
                          |     +-----------> 0x0000000B
                          |     |0000 0000|
        student::m_id <---+     +-----------> 0x0000000A
                          |     |0000 0000|
                          |     +-----------> 0x00000009
                          +-----+0000 0000|
                                +-----------> 0x00000008
                          +-----+0000 0000|
                          |     +-----------> 0x00000007
                          |     |0000 0000|
       student::m_age <---+     +-----------> 0x00000006
                          |     |0000 0000|
                          |     +-----------> 0x00000005
                          +-----+0000 0000|
                                +-----------> 0x00000004
                          +-----+0000 0000|
                          |     +-----------> 0x00000003
                          |     |0000 0000|
person_base::m_gender <---+     +-----------> 0x00000002
                          |     |0000 0000|
                          |     +-----------> 0x00000001
                          +-----+0000 0000|
                                +-----------> 0x00000000
```

通过 vs 开发人员工具输入 `cl /d1 reportSingleClassLayout__(类型) __(文件名)` 来查看的结果

```text
class student   size(12):
  +---
0 | +--- (base class person_base)
0 | | m_gender
  | +---
  | <alignment member> (size=3)
4 | m_age
8 | m_id
  | <alignment member> (size=3)
  +---
```

在这里由于内存对齐的问题，故原本存在于基类中的类型为 char 的成员(`m_gender`)的内存占用的为4个字节，不过这里不进行额外的展开，详情请参考 [这一篇文章](#https://github.com/NGPONG/document/blob/master/C/2019/12_18/C_Programming_Language.md#%E5%85%B3%E4%BA%8E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E9%97%AE%E9%A2%98)，需要额外说明一下的是，<font color = "red">基类是一个复合类型，而派生类继承自基类中的成员无非就是把基类中的成员初始化在派生类中所在的内存段当中，即，它们是一体的，所以我们在计算基类中的成员的偏移位置所需的 **_对齐单位_** 的参考并不是以派生类的视角为基准，而是以基类的视角所构成的 **_对齐单位_** 为准，这里要和直接声明在类中的类型为复合类型的成员不同，对于它们去计算在内存中的偏移单位时，对齐单位 的参考是以当前复合类型的视角为基准</font>

其实我们通过继承与派生在内存中的模型，我们可以总结为 : <font color = "red">子类派生自父类，实质上它是继承了父类中所有的成员(无视访问修饰符)(非实例构造型函数，如: 构造函数, 析构函数, 等号运算符重载函数)</font>，<font color = "red">一个子类在实例创建的过程中，会 **_优先_** 初始化其所继承的父类(默认情况下调用父类的默认构造函数)中的所有成员至以子类实例为基准所构建的内存段的起始位置上，然后在 以父类中的成员所构建的数据所在内存地址的结束位置 继续往下初始化子类中的成员数据</font>

<font color = "red">需要严格说明的是，派生类在实例创建的过程中并 **_不是_** 又在内存中创建了一份父类的实例，然后子类通过某种方式 **_'引用'_** 了这个在不同内存段中的基类以达到访问基类中的成员的目的</font>，继承只是一个语言在抽象上的概念，通过这种抽象的 **_'继承关系'_** 来把派生和基类区分开来，实质上基类在确定好其派生关系后，其所有的成员在内存中的数据都会在派生类创建的过程中把它们优先初始化在以子类为基准的内存段上，我们可以从 **_'派生类的视角'_** 理解为：派生类和基类是一体的

有了 cpp 中类的内存模型为基准，我们可以进行一个有趣的实验 : 我们都知道，派生类所继承自基类中的成员会受到基类中成员声明的访问修饰符的影响的，也就意味着基类中某个声明为私有的成员在其派生类中是无法通过直接的方式去访问的，当然这里重点强调的是 **_'直接'_**，上面对于继承的内存模型我们会发现，实际上基类中的所有成员是存储在派生类的实例其所对应的内存段当中，那么我们可以大胆的认为基类中声明为 `private` 的成员实际上并不是 `private` 的，因为我们完全可以通过一个派生类的内存首地址，通过地址偏移的方式找到那个声明为 `private` 的在基类的成员其在内存中的首地址，然后通过解引用的方式以操作它，事实的确如此，再次强调的是，<font color = "red">继承只是语言上的一个抽象的功能，是编译器层面上为了使我们更方便去编写 oop 的工程项目所提供的功能，实际上我们要怎么玩完全由开发人员来决定</font>

```cpp
class person_base {
private:
  char m_gender = 'K';
};

class student : public person_base {
public:
  int m_age;
  char m_id;

public:
  void printp(void) {
    printf("%c\n", *(char *)this);
  }
};
```

<br/>

<span id = "子类和父类实例的释放顺序(析构函数的调用顺序)"></span>

#### 子类和父类实例的释放顺序(析构函数的调用顺序)

子类的实例在被释放的时候，会先释放掉子类中的成员(调用子类的析构函数)，然后再去释放其所继承自父类中的成员(调用父类的析构函数)，<font color = "red">造成这种原因主要是因为 栈 的 FIFO 的机制所导致的</font>，前面在[继承的内存模型](#继承的内存模型)中提到，一个子类在进行实例化的过程中，会先初始化其父类中的成员至子类的内存段中，然后去初始化子类中的成员，也就是说子类的初始化顺序是在其父类中的成员初始化完毕后发生的，所以在子类即将被释放的时候，也会先释放掉子类中的成员然后再去释放掉其所继承下来的父类中的成员

我们可以把这个类的构造和析构的过程理解成一个盖房子的工作，再开始之前，我们往往需要设定一份蓝图，然后从外部开始建造，建造完毕后开始装填内部的装饰，而拆卸时的顺序则反之

<br/>

<span id = "显示指定父类构造函数进行父类成员的初始化工作"></span>

#### 显示指定父类构造函数进行父类成员的初始化工作

子类在实例化的过程中会先初始化其所继承下来的父类中的成员，即调用父类中的构造函数，如在没有进行显式指定的情况下，编译器对此的调用都是父类中的 **_默认构造函数_**，那么，当我们在子类中并没有显式的指定父类初始化所需的构造函数，并且父类中有一个我们所自定义的构造函数时，子类在进行实例化时就会失败，原因在于当我们在父类中自定义了一个构造函数后，编译器就不会为其再去提供一个默认的构造函数，那么这个子类在进行实例化的过程中，由于编译器找不到其父类的默认构造函数所以报错了，解决这一办法只需要在其父类中添加一个默认的构造函数即可解决，当然更推荐的做法则为在子类的构造函数的 [初始化列表](#构造函数中的初始化参数列表) 中显示指定其父类初始化所需使用的构造函数即可解决 ： <font color = "red">basic(type1.type2,……)</font>，<font color = "red">在这里需要注意的是，我们尽量保证显式指定基类的构造函数调用要放在初始化列表的最前面，虽然不遵守这一规则也能够编译通过并正常使用，但是这样的话就不太符合派生类的实例在初始化的过程中会先初始化其父类然后再初始化派生类中的成员这一逻辑关系了(只是看着不像，并不意味着我们这们写会造成先初始化派生类内部的成员)</font>

```cpp
#include <iostream>
using namespace std;

class Person {
public:
  int id;
  Person(int _id) : id(_id) { }
};

class Student : public Person {
public:
  const char *name;

  Student(const char *_name) : Person::Person(30), name(_name) {
    cout << "Person id = " << Person::id << endl;
    cout << "Student name = " << this->name << endl;
  }
};

int main(void) {
  Student stu("hello,world");

  return EXIT_SUCCESS;
}
```

<br/>

<span id = '引用父类中的成员'></span>

#### 引用父类中的成员

**_关于一段继承体系中，调用存在二义性的问题_**

在一个类所属的一段继承关系中，我们要保证成员之间的调度不会出现二义性的问题，对于 : 

- 派生类和基类中存在名字相同的成员的时候，调用会存在二义性，编译器会直接隐藏掉基类中会因为此次调用而造成二义性冲突的成员(如果是所冲突的成员为函数，则隐藏掉其包括所有重载的版本)，也就意味着可能我们本次针对该成员的调用是想访问在其基类实例中该成员的信息，但是实际上获取到的却是当前派生类实例中该成员的信息

- 派生类所继承的多个基类中存在同名成员时，调用会存在二义性，因为编译器并不知道该调用到底是针对派生类继承的基类 **__basicA_** 中的成员亦或者说继承的基类 **__basicB_** 中的成员，故针对这种情况下编译器会直接报错，导致编译不通过

- 当一个派生类中同时存在以上两种情况的继承关系时，第一种情景会优先覆盖掉第二种情景所发生的问题

**_显式的引用父类中的成员_**

为了解决上面所提到的 **_关于一段继承体系中，调用存在二义性的问题_** 问题，我们可以在调用时显示的指定当前所调用成员具体是在哪个所属基类的作用域下，如下面的代码所示 : 

```cpp
class person_base {
public:
  char m_gender = 'K';
  const static int s_id = 0x80;

public:
  void fun_test(void) {
    cout << "Hello,person_base" << endl;
  }
  void fun_test(int a) {
    cout << a << endl;
  }
};

class student : public person_base {
public:
  int m_age;
  char m_gender = 'o';
  const static int s_id = 0x400;

public:
    void fun_test(void) {
        cout << "Hello,student" << endl;
    }
};
int main(void) {
  student stu;

  stu.m_gender;
  stu.person_base::m_gender;      /* 显示的调用父类中的普通变量成员 */

  stu.s_id;
  student::s_id;
  stu.person_base::s_id;          /* 显示的调用父类中的静态变量成员 */
  student::person_base::s_id;     /* 显示的调用父类中的静态变量成员 */
  student::person_base::s_id;     /* 显示的调用父类中的静态变量成员 */
  person_base::s_id;          

  stu.fun_test();
  stu.person_base::fun_test();    /* 显示的调用父类中的函数成员 */
  stu.person_base::fun_test(1);   /* 显示的调用父类中的函数成员 */

   return EXIT_SUCCESS;
}
```

当然，对于 :: 操作符去引用具体基类作用域的作用并不单单只是通过子类的实例来完成显示调用其基类中的成员的目的，我们在子类的实例的上下文中，同样可以直接通过 :: 去引用其基类的作用域以达到在子类的上下文中使用 **_base_** 的效果(<font color = "red">cpp中并没有 **_base_** 指针，但是可以通过这种方式来达到 **_base_** 指针的效果</font>)

```cpp
class person_base {
public:
  char m_gender = 'K';
};

class student : public person_base {
public:
  int m_age;
  char m_gender = 'o';

public:
  student() {
    person_base::m_gender = 'Z';
    cout << person_base::m_gender << endl;

    this->m_gender = 'Q';
    cout << this->m_gender << endl;
  }
};
```

<br/>

<span id = "里式转换"></span>

#### 里式转换

里式转换这一概念其实并不陌生，我们在其它的 OOP 语言中也看到过这个概念，而 cpp 中同样遵循着这一规律，即 : 

- 基类的 **_指针_** 可用于接收一个子类实例的内存地址(<font color = "red">向上类型转换</font>)

- 当基类的 **_指针_** 所指向的是一个子类的实例在内存中的地址，那么这个基类指针可以强转为子类指针(<font color = "red">向下类型转换</font>)

上面所提到的都是 **_指针类型_** 可遵循，<font color = "red">其实也就是说 **_引用类型_** 同样也可以适用</font>，因为引用类型其实质就是一个指针

为什么指针类型为基类的指针可用于接收一个子类实例的地址？通过[继承的内存模型](#继承的内存模型)一节中，我们可以知道，基类中的成员数据会从其派生在内存中的首地址开始优先构建的，那么<font color = "red">当我们用一个基类类型的指针去接收一个子类实例在内存中的首地址的时候，是没有任何问题的，因为我们只是通过基类类型的指针去改变了指针解引用的步长限定在子类在内存段中，独属于基类成员数据的那段内存的范围内，即仅仅是操作针对于该派生的基类内部所保有的成员数据，反之，一个合法的指针(基类的指针所指向的地址是一个子类的实例)也同样是能够用于强转为子类指针，因为该操作同样也仅仅只是改变了指针的解引用方式，使之解引用的步长能够扩散到整个派生类所占用的范围，这是一种 **_安全的转换关系_**</font>，我们要明白的是，<font color = "red">指针的类型永远只是用来衡量解引用操作在内存段中所需的偏移量，并不意味着指针的类型就代表了整个实例的本身</font>，那么反过来，<font color = "red">一个派生类类型的指针是否可以接收其基类实例在内存中的地址呢？答案肯定是 **_不可以的_**，因为作为派生类所继承下来的基类中的成员这个是属于它们之间的共性，基类中的成员的数据往往能够且足够被包含在子类实例所指向的内存空间内，但是作为派生往往存在着它的一些特性，简而言之就是一个派生类在内存中的内存单元通常都是要比其基类要大的，那么当我们使用一个偏移步长为派生类的指针去对一个内存长度小于或者等于派生类步长的基类实例做解引用操作的时候，就会发生内存越界的情况，是一种 **_不安全的操作_**</font>

```cpp
#include <iostream>
using namespace std;

class person_base {
public:
  char m_gender = 'K';
};

class student : public person_base {
public:
  int m_age = 10;
};

int main(void) {
  student stu_stack;
  person_base *base_1 = &stu_stack;

  person_base *base_2 = new student();
  student *stu_heap = (student *)base_2;

  return EXIT_SUCCESS;
}
```

其实单纯的类类型也符合这一规律，即，基类可以接收一个子类的实例用于初始化，当基类的实例是通过子类来初始化完成，那么在子类 拥有符合条件的构造函数的情况下(由于需要构成对于子类的，故派生类中需要有一个基类引用作为形参的构造函数)可以完成基类强转为派生类，但是需要注意的是，这种转换关系所依赖的是基类中的 拷贝/移动构造(即形参为基类的引用)(基类接收一个子类的实例用于初始化)亦或者通过子类中 拥有符合条件的构造函数(基类强转为派生类)来完成的，即<font color = "red">该转换方式是会丢失掉子类中的成员数据的，那么在一个基类并不保有子类的成员数据的情况下，这种转换同样也是不符合多态的</font>，<font color = "red">在这种转换情境之下，真正符合多态的定义仅仅只是在把子类的实例用作于基类构造时，因为基类构造的形参是基类的引用并引用了一个派生类的实例</font>

```cpp
#include <iostream>
using namespace std;

class person_base {
public:
  char m_gender = 'K';

  person_base() {}

  person_base(person_base &per) {
    this->m_gender = per.m_gender;
  }

  person_base(person_base &&per) {
    this->m_gender = per.m_gender;
  }
};

class student : public person_base {
public:
  int m_age = 10;

  student() : person_base(*this){};

  student(person_base &per) {
    this->m_age = 10;
  }
};

int main(void) {
  person_base base = student();

  student stu = (student)base;

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "菱形继承"></span>

#### 菱形继承

菱形继承关系，即最下级派生类所继承的多个基类是共同派生自同一个最上级基类，这时候就会造成一些问题 : 

1. 由于最下级派生类所继承的多个基类都是继承自同一个最上级基类，故它们所继承自最上级基类中的属性其实以最下级派生类的眼光来看待的话，是存在 **_属性重复_** 的问题的，如下图，最上级基类保有一个 `SEX` 性别的成员，而其下级派生类中由于继承自 `ANIMAL` 最上级基类的关系，它们同样都拥有着 `SEX` 性别的成员，但是如果把继承的体系继续延伸到 ANIMAL 的二级派生类(最下级派生类) `BYBIRD` 时，`BYBIRD` 所继承自 `DOG` 和 `CAT` 身上的 `SEX` 成员属性(原始来源 ANIMAL)是存在重复的，因为即使是 杂交动物(`BYBIRD`) 也只能有一个性别的属性

2. 由于 `HYBIRD` 的直接上级父类 `DOG` 和 `CAT` 中都保有相同的属性 `SEX`，故当我们想通过 `HYBIRD` 的实例去获取其父类的属性 `SEX` 时就会造成二义性的问题，并且这种二义性问题的情景会直接导致编译失败

```cpp
class ANIMAL {
public:
  char SEX;
};

class DOG : public ANIMAL { };

class CAT : public ANIMAL { };

class HYBIRD : public DOG, public CAT { };
```

```text
                    ANIMAL
                 +----------+
+----------------+-> SEX <--+-----------------+
|                +----+-----+                 |
|                     |                       |
|                     |                       |
|                     |                       |
|                     |                       |
|        +------------+-------------+         |
|        |                          |         |
|        |                          |         |
|        v                          v         |
|       DOG                        CAT        |
|   +----------+               +----------+   |
+-----> SEX    |               |   SEX <------+
    +----+-----+               +----+-----+
         |                          |
         |                          |
         |                          |
         +------------+-------------+
                      |
                      |
                      v
                    HYBIRD
                 +----------+
                 |          |
                 +----------+

------------------------------------------------------+
                                                      |
class HYBIRD   size(2):                               |
   +---                                               |
 0 | +--- (base class DOG)                            |
 0 | | +--- (base class ANIMAL)                       |
 0 | | | SEX                                          |
   | | +---                                           |
   | +---                                             |
 1 | +--- (base class CAT)                            |
 1 | | +--- (base class ANIMAL)                       |
 1 | | | SEX                                          |
   | | +---                                           |
   | +---                                             |
   +---                                               |
------------------------------------------------------+
```

虽然我们可以采用 `::` 引用具体某个基类作用域的方式去解决 **_第二类导致编译失败的问题_**，但是这样做所导致的只是 '程序上' 没有问题，设计上却没有遵循 'OOP' 规范，故更好的做法是采用 <font color = "red">**_虚基类继承_**</font>

<br/>

<span id = "虚继承"></span>

#### 虚继承

在继承基类时通过关键字 `virtual` 来声明当前所继承的基类是一个 <font color = "red">**_虚基类_**</font>，而这种继承虚基类的继承方式则称为 <font color = "red">**_虚继承_**</font>

<font color = "red">一个派生类通过虚继承的方式继承了某个虚基类时，派生类所继承的虚基类中的成员是被 **_共享_** 的，当然这种共享关系的视角是由继承虚基类的派生类继续往下延生的派生才能得以体现</font>，也就是说，继承自虚基类的派生类往下所衍生到的派生其实例的内存模型仅有一份上级虚基类中的成员，区别于普通的多继承，对于普通的多继承体系，是无法保证最上级基类往后所延伸到的最终派生在内存中的模型仅保有一份该最上级基类中的成员信息，正如 **_菱形继承_** 所存在的问题，最上级派生中的成员 `SEX` 衍生至最下级派生 `HYBIRD` 中其实是有两份 `SEX` 成员信息的，它们分别继承自 `DOG` & `CAT`，而当 `CAT & DOG` 使用虚继承的方式继承自 `ANIMAL` 时，它们所向下衍生出的派生其内存模型是仅有一份来自于最上级基类中的成员 `SEX` 的信息的，其从根本上解决了多继承可能存在的成员重复的问题和成员二义性可能导致的 OOP 逻辑错误的问题

```cpp
class ANIMAL {
public:
  char SEX;
};

class DOG : public virtual ANIMAL { };
class CAT : public virtual ANIMAL { };

class HYBIRD : public DOG, public CAT { };
```

**_虚继承内部实现_**

我们都知道，一起存在着一段继承体系的类，其在实例时会 **_优先_** 初始化其所继承的最上级基类(默认情况下调用基类的默认构造函数)的所有成员至以子类实例为基准所构建的内存段上，然后再以父类中的成员所构建的数据所在内存地址的结束位置继续往下初始化子类中的成员数据，虚继承同样于此，但是放在其派生类的内存首段的数据并不再是虚基类中的成员数据，而是一个名为 **_vbptr_** 的指针，该指针指向了一个名为 **_vbtable_** 的表格，该表格维护了指向其的 **_vbptr_** 的指针在内存中的首地址到虚基类中的成员信息的偏移量，而<font color = "red">虚基类中的成员数据实际上被放到了派生类在初始化完毕内部成员后继续往下所延伸的地址上</font>，依据菱形继承中，`ANIMAL DOG CAT HYBIRD` 之间的继承关系，我们把 `DOG` 和 `CAT` 改用虚继承的方式继承自 `ANIMAL`，那么其内存模型图如下

```cpp
class ANIMAL {
public:
  char SEX;
};

class DOG : public virtual ANIMAL { };
class CAT : public virtual ANIMAL { };

class HYBIRD : public DOG, public CAT { 
public:
  char *name;    
};
```

```text
class HYBIRD   size(11):
   +---
 0 | +--- (base class DOG)
 0 | | {vbptr}
   | +---
 4 | +--- (base class CAT)
 4 | | {vbptr}
   | +---
 8 | name
   +---
   +--- (virtual base ANIMAL)
12 | SEX
   +---

HYBIRD::$vbtable@DOG@:
 0 | 0
 1 | 8 (HYBIRDd(DOG+0)ANIMAL)

HYBIRD::$vbtable@CAT@:
 0 | 0
 1 | 4 (HYBIRDd(CAT+0)ANIMAL)
```


我们会发现，原本 `HYBIRD` 的内存首段信息本该出现的 `DOG` 和 `CAT` 的数据都替换为 **_vbptr_** 的形式了，而本该出现的两个 `SEX` 成员变成了只有一个(共享机制)并被放在派生类成员初始化的数据往后延生的内存段上(virtual base ANIMAL)，<font color = "red">当我们想访问 `BYBIRD` 的基类所继承下来的 `SEX` 数时，会依据指针 **_vbptr_** 所指向的 **_vbtable_**，在里头找到该 **_vbptr_** 指针在内存中的首地址到虚基类中的成员信息的偏移量，然后再依据这个偏移量从派生类的首地址开始偏移，以找到仅有的 SEX 成员</font>，保证调用不会存在二义性，我们可以简单的理解为 : <font color = "red">不管采用什么样的方式去调用(直接通过子类的实例亦或者通过 :: 去引用具体某个基类的作用域)基类中的成员信息，所获取到的始终都是同一个最上级虚基类的成员信息</font>

稍微扩展一下的是，`DOG` 和 `CAT` 都是采用的虚继承的方式去继承了 `ANIMAL`，也就是说放在他们各自的角度来看，`CAT` 和 `DOG` 的实例都各自维护了各自的 **_vbptr_** 的指针和各自的 **_vbtable_**，而同时派生自 `DOG` 和 `CAT` 的派生类 `HYBIRD` 来说，由于继承的传递性那么它就分别拥有了 `DOG` 和 `CAT` 各自维护的 `vbptr` 和 `vbtable`，也就是说 `HYBIRD` 的最终内存模型是拥有两个 **_vbptr_** 和 **_vbtable_** 的，但是由于该 **_vbptr_** 所维护的都是同属于一个虚基类中的成员信息，所以就算最下级派生类中出现了重复的 **_vbptr_** 和 **_vbtable_** 也不会造成二义性的调用，因为其最终的调用都会依据当前 **_vbptr_** 所在的地址和不同的偏移量去找到共同的最上级虚基类中的成员信息

虚继承到底是 **_虚_** 在哪里？虚就虚在所继承的基类中的成员信息，<font color = "red">当一个类使用的是虚继承的方式继承了一个虚基类，那么其所衍生到的派生类真正继承下来的仅仅只是那个因为使用虚继承的关系而生成的 **_vbptr_** 的指针和所指向的 **_vbtable_**，真实的，其继承自虚基类的成员信息由 **_vbptr_** 和 **_vbtable_** 所共同维护着</font>

**_虚继承的构造顺序_**

<font color = "red">一个存在虚基类的继承体系中，虚基类的构造函数将交由 **_当前所初始化的、某个虚基类往下所派生的子类_** 来负责显式调用构造(如果当前类的上级基类也同样显式调用了虚基类的构造，则该调用失效)</font>，并且，<font color = "red">在构造的过程中，虚基类总是会被优先调用构造的(假设虚基类还存在基类的情况)(该优先构造的工作是用于初始化虚基类所衍生出来的 **_vbptr_** 指针和其所指向的 **_vbtable_**)，在完成虚基类的优先初始化工作后则按照正常的继承关系的初始化方式继续完成当前实例的构造，即从最上层基类逐层往下初始化直接基类(不包含虚基类)和直接基类往下所派生的子类</font>

如下面的代码所示，我们在虚基类的上层还增加了一个最终基类 `BIOLOGICAL(物种)`，它用于反馈一个存在虚基类的继承体系中，虚基类永远都是永远初始化的情况，其次，我们在 `DOG CAT HYBIRD` 都分别显式的调用了虚基类的构造，这用于反馈虚基类的显式构造的调用永远都是交由当前所实例化的类来完成这一情景

```cpp
#include <iostream>
using namespace std;

class BIOLOGICAL {
public:
  BIOLOGICAL(){
    cout << "BIOLOGICAL CONSTRUCTOR" << endl;
  };
  BIOLOGICAL(char _SPECIES)
    : SPECIES(_SPECIES) {};
public:
  char SPECIES = 'P';
};

class ANIMAL : public BIOLOGICAL {
public:
  ANIMAL() : BIOLOGICAL() {}
  ANIMAL(char _SEX)
    : SEX(_SEX) {
    cout << "ANIMAL CONSTRUCTOR" << endl;
  }
public:
  char SEX = 'K';
};


class DOG : public virtual ANIMAL {
public:
  DOG(char *name)
    : ANIMAL('D'), d_name(name) {
    cout << "DOG CONSTRUCTOR" << endl;
  }
public:
  char *d_name;
};


class CAT : public virtual ANIMAL {
public:
  CAT(char *name)
    : ANIMAL('C'), c_name(name) {
    cout << "CAT CONSTRUCTOR" << endl;
  }
public:
  char *c_name;
};


class HYBIRD : public DOG, public CAT {
public:
  HYBIRD(char *name, char _SEX)
    : ANIMAL(_SEX), DOG(name), CAT(name) {
    cout << "HYBIRD CONSTRUCTOR" << endl;
  }

public:
  int h_age = 0x400;
};


int main(void) {
  HYBIRD bird((char *)"hello,hybird", 'H');

  CAT cat((char *)"hello,cat");

  DOG dog((char *)"hello,dog");

  return EXIT_SUCCESS;
}
```

**_通过虚继承的方式实现多继承_**

<font color = "red">当一个类中继承了多个虚基类，该类的实例其内存模型也仅有一个 **_vbptr_** 的指针和 **_vbtable_**，但是，**_vbtable_** 中会保存多个相对于当前 **_vbptr_** 到来自于不同虚基类中的成员信息的偏移量</font>(以保证能够成功的获取到不同虚基类中的成员信息)，区别于上一小节，上一小节是由于一个类继承了两个不同的基类但是它们都继承自同一个虚基类，那么作为下级派生就应当拥有上级基类中各自的成员信息，也就是两个 **_vbptr_** 和 **_vbtable_**

```cpp
class DOG { 
public:
  char *d_name = (char *)"DOG!";
};

class CAT { 
public:
  char *c_name = (char *)"CAT!";
};

class HYBIRD : public virtual DOG, public virtual CAT { 
public:
  char *h_name;    
};
```

```text
class HYBIRD   size(16):
   +---
 0 | {vbptr}
 4 | name
   +---
   +--- (virtual base DOG)
 8 | d_name
   +---
   +--- (virtual base CAT)
12 | c_name
   +---

HYBIRD::$vbtable@:
 0 | 0
 1 | 8  (HYBIRDd(HYBIRD+0)DOG)
 2 | 12 (HYBIRDd(HYBIRD+0)CAT)
```

继上一段代码的情景，<font color = "red">我们要保证一个类所继承的多个虚基类中并不会出现同名的成员信息，否则同样会出现成员调用的二义性</font>，这里需要区别于[菱形继承](#菱形继承)中所造成二义性的情景，菱形继承造成的二义性的根本原因是因为最下级派生所继承的多个基类都用用着共同的成员属性(它们都继承自同一个最上级基类)而导致最下级派生中存在着多个同名的成员属性，这种情况之下我们对于最下级派生的基类都采用虚继承的方式使它们继承自同一个最上级基类，那么转换到最下级派生的视角来看，原有的继承下来的重名成员都会因为其上级基类是使用虚继承的关系，所以真正被继承下来的都是 **_vbptr_** 和 **_vbtable_**，我们可以理解为在这种情况下重名的成员转变成 **_vbptr_** 和 **_vbtable_**，但由于他们所继承下来的属性都同属于一个虚基类上的成员信息，故在这种情况下不管我们是对该理应被重名的成员采取任何的访问方式都不会造成二义性，那么假设我们对于当前类采用虚继承的方式继承了多个虚基类，并且 多个虚基类中存在着同名的成员，这时候就又会出现二义性的问题了，<font color = "red">该二义性的发生并不是由本身的继承关系而造成的，是因为虚继承本身继承下来的成员就存在二义性所产生的，即 **_vbptr_** 和 **_vbtable_** 本身就维护着同名的成员</font>，所以这种情况之下并不能依赖于 **_为了解决本身继承所产生的二义性关系的虚继承_** 来解决，只能在采用虚继承继承了多个虚基类的派生亦或者其下级派生在调用产生二义性成员时使用 :: 引用具体某个虚基类的作用域的方式来避免这一问题，下面的代码则展示了该问题

```cpp
class DOG {
public:
  char *name = (char *)"DOG!";
};

class CAT {
public:
  char *name = (char *)"CAT!";
};

class HYBIRD : public virtual dog, public virtual cat { };     
```

```text
class HYBIRD    size(12):
   +---
 0 | {vbptr}
   +---
   +--- (virtual base DOG)
 4 | name
   +---
   +--- (virtual base CAT)
 8 | name
   +---
                 
HYBIRD::$vbtable@:
 0 | 0
 1 | 4 (HYBIRDd(HYBIRD+0)DOG)
 2 | 8 (HYBIRDd(HYBIRD+0)CAT)    
```


<br/>

<span id = "虚函数"></span>

#### 虚函数

虚函数的存在并不陌生，即 : <font color = "red">如果一个基类的指针(引用)所指向的是其派生实例在内存中的首地址并且该派生对于基类中的虚函数进行了重写，那么我们在使用这个基类的指针(引用)在调用其虚函数时，所调用的是派生类中的重写实现</font>

<font color = "red">需要注意的是，是只有使用基类的类型的指针(引用类型)去指向了重写了基类中的虚函数的派生的实例在内存中的首地址，并通过该指针去对虚函数进行调用才能够符合虚函数重写覆盖调用的定义的，因为只有在这种情境之下的声明才符合多态的定义</font>，具体原因参照[里式转换](#里式转换)

**_如何编写虚函数_**

一个成员函数的生面前添加 **_virtual_** 关键字来完成能够完成虚函数的定义，当一个类中声明了一个虚函数，那么它所派生出来的子类亦或者子类往下继续延生的派生都可以 <font color = "red">**_选择性地_**</font> 完成对它的重写，对于虚函数的重写有两种方式 : 

- 在派生类中声明了一个相同函数签名(相同返回值、相同函数名、相同形参列表)的函数

- 在派生类中声明了一个相同函数签名(相同返回值、相同函数名、相同形参列表)的函数，并在结尾使用了 **_override_** 关键字进行修饰

两种重写虚函数的方式所达到的效果是一样的，意为该函数重写了上级基类的虚函数，不同的是，<font color = "red">第二种方法如果在其基类中并没有找到对应 函数签名的虚函数时，则会编译报错，反观第一种重写方案，当基类中并没有对应函数签名的虚函数时编译并不会报错</font>，该函数仅仅只是被当成是当前派生类中的一个成员函数，在 cpp 标准中规定，对于虚函数的重写更加推荐的方式则为第二种方案

**_虚函数的内部实现_**

当一个类中声明了一个虚函数后，那么该实例的创建编译器会附带创建一个名为 **_vfptr_** 的指针，并插入到在其实例在内存中的首段位置，该指针指向了一个名为 **_vftable_** 的表格，该表格所维护的则为 <font color = "red">**_在基类中声明为虚的成员函数亦或者下级派生所重写的虚函数 在内存中的首地址_**</font>，当我们通过该类的实例去调用这个虚函数时，编译器并不会直接依照所调用函数的首地址进行调用，而是会根据 **_vfptr_** 指针所指向的 **_vftable_** 中，在其内部寻找所维护的函数地址并进行调用

<font color = "red">假设声明了虚函数的类进行了向下的派生，基类中的成员所衍生到的派生类随同一并继承下来的还会包括那个因为 虚函数 所生成的 **_vfptr_** 指针和其所指向的 **_vftable_**，如果在当前的派生中显示的指定了对于基类中的虚函数进行了重写，那么编译器会把当前派生中所重写至基类中的虚函数的成员函数在内存中的首地址 在 **_vftable_** 当中替换掉原本属于上级基类中的成员函数的首地址，故这时候 **_vftable_** 中所维护的函数地址其实为派生中所重写的虚函数，那么当我们使用一个指向派生类实例在内存中的首地址的基类类型的指针去调用虚函数时，所调用的则为在派生类中的重写实现</font>，如下面的代码 :

```cpp
class Animal {
public:
  Animal() {
    cout << "ANIMAL CONSTRUCTOR" << endl;
  }
public:
  virtual void speak() {
    cout << "ANIMAL SPEACKING!" << endl;
  }
public:
  int a_age;
};

class Cat : public Animal {
public:
  Cat() {
    cout << "CAT CONSTRUCTOR" << endl;
  }
public:
  void speak() override {
    cout << "CAT SPEAKING" << endl;
  }
public:
  int c_age;
};
```

```text
class Cat size(12):
   +---
 0 | +--- (base class Animal)
 0 | | {vfptr}
 4 | | a_age
   | +---
 8 | c_age
   +---

Cat::$vftable@:
   | &Cat_meta
   |  0
 0 | &Cat::speak
```

由于继承的延续性，**_vftable_** 会随着往下的派生而继续延生，也就是说，一段继承体系中，继续往下的某一个派生如果重写了上级基类中的虚函数，那么其重写的虚函数的首地址同样会覆盖掉 **_vftable_** 中所维护的函数地址，否则不会(**_可以选择性的进行重写_**)，其实简而言之，虚函数的调用依据永远都是依照 **_vftable_** 来进行的，而 **_vftable_** 则根据我们当前所实例化的类的重写依据的实现而实现，就上面的代码来说，我们实例化的是 `Cat` 并使用其 **_基类指针_** 去接收，那么 **_vftable_** 中最终所纳入的实现则为 `Cat` 中所重写的虚函数的首地址，假设 `Cat` 又往下衍生了一个派生，并且派生中重写了最上级基类中的虚函数，反之 `Cat` 并没有，那么我们在使用 **_基类指针_** 去接收最下级派生(Cat往下的派生)的实例的首地址的时候，**_vftable_** 则会依照 `Cat` 往下的派生所重写的函数而实现，反之在这种情境之下我们使用 **_基类指针_** 再去接收 `Cat` 实例的时候，这时候重写的依据就不再是 `Cat` 了，因为 `Cat` 中压根就没有进行过重写，那么 **_vftable_** 所维护的还是最上级基类中的实现

简而言之，<font color = "red">虚函数到底是使用当前继承体系中哪一个派生的重写，根据我们所具体实例化的对象来决定</font>

<br/>

<span id = "虚析构"></span>

#### 虚析构

对于一个存在着一段继承关系的类来说(最下级派生)，我们单纯的创建了针对于它的实例，那么当它即将被释放时，析构的调用惯例(这里仅仅讨论的是析构的调用顺序，并不是释放，对于释放而言自然是全都会被释放)是从内向外而进行的，即从最下层的派生中开始逐步往上层进行调用，但是对于需要进行多态操作的类来说，我们往往是使用一个基类去接收一个派生类的赋值，以通过最上级基类在保有派生类中的 **_'特性'_** 的情况下完成多态的操作

**_对于普通的在栈中所构建的多态而言_**，其释放顺序自然是标准的由内向外的顺序，因为在栈中所构建的多态，往往是需要我们在当前栈帧(函数)上下文中先去构建一个派生的实例，再使用上级基类类型的指针去接收这个下级派生实例在内存中的首地址，然后再通过这个类型为基类的指针去完成多态的操作，而这种操作之中，<font color = "red">重点的是，我们在当前栈帧上下文中先手动的构建了作为下级派生的实例，那么自然作为栈帧出栈时自然也会遵循着我们所构建的这个下级派生的实例，由内向外的进行析构的逐层调用</font>

**_但是对于在堆中所构建的多态而言_**，我们往往都是直接 `new` 一个派生类型实例并 **_直接_** 使用 **_基类类型的指针_** 去接收，那么当我们去 `delete` 释放这块内存的时候，<font color = "red">因为 `delete` 所释放的视角是以基类类型为开始的</font>，那么在这种情况之下，`delete` 虽然是能够释放掉所 `new` 的内存(确保所 `new` 出来的内存首地址是正确)，但是其继承体系的析构调用顺序仅仅只是从当前 **_基类类型_** 中开始，而不是标准的从内向外了，当然，如果我们把上面的情景转换为使用的是 **_当前所 new 的派生类型的指针做为接收_**，那么当我们在 delete 的时候，由于视角是从下级派生所开始，那么其析构的调用顺序也是由内向外的了

其实归根结底，仔细研究上面的两种情景我们会发现，<font color = "red">释放的顺序到底是由内向外还是仅仅只是作为自身往往都是由编译器在我们的代码中所看到的具体是由哪一层次的类来操作的视角来决定</font>，就拿情景一来说，由于我们在栈中显示的声明并使用了下级派生的变量，那么其在释放的时候，析构的调用顺序也自然依照这个下级派生开始由内向外进行释放，<font color = "red">而情景二中由于我们所声明的真正的变量是 **_基类类型_** (虽然内部的实现是其下级派生) 并且在 delete 的时候也是从 **_基类类型_** 这个层次的类作为视角而开始，故其即将被释放时，析构的调用顺序仅仅只是从 **_基类类型_** 这个上级基类开始，那么就有可能导致下级派生中的析构因为无法正常的调用但是下级析构却会维护着当前层次中声明在堆中的内存的生命周期而导致内存泄漏的问题，针对这种情景，我们这就需要引入 **_虚析构_** 的使用了</font>

虚析构，它能够保证我们所释放的成员以 **_上级基类_** 作为视角时，也能够在调用 **_上级基类_** 的虚构函数前会优先调用作为基类的派生并且重写了的虚析构的实现，作为基类中的 **_虚析构源_** 和其下级派生所 **_重写的虚析构_**，其同样也会由 **_vfptr_** 和 **_vftable_** 所维护着，如果在下一级派生中重写了上层的虚析构的话，则会在当前派生的上下文中替换掉 **_vftable_** 中关于上级虚析构在内存中的首地址，否则不会(可以选择性地进行重写，其原理和虚函数一致)，那么当我们释放的成员是以 **_上级基类_** 做为视角的情况下，则会依照 **_vftable_** 中所维护的当前继承体中的虚构函数的具体实现来决定由内向外的释放顺序

```cpp
#include <iostream>
using namespace std;

#include <string.h>

class Animal {
public:
  Animal(int _age)
    : a_age(_age) {
    cout << "ANIMAL CONSTRUCTOR" << endl;
  }
  virtual ~Animal() {
    cout << "ANIMAL DESCRTUCTOR" << endl;
  }

public:
  int a_age;
};


class Cat : public Animal {
public:
  Cat(int _age, char *_name)
    : Animal(_age) {
    cout << "CAT CONSTRUCTOR" << endl;
    this->name = new char[strlen(_name) + 1];
    strcpy(this->name, _name);
  }
  ~Cat() override {
    cout << "CAT DESTRUCTOR" << endl;
    delete[] this->name;
  }

public:
  char *name = nullptr;
};


class HEITAN : public Cat {
public:
  HEITAN(int _age, char *name)
    : Cat(_age, name) {
    cout << "HEITAN CONSTRUCTOR" << endl;
  }
  ~HEITAN() override {
    cout << "HEITAN DESTRUCTOR" << endl;
  }
};

int main(void) {
  Animal *animal = new HEITAN(1, (char *)"heitan");
  delete animal;

  return EXIT_SUCCESS;
}
```

```text
class HEITAN    size(12):
   +---
 0 | +--- (base class Cat)
 0 | | +--- (base class Animal)
 0 | | | {vfptr}
 4 | | | a_age
   | | +---
 8 | | name
   | +---
   +---
HEITAN::$vftable@:
   | &HEITAN_meta
   |  0
 0 | &HEITAN::{dtor} 
```

需要补充一点的是，虚析构同样是遵循着[虚函数](#虚函数)小节中所说明的特性，因为它本身就是一种虚函数，只是是一种虚构函数，我们无需把它想多过于复杂，只用把它理解为虚析构和虚析构的重写能够决定一段声明在堆中的多态继承体系的析构函数调用顺序和时机即可 

<br/>

<span id = "纯虚函数"></span>

#### 纯虚函数

<font color = "red">纯虚函数即声明的虚函数的实现赋值为 0，在这种情况之下，作为其下级派生则 **_必须_** 要对其进行重写，否则会导致编译不通过</font>，并且，<font color = "red">一个类中一旦出现了一个纯虚函数，那么这个类就被编译器认作为一个 抽象类，在 cpp 中对于抽象类的特性仅有不能实例化自身这一点</font>

对于纯虚函数而言，它其实和普通的虚函数是一样的，只是对于纯虚函数而言多了一条限制是其往下的派生必须要对该纯虚进行重写，否则会编译不通过

```cpp
#include <iostream>
using namespace std;

#include <string.h>

class Animal {
public:
  Animal() {
    cout << "animal constructor" << endl;
  }
  
  /* 纯虚函数 */
  virtual void speak() = 0;

  virtual ~Animal() {
    cout << "animal destructor" << endl;
  };
};

class Cat : public Animal {
public:
  Cat() {
    cout << "cat constructor" << endl;
  }

  void speak() override {
    cout << "hello,world!" << endl;
  }

  ~Cat() override {
    cout << "cat destructor" << endl;
  }
};

int main(void) {
  Animal *animal = new Cat();
  animal->speak();
  
  delete animal;

  return EXIT_SUCCESS;
}
```

<font color = "red">存在一条特例是，对于纯虚的析构函数(**_存虚析构_**)来说，虽然其实现也是赋值为 0，但是为了保证析构函数在一段存在继承体系的类的释放和调用顺序，所定义的纯虚析构自身还需要另外对其进行定义，否则同样会造成编译不通过</font>，这种语义对于纯虚函数本身的确看起来很别扭，似乎纯虚析构其实现赋值为 0 并无太大意义，的确如此，纯虚析构所保证的仅仅只是能够让当前所在类声明为一个抽象类，并且保证其下级派生必须对析构进行重写仅此而已

```cpp
#include <iostream>
using namespace std;

#include <string.h>

class Animal {
public:
  Animal() {
    cout << "animal constructor" << endl;
  }
  virtual ~Animal() = 0;
};

/* 定义 Animal 中的纯虚函数 */
Animal::~Animal() {
  cout << "animal destructor" << endl;
}

class Cat : public Animal {
public:
  Cat() {
    cout << "cat constructor" << endl;
  }

  ~Cat() override {
    cout << "cat destructor" << endl;
  }
};

int main(void) {
  Animal *animal = new Cat();
  delete animal;

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "友元成员"></span>

#### 友元成员

<font color = "red">当一个 类/结构体 中某一个成员使用了 **_friend_** 关键字进行修饰，那么它就是一个友元成员</font>，它用作与<font color = "red">修饰一个 **_成员变量(通常为复合类型的变量，基础类型无意义)的声明抑或是成员函数的声明或实现_**</font>，<font color = "red">**_当所修饰的成员属于一段声明时，我们要保证在全局作用于下有该实现所链接到的定义_**</font>

<font color = "red">友元用于修饰一段声明或定义，其意为友元成员其定义的上下文中(**_对于所修饰的是一个具体对象的友元成员，那么也就意味着该对象内部的所有成员函数都保有访问私有成员的权限_**)能够得到访问友元声明所处的类型中的私有成员的权限</font>

针对上面所提到的这点，我们是需要严格区分开来的，<font color = "red">友元成员只能够保证的是，在其定义的上下文中使用友元所声明的复合类型的实例时(函数形参, 局部变量)，我们通过该实例是能够获取到该复合类型中的私有成员的，但并不意味着我们可以通过直接的方式(this指针)访问到当前类中的私有成员</font>，简单而言，<font color = "red">友元成员虽然需要被 定义/声明 在一个类的内部，然而它并不属于这个类中的一个成员，具体来讲，**_友元的定义是作用于全局作用域之下的_**</font>

```cpp
using namespace std;

#include <string.h>

class Animal {
private:
  const static int age = 0x400;
  const char *name = "hello,world";

public:
  friend void take(Animal ani);
};

void take(Animal ani) {
  cout << ani.name << endl;
  cout << ani.age << endl;
}

int main(void) {
  Animal ani;
  take(ani);

  return EXIT_SUCCESS;
}
```

友元成员存在于全局作用域之下，那么是否就意味着，如果友元所修饰的是一段定义的话，我们在是可以通过直接的方式完成对其的调用呢，答案是否定的，<font color = "red">仅当友元成员(这里指的是成员函数类型的友元成员)的参数列表中出现了当前类型(友元成员所在的类型)的参数时，才能够通过直接的方式完成对该友元所修饰的定义的调用</font> ; <font color = "red">那么对于不存在 当前类型 的参数的定义的情况之下，我们想要通过直接的方式完成对其的调用还需要在全局命名空间之下对该定义做一次另外的声明才能够完成</font>，下面的代码展示了这一段解释中所说明的两种情况

```cpp
#include <iostream>
using namespace std;

#include <string.h>

class Animal {
private:
  const static int age = 0x400;
  const char *name = "hello,world";

public:
  friend void foo_01(int i, Animal ani) {
    cout << ani.age + i << endl;
  }

  friend void foo_02();
};

void foo_02() {
  Animal ani;
  cout << ani.name << endl;
}

int main(void) {
  Animal ani;

  foo_01(10, ani);
  foo_02();

  return EXIT_SUCCESS;
}
```

**_友元成员的特性_**

- 友元成员无传递性，比如说我们在类B中声明了类A为类B的友元成员，这时候我们又在类C中声明了类B为类C的友元成员，但是并不代表着类A是类C的友元成员

- 友元成员无互逆性，比如说我们在类B中声明了类A为类B的友元成员，但不代表这类B为类A的友元

- 访问修饰符对于友元成员的调用没有任何影响，因为其作用域根本就不属于当前类当中

**_友元成员的具体使用_**

- 普通函数

  - 对于普通函数而言，友元是可以用于修饰这个函数的定义亦或者声明的

  - 对于声明为友元的函数的定义始终会被编译器当作一个 内联函数 来看待

- 类或结构体

  - 友元所修饰的类或结构体只能够用于声明 

  - 所修饰的类或结构体其内部的所有成员函数都含有访问目标对象所有私有成员的权限

- 类或结构体中的成员函数

  - 友元所修饰的类或结构体的成员函数只能够用于声明

  - 友元如果想作用于针对于某个类中的成员函数进行修饰，我们还需要使用 `::` 关键字来引用具体某个类的作用域

```cpp
#include <iostream>
using namespace std;

/* 类的前置声明，为了方便在 Friend 函数中能够使用 House 的指针，原因是因为 House 的定义在 Friend 之后 */
class House; 
class Friend {
public:
  void VistBy_GoodFriend(House *host);
  void VistBy_NGPONG(House *host);
};


class House {
  /* 全局函数声明 */
  friend void foo(House *host);
  /* 类声明 */
  friend class Friend;
  /* 类中的成员函数声明 */
  friend void Friend::VistBy_GoodFriend(House *host);
private:
  void Go2_BedRoom(void) {
    cout << "Enter BedRoom" << endl;
  }
public:
  void Go2_Toliet(void) {
    cout << "Enter toliet" << endl;
  }
};


void Friend::VistBy_GoodFriend(House *host) {
  host->Go2_BedRoom();
}
void Friend::VistBy_NGPONG(House *host) { /* 事实上，这一段函数直接在 Friend 里头定义都是可以直接 */
                                          /* 访问到 House 中的私有成员的，因为在 House 中，已经 */
                                          /* 指定了 House 类为它的友元成员，意味着其内部中的所有 */
                                          /* 成员函数都能够直接访问到 House 内部的私有成员，但是因为 */
                                          /* House 类是在 Friend 类 之后定义的，也就意味着，如果我 */
                                          /* 们直接在 Friend 内部去访问 House 类的中的成员是访问不到 */
                                          /* 的，因为编译器遵循着由上至下的编译特性 */
  host->Go2_BedRoom();
}
void foo(House *host) {
  host->Go2_BedRoom();
}

int main(void) {
  House *house = new House();

  Friend *fre = new Friend();
  fre->VistBy_GoodFriend(house);
  fre->VistBy_NGPONG(house);

  foo(house);

  delete fre;
  delete house;

  return 0;
}
```

<br/>
<br/>

<span id = "函数的扩展"></span>

## 函数的扩展