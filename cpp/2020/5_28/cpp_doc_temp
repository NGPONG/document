


#include <iostream>
    -> 该文件还包含 include 着一些比较常用的头文件，如：stdlib.h 
    -- namespace：std
        -> cout << xxx << xxx << endl
            -> count：输出
            -> endl：
                -> 在 stdout 里面写入换行符，换行符的类型可以自动匹配适应当前 os 的类型，例如windows下为 \r\n，linux下位 \n
                -> 立即刷新文件缓冲区

标准输入流
    -> #include <iostream> -> namespace std;
    -> cin

    -> cin.get()
        -> 从文件缓冲区 stdin 中读取所输入的一个 char 字符，以 \n 作为本次从 stdin 缓冲区中取出数据的结束标识符 ( 能够接收到 \n 字符 )
        -> 由于此操作是从 stdin 中取出数据，也就意味着在调用该函数时会有一个阻塞的过程等待着我们的 input 设备去录入即将要输入到缓冲区中的数据

    -> cin.get(char *str,int size)
        -> 从文件指针 stdin 所指向的文件的缓冲区内获取 size 字节的数据（如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的执行并等待用户终端 input 设备把数据去输入到 stdin 缓冲区，并以 \n 字符作为本次输入的结束），以 \n 作为此次从 stdin 缓冲区中取出数据的结束标识符，把所读取到的内容填充至形参 str 所指向的内存空间中
        -> 该函数从缓冲区 stdin 中获取数据时会忽略掉 \n 字符，也就是说在调用完成该函数后，stdin 缓冲区中其实还留有着一个 \n 字符
        -> 该函数所给定的参数 str 必须为一个字符数组以保证写入权限，如果给定的是一个字符指针形式的字符串的话，该函数则会调用失败，因为该函数会逐地址写入所录入的字符
        -> 该函数是较为安全的，至始至终都会为 str 所指向的空间保留最后一位的字节内容以录入 '\0'，如果超出，则截断最后一位所采集到的数据以保证在录入 '\0' 字符时候，str 所指向的内存空间的足够
        
    -> cin.getline(char *str,int size)
        -> 从文件指针 stdin 所指向的文件的缓冲区内获取 size 字节的数据（ 如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的执行并等待用户终端 input 设备把数据去输入到 stdin 缓冲区，并以 \n 字符作为本次输入的结束 ），以 \n 作为此次从 stdin 缓冲区中取出数据的结束标识符，把所读取到的内容填充至形参 str 所指向的内存空间中
        -> 该函数会从 stdin 中获取到本次所录入的一整段字符串 ( 包括 \n )，但是在把该字符再写入到 str 所指向的内存空间当中前会先删除掉所获取到的该字符串结尾的 \n 字符
        -> 该函数所给定的参数 str 必须为一个字符数组以保证写入权限，如果给定的是一个字符指针形式的字符串的话，该函数则会调用失败，因为该函数会逐地址写入所录入的字符
        -> 该函数是较为安全的，至始至终都会为 str 所指向的空间保留最后一位的字节内容以录入 '\0'，如果超出，则截断最后一位所采集到的数据以保证在录入 '\0' 字符时候，str 所指向的内存空间的足够

    -> cin.ignore(int size)
        -> 删除掉 stdin 缓冲区内前 size 个字节的数据，如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的调用等待用户输入，当输入了 \n 后则意为本次输入的结束

    -> cin.peek()
        -> 查看 stdin 缓冲区内前1个字节的数据（仅查看，不删除），如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的调用等待用户输入，当输入了 \n 后则意为本次输入的结束

    -> cin.putback(char _ch)
        -> 把上一次从 stdin 中获取到的一个字符再放回 stdin 缓冲区对应该字符的原位置中，需要注意的是，我们不应该把该函数的使用当成是往 stdin 缓冲区内的首部插入一个字符的数据，不正当的使用会造成 stdin 缓冲区数据的清空

    -> cin >> expression
        -> 从文件指针 stdin 所指向的文件的缓冲区内获取数据（如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的执行并等待用户终端 input 设备把数据去输入到 stdin 缓冲区，并以 \n 字符作为本次输入的结束），以 \n 或者 \0 作为此次从 stdin 缓冲区中取出数据的结束标识符，并把所读取到的数据写入到 expression 所指向的内存空间当中
        -> 我们要保证 expression 的类型和本次从 stdin 中所获取到的数据的类型是一致的，否则 stdin 缓冲区会出现错误，比如说，expression 所指定的类型为 int 类型，但是 stdin 缓冲区所留有的类型却是一个字符类型，这时候 stdin 缓冲区就会出现错误，那么当我们下一次再去 stdin 缓冲区中获取数据时，就永远都无法获取到真实的、本应该存在在 stdin 缓冲区中的数据，针对这种情况，我们可以使用 cin.clear() 和 cin.sync() 去重置一次缓冲区中的数据以解决这个问题

    -> cin.fail()
        -> 根据 stdin 缓冲区中的错误标识来判断 stdin 缓冲区中是否发生了错误，如果该标识是一个发生错误的状态，则该函数返回的结果则为 1，否则为 0，当然，我们可以手动的调用 cin.sync() 函数来重置这个标识

    -> cin.clear()
        -> 清空 stdin 缓冲区中的数据
    
    -> cin.sync()
        -> 重置/复原 stdin 缓冲区错误的标识，简而言之，如果 cin.fail() 调用时获取到的结果为 1，那么在调用完这个函数后再去调用 cin.fail() 则获取到的结果则为 0







-> 结构体的扩展
    -> 提供了函数的支持 ( 在结构体中所声明的函数不在当前结构体所对应存储的内存段当中，即不会纳入内存对齐的考量范围 )
        -> 构造函数 拷贝构造函数 移动构造函数 析构函数的支持
        -> 我们对于结构体中的函数成员可以声明为定义亦或者一个链接符号形式的声明，但是不能同时存在同一个函数的声明和定义在同一个结构体当中
               当我们为结构体中的成员函数声明为链接符号形式的声明的时候，我们必须要保证在 全局作用域 下能够为该符号链接声明一个具体的定义，否则在当前结构体中，关乎到该声明的使用将都会使编译不通过

    -> this 指针的支持

    -> 友元成员的支持

    -> 运算符重载函数的支持

    -> 静态成员的支持，和类中的概念一样

    -> 结构体中的成员提供了访问修饰符的支持，并且默认情况下的访问修饰符为：public

    -> 在构造一个结构体类型的时候，我们为这个结构体所构造的普通成员变量是允许在声明的同时存在其定义的，而对于结构体中的函数，我们同样也可以存在声明和定义，需要注意的是，我们对于一个结构体中的成员函数进行声明的时候，那么我们还需要在外部通过 :: 引用作用域的手段来把当前在结构体中所定义的函数声明链接为具体的一个定义

    -> 在 cpp 中是允许空结构体的存在的，对于一个没有任何声明的结构体来说，其实例还是会在内存中占用 1 bytes 的空间大小，原因是因为 cpp 需要保证每一个类的实例在内存中都会是独一无二的存在




CPP对C的一些扩展
    -> 三元运算符 CPP 所返回的结果是变量，而 C 中所返回的是这个变量所存储的值，这就造就了一个特性，CPP可以对特定的三元运算符 ( 引用变量的三元运算符 ) 所返回的结果进行赋值操作

    -> bool 类型的支持

    -> 类型转换检测增强，对于类型转换必须严格执行

    -> 函数书写性检测
    
    -> CPP 下所声明在全局作用域下的成员 ( 全局变量 ) 默认情况下都是内部链接属性 ?????????????好像不是????????????????



函数的扩展
    -> 内联函数 ( inline function )
        -> 在 c 中，我们通常会把一些短并且执行频繁的计算写成 宏函数 以此避免函数调用所存在的开销，宏函数能够在 c 中进行广泛的使用并不是说宏函数就一定是完美无缺的，而是在 c 语言中似乎找不到第二个相似的特性以代替 宏函数 的功能，而 宏 对于 cpp 这种面向对象的语言来说，其存在的本身还是会存在着一些问题，比如：
            1. 宏函数是属于预处理阶段供预处理器进行宏定义展开的工作，而预处理器在 cpp 中是不允许访问类的成员，也就是说我们无法把某一个宏当作一个类中的成员来进行看待，简而言之，宏定义 没有作用域的一个概念
            2. 宏函数在特定情况下进行使用所拿到的结果可能并不是我们所预期的一种结果
        为了解决 宏定义（宏函数） 在 c 语言中所带来的一些历史性的遗留问题，cpp中推出了 inline function 的概念
        -> 内联函数本身也是一个真正的函数，它具有普通函数的所有行为，对比 宏函数 来说，内联函数会在适当的地方像预定义宏一样展开，也就是说，内联函数和宏函数一样同样能够解决函数调用时候的压栈，跳转，返回的开销问题，除此之外，由于内联函数背身也是一种真正的函数，也就意味着我们能够指定它声明在我们所需要的命名空间内，防止命名冲突的问题的同时又提升了程序的 oop 性
        -> 内联函数的定义
            -> 内联函数的定义方式很简单，在所需要定义为内联函数的开头添加 inline 关键字即可，需要注意的是，当我们函数分为函数的声明和函数的定义的时候，我们必须要在声明和定义中都要添加上 inline 关键字才算生效
            -> 对于在类中的成员函数编译器在编译的过程中都会自动添加上 inline 关键字
            -> 当我们为一个函数添加上了 inline 关键字，那该函数就被声明为了 内联函数，但是内联函数是一定会生效的吗？不一定，编译器会在编译的阶段考量内联函数的有效性，当这个内联函数符合一定的条件后，那么该函数的调用将采用内联编译，那么有效性都有哪些？
                1. 不能存在任何形式的循环语句
                2. 不能存在过多的条件判断语句
                3. 函数体不能过于庞大
                4. 不能对函数进行取址操作
            对于内联函数来说，其本身只是提供给编译器的一种意见，那么具体是要把这个函数当成普通函数的方式来调用还是通过内联的方式来调用这都取决于编译器本身，可能一个我们所声明的内联函数并没有符合一定的要求，那么编译器就不会把它当成内联函数来看待，可能一个函数并没有声明为内联的形式，但是在它调用的过程中编译器都会对它做内联编译，其实对于开发人员来说，我们无需特地的去声明一个内联函数，这部分工作大多都是交给编译器来完成，我们只需要明白存在这一概念并遵循着内联编译前提条件的注意事项即可

    -> 函数的默认参数，和 c# 类似，不展开
    void Exponentiation(int &a,int b = 2) {
        for (size_t i = 0; i < b; i++) {
            a *= a;
		}
    }

    int main(void) {

        int a = 8;
        Exponentiation(a);

        cout << a << endl;
    }

    -> 函数的占位参数


    -> 函数的重载
        -> 函数的重载，和 c# 类似，不展开，即 在同一个作用域下，我们可以额外定义不同参数个数、不同参数类型、不同参数顺序的同名函数
        -> 由于 cpp 中需要对函数重载的支持，故使用 cpp 的方式对源文件进行编译的过程中，会为我们所声明定义的亦或者所使用的函数都会额外添加一些其他的符号以区分函数重载的标识（根据不同编译器的实现不同而不同），比方说我们在 cpp 文件中所定义的函数为 fun_test()，而在进行过编译后他可能就会重命名为 _Z6Myfunc_test()，对此就会存在一个问题，由于在 c 中是不支持函数的重载的，故函数的原名在使用 c 的方式进行编译后原名不会发生改变，假设我们目前我们有一个 cpp 的源文件 main.cpp 和 c 的源文件 test.c 还有一个 c 源文件 test.c 所对应的头文件 test.h，如下面的代码
        *************test.h
        #include <stdio.h>

        void fun_test(char *name);

        *************test.c
        #include "test.h"

        void fun_test(char *name) {

            printf("Hello,World!%s\n",name);
        } 

        *************main.cpp
        #include <iostream>
        #include "test.h"

        using namespace std;
        
        int main(void) {

            fun_test("NGPONG");
            cout << "OK!" << endl;
            return 0;
        }
        

        可以看到，我们在 cpp 的源文件中引用了 c 语言源文件 test.c 所对应的头文件 test.h，将借助在头文件 test.h 中对于函数 fun_test(char *name) 已完成对 c 语言源文件中的功能函数的调用，但是这时候在进行编译时就会出现问题，因为我们是使用的 cpp 源文件工程进行编译工作的，也就是说编译器是以 cpp 的方式对文件进行编译和链接的，而头文件 test.h 虽然是对应着 c 语言源文件 test.c 的，但是它却在 cpp 源文件 main.cpp 被包含（#include）了进来的，也就意味着，当前头文件中的声明工作都要参与以 cpp 方式进行编译和链接的过程，前面提到过，cpp 由于需要对函数重载的支持，所以使用 cpp 的方式对文件进行编译的时候，都会把我们所声明定义的亦或者所使用的函数都会额外添加一些其他的符号以区分函数重载的标识，而这时候在头文件对于函数 void fun_test(char *name) 中的声明可能就会被改写成 void _Z6fun_test(char *name)，但是我们目前是没有任何一个函数的定义是 _Z6fun_test 的，所以函数 void fun_test(char *name) 在进行链接的过程中就无法找到这个函数的具体定义，提示无法找到外部符号

        那么产生这种问题的原因是因为 c 语言的源文件 test.h 参与了 cpp 编译的方式从而导致函数名变更而无法找到其原本在 c 语言文件 test.c 中所对应的函数定义所导致的，那么解决这种问题其实很简单，只要让它不参与 cpp 的方式进行编译即可，故我们只需要对需要进行编译的函数的前缀添加上关键字 extern "C"，当一个成员添加上该关键字后，那么编译器其编译和链接的方式则遵循 c 语言的规范来进行，需要注意的是，该关键字是 cpp 中独有的，在 c 中无法使用，也就是说我 对于函数的声明方式就需要从原来在头文件 test.h 中改写在 main.cpp 身上，并且我们还需要把原来在 cpp 源文件中所包括的头文件 test.h 去掉，以防止 cpp 编译器检测到两种不同形式 (头文件中是 void fun_test(char *name)，源文件中是 extern "C" void fun_test(char *name) ) 的声明而无法进行编译的情况，通过这样的改造后，我们就能够成功的在 cpp 源文件中使用 c 源文件中所提供的一些功能实现了，代码结构改写为下面的形式

        *************test.h
        #include <stdio.h>

        void fun_test(char *name);

        *************test.c
        #include "test.h"

        void fun_test(char *name) {

            printf("Hello,World!%s\n",name);
        } 

        *************main.cpp
        #include <iostream>

        using namespace std;

        extern "C" void fun_test(char *);
        
        int main(void) {

            fun_test("NGPONG");
            cout << "OK!" << endl;
            return 0;
        }

        当我们在 cpp 中对于函数 fun_test 的声明引入了关键字后，它就不会再去参与 cpp 的编译和链接的方式，而是遵循 c 标准的编译和链接的方式来进行，那么在其进入链接的阶段，函数 fun_test 在 cpp 源文件中的声明就会尝试在其它文件中寻找其定义，并最终会在 test.c 中找到该函数的定义，并把在 main.cpp 中的声明隐式提升为定义，以让我们在 cpp 源文件中实现调用 c 源文件中的功能函数

        这里可能会发现一个问题，首先第一点是当 c 源文件中的函数过多的话，那不是 cpp 源文件中对于函数的声明不久爆满了？而且原来的头文件 test.h 由于在 cpp 源文件中去掉以防止重复不同类型的声明所出现的错误，那么 test.h 不久没有任何实际价值了？是的，至少目前这段改造来说这个头文件的确是没用了，但是我们还能继续再改造下，其实关键字 extern "C" 不单单只用于声明一个成员的编译定义，还可以通过它来使用 { } 来包含一整段代码对于编译方式的定义，但是相应的我们还是不能把它放在 cpp 源文件当中，我们会把它放在头文件当中去，但是由于该关键字是 cpp 语言所支持的功能，故直接在头文件中使用会出现错误，所以这里我们还需要引入一个宏定义以区分编译当前文件的编译器使用的是 cpp 的功能还是 c 的功能，这个宏定义则叫做：__cplusplus，我们来看下改造后的代码

        *************test.h
        #ifdef __cplusplus
        extern "C" {
        #endif

        #include <stdio.h>

        void fun_test(char *name);

        #ifdef __cplusplus
        }
        #endif

        *************test.c
        #include "test.h"

        void fun_test(char *name) {

            printf("Hello,World!%s\n",name);
        } 

        *************main.cpp
        #include <iostream>
        #include "test.h"

        using namespace std;
        
        int main(void) {

            fun_test("NGPONG");
            cout << "OK!" << endl;
            return 0;
        }

        通过预处理指令 #ifdef 来区分当前是编译器所编译的功能是遵循 c 的规范还是 cpp 的规范，由于目前所编译的是 main.cpp 是属于 cpp 的规范，故该条件表达式是能够成功执行并且还是以 cpp 标准规范来进行处理，这样就可以使用 extern "C" 关键字了，并且我们还通过该关键字所提供的 { } 来完成在对 { } 内所有所有的成员都遵循 c 标准编译链接规范的目的，也就是说通过上面改造的代码，在 extern "C" { } 内的所有成员都会依照着 c 语言的规范来进行编译，这样就不会出现 cpp 编译时由于需要提供对函数重载的支持而故意??写函数名从而导致在头文件中所声明的函数找不到定义的情况了

        以上则为在 cpp 中实现调用 c 功能代码的方式，那么反过来可不可以呢？肯定是不行的，cpp 是对于 c 语言的扩展，故我们是能够在 cpp 中写入标准 c 的代码，但是 c 并不是 cpp 的扩展，故并不支持 cpp 中所扩展的关键字，也就是包括 extern "CPP" 了



运算符重载
    -> 运算符重载(operator overloading)只是一种”语法上的方便”,也就是它只是另一种函数调用的方式

    -> 成员函数运算符重载
    -> 全局函数运算符重载

    -> 定义重载的运算符就像定义函数，只是该函数的名字是 operator@，这里的 operator 是一个特殊的关键字，它和操作符 @ 构成了针对于某个操作符下的一个运算符重载函数，当我们定义好了一个运算符重载函数后，我们对于它的使用可以直接通过所定义的函数名来访问它 (operator@)，当然如果还是通过这种方式来进行访问的话，那么所构建的运算符重载就无任何实际意义了，当我们定义好一个运算符重载函数后，我们就能根据所定义的运算符所构成的表达式，并根据该运算符表达式中所录入的参数类型和参数个数 ( 在表达式中根据运算符所修饰的参数从左到右映射至所定义的运算重载函数的形参列表当中 ) 去匹配相符签名的运算符重载函数，以通过一段运算符的表达式就能够达到调用目标运算符重载函数的目的，这里通过一段运算符表达式能够达到调用目标运算符重载函数的方式主要核心是通过一点，那就是 参数匹配，我们只有保证在运算符表达式中所录入的参数是符合某个运算符表达式的形参签名列表才能够完成目标函数的调用，那么对于一个运算符重载函数来说，其参数保持在 0 ~ 2 个，具体个数取决于两个根本的因素
        -> 所重载的运算符是属于一元运算符 ( 一个形参 ) 还是二元运算符 ( 两个形参 )
        -> 运算符重载函数是声明在全局作用域下 ( 上一个因素的结果保持不变 ) 还是作为成员（非友元）声明在具体的某个 类/结构体 的内部 ( 上一个因素的结果减一 )
    在这里，第二条因素依赖于第一条因素，原因是因为当我们把运算重载函数作为成员（非友元）定义在某个 类/结构体 的内部时，对应的运算符所构造的表达式其从左到右的第一个参数其实就是当前实例的本身，故我们无需再去运算符重载函数的形参列表中又特定声明一个形参来去映射至对应运算符所构造的表达式其从左到右的第一个参数，举个例子，当所重载的运算符是一个二元运算符的时候，作为二元运算符表达式的左耳参数就是就是当前实例的本身，那么对应的，表达式中的右耳的参数则会映射到运算符重载函数中的形参列表中的第一个参数，而当我们把一个运算符重载函数定义为全局，那么就意为该重载函数其实是不属于任何一个复合类型中的成员，所以这个运算符重载函数中的形参个数也需要依据着所重载的运算符的元数来决定参数列表的个数，下面的代码展示了在一个二元运算符中，当我们把运算符重载函数声明在全局亦或者某个复合类型成员内部时的参数列表的不同体现
    #include <iostream>
    using namespace std;

    struct Person {
    friend void operator+(Person &per_01, Person &per_02) {
        per_01.m_age += per_02.m_age;
        return;
    };

    public:
    Person(int age)
        : m_age(age) {}

    Person(const Person &per) {
        this->m_age  = per.m_age;
    }
    ~Person() {
        cout << "Person descturctor" << endl;
    }

    Person &operator+(int age) {
        this->m_age += age;
        return *this;
    }

    public:
    int m_age;
    };

    int main(void) {

    Person per_01(0);
    Person per_02(256);
    per_01 + 1 + 2 + per_02;

    system("pause");
    return EXIT_SUCCESS;
    }

    -> 保证一个运算符重载函数在全局作用域下亦或者某个类的作用域下有其定义
        -> 运算符重载函数理论上来说是可以声明在任意地方，但是我们需要注意的是，我们使用运算符重载函数的过程通常都是通过其所重载的具体的运算符所构造的表达式以映射到具体的运算符重载函数来完成它的调用，也就是说，当我们使用指定的运算符所构建的表达式的代码位置是无法通过直接的方式访问本该我们所预想的该表达式所对应的运算符重载函数所在的作用域的时候，我们直接通过运算符表达式以完成对应的运算符重载函数的调用就会失败了，因为我们在构建运算符表达式的时候是不能单独引用具体某个作用域的，那么我们换种思想，我们可不可以直接通过 :: 来引用具体的某个作用域并通过所指定的运算符重载函数名以完成它的调用呢？答案是可以的，但是这样做并无实际意义，所以，我们要保证的是，使用运算符重载函数所重载的运算符所构建的表达式所处的作用域是能够通过直接的方式访问得到该运算符所映射到具体的运算符重载函数身上

    -> 前面提到过，运算符重载函数我们可以书写在全局作用域下亦或者具体到某个 类/结构体 中的成员当中，那么我们假设在同一个命名空间这个大的、运算符重载函数可被发现的作用域之下分别书写了两个相同重载符号的运算符重载函数的时候，我们要保证 所构建出来的表达式映射到具体的运算符重载函数时 并不会出现二义性，如下面的代码则是一个典型的二义性的例子，我们所书写的表达式编译器不知道其具体是映射到 类中所书写的运算符重载函数呢，还是在全局作用域下所书写的运算符重载函数，因为两者都是复合我们所书写的表达式的构建，这就会造成一个二义性
    #include <iostream>
    using namespace std;

    struct Person {
    friend void operator+(Person &per_01, int age) {
        per_01.m_age += age;
        return;
    };

    public:
    Person(int age)
        : m_age(age) {}

    Person(const Person &per) {
        this->m_age  = per.m_age;
    }
    ~Person() {
        cout << "Person descturctor" << endl;
    }

    Person &operator+(int age) {
        this->m_age += age;
        return *this;
    }

    public:
    int m_age;
    };

    int main(void) {

    Person per_01(0);
    Person per_02(256);
    per_01 + 1 + 2 + 3;

    system("pause");
    return EXIT_SUCCESS;
    }

    -> 运算符重载函数的形参列表中，必须具有 复合类型（类/结构体）或者枚举类型作为参数，所以，如果我们想单纯的通过运算符重载函数去改变内置数据类型（int,char,etc）的运算规则是不可行的

    -> 运算符重载函数允许进行重载

    -> 当运算符重载函数作为 成员函数 而出现时，其不能声明为静态

    -> 运算符重载函数是可以作为一个类中的友元成员的
        -> 当运算符重载函数作为一个类中的友元声明的时候，由于友元成员虽然需要被 定义/声明 在一个类的内部，但是它并不属于这个类中的一个成员，具体来讲，友元的定义是作用于全局作用域之下，故运算符重载函数中的 形参个数 要以声明在全局作用域下的运算符重载函数的角度来看待，相应的，和普通的运算符重载函数一样，对应的运算符表达式会在全局作用域下通过参数匹配的方式搜寻到该友元声明的具体定义

    -> 尽量不要重载逻辑运算符 &&/||
        -> 当我们对于逻辑运算符进行了重载，那么该运算符原来所保有的短路求值的特性就会被取消，什么是短路求值，就 && 来说，如果一旦表达式的左耳是一个假值得话，那么 && 所构成得表达式整体就是一个假值，即 && 表达式得右耳是无需进行计算的，而当我们进行了重载后，不管左耳是否是一个已经能够确定整个逻辑运算表达式得标识值，作为右耳函数会参与进行计算以匹配到具体得所重载得函数得调用，这可能并不是我们想要得结果，并且在一定程度上能够带来性能得损失（进行了无关紧要的计算）

    -> 运算符重载函数的使用
        -> +
            -> 返回值和形参并没有特殊的条件限制
            -> 可以声明在任意的位置 (成员函数/全局函数)
        -> << / >>
            -> 返回值和形参并没有特殊的条件限制
            -> 可以声明在任意的位置 (成员函数/全局函数)
        -> =
            -> 通常用于作为拷贝语义和移动语义的展开，这里不详细讲
            -> 返回值和形参并没有特殊的条件限制
            -> 只能够声明为成员函数
        -> ++/--
            -> 如果是后置运算，我们要保证形参列表中的保有一个 int 类型的占位参数并且其在参数列表中的最后的位置，以告诉编译器该运算符重载函数是一个后置运算符重载函数，而对于前置运算符对于形参则无特殊的限制
            -> 返回值没有特殊的条件限制
            -> 可以声明在任意的位置 (成员函数/全局函数)
        -> ()
            -> 返回值和形参并没有特殊的条件限制
            -> 只能够声明为成员函数
            -> 该运算符所构造的重载调用更专业的名称为：仿函数
        -> ==/!=
            -> 返回值和形参并没有特殊的条件限制
            -> 可以声明在任意的位置 (成员函数/全局函数)
        -> []
            -> 形参  ( 到时候 blog 的书写格式要按照下面的这种方式吗？ ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ )
                -> 成员：1个
                -> 全局：2个 
                [] 虽然是一个一元运算符，但是我们实际上需要把它当作一个二元表达式的形参个数来看待
            -> 返回值无特殊的限制
            -> 只能够声明为成员函数
        -> *
            -> 返回值和形参并没有特殊的条件限制
            -> 可以声明在任意的位置 (成员函数/全局函数)
        -> ->
            -> '->' 是一个一元运算符，故形参个数要按照一元表达式的形参格式来看待
               虽然是一个一元符，但是它却不支持单独使用，即他所构造出来的表达式在之后往往需要承接着对于另一方的调用才能够通过编译
            -> 返回值要么返回一个裸指针，要么（按引用或值）返回同样重载了运算符 -> 的对象，由于其返回值的限制还有 '->' 无法单独使用的特性，意味着我们使用 '->' 所构成的表达式在映射到对应的函数调用完毕并且返回相应的值后，我们还要承接着一次 '->' 的调用，意味着实际要调用的表达式需要有两次 '->' 操作符的使用 '->->' 但是编译器会帮我省去后一次 '->'
            -> 只能够声明为成员函数



模板
    -> 模板技术是泛型编程的基础，模板能够把 函数或类 的上下文中要处理的数据类型进行参数化，表现为参数的多态性，并且由于模板所保有的 类型参数化 的特点，模板我们又称 参数模板

    -> 模板的声明
        -> 当一个 类或函数 的前置中出现了关键字 template<typename/class T> 的修饰，那么就可以在当前所修饰的 类或函数 的上下文中使用这个 虚拟类型T 所做的变量声明去完成逻辑运算并且编译器暂时放弃对使用到 虚拟类型T 的地方做语法的检查，即暂时不考虑模板虚拟类型参数使用的有效性，当我们在使用这个模板成员（调用这个函数或者声明这个类） 的时候我们就可以 显示或隐式 的指定虚拟类型T的具体类型，编译器会依照我们 显示或隐式 指定的具体的类型替换至当前上下文中使用到虚拟类型T的地方并新生成一个不同副本的 函数或类，然后再针对此新生成的成员结果针对性的做一次完整语法校验的编译性工作，我们是完全可以把 模板 和 宏 联系在一起的，亦或者说 模板 是一种更加高级的 宏，因为对于 模板 来说，它并不是一种 真实 存在的成员，也就是说我们在不适用它的时候，他是不会编译进一个二进制文件当中的，而当我们真正的去使用这个定义好的模板成员并指定了其虚拟类型的具体类型，编译器才会依照所指定的类型去新创建一个完全体的副本，而这个副本才会编译进一个二进制文件当中
        -> 额外扩充一点，我们会发现模板所声明的虚拟类型 T 前面还使用了 typename/class 来进行修饰，其实二者的使用并无任何区别，只是我们都会约束对于函数模板的声明使用 typename，而对于类模板的声明则使用 class
        #include <iostream>
        using namespace std;

        template<typename T> 
        void fun_test(T value) {
            value += 1;
            cout << value << endl;
        }
        
        int main(void) {
            fun_test<int>(0x200);

            system("pause");
            return EXIT_SUCCESS;
        }

    -> 模板成员是无法进行单独的使用的，我们必须要在其使用前指定模板中的虚拟类型 T,T1,T2,etc 的具体类型才能够进行使用，cpp中提供了两种方式去指定一个模板虚拟类型的具体类型
        -> 显示指定：
            -> 在调用模板成员时通过操作符 <Type> 去显示的指定当前模板成员
        -> 隐式指定：
            -> 隐式指定的方式只能够针对于 函数模板 的使用(类模板不可用)，当在调用 函数模板 时，编译器会依照函数调用所录入的实参具体类型去自动推导出当前函数模板的虚拟类型的具体类型，即通过这种方式完成函数模板的调用是不需要显示的指定虚拟类型（<Type>）的具体类型的，但需要注意的是，我们要保证同一个虚拟类型下所对应函数形参在进行调用时所录入的实参并不会对其产生一个二义性访问，如下面的代码则为一个典型的二义性访问，这时候编译器所提供的自动类型推导则会失效
            template<typename T>
            void fun_test(T var1, T var2) {
                cout << "template function" << endl;
                cout << var1 << endl;
                cout << var2 << endl;
            }

            int main(void) {
                fun_test(0x400, 'G');
                return EXIT_SUCCESS;
            }
            -> 隐式指定的类型是函数指针类型时，还差点！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
                template<typename _Arg, typename _Result>
                void fun_test(_Result (*_invoker)(_Arg)) {
                cout << typeid(_Result).name() << endl;
                cout << typeid(_Arg).name() << endl;
                cout << typeid(_invoker).name() << endl;
                }

                template<typename _Result>
                void fun_test_02(_Result invoker) {
                invoker(0x400);
                }

                bool __fun(int _val) {
                cout << _val << endl;
                return false;
                }

    -> 指定模板的默认类型，具体来说它是仅对 类模板 有意义，因为对于 类模板 来说，编译器并没有提供隐式指定的方式来完成模板类的虚拟类型的自动类型推导功能

    -> 模板成员可以具有声明和实现，需要强调的是
        -> 我们无法在实现一个 函数模板的声明亦或者说类模板内部的成员声明 时就去指定模板成员的虚拟类型的具体类型，可以简单的理解为，我们永远只能够在使用模板成员的时候才可以去指定该模板成员的虚拟类型的具体类型
        -> 其次就是关于 模板成员 的实现和声明 分文件编写的问题，前面提到，对于模板成员来说，它并不是一个真实存在的成员，仅当我们真正的去使用使用了这个模板成员并指定了模板虚拟类型的具体类型后，编译器才会为我们生成一个真实存在的成员，那么当一个模板成员的声明和实现并不是 声明在同一个文件内亦或者被包含在一个文件内 的情况下，编译时会报错，原因是因为编译器是属于独立单元进行的编译工作，当我们在一个编译单元内使用一个仅存在声明的模板成员时，由于对于模板成员来说，其符号链接仅仅只能够在当前编译单元中进行，无法扩展至其它的文件，故这时候我们在使用的时候就会出现错误，解决方案则为把模板成员的声明和实现都写在同一个文件内，在 cpp 中针对这种需要被包含的，但是却存在实现的文件的后缀约定俗成的写为 .hpp
        #include <iostream>
        using namespace std;

        /* Template class */
        template<class T>
        class Person {
        public:
          Person(T _age)
            : m_age(_age){};
        public:
          /* Declare function members of the template class */
          void p_print(T _age_plus);
        public:
          T m_age;
          char gender;
        };
        /* Function member that implement the template class */
        template<class T>
        void Person<T>::p_print(T _age_plus) {
          cout << this->m_age + _age_plus << endl;
        }


        /* Declare template function */
        template<typename T>
        void fun_test(T &per);

        /* Implement template function */
        template<typename T>
        void fun_test(T &var) {
          var.p_print(0x100);
        }

        int main(void) {
          Person<int> per(0x200);
          fun_test(per);

          system("pause");
          return EXIT_SUCCESS;
        }


    -> 两种模板机制
        -> 函数模板
            -> 函数模板即 所修饰的成员 为一个函数
            -> 在使用隐式指定的方式去指定模板虚拟类型的具体类型的情况下，如果函数模板的调用和现存上下文中的某个普通函数的调用存在二义性，则 cpp 编译器会优先考虑普通函数，除非更改为显示指定的方式亦或者在调用时声明空模板类型然后模板的虚拟参数类型则依照隐式方式去指定
               当然，如果函数模板对比普通函数的调用能够得到更加合适的匹配，则编译器会优先调用函数模板
            -> 函数模板可以存在重载并且我们无需担心所重载的版本会和现存的普通函数会出现二义性冲突问题，因为编译器总会依照我们的代码去匹配最适合的函数的调用
            -> 函数模板的具体化
                -> 在某些情况下，我们针对于某个具体的类型所引用的函数模板的内部实现可能不太满意，这时候我们可以针对这个具体的类型去提供该函数模板的另一个特殊的副本，这个副本就叫做 具体化函数模板，即声明一个相同签名的函数并使用空模板操作符 template<> 进行修饰，然后函数的形参列表由原有的所指定的虚拟类型直接替换为具体的类型即可，那么当我们在使用这个具体的类型去对函数模板进行调用时（调用方式），所调用的实现则为我们所指定的具体化函数模板的实现
                -> 对于一个具体化的函数模板而言，其调用的优先级要高于其最原始的函数模板的副本

        -> 类模板
            -> 类模板即 所修饰的成员 为一个函数
            -> 一个声明为 类模板 的类型则为 class_name<Type>
            -> 类模板同样是可以用于继承的，需要注意的是，类模板所派生的子类需要在继承语句时就需要指定其上级基类类模板的虚拟类型的具体类型，当然我们同样可以把这个具体的类型扩展至当前派生类的虚拟类型以代替
                template<class T>
                class Person {
                public:
                  Person(T _age) : m_age(_age) { };
                public:
                  T m_age;
                };

                /* 显示的指定上级基类类模板的虚拟类型的具体类型 */
                template<class T, class T_BASE>
                class Student : public Person<T_BASE> {
                public:
                  Student(T _name, T_BASE _age) : Person<T_BASE>(_age), m_name(_name) { };
                public:
                  T1 m_name;
                };

                /* 上级基类类模板虚拟类型的具体类型扩展至当前派生的虚拟类型身上 */
                template<class T>
                class Workder : public Person<int> {
                public:
                  Student(T _name, int _age) : Person<int>(_age), m_name(_name) { };
                public:
                  T1 m_name;
                };

            -> 友元成员
                -> 模板友元
                    -> 当一个普通类中的友元声明赋以模板的形式而存在，那么这个友元声明则为 模板友元
                    -> 对于 模板友元 来说，其同样需要遵循友元成员所需注意的要素，需要注意的一种情景时，当 模板友元 所修饰的是一段定义，并且其包含着 当前类型 的参数，那么我们在通过直接的方式去调用该友元成员的时候，我们是无法显示的指定模板虚拟类型的具体类型的，也就是说虚拟类型的匹配依赖至参数录入所触发的隐式指定机制上，除非我们在全局命名空间下对于该模板友元所修饰的成员做一次声明，那么在这种情境之下我们才可以显示的指定模板友元虚拟类型的具体类型
                    #include <iostream>
                    using namespace std;
                    
                    class Person {
                      template<typename T>
                      friend void fun_test_01(Person &per, T var) {
                        cout << "FUN_TEST_01" << endl;
                        cout << per.m_age + var << endl;
                      }

                      template<typename T>
                      friend void fun_test_02(Person &per, T var) {
                        cout << "FUN_TEST_02" << endl;
                        cout << per.m_age + var << endl;
                      }
                    
                      template<typename T>
                      friend void fun_test_03(Person &per, T var);
                    
                    public:
                      Person(int _age)
                        : m_age(_age){};
                    
                    private:
                      int m_age;
                    };
                    
                    template<typename T>
                    void fun_test_02(Person &per, T var);
                    
                    template<typename T>
                    void fun_test_03(Person &per, T var) {
                      cout << "FUN_TEST_03" << endl;
                      cout << per.m_age + var << endl;
                    }
                    
                    int main(void) {
                      Person per(0x400);

                      /** 
                       * 由于 fun_test_01 并没有在全局作用域下有一个其对应的声明，
                       * 故我们无法显示的指定该模板虚拟类型的具体类型，只能够依赖于参
                       * 数录入所触发的隐式指定的机制来完成 
                       */
                      fun_test_01(per, 0x200);
                    
                      fun_test_02<int>(0x200);
                    
                      fun_test_03<int>(per, 0x100);
                    
                      system("pause");
                      return EXIT_SUCCESS;
                    }

                -> 模板类中的友元成员
                    -> 对于模板类中的友元成员，必须要包含当前模板类型的参数
                    -> 友元所修饰的定义
                        -> 由于对于 模板类中的友元成员 来说，其必须要包含着当前模板类型的参数，故对于一个友元所修饰的定义我们是可以直接在外部中进行调用的
                        #include <iostream>
                        using namespace std;

                        template<class T>
                        class Person {
                        public:
                          friend void fun_test(Person<T> &per,T var) {
                            cout << "FUN_TEST" << endl;
                            cout << var << endl;
                          }

                        public:
                          Person(T _age)
                            : m_age(_age) {};

                        private:
                          T m_age;
                        };

                        int main(void) {
                          Person<int> per_int(0x400);

                          fun_test(per_int, 0x400);

                          system("pause");
                          return EXIT_SUCCESS;
                        }

                    -> 友元所修饰的声明
                        -> 我们为友元所修饰的声明在全局命名空间下构建定义的方式较为复杂，一般来说分为以下两种方式
                        -> 
                        #include <iostream>
                        using namespace std;

                        /** STEP 4
                         * 由于 STEP 3 中使用了 Person<T>，但是 STEP 3 却定义在 Person<T> 之前，故还要在 STEP 3 之上为 Person<T> 做一次前置声明
                         */
                        template<class T>
                        class Person;

                        /** STEP 3
                         * 为 STEP 2 中的定义再做一次声明，该行代码应该出现在 STEP 1 和 STEP 2 之上
                         */
                        template<typename T>
                        void fun_test(Person<T> &per, T var);

                        template<class T>
                        class Person {
                        public:
                          /** STEP 1
                           * 指定该声明使用空模板类型，目的是为了能够准确的链接到 STEP 2 中的模板定义
                           */
                          friend void fun_test<>(Person<T> &per, T var);

                        public:
                          Person(T _age)
                            : m_age(_age) {};

                        private:
                          T m_age;
                        };

                        /** STEP 2
                         * 为模板类中的友元所修饰的声明构造一个即将链接到的定义
                         */
                        template<typename T>
                        void fun_test(Person<T> &per,T var) {
                          cout << "FUN_TEST" << endl;
                          cout << per.m_age + var << endl;
                        }

                        int main(void) {
                          Person<int> per_int(0x400);
                          fun_test(per_int, 0x400);

                          system("pause");
                          return EXIT_SUCCESS;
                        }

                        -> 
                        #include <iostream>
                        using namespace std;
                        
                        /** STEP 3
                         * 由于 STEP 2 中使用了 Person<T>，但是 STEP 2 却定义在 Person<T> 之前，故还要在 STEP 2 之上为 Person<T> 做一次前置声明
                         */
                        template<class T>
                        class Person;
                        
                        /** STEP 2
                         * 为模板类中的友元所修饰的声明构造一个即将链接到的定义，该行代码应该出现在 STEP 1 之上
                         */
                        template<typename T>
                        void fun_test(Person<T> &per,T var) {
                          cout << "FUN_TEST" << endl;
                          cout << per.m_age + var << endl;
                        }
                        
                        template<class T>
                        class Person {
                        public:
                          /** STEP 1
                           * 指定该声明使用空模板类型，目的是为了能够准确的链接到 STEP 2 中的模板定义
                           */
                          friend void fun_test<>(Person<T> &per, T var);
                        
                        public:
                          Person(T _age)
                            : m_age(_age) {};
                        
                        private:
                          T m_age;
                        };
                        
                        int main(void) {
                          Person<int> per_int(0x400);
                          fun_test(per_int, 0x400);
                        
                          system("pause");
                          return EXIT_SUCCESS;
                        }


类型转换
    -> 对于类型转换需要一提的是，在 c/cpp 中的强制类型转换还是典型的非强制类型转换也好，即使转换失败也不会在运行时发生错误，仅有的错误只是会得到一个错误的转换结果亦或者是编译级别时所发生的错误

    -> 静态类型转换：static_cast<type>(expression)
        -> 静态类型转换对于任何结果失败的转换都会在 编译时发生错误
        -> 内置数据类型的 窄化或典型的非强制 转换
        -> 不可用于自定义类型的转换
        -> 可用于内置数据类型的 指针/引用 的转换，除了非 void * 类型的指针之间的转换 都会针对 表达式的指针类型与目标指针类型 做匹配校验，如无法进行有效的匹配则转换失败
        -> 可用于 继承结构中类型指针 的 上行转换(DERIVED -> BASE) 和 下行转换(BASE -> DERIVED)，但是 不支持没有任何继承体系的类型的指针 之间的转换
        #include <iostream>
        using namespace std;
        
        class BASE {};
        class DERIVED : public BASE {};
        class OTHER {};
        
        int main(void) {
            /* 1. 基础数据类型转换 */
            int a = 0x400;
            long a_l = static_cast<long>(a);                        /* 典型的非强制转换 */     
            int b = 364;                    
            char b_c = static_cast<char>(b);                        /* 窄化转换，可能会丢失精度 */
        
            /* 2. 无法应用于自定义数据类型的转换 */
            BASE base_01;
            DERIVED derived_01 = static_cast<BASE>(base_01);
        
            /* 3. 指针类型的转换，对于除了非 void * 的指针类型，对会 目标类型与表达式类型 之间的指针类型进行校验 */
            char *c_p = static_cast<char *>(&a);                    /* 失败，int * 与 char * 不匹配 */
            void *p_01 = static_cast<void *>(&a);                   /* 成功，void * 指针类型不做检验 */
            int *p_02 = static_cast<int *>(p_01);                   /* 成功，void * 指针类型不做检验 */
            int *p_03 = static_cast<int *>(p_02);                   /* 成功，int * 与 int * 匹配 */
        
            /* 4. 类指针的静态定位 */
            BASE base;
            DERIVED derived;
            OTHER other;
            BASE *p_base = static_cast<BASE *>(&derived);           /* 上行转换 */
            DERIVED *p_derived = static_cast<DERIVED *>(p_base);    /* 下行转换 */
            OTHER *p_other = static_cast<OTHER *>(p_base);          /* 失败，转换对象间不存在继承体系 */
        
            return EXIT_SUCCESS;
        }

    -> 动态类型转换：dynamic_cast<type>(expression)
        -> 该转换在运行时需要一点额外的开销
        -> 不支持应用于 基础内置数据类型或者是基础内置数据类型的指针/引用 的转换，对于这些类型的转换会在编译时抛出错误
        -> 仅支持 存在虚成员（要保证 expression 是保有虚成员的表达式，否则会在编译时抛出错误） 的类的指针/引用 之间的转换，对于任何转换失败的结果并不会在编译时出现异常，仅仅会返回一个指向空的指针
        -> 动态类型转换常用于一段存在继承体系的类的向上/向下类型转换，对于向下类型转换来说，仅当类型转换是争取的并且是成功的时，返回值是一个指向所需类型的指针，否则它将返回指向空的指针来表示转换失败（expression 的本身并不是指向 derived），我们可以理解为动态类型转换对于向下类型转换来说多了一个运行时的检测功能
        -> 动态类型转换还可以用于存在交叉继承体系的类的转换
        #include <iostream>
        using namespace std;

        class BASE { virtual ~BASE() {}; };

        class DERIVED : public BASE {};

        class OTHER {};

        int main(void) {
          /* 基础类型的转换 */
          int *p_a = new int(0x400);
          long *p_b = dynamic_cast<long *>(p_a);                                          /* 失败，动态类型转换不支持基础数据类型和基础数据类型指针间的转换 */


          /* 类的指针/引用的转换 */
          BASE *base_non_polymorphism = new BASE;
          DERIVED *der_non_polymorphism = dynamic_cast<DERIVED *>(base_non_polymorphism); /* 失败，expression 无法构成多态，故向下类型转换失败，并返回一个空指针 */

          BASE *base_polymorphism = new DERIVED;
          DERIVED *der_polymorphism = dynamic_cast<DERIVED *>(base_polymorphism);         /* 成功，expression 可以构成多态 */
          BASE *base_more = dynamic_cast<BASE *>(der_polymorphism);                       /* 成功，向上类型转换 */

          OTHER *other = dynamic_cast<BASE *>(der_polymorphism);                          /* 失败，OTHER 和 expression 并不存在于同一条继承体系当中 */

          return EXIT_SUCCESS;
        }

    -> 常量类型转换：const_cast<type>(expression)
        -> 可以将 常量/非常量 转换为 常量/非常量
        -> 仅支持 指针/引用 间的转换，对于非 指针/引用 的转换会在编译时抛出错误
        #include <iostream>
        using namespace std;
        
        int main(void) {
          int a = 0x400;
          /* const int a_c = const_cast<const int>(a); */     /* 失败，仅支持指针类型的转换 */
        
          int *a_p = new int(0x400);
          const int *a_p_c = const_cast<const int *>(a_p);
          int *a_p_normal = const_cast<int *>(a_p_c);
        
          int &a_r = *a_p;
          const int &a_r_c = const_cast<const int &>(a_r);
          int &a_r_normal = const_cast<int &>(a_r_c);
        
          system("pause");
          return EXIT_SUCCESS;
        }

    -> 重定义转换：reinterpret_cast<type>(expression)
        -> 重定义转换是一种不安全的转换，它可以把非指针类型转换为指针，又可以把指针类型转化为非指针类型，不推荐使用！
        #include <iostream>
        using namespace std;

        int main(void) {
          int a = 0x400;
          int *a_p = reinterpret_cast<int *>(a);   /* unsafe:a_p->0x400 */

          return EXIT_SUCCESS;
        }



-> 异常
    -> 异常捕获：try - catch(exception_type instance)
        -> 尝试执行 try 块中的代码，仅当可能出现亦或者显示抛出（throw）的异常则最终会被捕获到 catch 块的内部
        -> try 和 catch 必须是成对的出现，无法进行单独的使用，否则会造成编译级的报错
        -> catch 块开始前必须要声明一个异常类型 exception_type，所抛出（throw）的异常（expression）最终会映射至声明了对应 expression 类型的 catch 块的上下文当中，需要注意的是，所 throw 的 expression 的类型必须和 catch 的 exception_type 的类型进行严格匹配，举个例子，所 throw 的 expression 的类型为 int 类型时，那么 catch 所指定的异常类型也必须为 int 类型，如果一段异常的上下文中所 throw 的 expression 并没有一个有效的 catch 进行匹配，则直接终止程序
        -> catch 块中可以指定任意类型的异常类型 exception_type，当 exception_type 的类型为 ... 时，则意味指定的异常类型为其它类型
        -> catch 块所声明的异常类型在 catch 块结束前会释放掉其在栈中的内存数据，如果所声明的异常类型在堆中存有数据则需要我们进行手动的释放工作，否则会出现内存泄漏的问题
        -> 针对 catch 中所即将捕获的所 throw 的不同异常类型的 expression，我们在同一个 try 块中指定多种不同异常类型的 catch
        
    -> 抛出异常：throw expression
        -> throw expression 用于抛出一个异常，并指定一个异常的实例 expression，异常实例可以是任意类型的值，我们要保证的是一个 throw expression 最终都会有一个 try 进行异常侦测，相对应的，都会有一个声明了 所 throw 的 expression 类型的 catch 块来完成 try 后的异常捕获工作，如果 throw expression 所处的上下文中并没有一个合法的 try-catch 进行异常的捕获，那么会跳到其上级调用者的上下文中进行寻找，以此重复，直至找不到为止则程序终止
        -> 当 throw 不指定 expression 并且它出现在一个拥有合法异常类型声明的 catch 块中时，则会延续当前 catch 块中所声明的异常类型继续向上抛出异常，我要们要注意他不可以出现在其他上下文中，否则程序会直接终止
        -> catch 块中所声明的异常类型会根据所 throw 的对应类型的 expression 去进行构造，其实更细来讲的话，当我们 throw 一个 expression 时，编译器会根据这个 expression 为我们去构造一个临时的、将亡的、左值变量，没错，是一个临时、将亡的 左值 变量，然后对应 expression 类型的 catch 块的异常类型的声明则会根据这个左值变量去进行构造，并在当前 catch 上下文执行完毕后会显式的释放掉这个左值变量在栈中的内存，如果 expression 所创建的临时的、无名的变量会在堆中存有数据，即一个指针，由于该指针所指向的堆中的地址最终会映射至 catch 块中所声明的异常类型当中（catch 块中的所声明的异常类型会依据所 throw 的 expression 去进行构造），故在 catch 块结束时，编译器所构造的临时的、无名的、类型为左值的指针变量也仅仅会被释放掉其在栈中的数据，而在堆中的数据的生命周期则同步至 catch 块中所声明的异常类型去进行管控，也就是说我们要针对这个异常类型去进行手动的释放内存的工作，否则会出现内存泄漏的问题
        -> 从 try 代码块开始，到 throw 抛出异常之前，所有栈上的数据都会被释放掉，这一过程又称为 栈解旋，当然 栈解旋 所保证的内存有效性的工作也仅仅针对栈上，对于堆中分配的内存我们在 throw 之前需要对其进行手动的释放，否则会出现可能的内存泄露的问题
        -> throw 可以写在构造函数当中

    -> 关于 catch 块中所声明的异常类型的效率问题
        -> 我们都知道，throw expression 其实编译器会根据这个 expression 为我们构建一个临时、将亡的 左值 变量，并在最后，最终捕获到到这个异常的 catch 块中所声明的异常类型会依据这个 左值变量 去完成构造初始化工作，对于内置数据类型的异常类型而言似乎并无太大问题，但是对于一个自定义的异常类型的类来说，由于该类的构造是通过一个对应类型实例的左值变量来完成，故会调用该类型的拷贝构造函数来完成 catch 块中所声明的异常类型的初始化工作，由于在这里调用了拷贝构造函数，故可能会在某些程度上带来性能损失的问题，由于 throw 的 expression 虽然是一个临时的、将亡的变量，但是其实质是一个左值变量，故解决这一方案只需要把 catch 块中所声明的异常类型改为左值引用即可
    
    -> 系统标准异常接口 exception
        -> exception	        所有标准异常类的父类
           bad_alloc	        当operator new and operator new[]，请求分配内存失败时
           bad_exception	    这是个特殊的异常，如果函数的异常抛出列表里声明了bad_exception异常，当函数内部抛出了异常抛出列表中没有的异常，这是调用的unexpected函数中若抛出异常，不论什么类型，都会被替换为bad_exception类型
           bad_typeid	        使用typeid操作符，操作一个NULL指针，而该指针是带有虚函数的类，这时抛出bad_typeid异常
           bad_cast	            使用dynamic_cast转换引用失败的时候
           ios_base::failure	io操作过程出现错误

           logic_error	        逻辑错误，可以在运行前检测的错误
            -> logic_error的子类：
            length_error	    试图生成一个超出该类型最大长度的对象时，例如vector的resize操作
            domain_error	    参数的值域错误，主要用在数学函数中。例如使用一个负值调用只能操作非负数的函数
            out_of_range	    超出有效范围
            invalid_argument	参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是’0’或’1’的时候，抛出该异常

           runtime_error		运行时错误，仅在运行时才可以检测的错误
           -> runtime_error的子类：
            range_error	        计算结果超出了有意义的值域范围
            overflow_error	    算术计算上溢
            underflow_error	    算术计算下溢
            invalid_argument	参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是’0’或’1’的时候，抛出该异常


lambda
    -> cpp11 为了简化回调函数定义时繁琐的工作，提供了 lambda 表达式去用于 定义并创建匿名的函数对象，在编译时，编译器则会依据 lambda 表达式的声明形式去构建出一个匿名函数

    -> lambda 表达式的构成
    [capture](parameters) mutable ->return_type {
        statement
    }

        -> [capture]: 函数对象参数
            -> [capture] 标识着 lambda 表达式的开始，它无法省略
            -> 一个 lambda 表达式虽然是支持写在一个函数体的上下文中，但是在默认情况下，lambda表达式内的上下文声明中是不可以显式的指定那些 从函数体开始到定义lambda为止范围内可见的局部变量(包括lambda表达式声明所在类的this)，因为 lamdba 表达式编译器在编译时才会根据当前表达式的声明去另外创建一种匿名函数，简而言之，lambda 表达式声明内部的上下文是根本就不被含纳在声明 lamdaba 表达式本身所处的作用域内，除非我们显式的指定 [capture]，以告诉编译器 lambda 表达式内部的上下文中所 使用到的、属于 lambda 表达式本身所处的作用域内的 变量需要以哪种形式去 拷贝/引用 到 lambda 表达式内部的上下文当中，以让 lambda 表达式内部的上下文中能够使用到非当前上下文作用域内 的变量

            -> []:不使用任何声明 lambda 表达式本身所处的作用域内的任何变量，即 lambda 表达式内部的上下文和外部作用域(非全局)处于一种隔离的状态
            -> [=]:lambda 表达式内部的上下文中所使用到的 [所有] 属于 lambda 表达式本身所处的作用域内的变量以值拷贝的形式拷贝到 lambda 表达式内部的上下文当中
            -> [&]:lambda 表达式内部的上下文中所使用到的 [所有] 属于 lambda 表达式本身所处的作用域内的变量以地址引用的形式引入到 lambda 表达式内部的上下文当中
            -> [this]:lambda 表达式内部的上下文中可以使用所处类的 this 指针去访问类中的成员
            -> [variable]:lambda 表达式本身所处的作用域内的变量 variable 以值拷贝的形式拷贝到 lambda 表达式内部的上下文当
            -> [&variable]:lambda 表达式本身所处的作用域内的变量 variable 以地址引用的形式把它引用到 lambda 表达式内部的上下文当中

            -> lambda 能够通过 [capture] 所指定的函数对象参数来决定 是否含纳、如何含纳 声明lambda表达式本身所在作用域内的变量至lambda表达式内部上下文的声明中，这种机制称之为 [捕获]，而应用了这一机制的lambda 表达式也称为捕获lambda表达式，需要注意的是，捕获lambda所捕获的外部作用域下的变量都是以 只读 的方式存在于 lambda 表达式内部上下文的声明当中的，这时候就可能存在一个问题，当以值传递的方式所 捕获 的外部作用域下的变量，一切的修改都无法映射至外部作用域上的具体变量，即我们对其的修改仅仅只在当前 lambda 表达式内部上下文声明的作用域之内进行，而就引用传递来说，同样也是无法修改，只是无法修改的仅是引用的指向，而不是所引用的对象在内存中的数据

        -> (parameters): 匿名函数的形参列表，如当前匿名函数并没有形参，则可以省略

        -> mutable: 当函数对象参数是以值传递的形式而存在时，编译器都会把它们设为只读的变量，那么当我们加了该关键字后，编译器就不会把它们设置为只读变量了，即可以修改按值传递进来的拷贝，如无特殊要求可以省略

        -> return_type: 显式的指定当前匿名函数的返回值类型，就算不显式的进行指定，编译器也会依照匿名函数上下文中所 return 的类型去判断所返回的函数指针的返回值类型

        -> { statement }: 指定 lambda 表达式内部上下文的声明

    -> lambda 表达式与函数指针
        -> 没有使用函数对象参数的lambda表达式其可以返回一个对应函数类型(形参和返回值类型)并指向刚刚所构建出来的匿名函数地址的 [函数指针]
        -> 而使用了函数对象参数的捕获lambda表达式仅只能够隐式转换为 一个具体的、能够保存所捕获变量的状态 的对象，在这里，更推荐的方式则为在 <functional> 头文件中的 std::function<>，那么，为什么对于捕获lambda而言就需要使用这种特殊的存储方式而不仅仅只是一个单纯的函数指针，这就需要从捕获lambda的本质来谈起

        对于 捕获lambda 来说，它能够把外部作用域下的变量纳入到当前lambda上下文的声明中，这并不是什么黑科技，编译器只是把它所使用到的一些外部作用域下的变量通过不同的形式（值或者引用）把它们的状态保存起来并结合着当前lambda上下文的声明一同放入一个 "容器" 里面去，而对于 lambda 的调用则会依托着这个容器来进行，那么在 lambda 上下文声明中对于原本隶属外部作用域下的变量的调用则更改为仅仅针对容器内部所维护的从外部作用域下捕获进来的临时变量的状态来进行，需要注意的是，容器内部所维护的那些映射至外部作用域下的变量的状态在容器本身未释放之前，原本隶属于外部作用域下本身应该被释放的变量都会呈现着一种 闭包 的状态
        
        需要扩充一点的是，我们都说使用 [=] 函数对象参数不能改变外部作用域下的变量的值，因为这些变量放到lambda上下文的声明中仅仅只是以一个值传递的形式而存在，那么这里的无法改变外部作用域这句话还真的是无法改变外部作用域下的变量的本身，但并不意味着在捕获lambda所构造的容器中内部所维护的对应的这个变量的值是无法改变的，即管理着这个 lambda表达式和外部作用域下变量的状态的 容器在其被释放前，所维护的变量的状态值一直都是一种有效值


STL
    -> STL Standard template library

    -> STL 从广义上分为了 容器(container)、算法(algorithm)、迭代器(iterator)，其中，容器和算法之间通过迭代器进行了无缝的链接，如果需要进一步的细分，具体来说 STL 其实提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器
       容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。
       算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.
       迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-> , operator++,operator--等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。
       仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template
       适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。
       空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.
    STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数

    -> STL 的优点
        -> STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。
        -> STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作
        -> 程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。
        -> STL 具有高可重用性，高性能，高移植性，跨平台的优点。
            -> 高可重用性：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会
            -> 高性能：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。
            -> 高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。

    -> 容器
        -> STL 针对不同的数据结构去提供了不同的容器，根据不同的数据结构的排列特性，划分为了 序列式容器 和 关联式容器
            -> 序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等
            -> 关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器
            -> 为什么要称为容器？因为对于容器来说，其内部总有一个针对于当前容器需要管控的一种基础数据类型，对于容器来说，其指示为我们在其下层的基础上再封装了一层所以称之为容器，与之所替代的是，容器针对该内置所管控的一种数据类型提供了多种针对其进行操作的 API 函数，并且对于其内置所管控的数据类型在内存中的生命周期也交由容器本身来进行管控，简而言之，对于容器内部所使用到的数据类型，开发人员并不需要关心其创建和销毁，我们要保证的是能够熟练使用容器本身即可， 值得一提的是，这也是 STL 中的容器作为一种广为大众所使用的原因之一
            -> STL 所提供的所有容器内部所维护的数据结构所使用的内存都是开辟在内存 堆 上的，牺牲掉线程栈上快速的存取速度以换来更加灵活的内存空间的使用，作为容器的使用者，我们无需关心当前容器内部所使用的元素在堆中内存开辟，其都由容器本身来进行管理，反之容器内部所维护的这些在堆中的元素也会随着容器本身的释放也一并释放掉他们所占用的内存

        -> string
            -> STL 针对原始在 c 语言中操作字符串（char *）时所存在的诸多痛点，提供了 string 容器以替代，string 是一个类，其隶属于头文件 <string> 当中，其内部封装了一个 char * 类型的字符串，即它是一个封装了 char * 字符串的容器
            -> 使用 string 去进行字符串操作时，string 其内部自有对字符串的内存管理、动态扩容和释放的功能，即开发人员使用 string 去操作字符串时并不需要关心内存的释放和溢出的问题
            -> string 作为一个类，其内部提供了众多的成员函数的 API 去针对字符串进行操作，简而言之，使用 string 对于字符串的操作会显得更加的便捷

            -> string 的构造
                -> string()                      默认构造，构建一个空的 string 容器
                -> string(const string &str)     拷贝构造函数，依据已有的 string 实例内部所管控的字符串去构造当前 string 容器的实例
                -> string(const char *str)       使用 char * 类型的字符串进行构造
                -> string(int n, char _ch)       使用 n 个字符 _ch 进行构造

                #include <iostream>
                #include <string>
                using namespace std;

                int main(void) {
                    string str_01;
                    string str_02("HELLO,WORLD!");
                    string str_03 = "HELLO,WORLD!";
                    string str_04 = str_03;
                    string str_05(str_04);
                    string str_06(5, 'A');

                    return EXIT_SUCCESS;
                }

            -> 赋值
                -> string &operator=(const char *str)                   根据字符串 str 去重新构造 string 实例内部所管控的字符串
                -> string &operator=(const string &str)                 根据 拷贝赋值运算符 去重新构造 string 实例内部所管控的字符串
                -> string &operator=(char _ch)                          根据字符 _ch 去重新构造 string 实例内部所管控的字符串
                -> string &assign(const char *str)                      根据字符串 str 去重新构造 string 实例内部所管控的字符串
                -> string &assign(const char *str, int n)               截取字符串 str 的前 n 个字符去重新构造 string 实例内部所管控的字符串
                -> string &assign(const string &str)                    根据已有的 string 实例内部所管控的字符串去重新构造当前实例内部所管控的字符串
                -> string &assign(int n, char _ch)                      使用 n 个字符 _ch 去重新构造 string 实例内部所管控的字符串
                -> string &assign(const string &str, int start, int n)  根据已有的 string 实例内部所管控的字符串从 start 下标开始的 n 个字符去重新构造当前实例内部所管控的字符串

                #include <iostream>
                #include <string>
                using namespace std;

                int main(void) {
                    string str_source;
                    string str_dest = "HELLO,WORLD";

                    str_source = "NGPONG!";
                    str_source = str_dest;
                    str_source = 'A';
                    str_source.assign("HELLO,NGPONG!");
                    str_source.assign("HELLO,NGPONG!", 2);
                    str_source.assign(str_dest);
                    str_source.assign(10, 'A');
                    str_source.assign(str_dest, 6, 5);

                    return EXIT_SUCCESS;
                }

            -> 下标获取
                -> 由于所返回的都是 string 实例内部所管控的字符串的某一个下标字符的引用，那么当 string 容器内部所管控的字符串的内存被重新分配后，原有的引用则会失效，这时候再继续使用则会发生错误
                -> char &operator[](int n)    获取字符串下标为 n 的字符，当 n 超出当前字符串最大长度时，程序会直接结束
                -> char &at(int n)            获取字符串下标为 n 的字符，当 n 超出当前字符串最大长度时，则抛出 out_of_range 的异常

                #include <iostream>
                #include <string>
                using namespace std;

                int main(void) {
                    string str = "HELLO,WORLD";
    
                    cout << str[5] << endl;
                    cout << str.at(0) << endl;
    
                    try {
                        str.at(0x400);
                    } catch (out_of_range _e) {
                        cout << _e.what() << endl;
                    }

                    return EXIT_SUCCESS;
                }

            -> 追加
                -> string &operator+=(const string &str)                已有 string 的实例 str 内部所管控的字符串追加到当前 string 实例内部所管控的字符串的末尾处
                -> string &operator+=(const char *str)                  字符串 str 追加到 string 实例内部所管控的字符串的末尾处
                -> string &operator+=(const char _ch)                   字符 _ch 追加到 string 实例内部所管控的字符串的末尾处
                -> string &append(const char *str)                      字符串 str 追加到 string 实例内部所管控的字符串的末尾处
                -> string &append(const char *str, int n)               字符串 str 的前 n 个字符追加到 string 实例内部所管控的字符串的末尾处
                -> string &append(const string &str)                    已有 string 的实例 str 内部所管控的字符串追加到当前 string 实例内部所管控的字符串的末尾处
                -> string &append(const string &str, int start, int n)  已有 string 的实例 str 内部所管控的字符串从 start 下标开始的 n 个字符追加到当前 string 实例内部所管控的字符串的末尾处
                -> string &append(int n, char _ch)                      string 实例内部所管控的字符串的末尾处追加 n 个字符 _ch

                #include <iostream>
                #include <string>
                using namespace std;

                int main(void) {
                    string str_src = "HELLO,WORLD";
                    string str_dest = "NGPONG";

                    str_src += ",";
                    str_src += str_dest;
                    str_src += '!';

                    str_src.append(1, ',');
                    str_src.append("hahaha");
                    str_src.append(",GET,UP!", 5);
                    str_src.append(str_dest);
                    str_src.append(str_dest, 0, 2);

                    return EXIT_SUCCESS;
                }

            -> 查找
                -> 对于任何无法匹配的结果都返回 -1
                -> int find(const string &str, int pos = 0) const           当前 string 实例内部所管控的字符串中的 pos 下标开始，从左到右查找已有 string 实例 str 内部所管控的字符串第一次出现下标
                -> int find(const char *str, int pos = 0) const             当前 string 实例内部所管控的字符串中的 pos 下标开始，从左到右查找字符串 str 第一次出现的下标
                -> int find(const char *str, int pos, int n) const          当前 string 实例内部所管控的字符串中的 pos 下标开始，从左到右查找字符串 str 前 n 个字符第一次出现的下标
                -> int find(const char _ch, int pos = 0) const              当前 string 实例内部所管控的字符串中的 pos 下标开始，从左到右查找字符 _ch 第一次出现的下标
                -> int rfind(const string &str, int pos = str_size) const   当前 string 实例内部所管控的字符串中的 pos 下标开始，从右到左查找已有 string 实例 str 内部所管控的字符串第一次出现下标
                -> int rfind(const char *str, int pos = str_size) const     当前 string 实例内部所管控的字符串中的 pos 下标开始，从右到左查找字符串 str 第一次出现的下标
                -> int rfind(const char *str, int pos, int n) const         当前 string 实例内部所管控的字符串中的 pos 下标开始，从右到左查找字符串 str 前 n 个字符第一次出现的下标
                -> int rfind(const char _ch, int pos = str_size) const      当前 string 实例内部所管控的字符串中的 pos 下标开始，从右到左查找字符 _ch 第一次出现的下标

                #include <iostream>
                #include <string>
                using namespace std;

                int main(void) {
                    string str_src = "HELLO,WORLOD";
                    string str_fi = "WOR";

                    cout << str_src.find(str_fi, 0) << endl;
                    cout << str_src.find("LO", 0) << endl;
                    cout << str_src.find("LO", 5, 2) << endl;
                    cout << str_src.find('E', 0) << endl;

                    cout << str_src.rfind(str_fi, str_src.size()) << endl;
                    cout << str_src.rfind("LK", str_src.size()) << endl;
                    cout << str_src.rfind("LO", 5, 2) << endl;
                    cout << str_src.rfind('E', str_src.size()) << endl;

                    return EXIT_SUCCESS;
                }

            -> 替换
                -> string &replace(int pos, int n, const string &str)   当前 string 实例内部所管控的字符串中的 pos 下标开始的前 n 个字符，替换为已有 string 实例 str 内部所管控的字符串
                -> string &replace(int pos, int n, const char* str)     当前 string 实例内部所管控的字符串中的 pos 下标开始的前 n 个字符，替换为字符串 str

                #include <iostream>
                #include <string>
                using namespace std;

                int main(void) {
                    string str_src = "HELLO,WORLD";
                    string str_rep = "NGPONG!";

                    str_src.replace(str_src.find(',') + 1, str_src.size() - (str_src.find(',') + 1), str_rep);
                    str_src.replace(6, 7, "wupeng!");

                    return EXIT_SUCCESS;
                }

            -> 比较
                -> 对于比较结果：
                   原始 >  目标  = 1
                   原始 <  目标  = -1
                   原始 == 目标  = 0
                -> int compare(const string &str) const   当前 string 实例内部所管控的字符串与已有 string 实例 str 内部所管控的字符串，进行比较
                -> int compare(const char *str) const     当前 string 实例内部所管控的字符串与字符串 str，进行比较
                
                #include <iostream>
                #include <string>
                using namespace std;

                int main(void) {
                    string str_cp_01 = "BCDEFG";
                    string str_cp_02 = "AWERT";

                    cout << str_cp_01.compare(str_cp_02) << endl;

                    return EXIT_SUCCESS;
                }

            -> 截取
                -> string substr(int pos = 0, int n = str_size) const  截取当前 string 实例内部所管控的字符串的 pos 下标开始的前 n 个字符，并返回管控着截取结果的 string 容器的实例

                #include <iostream>
                #include <string>
                using namespace std;

                int main(void) {
                    string str_src = "HELLO,WORLD";
                    string str_des = "NGPONG,";

                    str_src.insert(str_src.find(',') + 1, str_des);
                    str_src.insert(2, "OO");
                    str_src.insert(0, 3, 'A');

                    /* AAAHEOOLLO,NGPONG,WORLD */
                    cout << str_src << endl;

                    return EXIT_SUCCESS;
                }

            -> 删除
                -> string &erase(int pos, int n = str_size)     删除当前 string 实例内部所管控的字符串从下标 pos 开始的 n 个字符

                #include <iostream>
                #include <string>
                using namespace std;

                int main(void) {
                    string str = "HELLO,WORLD";
                    str.erase(0, 6);
                    cout << str << endl;

                    return EXIT_SUCCESS;
                }

            -> 通用
                -> size_t size()：获取字符串的真实长度
                -> const char *c_str()：获取 string 容器内部所维护的真实的字符串


        -> vector
            -> vector 是 STL 中提供的一种存储功能性的容器，它是一个动态数组，具体来说，vector 内部所维护的是一个指向 [堆] 中的一段线性空间的指针，并且，对于数组长度即将溢出于线性空间的的情景，vector 容器其内置了针对这段线性空间去进行 动态扩容（并不是使用一个常数项作为动态扩容的基准值，而是使用其内置的一套算法所求得的结果）的策略，需要强调的是，我们使用 vector 作为一种动态数组的存储媒介我们无需关心 vector 内部所使用的那一段在 堆 中的内存，对于 vector 本身来说，它代替了开发者来完成其内部指针所指向的那块 堆 中的内存的创建和销毁工作
            -> vector 容器的设计是一种单端数组，为符合常数项时间模式的新增和删除，vector 容器内部所提供的新增和删除元素的 API 都是仅针对数组中的尾元素所进行的，当然这并不代表着我们无法对该数组进行随机性的插入和删除操作，作为容器本身也提供了这些 API 用于支持，由于 vector 内部所维护的动态数组是真正意义上的连续性的存储空间，那么对于长度越长并且越接近于首部元素下标的新增和删除操作，所带来的性能损耗的确是灾难性的（需要 往后/往前 移动大量的元素），当我们理解了这一点，自然也明白为什么 vector 会被抽象为一种单端型的数组了
            -> vector 动态数组所谓的动态扩容并不会在原空间的基础上延续新空间(因为无法保证原空间之后尚有可配置的空间)，而是会申请一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间，因此，对vector的任何操作，一旦引起空间的重新配置，指向当前 vector 的所有迭代器就都失效了
            -> 一个 vector 的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所
            ，所新增的元素（除了随机插入）总是会在数组的结尾进行，而所取出的元素（非随机下标获取）总是拿出最后一个元素，故 vector 对于首元素的插入和删除操作效率会较低，因为其总是会移动首元素之后的所有元素才能够完成操作
            -> vector 所提供的迭代器是一种随机访问迭代器，它们总是会指向容器数组阵列的首元素和尾元素的位置

            -> vector 的初始化构造
                -> vector<T>()                      默认构造，构建一个空的 vector 容器
                -> vector<T>(V _begin, V _end)      该构造函数是一个存在虚拟类型为 V 的模板函数，V 的具体化用于接收能够指示一段线性数组 [begin, end) 开闭区间的迭代器(隶属于容器的)亦或者地址，并使用它来完成当前 vector 容器内部所管控的动态数组的初始化工作
                -> vector<T>(int n, T _element)     该构造函数使用 n 个 _element 用于 vector 容器内部动态数组的初始化构造工作
                -> vector(const vector &_vec)       拷贝构造函数，将已有 vector 容器实例内部所管控的动态数组中的 [有效元素] 拷贝至当前 vector 容器实例内部所管控的动态数组中

                /* vector<T>() */
                vector<int> ve_empty;

                /* vector<T>(V begin, V end) */
                vector<int> ve_01(ve_empty.begin(), ve_empty.end());
                int nums[5] = { 1, 2, 3, 4, 5 };
                vector<int> ve_02(nums, nums + (sizeof(nums) / sizeof(int)));

                /* vector<T>(n, T _element) */
                vector<int> ve_03(10, 23);

                /* vector(const vector &_vec) */
                vector<int> ve_04(ve_02);

            -> 重新赋值
                -> void assign(V _begin, V _end)               该函数是一个存在虚拟类型为 V 的模板函数，V 的具体化用于接收能够指示一段线性数组 [begin, end) 开闭区间的迭代器(隶属于容器的)亦或者地址，并使用它来完成当前 vector 容器实例内部所管控的动态数组的重新赋值的工作
                -> void assign(int n, _element)                该函数使用 n 个 _element 用于 vector 容器内部动态数组的重新赋值的工作
                -> vector &operator=(const vector &_vec)       拷贝赋值运算符，依据已有 vector 的实例内部所管控的动态数组中的 [有效元素] 去重新构造当前 vector 容器实例本身内部所管控的动态数组
                -> void swap(vector &_vec)                     交换目标 vector 容器与当前 vector 容器内部用于管控指向堆中线性空间的指针所指向的地址，并重新更新双方容器内部所管控的动态数组的 size 和 capacity

                int nums_src[5] = { 1, 2, 3, 4, 5 };
                vector<int> ve_src;

                /* void assign(V _begin, V _end) */
                ve_src.assign(nums_src, nums_src + (sizeof(nums_src) / sizeof(int)));

                /* void assign(n, _element) */
                ve_src.assign(10, 1024);

                vector<int> ve_des;

                /* vector& operator=(const vector &_vec) */
                ve_des = ve_src;

                /* void swap(vector &_vec) */
                ve_des.swap(ve_src);

            -> 获取 vector 的迭代器
                -> 正序遍历
                -> vector<int>::iterator begin()            获取 vector 容器的正序起始迭代器，正序起始迭代器所指向的是 vector 内部所管控的动态数组中的首元素的位置
                -> vector<int>::iterator end()              获取 vector 容器的正序结束迭代器，正序结束迭代器所指向的是 vector 内部所管控的动态数组中的最后一个元素的下一个位置
                -> 
                ->     +---+---+---+---+---+
                ->     | 1 | 2 | 3 | 4 | 5 |
                ->     +-+-+---+---+---+---+
                ->       ^                    ^
                ->       |                    |
                ->     begin                 end
                -> 
                -> 
                -> 逆序遍历
                -> vector<int>::reverse_iterator rbegin()   获取 vector 容器的逆序起始迭代器，逆序起始迭代器所指向的是 vector 内部所管控的动态数组中的最后一个元素的位置
                -> vector<int>::reverse_iterator rend()     获取 vector 容器的逆序结束迭代器，逆序结束迭代器所指向的是 vector 内部所管控的动态数组中的首元素的上一个位置
                -> 
                ->     +---+---+---+---+---+
                ->     | 1 | 2 | 3 | 4 | 5 |
                ->     +---+---+---+---+-+-+
                ->   ^                   ^
                ->   |                   |
                -> rend                rbegin             

                vector<int> _ve;

                vector<int>::iterator _it_begin = _ve.begin();
                vector<int>::iterator _it_end = _ve.end();

                vector<int>::reverse_iterator _rt_begin = _ve.rbegin();
                vector<int>::reverse_iterator _rt_end = _ve.rend();

            -> vector 容器的大小操作
                -> size_t size()                    返回 vector 容器内部动态数组的有效元素个数
                -> bool empty()                     判断是否是一个空容器（无任何有效元素的录入）
                -> size_t capacity()                获取 vector 容器内部动态数组的真实容量
                -> void resize(int n)               重新指定 vector 容器内部动态数组的长度为 n，如果 n 较调用前的长度大，则以默认值填充超出的位置，如果 n 较调用前的长度小，则末尾超出数组长度的元素被删除（所删除的仅仅只是真实的元素，并无法缩减内部动态数组的真实容量）
                -> void resize(int n, T _element)   重新指定 vector 容器内部动态数组的长度为 n，如果 n 较调用前的长度大，则以拷贝所指定的 _element 去填充超出的位置，如果 n 较调用前的长度小，则末尾超出数组长度的元素被删除（所删除的仅仅只是真实的元素，并无法缩减内部动态数组的真实容量）
                -> void reserve(int len)            调整 vector 容器内部动态数组的真实容量至 len，所新增出来的预留位置并未进行过初始化，即不可被访问，也不可执行随机插入操作（仅仅允许插入有效元素至当前动态数组尾元素的下一个元素的位置），简而言之，它们都不是 [有效元素]，当 len 所指定的长度要小于当前 vector 容器内部动态数组的真实容量时，则该函数调用无任何结果

                int nums[5] = { 1, 2, 3, 4, 5 };
                vector<int> _ve(nums, nums + (sizeof(nums) / sizeof(int)));

                /* size_t size() */
                size_t _ve_size = _ve.size();

                /* size_t capacity() */
                size_t _ve_capacity = _ve.capacity();

                /* bool empty() */
                bool is_empty = _ve.empty();

                /* void resize(int n) */
                _ve.resize(10);

                /* void resize(int n, T _element) */
                _ve.resize(7, 0x400);

                /* void reserve(int len) */
                _ve.reserve(0x400);

            -> 根据下标获取元素
                -> T &at(int _idx)     返回 vector 容器内部所维护的动态数组的下标为 _idx 的元素的引用，如果 _idx 超出内部数组的有效元素个数，则抛出out_of_range异常
                -> T &operator[_idx]   返回 vector 容器内部所维护的动态数组的下标为 _idx 的元素的引用，如果 _idx 超出内部数组的有效元素个数，则程序崩溃
                -> T &front()          返回 vector 容器内部所维护的动态数组的首元素的引用
                -> T &back()           返回 vector 容器内部所维护的动态数组的尾元素的引用

                int nums[5] = { 1, 2, 3, 4, 5 };
                vector<int> _ve(nums, nums + (sizeof(nums) / sizeof(int)));

                int &num_01 = _ve.at(0);
                int &num_02 = _ve[1];
                int &num_03 = _ve.front();
                int &num_04 = _ve.back();

            -> 插入
                -> void insert(const_iterator pos,T _element)    根据迭代器 pos 所指向的元素的下标往 vector 容器内部的动态数组插入一个元素 _elemenet，如果迭代器 pos 所指向的元素下标超出了动态数组的真实容量，则程序崩溃
                -> void push_back(T _element)                    往 vector 容器内部的动态数组的尾部插入元素 _element

                int nums[5] = { 1, 2, 3, 4, 5 };
                vector<int> _ve(nums, nums + (sizeof(nums) / sizeof(int)));

                /* void insert(const_iterator pos,T _element) */
                _ve.insert(_ve.begin() + 2, 0x400);

                /* void push_back(T _element) */
                _ve.push_back(0x200);

            -> 删除
                -> void pop_back()                                        删除 vector 容器内部的动态数组中的尾元素
                -> void erase(const_iterator start, const_iterator end)   vector 容器内部的动态数组中删除迭代器 start 和 迭代器 end 所指向的下标之间的所有的 [真实元素]
                -> void erase(const_iterator pos)                         vector 容器内部的动态数组中删除迭代器 pos 所指向的元素
                -> void clear()                                           删除 vector 容器内部的动态数组中的所有的 [真实元素]

                int nums[5] = { 1, 2, 3, 4, 5 };
                vector<int> _ve(nums, nums + (sizeof(nums) / sizeof(int)));

                /* void pop_back() */
                _ve.pop_back();

                /* void erase(const_iterator start, const_iterator end) */
                _ve.erase(_ve.begin(), _ve.begin() + 2);

                /* void erase(const_iterator pos) */
                _ve.erase(_ve.begin() + 1);

                /* void clear() */
                _ve.clear();

            -> vector 容器能够保证其内部所管控的数组在长度不足的情况下提供动态扩容的机制以防止内存长度溢出的问题，但是却无法提供动态数组的动态收缩的策略，针对某些情况我们需要缩减动态数组的长度以保证内存空间的足够性
            void fun_test() {
              vector<int> _ve;
              for (size_t i = 0; i < 100000; ++i) {
                _ve.push_back(i);
              }

              /** 
               * resize 函数仅仅只能够缩减 vector 内部动态数组中的真实元素的长度，
               * 但是动态数组的真实容量却并不会缩减，简而言之，我们虽然把它的真实元素的长度缩减至 5 个，
               * 但是动态数组其真实容量还是在进行了 100000 新增操作后的容量，这里就会造成内存空间浪费的问题
              */
              _ve.resize(10);
              cout << _ve.capacity() << endl;

              /** 
               * 通过匿名对象调用 vector 容器的拷贝构造函数，把已有 vector 实例 _ve 内部的动态数组的真实元素（5个）拷贝至
               * 匿名对象内部所构造的动态数组中，由于仅仅指示拷贝的原始动态数组中的 真实元素，故该匿名对象 vector 内部所管控的动态数组的
               * 长度也仅仅是以元素动态数组的真实元素的个数为单位，这时候我们在通过 swap() 函数来交换匿名对象内部所管控的动态数组和元素动态数组之间
               * 在内存堆中的地址，以让原始 vector 内部指向的数组为 匿名对象 所构造出来的动态数组，并且被交换后的、长度更长的动态数组由于匿名对象在调用完毕后
               * 就会进行销毁，故其也进行了销毁，以此来完成了 静态缩减 容量的目的
              */
              vector<int>(_ve).swap(_ve);
              cout << _ve.capacity() << endl;
            }

            -> vector 容器内部的数组的动态扩容机制总是琢磨不定的，因为其由 vector 内置的一套算法来完成，那么在一个高额新增操作的时候，动态数组就需要不断地经历销毁内存、构建新的内存、拷贝旧内存中的数据至新内存当中，这就会造成较大的性能损失，解决办法就是在有效的范围内先通过 reserve 函数来调整更多的动态数组的真实容量，并在此基础上再进行元素的插入操作即可
            void fun_test_02(void) {
              /* 记录两次不同的处理方式，vector 内部的动态数组的扩容次数 */

              int num_01 = 0;
              vector<int> _ve_01;
              int *p_temp_01 = nullptr;
              for (size_t i = 0; i < 1000000; ++i) {
                _ve_01.push_back(i);

                /**
                 * 每一次 vector 内部所管控的动态数组的扩容都会使用一块新的内存地址，
                 * 故通过此机制来判断下一次插入数据后的元素首地址是否等于上一次元素的首地址来判断
                 * 当前插入操作是否引起了动态数组的扩容操作
                */
                if (p_temp_01 != &_ve_01.at(0)) {
                  p_temp_01 = &_ve_01.at(0);
                  ++num_01;
                }
              }
              cout << num_01 << endl;

              int num_02 = 0;
              vector<int> _ve_02;
              int *p_temp_02 = nullptr;
              _ve_02.reserve(1000000); /* 在可控范围内，预先调整 vector 内部动态数组的长度 */
              for (size_t i = 0; i < 1000000; ++i) {
                _ve_02.push_back(i);
                if (p_temp_02 != &_ve_02.at(0)) {
                  p_temp_02 = &_ve_02.at(0);
                  ++num_02;
                }
              }
              cout << num_02 << endl;
            }


        -> deque
            -> deque 是 STL 提供的一种存储功能性的容器，其和 vector，deque 同样也可以作为一种 动态数组 而使用，其所使用的存储区域同样也是以 堆 作为基准，作为容器本身，它在 堆 中所使用的内存自然也由 deque 自身来进行管理和释放

            -> 
               deque 其内部所维护的其实并不是一段真正意义上的 连续性 存储空间，它的真正的存储模型是以不同区域段的内存空间所组合而成，一旦有必要对于 deque 所维护的内存空间进行一次动态扩容，那么 deque 便会申请出一段新的、在堆中的连续定量的内存空空间，并把它串接在 deque 所维护的中控器的首端亦或者尾端，所谓中控器，其实是一个使用着一小块连续内存空间的 map（不是 STL 的 map 容器），其中每个元素都是一个指针，分别指向了刚刚所提到的不同区域段的内存空间，deque 以这块真正意义上的连续性存储空间的 map 为基准，把这些不同区域段的内存空间延续起来，并带给了使用者误认为所使用的是一种连续性内存空间的假象，不可否认的是，这种数据结构能够带来的最大的好处就是，对于数组的动态扩容机制就可以巧妙的避开了像 vector 那样总需要经历 申请一块更大的内存空间、旧内存空间的数据拷贝至新内存空间当中、释放掉旧内存空间 的轮回，但是相对的，由于该数据结构的复杂性，并且 deque 更多的工作还要在这个复杂的数据结构的基础上维护这些分段连续的内存空间的连续性的假象，这就造成了其所内置的 迭代器 相较于 vector 所内置的迭代器其复杂度根本不是一个量级的，这当然也会影响到了使用 deque 进行运算时的各个层面，因此，除非有必要，我们应该尽可能的使用vector，而不是deque，就如对 deque 进行的排序操作，为了最高效率，可将 deque 先完整的复制到一个 vector 中，对 vector 容器进行排序，再复制回 deque

               也正因为 deque 数据结构的这一特性，所以 deque 和 vector 有一点更大的区别是，deque 本身并没有 "容量" 这一概念，值得一提的是，这个 容量 的概念是上升至整个容器所维护的内存段本身的，对于 vector 而言，由于其使用的是一个真正的延续性的内存空间，故这段空间是存在容量的，而对于 deque 来说，它的内存的都是以段式进行存储，它随时可以增加一段新的空间并通过中控器链接起来，故没有完整意义上的 容量 的概念

               deque 的这种数据结构所带来的另一种特性就是，deque 设计的是一种双端式的数组，deque 容器内部所提供的新增和删除元素的 API 既可以针对数组中的首元素进行，也可以针对尾元素进行的，在 vector 中，由于其是线性存储空间的特性，对于首部元素的插入和删除的操作会带来较大的性能损失，而放在 deque 身上，由于它所使用的是分段式内存存储的机制，故 deque 对于数组首部元素的新增和删除的操作较 vector 来说会更容易实现，换句话说，deque 允许使用常数项时间的方式对头端进行元素的插入和删除操作，这也是为什么它会被抽象为一种 双端式数组 的原因

            -> deque 所提供的迭代器是一种随机访问迭代器，它们总是会指向容器数组阵列的首元素和尾元素的位置

            -> deque 的初始化构造 
                -> deque<T>()                      默认构造，构建一个空的 deque 容器
                -> deque<T>(V _begin, V _end)      该构造函数是一个存在虚拟类型为 V 的模板函数，V 的具体化用于接收能够指示一段线性数组 [begin, end) 开闭区间的迭代器(隶属于容器的)亦或者地址，并使用它来完成当前 deque 容器内部所维护的动态数组的初始化工作
                -> deque<T>(int n, T _element)     该构造函数使用 n 个 _element 用于 deque 容器内部动态数组的初始化构造工作
                -> deque(const vector &_vec)       拷贝构造函数，将已有 deque 容器实例内部所维护的动态数组中的元素拷贝至当前 deque 容器实例内部所维护的动态数组中

                /* deque<T>() */
                deque<int> dq_empty;

                /* deque<T>(V _begin, V _end) */
                deque<int> dq_01(dq_empty.begin(), dq_empty.end());
                int nums[5] = { 1, 2, 3, 4, 5 };
                deque<int> dq_02(nums, nums + (sizeof(nums) / sizeof(int)));

                /* deque<T>(int n, T _element) */
                deque<int> dq_03(10, 23);

                /* deque(const vector &_vec) */
                deque<int> dq_04(dq_02);

            -> 重新赋值
                -> void assign(V _begin, V _end)               该函数是一个存在虚拟类型为 V 的模板函数，V 的具体化用于接收能够指示一段线性数组 [begin, end) 开闭区间的迭代器(隶属于容器的)亦或者地址，并使用它来完成当前 deque 容器实例内部所维护的动态数组的重新赋值的工作
                -> void assign(int n, _element)                该函数使用 n 个 _element 用于 deque 容器内部所维护的动态数组的重新赋值的工作
                -> deque &operator=(const deque &_deq)         拷贝赋值运算符，依据已有 deque 的实例内部所维护的动态数组中的元素去重新构造当前 deque 容器实例本身内部所维护的动态数组
                -> void swap(deque &_deq)                      交换目标 deque 容器与当前 deque 容器内部指向着用于管控分段式内存区域的中控器的指针，并重新更新双方容器内部所维护的动态数组的 size

                int nums_src[5] = { 1, 2, 3, 4, 5 };
                deque<int> dq_src;

                /* void assign(V _begin, V _end) */
                dq_src.assign(nums_src, nums_src + (sizeof(nums_src) / sizeof(int)));

                /* void assign(int n, _element) */
                dq_src.assign(10, 1024);

                deque<int> dq_des;

                /* deque &operator=(const deque &_deq) */
                dq_des = dq_src;

                /* void swap(vector &_vec) */
                dq_des.swap(dq_src);

            -> deque 容器的大小操作
                -> size_t size()                    返回 deque 容器内部动态数组的元素个数
                -> bool empty()                     判断是否是一个空容器（无任何有效元素的录入）
                -> void resize(int n)               重新指定 deque 容器内部所维护的动态数组的长度为 n，如果 n 较调用前的长度大，则以默认值填充超出的位置，如果 n 较调用前的长度小，则末尾超出数组长度的元素被删除
                -> void resize(int n, T _element)   重新指定 deque 容器内部动态数组的长度为 n，如果 n 较调用前的长度大，则以拷贝所指定的 _element 去填充超出的位置，如果 n 较调用前的长度小，则末尾超出数组长度的元素被删除

                int nums[5] = { 1, 2, 3, 4, 5 };
                deque<int> _dq(nums, nums + (sizeof(nums) / sizeof(int)));

                /* size_t size() */
                size_t _dq_size = _dq.size();

                /* bool empty() */
                bool is_empty = _dq.empty();

                /* void resize(int n) */
                _dq.resize(10);

                /* void resize(int n, T _element) */
                _dq.resize(7, 0x400);

            -> 根据下标获取元素
                -> T &at(int _idx)     返回 deque 容器内部所维护的动态数组的下标为 _idx 的元素的引用，如果 _idx 超出内部数组的有效元素个数，则抛出out_of_range异常
                -> T &operator[_idx]   返回 deque 容器内部所维护的动态数组的下标为 _idx 的元素的引用，如果 _idx 超出内部数组的有效元素个数，则程序崩溃
                -> T &front()          返回 deque 容器内部所维护的动态数组的首元素的引用
                -> T &back()           返回 deque 容器内部所维护的动态数组的尾元素的引用

                int nums[5] = { 1, 2, 3, 4, 5 };
                deque<int> _dq(nums, nums + (sizeof(nums) / sizeof(int)));

                int &num_01 = _dq.at(0);
                int &num_02 = _dq[1];
                int &num_03 = _dq.front();
                int &num_04 = _dq.back();

            -> 插入
                -> void insert(const_iterator pos,T _element)    根据迭代器 pos 所指向的元素的下标往 deque 容器内部所维护的动态数组中插入一个元素 _elemenet，如果迭代器 pos 所指向的元素下标超出了动态数组的真实容量，则程序崩溃
                -> void push_back(T _element)                    往 deque 容器内部的动态数组的尾部插入元素 _element
                -> void push_front(T _element)                   往 deque 容器内部的动态数组的首部插入元素 _element

                int nums[5] = { 1, 2, 3, 4, 5 };
                deque<int> _dq(nums, nums + (sizeof(nums) / sizeof(int)));

                /* void insert(const_iterator pos,T _element) */
                _dq.insert(_dq.begin() + 2, 0x400);

                /* void push_back(T _element) */
                _dq.push_back(0x200);

                /* void push_front(T _element) */
                _dq.push_front(0x100);

            -> 删除
                -> void pop_back()                                        删除 deque 容器内部的动态数组中的尾元素
                -> void pop_front()                                       删除 deque 容器内部的动态数组中的首元素
                -> void erase(const_iterator start, const_iterator end)   deque 容器内部所维护的动态数组中删除迭代器 start 和 迭代器 end 所指向的下标之间的所有的元素
                -> void erase(const_iterator pos)                         deque 容器内部所维护的动态数组中删除迭代器 pos 所指向的元素
                -> void clear()                                           删除 deque 容器内部的动态数组中的所有的元素

                int nums[5] = { 1, 2, 3, 4, 5 };
                deque<int> _dq(nums, nums + (sizeof(nums) / sizeof(int)));

                /* void pop_back() */
                _dq.pop_back();

                /* void pop_front() */
                _dq.pop_front();

                /* void erase(const_iterator start, const_iterator end) */
                _dq.erase(_dq.begin(), _dq.begin() + 2);

                /* void erase(const_iterator pos) */
                _dq.erase(_dq.begin() + 1);

                /* void clear() */
                _dq.clear();

        -> stack
            -> stack 是 STL 所提供的一种支持任意类型的存储性功能的容器，该容器的内部设计非常简单，其遵循 栈 的 FILO 的存储结构而进行设计，我们的对于该容器中元素的访问和插入永远只能从 栈顶 开始，并且 STL 并没有提供针对此容器的迭代器，换言之，stack 容器是不允许存在遍历的型为的; 为保证最大内存的可用性，该容器所使用的内存区域是以 堆 作为基准，并且作为容器本身，它在 堆 中所使用的内存也由 stack 自身来进行管理和释放
               
            -> stack 的初始化构造
                -> stack<T>()               默认构造，构建一个空的 stack 容器
                -> stack(const stack &_st)  拷贝构造函数，将已有 stack 容器实例内部所维护的元素拷贝至当前 stack 容器实例内部

                /* stack<T>() */
                stack<int> __st;

                /* stack(const stack &_st) */
                stack<int> __st_cpy(__st);

            -> 重新赋值
                -> stack &operator=(const stack &_st)   拷贝赋值运算符，依据已有 stack 的实例内部所维护的元素去重新构造当前 stack 实例
                stack<int> __st_src;
                stack<int> __st_cpy;

                /* stack &operator=(const stack &_st) */
                __st_src = __st_cpy;

            -> 操作元素
                -> void push(T _element)           向栈顶添加元素 _element
                -> void pop()                      从栈顶移除第一个元素
                -> T &top()                        返回栈顶元素的引用

                stack<int> __st;

                /* void push(T _element) */
                __st.push(0x100);
                __st.push(0x200);
                __st.push(0x300);

                /* T &top() */
                int _val = __st.top();
                cout << _val << endl;

                /* void pop() */
                __st.pop();

            -> stack 容器的大小操作
                -> bool empty()      判断 stack 容器内部是否为空
                -> size_t size()     获取 stack 容器内部所维护的元素的个数

                stack<int> __st;

                /* bool empty() */
                bool flag = __st.empty();

                /* size_t size() */
                size_t cout = __st.size();


        -> queue
            -> queue 是 STL 所提供的一种支持任意类型的存储性功能的容器，该容器的内部设计非常简单，其遵循 队列 的 FIFO 的存储结构而进行设计，我们的对于该容器中元素的访问永远只能从 队头 开始而对于元素的插入操作永远只能从 队尾 进行，并且 STL 并没有提供针对此容器的迭代器，换言之，queue 容器是不允许存在遍历的型为的; 为保证最大内存的可用性，该容器所使用的内存区域是以 堆 作为基准，并且作为容器本身，它在 堆 中所使用的内存也由 queue 自身来进行管理和释放

            -> queue 的初始化构造
                -> queue<T>()               默认构造，构建一个空的 queue 容器
                -> queue(const queue &_qe)  拷贝构造函数，将已有 queue 容器实例内部所维护的元素拷贝至当前 queue 容器实例内部

                /* queue<T>() */
                queue<int> __qe;

                /* queue(const queue &_qe) */
                queue<int> __qe_cpy(__qe);

            -> 重新赋值
                -> queue &operator=(const queue &_qe)   拷贝赋值运算符，依据已有 queue 的实例内部所维护的元素去重新构造当前 queue 实例
                queue<int> __qe_src;
                queue<int> __qe_cpy;

                /* queue &operator=(const queue &_qe) */
                __qe_src = __qe_cpy;

            -> 操作元素
                -> void push(T _element)           向队尾添加元素 _element
                -> void pop()                      从队头移除第一个元素
                -> T &back()                       返回对尾的元素的引用
                -> T &front()                      返回队头的元素的引用

                queue<int> __qe;

                /* void push(T _element) */
                __qe.push(0x100);
                __qe.push(0x200);
                __qe.push(0x300);

                /* T &back() */
                int val_back = __qe.back();

                /* T &front() */
                int val_front = __qe.front();
            
                /* void pop() */
                __qe.pop();

            -> queue 容器的大小操作
                -> bool empty()      判断 queue 容器内部是否为空
                -> size_t size()     获取 queue 容器内部所维护的元素的个数

                queue<int> __qe;

                /* bool empty() */
                bool flag = __qe.empty();

                /* size_t size() */
                size_t cout = __qe.size();


        -> list
            -> list 是 STL 所提供的一种支持任意类型的存储性功能的容器，其内部所维护的是一张以 堆 作为内存基础去进行节点的动态扩展的 双向循环链表，开发人员使用 list 时无需节点的内存管理和释放的工作，其都转交 list 容器本身来进行管控
            -> 作为一张链表，由于每一个节点都需要维护着一个指针域和数据域，所以 list 对比相同长度的数组其空间复杂度要大得多，并且节点于节点之间由于是通过指针域的指向来完成下一个节点的寻址，故对于 list 的随机节点访问性的操作来说，其时间复杂度也会比数组高出许多，好处在于使用 list 去执行新增和删除操作时，其总是能够通过常数项时间来完成，因为对于 list 来说，其新增和删除元素仅仅只需要改变两端节点的指针指向即可完成，对比数组还需要大量的向后/向前移动元素造成了较大的性能损失，并且对于 list 来说，因为每一个节点都是一块新的内存空间，故其新增结点时所使用的内存总是那么针对性的，对比 数组 来说在这方面 list 能够体现出绝对的空间利用效
            -> list 所提供的迭代器并不是一种随机访问迭代器，这由于 链表 本身的特性所导致的，所提供的迭代器仅仅只能够完成单步自增/自减的操作，除此之外，链表 本身的特性还让使用 list 执行插入操作和删除操作时都不会造成原有 list 迭代器的失效，因为对于链表来说其新增和删除节点时总是针对那一块独立的内存空间，并不会因为当前操作而导致整个 链表 维护的所有节点所使用的内存空间需要一次全局的置换，即便会发生变化，也仅仅只是针对当前操作所指定的节点所在的迭代器而言

            -> list 的构造初始化
                -> list<T>()                      默认构造，构建一个空的 list 容器
                -> list<T>(V _begin, V _end)      该构造函数是一个存在虚拟类型为 V 的模板函数，V 的具体化用于接收能够指示一段线性数组 [begin, end) 开闭区间的迭代器(隶属于容器的)亦或者地址，并使用它来完成当前 list 容器内部所维护的双向循环链表的初始化工作
                -> list(int n, T _element)        该构造函数使用 n 个 _element 用于 list 容器内部双向循环链表的初始化构造工作
                -> list(const list &_li)          拷贝构造函数，将已有 list 容器实例内部所维护的双向循环链表中的节点拷贝至当前 list 容器实例内部所维护的双向循环链表中

                /* list<T>() */
                list<int> li_empty;

                /* list<T>(V _begin, V _end) */
                list<int> li_01(li_empty.begin(), li_empty.end());
                int nums[5] = { 1, 2, 3, 4, 5 };
                list<int> li_02(nums, nums + (sizeof(nums) / sizeof(int)));

                /* deque<T>(int n, T _element) */
                list<int> li_03(10, 23);

                /* deque(const vector &_vec) */
                list<int> li_04(li_02);

            -> list 的重新赋值
                -> void assign(V _begin, V _end)      该函数是一个存在虚拟类型为 V 的模板函数，V 的具体化用于接收能够指示一段线性数组 [begin, end) 开闭区间的迭代器(隶属于容器的)亦或者地址，并使用它来完成当前 list 容器实例内部所维护的双向循环链表的重新赋值的工作
                -> assign(int n, _element)            该函数使用 n 个 _element 用于 list 容器内部所维护的双向循环链表的重新赋值的工作
                -> list &operator=(const list &_li)   拷贝赋值运算符，依据已有 list 的实例内部所维护的双向循环链表中的节点去重新构造当前 list 容器实例本身内部所维护的双向循环链表
                -> void swap(lst)                     交换目标 list 容器与当前 list 容器内部指向着存在于堆中的双向循环链表的指针，并重新更新双方容器内部所维护的双向循环链表的 size

            -> list 容器的大小操作
                -> size_t size()                    返回 list 容器内部双向循环链表的节点个数
                -> bool empty()                     判断是否是一个空容器（无任何节点的链接）
                -> void resize(int n)               重新指定 list 容器内部所维护的双向循环链表的节点链接长度为 n，如果 n 较调用前的长度大，则以默认值填充超出的位置，如果 n 较调用前的长度小，则删除超出链表长度 n 的节点
                -> void resize(int n, T _element)   重新指定 list 容器内部所维护的双向循环链表的节点链接长度为 n，如果 n 较调用前的长度大，则拷贝所指定的 _element 去填充超出的位置，如果 n 较调用的长度小，则删除超出链表长度 n 的节点

                int nums[5] = { 1, 2, 3, 4, 5 };
                list<int> _li(nums, nums + (sizeof(nums) / sizeof(int)));

                /* size_t size() */
                size_t _li_size = _li.size();

                /* bool empty() */
                bool is_empty = _li.empty();

                /* void resize(int n) */
                _li.resize(10);

                /* void resize(int n, T _element) */
                _li.resize(7, 0x400);

            -> 插入
                -> void push_back(T _element)                    从 list 容器内部的双向循环链表的尾处新增数据域为 _element 的节点
                -> void push_front(T _element)                   从 list 容器内部的双向循环链表的首处新增数据域为 _element 的节点
                -> void insert(const_iterator pos,T _element)    根据迭代器 pos 所指向的节点的下标往 list 容器内部所维护的双向循环链表中插入一个数据域为 _elemenet 的节点，如果迭代器 pos 所指向的元素下标超出了双向循环链表的长度，则程序崩溃

                int nums[5] = { 1, 2, 3, 4, 5 };
                list<int> _li(nums, nums + (sizeof(nums) / sizeof(int)));

                /* void insert(const_iterator pos,T _element) */
                _li.insert(++_li.begin(), 0x400);

                /* void push_back(T _element) */
                _li.push_back(0x200);

                /* void push_front(T _element) */
                _li.push_front(0x100);

            -> 删除
                -> void pop_back()                                                          删除 list 容器内部的双向循环链表中的尾节点
                -> void pop_front()                                                         删除 list 容器内部的双向循环链表中的首节点
                -> void clear()                                                             删除 list 容器内部的双向循环链表中的所有的节点
                -> void erase(list<T>::const_iterator start, list<T>::const_iterator end)   list 容器内部所维护的双向循环链表中删除迭代器 start 和 迭代器 end 所指向的下标之间的所有的节点
                -> void erase(list<T>::const_iterator pos)                                  list 容器内部所维护的双向循环链表中删除迭代器 pos 所指向的节点

                int nums[5] = { 1, 2, 3, 4, 5 };
                list<int> _li(nums, nums + (sizeof(nums) / sizeof(int)));

                /* void pop_back() */
                _li.pop_back();

                /* void pop_front() */
                _li.pop_front();

                /* void erase(const_iterator start, const_iterator end) */
                _li.erase(_li.begin(), ++_li.begin());

                /* void erase(const_iterator pos) */
                _li.erase(++_li.begin());

                /* void clear() */
                _li.clear();

            -> 节点数据域的获取
                -> T &front()      返回 list 容器内部所维护的双向链表的首节点数据域的引用
                -> T &back()       返回 list 容器内部所维护的双向链表的尾节点数据域的引用

                int nums[5] = { 1, 2, 3, 4, 5 };
                list<int> _li(nums, nums + (sizeof(nums) / sizeof(int)));
                int &num_03 = _li.front();
                int &num_04 = _li.back();

            -> 功能性
                -> reverse()          链表反转
                -> sort(T __fu)       依据所指定的返回值为 bool 并 拥有两个链表节点数据域形参的函数或者二元仿函数 去进行链表的排序

                bool __sort(int &num_01, int &num_02) {
                  return num_01 < num_02;
                }
                void fun_common(void) {
                  int nums[5] = { 3, 2, 4, 1, 5 };
                  list<int> _li(nums, nums + (sizeof(nums) / sizeof(int)));

                  /* sort(T __fu) */
                  _li.sort(__sort);

                  /* reverse() */
                  _li.reverse();
                }

        -> pair
            -> pair 又称为对组，它可以将一对可具有不同类型的值，组合为一个值，并将它们分别映射到 pair 的公共属性 frist 和 second 的访问上
            -> pair 所使用的内存是以 堆 作为基准，并由 pair 本身来负责管理在堆中所使用的内存和其释放，开发人员无需关心会产生内存泄漏亦或者超出的问题

            -> pair 的使用
            /** 
             * constructor
             *   pair<T,V>(T _t, V _v)                指定 pair 所需维护的两个具体的值来进行 pair 实例的初始化构造
             *   pair<T,V>(const pair<T,V> &__p)      拷贝构造函数，依据已有的 pair 实例内部所维护的两个可存在不同类型的值去构造当前 pair 的实例
             * 
             * function
             *   pair<T,V> make_pair<T,V>(T _t, V_v)  该函数用于接受两个可存在不同类型的值，并返回相应类型的 pair
             * 
             * member
             *   first                                获取 pair 所维护的第一个值
             *   second                               获取 pair 所维护的第二个值                                     
             */
             void foo(void) {
                /* pair<T,V>(T _t, V _v) */
                pair<string, int> __p_1("HELLO,WORLD", 0x400);     

                /* pair<T,V> make_pair<T,V>(T _t, V_v) */
                pair<char, string> __p_2 = make_pair('A', "NGPONG!");   

                /* pair<T,V>(const pair<T,V> &__p) */
                pair<string, int> __p_3 = __p_1;     

                /* first  */
                cout << __p_1.first << endl;    

                /* second */
                cout << __p_1.second << endl;
             }
             
        -> set/multiset
            -> set 是 STL 所提供的一种支持任意类型的存储性功能的容器，其内部采用 红黑树 作为实现，其拥有一个十分重要的特性即是，set 内部维护的树所新增的节点，由于二叉树的平衡性，它都会依据该节点的 键值 进行自动的排序（默认是正序排序，也可认为的指定排序的规则），这里需要扩充一下的是，set 中的节点内部所存有的数据既可作为 键 也可以作为 值，二者放在 set 中的节点元素而言并不是分开的一种概念，并且对于 set 来说，它不允许出现重复的键值，对于用户重复插入的键值，set 会保证此次的插入操作是一个无效操作，简而言之就是插入失败
            -> set 内部所维护的这颗 红黑树 和其它容器一样，都是存储在堆中的，并且由容器本身去负责管理这棵树在堆中所使用内存的申请和释放
            -> set 由于使用的是 红黑树 作为存储模型，故使用 set 去针对节点的键值进行搜索时，是非常快的，但是相应的，为了保证 set 内部所维护的这颗 红黑树 的 二叉平衡性，set 并不提供针对节点的键值进行修改的操作，具体体现则为其对外仅提供了 只读性质的迭代器，要作为补充的是，set 所提供的并不是一种提供随机访问性的迭代器，其只能够完成单步自增/自减的操作，那么我们不妨在总结一下，set 所提供的迭代器是一种 只读单步自增/减 的迭代器
            -> 由于一个棵本身也可以作为一张链表来看待，故 set 容器与 list 容器存在相同的一点是，当对容器中的节点进行插入操作或者删除操作的时候，所操作的元素永远都是存在针对性的，即这些新增和删除的操作并不会引起整棵树的内存置换
            -> 相对 set 而言还有另一种容器跟它相呼应，那就是 multiset，作为 multiset 而言，它和 set 所存在的唯一的区别就是 multiset 允许节点的键值重复，其余相较于 set 不管是功能性而言还是内置结构都是一模一样的

            -> set 初始化构造
                -> set 可以指定两种虚拟类型，其中 
                    -> T 则为节点键值的具体类型
                    -> F 则为指定 set 的排序规则的二元仿函数类型，其默认值为一个提供了 正序排序 的功能的二元仿函数 [less<K>]，如有需要，我们可以显示的指定它
                -> 
                -> set<T,F = less<T>>()                       默认构造，构建一个空的 set 容器
                -> set<T,F = less<T>>((V _begin, V _end)      该构造函数是一个存在虚拟类型为 V 的模板函数，V 的具体化用于接收能够指示一段线性数组 [begin, end) 开闭区间的迭代器(隶属于容器的)亦或者地址，并使用它来完成当前 set 容器内部所维护的红黑树的初始化工作)
                -> set(const set &__s)                        拷贝构造函数，将已有 set 容器实例内部所维护的红黑树的节点拷贝至当前 set 容器实例内部所维护的红黑树当中

                template<class _Ty>
                struct __DESC {
                  constexpr bool operator()(const _Ty &left, const _Ty &right) {
                    return left > right;
                  }
                };

                void fun_constructor(void) {
                  /* set<T,F = less<T>>() */
                  set<int> __s_nor;

                  /* set<T,F = less<T>>((V _begin, V _end) */
                  int nums[5] = { 3, 1, 5, 2, 4 };
                  set<int, __DESC<int>> __s(nums, nums + sizeof(nums) / sizeof(int));

                  /* set(const set &__s) */
                  set<int, __DESC<int>> __s_des(__s);
                }

            -> set 的重新赋值
                -> set &operator=(const set &__s)     拷贝赋值运算符，依据已有 set 的实例内部所维护的红黑书的节点去重新构造当前 set 容器实例本身内部所维护的红黑树
                -> void swap(set &__s)                交换目标 set 容器与当前 set 容器内部指向着存在于堆中的红黑树的指针，并重新更新双方容器内部所维护的红黑树的 size

                int nums_01[5] = { 3, 1, 5, 2, 4 };
                set<int> __s_01(nums_01, nums_01 + sizeof(nums_01) / sizeof(int));

                int nums_02[5] = { 9, 6, 10, 8, 7 };
                set<int> __s_02(nums_02, nums_02 + sizeof(nums_02) / sizeof(int));

                /* void swap(set &__s) */
                __s_01.swap(__s_02);

                /* set &operator=(const set &__s) */
                __s_01 = __s_02;

            -> set 的大小操作
                -> size_t size()                    返回 set 容器内部所维护的红黑树的节点个数
                -> bool empty()                     判断是否是一个空容器（无任何节点的链接）

                int nums[5] = { 3, 1, 5, 2, 4 };
                set<int> __s(nums, nums + sizeof(nums) / sizeof(int));

                /* size_t size() */
                int cout = __s.size();

                /* bool empty() */
                bool flag = __s.empty();

            -> 插入
                -> pair<set<T>::iterator, bool> insert(T _key)    向 set 容器内部所维护的红黑树中新增一个节点，并赋予该节点的键值为 _key，最后返回能够标识当前所插入的节点在整个数中的位置的迭代器和是否插入成功所结合而成的 pair

                int nums[5] = { 3, 1, 5, 2, 4 };
                set<int> __s(nums, nums + sizeof(nums) / sizeof(int));

                /* pair<set<T>::iterator, bool> insert(T _key) */
                pair<set<int>::iterator, bool> result = __s.insert(0x400);

            -> 删除
                -> void clear()                                                                             删除 set 容器内部所维护的红黑树的所有的节点
                -> set<T>::const_iterator erase(set<T>::const_iterator start, set<T>::const_iterator end)   set 容器内部所维护的红黑树中删除迭代器 start 和 迭代器 end 所指向的下标之间的所有的节点，最后返回只想当前所操作元素的下一个元素的迭代器
                -> set<T>::const_iterator erase(set<T>::const_iterator pos)                                 set 容器内部所维护的双向循环链表中删除迭代器 pos 所指向的节点，最后返回只想当前所操作元素的下一个元素的迭代器
                -> void erase(T _key)                                                                       set 容器内部所维护的红黑树中删除对应键值 _key 的节点

                int nums[5] = { 3, 1, 5, 2, 4 };
                set<int> __s(nums, nums + sizeof(nums) / sizeof(int));

                /* void erase(set<T>::const_iterator pos) */
                __s.erase(__s.begin(), ++__s.begin());

                /* void erase(set<T>::const_iterator start, set<T>::const_iterator end) */
                __s.erase(__s.begin());

                /* void erase(T _key) */
                __s.erase(5);

                /* void clear() */
                __s.clear();

            -> 查找
                -> set<T>::const_iterator find(T _key)                                              在 set 内部所维护的红黑树中查找相符合键值 _key 的结点并返回第一次找到该结点所在下标的迭代器，若不存在匹配键值 _key 的节点，则返回指向最后一个元素的后一个位置的迭代器，即 set<int>.end() 的调用结果
                -> size_t count(T _key)                                                             在 set 内部所维护的红黑树中查找相符合键值 _key 的结点的个数
                -> set<T>::const_iterator lower_bound(T _key)                                       在 set 内部所维护的红黑树中查找相符合 目标节点键值 >= _key 的结点并返回该结点所在下标的迭代器，若不存在，则返回指向最后一个元素的后一个位置的迭代器，即 set<int>.end() 的调用结果
                -> set<T>::const_iterator upper_bound(T _key)                                       在 set 内部所维护的红黑树中查找相符合 目标节点键值 > _key 的结点并返回该结点所在下标的迭代器，若不存在，则返回指向最后一个元素的后一个位置的迭代器，即 set<int>.end() 的调用结果
                -> pair<set<int>::const_iterator, set<int>::const_iterator> equal_range(T _key)     依据指定的键值 _key 返回 lower_bound 和 upper_bound 调用所获取到的 迭代器 的组合值 pair，其中 first 为 lower_bound 调用结果所获取到的迭代器，second 为 upper_bound 调用结果所获取到的迭代器

                int nums[5] = { 3, 1, 5, 2, 4 };
                set<int> __s(nums, nums + sizeof(nums) / sizeof(int));
                
                /* set<T>::const_iterator find(T _key) */
                set<int>::const_iterator it_find = __s.find(2);
                
                /* size_t count(T _key) */
                size_t count = __s.count(3);
                
                /* set<T>::const_iterator lower_bound(T _key) */
                set<int>::const_iterator it_lower = __s.lower_bound(3);
                
                /* set<T>::const_iterator upper_bound(T _key) */
                set<int>::const_iterator it_uppler = __s.upper_bound(3);
                
                /* pair<set<int>::const_iterator, set<int>::const_iterator> equal_range(T _key) */
                pair<set<int>::const_iterator, set<int>::const_iterator> _res = __s.equal_range(3);

        -> map
            -> map 是 STL 所提供的一种以键值对形式而存在的存储性功能的容器，和 set 一样，其内置的数据模型也是根据 红黑树 来进行实现的；虽然 map 和 set 的内置的数据模型的实现使用的都是红黑树，但是存在较大不同的是，对于 map 来说是能够细分出来当前节点的 键 和 值，具体来说，每一个节点其实都是一个 pair<const K,V> 类型，以 K 作为该节点的键(第一元素)，以 V 作为该节点的实值(第二元素)，并且我们每次为 map 内部所维护的树新增的节点，map 都会遵循二叉树的平衡性，根据该节点的 键（K） 进行自动的排序（默认是正序排序，也可认为的指定排序的规则），这里需要强调的是，在 map 中的这颗 红黑树 其搜索依据是根据每个元素中独立出 值 的 键 所进行的，也就是说我们针对 map 节点中的 键 进行搜索操作时，其速度是相当的快的，并且 map 为了保证这个红黑树的平衡性，每个节点 pair<const K,V> 中作为 键 而存在的模板虚拟类型 k 都使用了 const 修饰符进行修饰，以保证我们无法修改每个节点中的 键，但是对于值而言，我们是可以进行任意修改的，因为它并不作为这颗二叉树的排序依据而存在
            -> map 中每个节点是不允许出现重复的 键 的，对于用户重复插入相同的 键，map 会保证此次的插入操作是一个无效操作(对于数组式的插入操作，如果树中已存在相同的 键，则会更新当前 键 所对应的值)，简而言之就是插入失败
            -> map 内部所维护的这颗 红黑树 和其它容器一样，都是存储在堆中的，并且由容器本身去负责管理这棵树在堆中所使用内存的申请和释放
            -> 和 set 存在区别的是，map 所提供迭代器并不是一种存粹的只读访问迭代器，map 对于其 键 的只读体现仅在于每个节点的 键 类型使用了 const 关键字进行了修饰（pair<const K,V>），并且它也不是一种提供随机访问性的迭代器，其只能够完成单步自增/自减的操作
            -> 由于一个棵本身也可以作为一张链表来看待，故 map 容器与 list 容器存在相同的一点是，当对容器中的节点进行插入操作或者删除操作的时候，所操作的元素永远都是存在针对性的，即这些新增和删除的操作并不会引起整棵树的内存置换
            -> 相对 map 而言还有另一种容器跟它相呼应，那就是 multimap，作为 multimap 而言，它和 map 所存在的唯一的区别就是 multimap 允许节点的键值重复，其余相较于 map 不管是功能性而言还是内置结构都是一模一样的

            -> map 初始化构造
                -> map 可以指定三种虚拟类型，其中
                    -> K 则为节点的 键 的具体类型
                    -> V 则为节点的 值 的具体类型
                    -> F 则为指定 map 的排序规则的二元仿函数类型，其默认值为一个提供了 正序排序 的功能的二元仿函数 [less<K>]，如有需要，我们可以显示的指定它
                -> map<K, V, F = less<K>>()                   默认构造，构建一个空的 map 容器
                -> map(const set &__m)                        拷贝构造函数，将已有 map 容器实例内部所维护的红黑树的节点拷贝至当前 map 容器实例内部所维护的红黑树当中

                template<class _Ty>
                struct __DESC {
                  constexpr bool operator()(const _Ty &left, const _Ty &right) {
                    return left > right;
                  }
                };

                void fun_constructor(void) {
                  /* map<K, V, F = less<K>>() */
                  map<string, int, __DESC<string>> __m_nor;

                  /* set(const set &__s) */
                  map<string, int, __DESC<string>> __m_des(__m_nor);
                }

            -> map 的重新赋值
                -> map &operator=(const map &__m)     拷贝赋值运算符，依据已有 map 的实例内部所维护的红黑书的节点去重新构造当前 map 容器实例本身内部所维护的红黑树
                -> void swap(map &__m)                交换目标 map 容器与当前 map 容器内部指向着存在于堆中的红黑树的指针，并重新更新双方容器内部所维护的红黑树的 size

                map<string, int> __m_src;
                __m_src["C"] = 3;
                __m_src.insert(make_pair("A", 1));
                __m_src.insert(map<string, int>::value_type("B", 2));

                map<string, int> __m_des;

                /* void swap(set &__s) */
                __m_src.swap(__m_des);

                /* set &operator=(const set &__s) */
                __m_src = __m_des;

            -> map 的大小操作
                -> size_t size()                    返回 map 容器内部所维护的红黑树的节点个数
                -> bool empty()                     判断是否是一个空容器（无任何节点的链接）

                map<string, int> __m;
                
                /* size_t size() */
                int cout = __m.size();
                
                /* bool empty() */
                bool flag = __m.empty();
                
            -> 插入
                -> pair<map<K,V>::iterator, bool> insert(pair<const K,V> __p)    向 map 容器内部所维护的红黑树中新增一个节点，并赋予该节点的键为对组 __p 的第一元素，该节点的值为对组 __p 的第二元素，最后返回能够标识当前所插入的节点在整个数中的位置的迭代器和是否插入成功所结合而成的对组
                -> V &operator[](const K &_key)                                  向 map 容器内部所维护的红黑树中依据所指定的 键 _key 搜索是否存在该节点，如不存在，则依据 map 所指定的 值 的类型并调用其默认构造去创建一个默认的 值 并与键 _key 进行绑定，然后往树种新增一个节点，最后返回该 值 的引用

                map<string, int> __m;

                /* pair<map<K,V>::iterator, bool> insert(pair<const K,V> __p) */
                pair<map<string, int>::iterator, bool> result_01 = __m.insert(pair<string, int>("C", 3));
                pair<map<string, int>::iterator, bool> result_02 = __m.insert(make_pair("A", 1));
                pair<map<string, int>::iterator, bool> result_03 = __m.insert(map<string, int>::value_type("D", 4));

                /* V &operator[](const K &_key) */
                __m["B"] = 2;

            -> 删除
                -> void clear()                                                                 删除 map 容器内部所维护的红黑树的所有的节点
                -> map<K,V>::iterator erase(map<K,V>::iterator start, map<K,V>::iterator end)   map 容器内部所维护的红黑树中删除迭代器 start 和 迭代器 end 所指向的下标之间的所有的节点，最后返回指向当前所操作元素的下一个元素的迭代器
                -> map<K,V>::iterator erase(map<K,V>::iterator pos)                             map 容器内部所维护的红黑树中删除迭代器 pos 所指向的节点，最后返回指向当前所操作元素的下一个元素的迭代器
                -> void erase(K _key)                                                           map 容器内部所维护的红黑树中删除对应键 _key 的节点

                map<string, int> __m;
                __m["C"] = 3;
                __m["A"] = 1;
                __m["D"] = 4;
                __m["B"] = 2;

                /* map<K,V>::iterator erase(map<K,V>::iterator pos) */
                __m.erase(__m.begin(), ++(++__m.begin()));

                /* map<K,V>::iterator erase(map<K,V>::iterator start, map<K,V>::iterator end) */
                __m.erase(__m.begin());

                /* void erase(K _key) */
                __m.erase("C");

                /* void clear() */
                __m.clear();

            -> 查找
                -> map<K,V>::iterator find(K _key)                                              在 map 内部所维护的红黑树中查找相符合键值 _key 的结点并返回第一次找到该结点所在下标的迭代器，若不存在匹配键值 _key 的节点，则返回指向最后一个元素的后一个位置的迭代器，即 map<K,V>.end() 的调用结果
                -> size_t count(K _key)                                                         在 map 内部所维护的红黑树中查找相符合键值 _key 的结点的个数
                -> map<K,V>::iterator lower_bound(K _key)                                       在 map 内部所维护的红黑树中查找相符合 目标节点键 >= _key 的结点并返回该结点所在下标的迭代器，若不存在，则返回指向最后一个元素的后一个位置的迭代器，即 map<K,V>.end() 的调用结果
                -> map<K,V>::iterator upper_bound(K _key)                                       在 map 内部所维护的红黑树中查找相符合 目标节点键 > _key 的结点并返回该结点所在下标的迭代器，若不存在，则返回指向最后一个元素的后一个位置的迭代器，即 map<K,V>.end() 的调用结果
                -> pair<map<K,V>::iterator, map<K,V>::iterator> equal_range(K _key)             依据指定的键值 _key 返回 lower_bound 和 upper_bound 调用所获取到的迭代器对组 pair，其中 first 为 lower_bound 调用结果所获取到的迭代器，second 为 upper_bound 调用结果所获取到的迭代器

                map<string, int> __m;
                __m["C"] = 3;
                __m["A"] = 1;
                __m["D"] = 4;
                __m["B"] = 2;
                
                /* map<K,V>::iterator find(K _key) */
                map<string, int>::iterator it_find = __m.find("B");
                
                /* size_t count(K _key) */
                size_t count = __m.count("A");
                
                /* map<K,V>::iterator lower_bound(K _key) */
                map<string, int>::iterator it_lower = __m.lower_bound("C");
                
                /* map<K,V>::iterator upper_bound(T _key) */
                map<string, int>::iterator it_uppler = __m.upper_bound("C");
                
                /* pair<map<K,V>::iterator, map<K,V>::iterator> equal_range(K _key) */
                pair<map<string, int>::iterator, map<string, int>::iterator> _res = __m.equal_range("C");

    -> 仿函数
        -> 重载了函数调用操作符 的类的使用其行为类似于一个函数调用，针对此特性我们通常也称这种类为：函数对象、仿函数，并且，根据函数调用操作符所重载的函数所录入的形参数量去划分该仿函数的元级，即该仿函数是一个几元仿函数，对于大多数情况而言，我们更多使用的是 一元仿函数（unary functor）和 二元仿函数（binary functor）
        -> 仿函数的定义通常有一条并不成文的规定，我们在定义仿函数的时候通常是不需要去定义该类的构造和析构
        -> 仿函数更多的和 STL 绑定起来使用，在 STL 中，通过仿函数可以非常方便的去为 某一种容器亦或者某算法 去提供我们所自定义的操作逻辑
        -> 由于仿函数的真正核心是属于一个类中的成员函数，故对于仿函数的使用其实都能够享有 内联函数 所带来的好处的，对比一般的函数调用而言可能在某些情况下仿函数会更显示出性能优势，除此之外，使用仿函数能够把一个函数的调用也进行抽象化，即增强了代码的 oop 性和通用性，并且也是因为 类 的本身，仿函数是可以拥有属于自己的状态的，如有需要的话

        -> 谓词
            -> 如果仿函数其内部 函数调用操作符所重载的函数 的返回值为 bool 类型，那么我们也可以称这个仿函数为：谓词，并且根据仿函数的具体元数来划分这个谓词是几元谓词

        -> 内建仿函数
            -> STL 为了保证统一性，其内建了一些仿函数，它们大致划分为：算数类函数对象、关系运算类函数对象、逻辑运算类仿函数，这些由 STL 内建的仿函数都划分在 functional 这个头文件当中

            6个算数类函数对象,除了negate是一元仿函数，其他都是二元仿函数
            template<class T> T plus<T>             加法仿函数
            template<class T> T minus<T>            减法仿函数
            template<class T> T multiplies<T>       乘法仿函数
            template<class T> T divides<T>          除法仿函数
            template<class T> T modulus<T>          取模仿函数
            template<class T> T negate<T>           取反仿函数

            6个关系运算类函数对象,每一种都是二元仿函数
            template<class T> bool equal_to<T>      等于
            template<class T> bool not_equal_to<T>  不等于
            template<class T> bool greater<T>       大于
            template<class T> bool greater_equal<T> 大于等于
            template<class T> bool less<T>          小于
            template<class T> bool less_equal<T>    小于等于

            逻辑运算类运算函数,not为一元仿函数，其余为二元仿函数
            template<class T> bool logical_and<T>   逻辑与
            template<class T> bool logical_or<T>    逻辑或
            template<class T> bool logical_not<T>   逻辑非

            #include <set>
            #include <vector>
            #include <iostream>
            #include <algorithm>
            #include <functional>
            using namespace std;

            template<class T>
            class set_printer {
            public:
              void operator()(const T &_val) {
                cout << _val << endl;
              }
            };
            void foo(void) {
              set<int, greater<int>> __s;
              __s.insert(4);
              __s.insert(2);
              __s.insert(5);
              __s.insert(1);
              __s.insert(3);
              
              vector<int> __v;
              __v.push_back(3);
              __v.push_back(5);
              __v.push_back(1);
              __v.push_back(4);
              __v.push_back(2);
              sort(__v.begin(), __v.end(), less<int>());
              
              for_each(__s.begin(), __s.end(), set_printer<int>());
              for_each(__v.begin(), __v.end(), set_printer<int>());
            }

    -> 适配器
        -> 仿函数适配器
            -> binder2nd bind2nd(const _Function &__f_binary, const _Type &__val)
                -> 参数：
                    -> __f_binary：需要是一个二元仿函数(所重载的函数调用操作符的函数需要声明为 常函数，因为最终会通过一个常函数来调用仿函数)并且继承自 binary_function<T1 arg_01, T2 arg_02, R ret>
                    -> __val：需要和 __f_binary 进行绑定的值
                -> 返回值：
                    -> binder2nd：一个一元仿函数，其所实现的重载函数调用操作符的函数的返回值同步至所指定的仿函数 __f_binary，形参列表接收一个所指定的二元仿函数 __f_binary 的第一个形参的类型的形参 __val_src 的输入，并在其内部实现中又调用了我们所录入的仿函数 __f_binary，并在调用 __f_binary 时会输入两个参数，它们分别是 __val_src 和 bind2nd 构造时所录入的实参 __val
                -> 使用场景：
                    -> 在某些 API 需要指定一个一元仿函数但是现有只有二元仿函数时，可以使用 bind2nd 进行适配工作
                class print_m : public binary_function<int, int, void> {
                public:
                  void operator()(int _val_01, int _val_02) const {
                    cout << _val_01 + _val_02 << endl;
                  }
                };
                void foo_functor(void) {
                  int nums[5] = { 1, 2, 3, 4, 5 };
                  vector<int> __v(nums, nums + (sizeof(nums) / sizeof(int)));

                  for_each(__v.begin(), __v.end(), bind2nd(print_m(), 1000));
                }

        -> 取反适配器
            -> unary_negate not1(const _Function &__f_unary)
                -> 参数：
                    -> __f_unary：需要一个返回值为 bool 类型的一元仿函数并且继承自 unary_function<T1 arg, R ret>
                -> 返回值：
                    -> unary_negate：一个一元仿函数，重载的函数调用操作符的函数的返回值和形参列表同步至所指定的仿函数 __f_unary，并且其内部实现中会调用返回所录入的一元仿函数 __f_unary 的取反结果
            -> binary_negate not1(const _Function &__f_binary)
                -> 参数：
                    -> __f_binary：需要一个返回值为 bool 类型的二元仿函数并且继承自 binary_function<T1 arg_01, T2 arg_02, R ret>
                -> 返回值：
                    -> binary_negate：一个二元仿函数，重载的函数调用操作符的函数的返回值和形参列表同步至所指定的仿函数 __f_binary，并且其内部实现中会调用返回所录入的二元仿函数 __f_binary 的取反结果
            -> 使用场景：
                -> 当我们针对某种返回 bool 类型的仿函数的真实取值结果并不满意时，我们可以通过 not 适配器的适配作用在不更改原仿函数的源代码的前提下完成对其取值结果的取反工作
            void foo_NOT(void) {
              int nums[5] = { 3, 2, 4, 1, 5 };
              vector<int> __v(nums, nums + (sizeof(nums) / sizeof(int)));

              sort(__v.begin(), __v.end(), not2(less<int>()));

              vector<int>::iterator _result = find_if(__v.begin(), __v.end(), not1(bind2nd(greater<int>(), 2)));
              cout << *_result << endl;
            }

        -> 函数适配器
            -> pointer_to_unary_function ptr_fun(unary_function invoker)
                -> 参数：
                    -> unary_function：接收一个返回值为任意类型，但是只有一个任意类型形参的函数指针
                -> 返回值：
                    -> pointer_to_unary_function：一个 一元仿函数，所重载的函数调用操作符的函数是一个形参列表和返回值类型同步至函数指针并且声明为 cost 的常函数，其内部实现中会调用函数指针 invoker
            -> pointer_to_unary_function ptr_fun(unary_function invoker)
                -> 参数：
                    -> binary_function：接收一个返回值为任意类型，但是有两个任意类型形参的函数指针
                -> 返回值：
                    -> pointer_to_binary_function：一个 二元仿函数，所重载的函数调用操作符的函数是一个形参列表和返回值类型同步至函数指针并且声明为 cost 的常函数，其内部实现中会调用函数指针 invoker
            -> 使用场景：
                -> 将一个普通的函数转换为 所重载的函数调用操作符的函数声明为 const 的仿函数

        -> 成员函数适配器
            -> mem_fun_ref_t mem_fun_ref(member_function_none invoker)
                -> 参数：
                    -> member_function_none：接受一个任意类型返回值但是无形参的某个类的 [成员函数]
                -> 返回值：
                    -> mem_fun_ref_t：一个 一元仿函数，所重载的函数调用操作符的函数的返回值同步至成员函数 invoker，形参列表接收一个 成员函数 所在类的类型的形参 _src，所指定的成员函数 invoker 依赖形参 _src 的实例化完成其调用操作
            -> mem_fun1_ref_t mem_fun_ref(member_function_unary invoker)
                -> 参数：
                    -> member_function_unary：接受一个任意类型返回值但是只有一个形参的某个类的 [成员函数]
                -> 返回值：
                    -> mem_fun1_ref_t：一个 二元仿函数，所重载的函数调用操作符的函数的返回值同步至成员函数 invoker，形参列表接收 成员函数 所在类的类型的形参 _src 和 成员函数 第一个形参的类型的形参 _arg，所指定的成员函数 invoker 依赖形参 _src 的实例化并在调用时录入形参 _arg 完成其调用操作

            -> 使用场景：
                -> 该适配器能够将一个成员函数一种仿函数以供调用，其内部实现依赖于成员函数和函数指针之间的转换关系来完成，简而言之该函数的调用还是要依赖于成员函数所在类型实例的本身才能够完成调用
            class Person {
            public:
              Person(int _age)
                : m_age(_age){};
            public:
              void speak(string _words) {
                cout << _words << " age = " << this->m_age << endl;
              }
              void Do() {
                cout << "DO! AGE = " << this->m_age << endl;
              }
            
            public:
              int m_age;
            };
            void foo_member_function(void) {
              vector<Person> __v;
              __v.push_back(Person(1));
              __v.push_back(Person(2));
              __v.push_back(Person(3));
              __v.push_back(Person(4));
              __v.push_back(Person(5));
            
              for_each(__v.begin(), __v.end(), bind2nd(mem_fun_ref(Person::speak), "HELLO,WORLD"));
            
              for_each(__v.begin(), __v.end(), mem_fun_ref(Person::Do));
            }


    -> 算法
        -> STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成

        -> 遍历算法
            -> _Function for_each(_InputIterator start, _InputIterator end, _Function _fn)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至所指定的 一元仿函数或者函数指针 当中，最后会返回所指定的 一元仿函数或者函数指针
                void printer_for_each(const int &_val) {
                  cout << _val << endl;
                }
                void foo_for_each(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 10; ++i) {
                    __v.push_back(i + 1);
                  }

                  void (*invoker)(const int &) = for_each(__v.begin(), __v.end(), printer_for_each);
                }
            -> void transform(_InputIterator start, _InputIterator end, _OutputIterator start_des, _UnaryOperation unary_op)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至所指定的 返回值和形参类型为容器中的元素类型的一元仿函数或者函数指针 unary_op 当中，并依照它的返回结果 [重新赋值] 给迭代器 start_des 所指向的目标容器中
                -> 该函数的调用必须要保证目标迭代器 __result 所指向的容器中是含有 [有效元素] 的，否则会调用失败
                int f_transform(int &_val) {
                  return _val + 1;
                }
                void foo_transform(void) {
                  vector<int> __v_src;
                  for (size_t i = 0; i < 10; ++i) {
                    __v_src.push_back(i + 1);
                  }

                  vector<int> __v_des;
                  __v_des.resize(__v_src.size());
                  transform(__v_src.begin(), __v_src.end(), __v_des.begin(), f_transform);
                }
        
        -> 查找算法
            -> iterator_pos find(iterator start, iterator end, T _val)
                -> 在容器指定范围(迭代器 start 和 end 划分的范围)内的元素中查找值为 _val 的元素并返回第一次找到该元素所在下标的 [目标容器类型的迭代器]，若不存在，则返回指向最后一个元素的后一个位置的迭代器
                void foo_find(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 10; ++i) {
                    __v.push_back(i);
                  }

                  vector<int>::iterator _pos = find(__v.begin(), __v.end(), 4);
                  if (_pos != __v.end()) cout << *_pos << endl;
                }
            -> iterator_pos find_if(iterator start, iterator end, _Function _fn)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至所指定的 返回值为 bool 类型的一元仿函数或者函数指针 _fn 当中，当 _fn 所返回的结果为 true 时，则该函数返回当前元素所在下标的 [目标容器类型的迭代器]，若不存在，则返回指向最后一个元素的后一个位置的迭代器
                void foo_find_if(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 10; ++i) {
                    __v.push_back(i);
                  }

                  vector<int>::iterator _result = find_if(__v.begin(), __v.end(), [](int &_val) { return _val > 3; });
                  if (_result != __v.end()) cout << *_result << endl;
                }
            -> iterator_pos adjacent_find(iterator start, iterator end)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，并寻找间隔相邻的并且值重复的元素，如果存在，则返回所重复元素的上一个元素所在下标的 [目标容器类型的迭代器]，若不存在，则返回指向最后一个元素的后一个位置的迭代器
                void foo_adjacent_find(void) {
                  vector<int> __v;
                  __v.push_back(1);
                  __v.push_back(2);
                  __v.push_back(3);
                  __v.push_back(3);
                  __v.push_back(4);

                  vector<int>::iterator _result = adjacent_find(__v.begin(), __v.end());
                  if (_result != __v.end()) cout << *_result << endl;
                }
            -> bool binary_search(iterator start, iterator end, const T &_val)
                -> 使用二分查找法查找容器指定范围(迭代器 start 和 end 划分的范围)内的元素，并判断是否存在值为 _val 的元素，如果存在则返回 true，如果不存在则返回false
                -> 由于该算法使用的是二分查找法，为了该算法的运行不会失效，我们需要保证指定的容器内部所存储的元素是一个 有序序列
                void foo_binary_search(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 10; ++i) {
                    __v.push_back(i);
                  }

                  bool _result = binary_search(__v.begin(), __v.end(), 3);
                  cout << _result << endl;
                }
            -> int binary_search(iterator start, iterator end, const T &_val)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，并统计值为 _val 的元素所出现的次数并返回
                void foo_count(void) {
                  vector<int> __v;
                  __v.push_back(1);
                  __v.push_back(2);
                  __v.push_back(3);
                  __v.push_back(3);
                  __v.push_back(4);

                  int _count = count(__v.begin(), __v.end(), 3);
                }
            -> int count_if(iterator start, iterator end, _Function _fn)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至所指定的 返回值为 bool 类型的一元仿函数或者函数指针 _fn 当中，并统计 _fn 返回值为 true 的次数，最后返回所统计的结果
                void foo_count_if(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 10; ++i) {
                    __v.push_back(i);
                  }

                  int _count = count_if(__v.begin(), __v.end(), [](int &_val) { 
                    return _val > 5; 
                  });
                  cout << _count << endl;
                }

        -> 排序算法
            -> void sort(iterator start, iterator end, _Function _fn)
                -> 对容器内指定范围(迭代器 start 和 end 划分的范围)内的元素依照返回值为 bool 类型，形参类型为容器中的元素的值的类型的二元仿函数或函数指针 去进行排序
                void foo_sort(void) {
                  vector<int> __v;
                  __v.push_back(4);
                  __v.push_back(1);
                  __v.push_back(5);
                  __v.push_back(2);
                  __v.push_back(3);

                  sort(__v.begin(), __v.end(), [](int &_left, int &_right) { return _left > _right; });
                }
            -> void random_shuffle(iterator start, iterator end)
                -> 随机置乱容器指定范围(迭代器 start 和 end 划分的范围)内的元素的原始次序
                void foo_random_shuffle(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 5; ++i) {
                    __v.push_back(i);
                  }

                  random_shuffle(__v.begin(), __v.end());

                  for_each(__v.begin(), __v.end(), [](int &_val) { cout << _val << endl; });
                }
            -> void reverse(iterator start, iterator end)
                -> 反转容器中指定范围(迭代器 start 和 end 划分的范围)内的元素的次序
                void foo_reverse(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 5; ++i) {
                    __v.push_back(i);
                  }

                  reverse(__v.begin(), __v.end());
                }

        -> 拷贝/替换/合并
            -> void merge(iterator src_start_1, iterator src_end_1, iterator src_start_2, iterator src_end_2, iterator des_start)
                -> 合并指定范围内(两个容器的开始和起始迭代器 src_start_1、src_end_1、src_start_2、src_end_2) 的两个容器的元素，并重新赋值给目标容器(迭代器 des_start 所指向的容器)当中
                -> 我尽量要保证原始合并的两个数据源是有序序列，否则合并后的结果将可能会出现相较之前的乱序
                -> 目标容器在合并前要保证其内部元素中是含有 [有效元素] 的，否则会调用失败
                void foo_merge(void) {
                  vector<int> __v_src_1;
                  __v_src_1.push_back(1);
                  __v_src_1.push_back(2);
                  __v_src_1.push_back(3);
                  __v_src_1.push_back(4);
                  __v_src_1.push_back(5);

                  vector<int> __v_src_2;
                  __v_src_2.push_back(6);
                  __v_src_2.push_back(7);

                  vector<int> __v_des;
                  __v_des.resize(__v_src_1.size() + __v_src_2.size());
                  merge(__v_src_1.begin(), __v_src_1.end(), __v_src_2.begin(), __v_src_2.end(), __v_des.begin());
                }
            -> void copy(iterator src_start, iterator src_end, iterator des_start)
                -> 拷贝原始容器中指定范围(迭代器 start 和 end 划分的范围)内的元素并重新赋值给目标容器(迭代器 des_start 所指向的容器)当中
                -> 目标容器在拷贝前要保证其内部元素中是含有 [有效元素] 的，否则会调用失败
                void foo_copy(void) {
                  vector<int> __v_src;
                  for (size_t i = 0; i < 5; ++i) {
                    __v_src.push_back(i);
                  }
                
                  vector<int> __v_des;
                  for (size_t i = 5; i < 10; ++i) {
                    __v_des.push_back(i);
                  }
                  copy(__v_src.begin(), __v_src.end(), __v_des.begin());
                
                  copy(__v_des.begin(), __v_des.end(), ostream_iterator<int>(cout, " "));
                }
            -> void replace(iterator start, iterator end, const T &_old_val, const T &_new_val)
                -> 查找容器中指定范围(迭代器 start 和 end 划分的范围)内值为 _old_val 的元素，并修改其值为 _new_val
                void foo_replace(void) {
                  vector<int> __v;
                  __v.push_back(1);
                  __v.push_back(2);
                  __v.push_back(2);
                  __v.push_back(3);
                  __v.push_back(4);

                  replace(__v.begin(), __v.end(), 2, 0x400);
                }
            -> void replace_if(iterator start, iterator end, function _fn, const T &_new_val)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至所指定的 返回值为 bool 类型，形参类型为容器中的元素的值的类型的一元仿函数或者函数指针 _fn 当中并调用，当该 _fn 返回 true 时，则当前所操作的元素的值替换为 _new_val
                bool m_replace(int &_old_val) {
                  return _old_val > 2;
                }
                void foo_replace_if(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 5; ++i) {
                    __v.push_back(i);
                  }

                  replace_if(__v.begin(), __v.end(), m_replace, 0x400);
                }
            -> void swap(Container c_src, Container c_des)
                -> 交换两个容器(相同容器类型)的内部用于管控数据空间的指针所指向的地址
                void foo_swap(void) {
                  vector<int> __v_1;
                  for (size_t i = 0; i < 5; ++i) {
                    __v_1.push_back(i);
                  }

                  vector<int> __v_2;
                  for (size_t i = 5; i < 10; ++i) {
                    __v_2.push_back(i);
                  }

                  swap(__v_1, __v_2);
                }

        -> 算数生成
            -> T accumulate(iterator start, iterator end, const T &_init_val)       <numeric>
                -> 以 _init_val 作为初始化数据，在此基础上累加容器指定范围(迭代器 start 和 end 划分的范围)内的元素的值，最后返回累加后的结果
                void foo_accumulate(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 5; ++i) {
                    __v.push_back(i);
                  }

                  int num = accumulate(__v.begin(), __v.end(), 100);
                  cout << num << endl;
                }
            -> void fill(iterator start, iterator end, const T &_val)
                -> 容器指定范围(迭代器 start 和 end 划分的范围)内的元素的值替换为 _val
                void foo_fill(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 5; ++i) {
                    __v.push_back(i);
                  }

                  fill(__v.begin(), __v.begin() + 2, 0x400);
                }

        -> 集合算法
            -> iterator set_intersection(iterator src_start_1, iterator src_end_1, iterator src_start_2, iterator src_end_2, iterator des_start)
                -> 该算法提供查找并集的功能
                -> 查找指定范围内(两个容器的开始和起始迭代器 src_start_1、src_end_1、src_start_2、src_end_2) 的两个容器的元素中元素的值相同的元素，并把它重新赋值给目标容器(迭代器 des_start 所指向的容器)当中，最后会返回目标容器的 结束迭代器(end())
                -> 我尽量要保证原始的两个容器的数据源是有序序列，否则目标容器所获取到的结果将可能会出现乱序
                -> 目标容器在赋值前要保证其内部元素中是含有 [有效元素] 的，否则会调用失败
                void foo_set_intersection(void) {
                  vector<int> __v_src_1;
                  vector<int> __v_src_2;
                  for (size_t i = 0; i < 10; ++i) {
                    __v_src_1.push_back(i);
                    __v_src_2.push_back(i + 5);
                  }

                  vector<int> __v_des;
                  __v_des.resize(__v_src_1.size(), __v_src_2.size());

                  vector<int>::iterator i_end = set_intersection(__v_src_1.begin(), __v_src_1.end(), __v_src_2.begin(), __v_src_2.end(), __v_des.begin());
                }
            -> iterator set_union(iterator src_start_1, iterator src_end_1, iterator src_start_2, iterator src_end_2, iterator des_start)
                -> 该算法提供查找交集的功能
                -> 去除掉，指定范围内(两个容器的开始和起始迭代器 src_start_1、src_end_1、src_start_2、src_end_2) 的两个容器中，值重复的元素并进行合并，并把合并后的结果重新赋值给目标容器(迭代器 des_start 所指向的容器)当中，最后会返回目标容器的 结束迭代器(end())
                -> 我尽量要保证原始的两个容器的数据源是有序序列，否则目标容器所获取到的结果将可能会出现乱序
                -> 目标容器在合并前要保证其内部元素中是含有 [有效元素] 的，否则会调用失败
                void foo_set_union(void) {
                  vector<int> __v_src_1;
                  vector<int> __v_src_2;
                  for (int i = 0; i < 10; i++) {
                    __v_src_1.push_back(i);
                    __v_src_2.push_back(i + 5);
                  }

                  vector<int> __v_des;
                  __v_des.resize(__v_src_1.size() + __v_src_2.size());

                  vector<int>::iterator i_end = set_union(__v_src_1.begin(), __v_src_1.end(), __v_src_2.begin(), __v_src_2.end(), __v_des.begin());
                }
            -> iterator set_difference(iterator src_start_1, iterator src_end_1, iterator src_start_2, iterator src_end_2, iterator des_start)
                -> 该算法提供查找差集的功能
                -> 查找容器指定范围(迭代器 src_start_1 和 src_end_1 划分的范围)内 [相较于] 容器指定范围(迭代器 src_start_2 和 src_end_2 划分的范围)内，元素的值不同的元素，并把结果重新赋值给目标容器(迭代器 des_start 所指向的容器)当中，最后会返回目标容器的 结束迭代器(end())
                -> 我尽量要保证原始的两个容器的数据源是有序序列，否则目标容器所获取到的结果将可能会出现乱序
                -> 目标容器在赋值前要保证其内部元素中是含有 [有效元素] 的，否则会调用失败
                void foo_set_difference(void) {
                  vector<int> __v_src_1;
                  vector<int> __v_src_2;

                  for (int i = 0; i < 10; i++) {
                    __v_src_1.push_back(i);
                    __v_src_2.push_back(i + 5);
                  }

                  vector<int> __v_des;
                  __v_des.resize(max(__v_src_1.size(), __v_src_2.size()));

                  vector<int>::iterator i_end = set_difference(__v_src_1.begin(), __v_src_1.end(), __v_src_2.begin(), __v_src_2.end(), __v_des.begin());

                  /* vector<int>::iterator i_end = set_difference(__v_src_2.begin(), __v_src_2.end(), __v_src_1.begin(), __v_src_1.end(), __v_des.begin()); */
                }

    -> 迭代器 
        -> iterator：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式
        -> 迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题
        -> 迭代器的种类
            -> 输入迭代器	    提供对数据的只读访问	                                        只读，支持++、==、！=
               输出迭代器	    提供对数据的只写访问	                                        只写，支持++
               前向迭代器	    提供读写操作，并能向前推进迭代器	                              读写，支持++、==、！=
               双向迭代器	    提供读写操作，并能向前和向后操作	                              读写，支持++、--，
               随机访问迭代器	 提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器	 读写，支持++、--、[n]、-n、<、<=、>、>=
        -> 每一种容器的每一种不同的模板类型都由其对应着的迭代器

            