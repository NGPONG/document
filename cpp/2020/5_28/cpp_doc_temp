


#include <iostream>
    -> 该文件还包含 include 着一些比较常用的头文件，如：stdlib.h 
    -- namespace：std
        -> cout << xxx << xxx << endl
            -> count：输出
            -> endl：
                -> 在 stdout 里面写入换行符，换行符的类型可以自动匹配适应当前 os 的类型，例如windows下为 \r\n，linux下位 \n
                -> 立即刷新文件缓冲区

标准输入流
    -> #include <iostream> -> namespace std;
    -> cin

    -> cin.get()
        -> 从文件缓冲区 stdin 中读取所输入的一个 char 字符，以 \n 作为本次从 stdin 缓冲区中取出数据的结束标识符 ( 能够接收到 \n 字符 )
        -> 由于此操作是从 stdin 中取出数据，也就意味着在调用该函数时会有一个阻塞的过程等待着我们的 input 设备去录入即将要输入到缓冲区中的数据

    -> cin.get(char *str,int size)
        -> 从文件指针 stdin 所指向的文件的缓冲区内获取 size 字节的数据（如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的执行并等待用户终端 input 设备把数据去输入到 stdin 缓冲区，并以 \n 字符作为本次输入的结束），以 \n 作为此次从 stdin 缓冲区中取出数据的结束标识符，把所读取到的内容填充至形参 str 所指向的内存空间中
        -> 该函数从缓冲区 stdin 中获取数据时会忽略掉 \n 字符，也就是说在调用完成该函数后，stdin 缓冲区中其实还留有着一个 \n 字符
        -> 该函数所给定的参数 str 必须为一个字符数组以保证写入权限，如果给定的是一个字符指针形式的字符串的话，该函数则会调用失败，因为该函数会逐地址写入所录入的字符
        -> 该函数是较为安全的，至始至终都会为 str 所指向的空间保留最后一位的字节内容以录入 '\0'，如果超出，则截断最后一位所采集到的数据以保证在录入 '\0' 字符时候，str 所指向的内存空间的足够
        
    -> cin.getline(char *str,int size)
        -> 从文件指针 stdin 所指向的文件的缓冲区内获取 size 字节的数据（ 如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的执行并等待用户终端 input 设备把数据去输入到 stdin 缓冲区，并以 \n 字符作为本次输入的结束 ），以 \n 作为此次从 stdin 缓冲区中取出数据的结束标识符，把所读取到的内容填充至形参 str 所指向的内存空间中
        -> 该函数会从 stdin 中获取到本次所录入的一整段字符串 ( 包括 \n )，但是在把该字符再写入到 str 所指向的内存空间当中前会先删除掉所获取到的该字符串结尾的 \n 字符
        -> 该函数所给定的参数 str 必须为一个字符数组以保证写入权限，如果给定的是一个字符指针形式的字符串的话，该函数则会调用失败，因为该函数会逐地址写入所录入的字符
        -> 该函数是较为安全的，至始至终都会为 str 所指向的空间保留最后一位的字节内容以录入 '\0'，如果超出，则截断最后一位所采集到的数据以保证在录入 '\0' 字符时候，str 所指向的内存空间的足够

    -> cin.ignore(int size)
        -> 删除掉 stdin 缓冲区内前 size 个字节的数据，如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的调用等待用户输入，当输入了 \n 后则意为本次输入的结束

    -> cin.peek()
        -> 查看 stdin 缓冲区内前1个字节的数据（仅查看，不删除），如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的调用等待用户输入，当输入了 \n 后则意为本次输入的结束

    -> cin.putback(char _ch)
        -> 把上一次从 stdin 中获取到的一个字符再放回 stdin 缓冲区对应该字符的原位置中，需要注意的是，我们不应该把该函数的使用当成是往 stdin 缓冲区内的首部插入一个字符的数据，不正当的使用会造成 stdin 缓冲区数据的清空

    -> cin >> expression
        -> 从文件指针 stdin 所指向的文件的缓冲区内获取数据（如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的执行并等待用户终端 input 设备把数据去输入到 stdin 缓冲区，并以 \n 字符作为本次输入的结束），以 \n 或者 \0 作为此次从 stdin 缓冲区中取出数据的结束标识符，并把所读取到的数据写入到 expression 所指向的内存空间当中
        -> 我们要保证 expression 的类型和本次从 stdin 中所获取到的数据的类型是一致的，否则 stdin 缓冲区会出现错误，比如说，expression 所指定的类型为 int 类型，但是 stdin 缓冲区所留有的类型却是一个字符类型，这时候 stdin 缓冲区就会出现错误，那么当我们下一次再去 stdin 缓冲区中获取数据时，就永远都无法获取到真实的、本应该存在在 stdin 缓冲区中的数据，针对这种情况，我们可以使用 cin.clear() 和 cin.sync() 去重置一次缓冲区中的数据以解决这个问题

    -> cin.fail()
        -> 根据 stdin 缓冲区中的错误标识来判断 stdin 缓冲区中是否发生了错误，如果该标识是一个发生错误的状态，则该函数返回的结果则为 1，否则为 0，当然，我们可以手动的调用 cin.sync() 函数来重置这个标识

    -> cin.clear()
        -> 清空 stdin 缓冲区中的数据
    
    -> cin.sync()
        -> 重置/复原 stdin 缓冲区错误的标识，简而言之，如果 cin.fail() 调用时获取到的结果为 1，那么在调用完这个函数后再去调用 cin.fail() 则获取到的结果则为 0







-> 结构体的扩展
    -> 提供了函数的支持 ( 在结构体中所声明的函数不在当前结构体所对应存储的内存段当中，即不会纳入内存对齐的考量范围 )
        -> 构造函数 拷贝构造函数 移动构造函数 析构函数的支持
        -> 我们对于结构体中的函数成员可以声明为定义亦或者一个链接符号形式的声明，但是不能同时存在同一个函数的声明和定义在同一个结构体当中
               当我们为结构体中的成员函数声明为链接符号形式的声明的时候，我们必须要保证在 全局作用域 下能够为该符号链接声明一个具体的定义，否则在当前结构体中，关乎到该声明的使用将都会使编译不通过

    -> this 指针的支持

    -> 友元成员的支持

    -> 运算符重载函数的支持

    -> 静态成员的支持，和类中的概念一样

    -> 结构体中的成员提供了访问修饰符的支持，并且默认情况下的访问修饰符为：public

    -> 在构造一个结构体类型的时候，我们为这个结构体所构造的普通成员变量是允许在声明的同时存在其定义的，而对于结构体中的函数，我们同样也可以存在声明和定义，需要注意的是，我们对于一个结构体中的成员函数进行声明的时候，那么我们还需要在外部通过 :: 引用作用域的手段来把当前在结构体中所定义的函数声明链接为具体的一个定义

    -> 在 cpp 中是允许空结构体的存在的，对于一个没有任何声明的结构体来说，其实例还是会在内存中占用 1 bytes 的空间大小，原因是因为 cpp 需要保证每一个类的实例在内存中都会是独一无二的存在




CPP对C的一些扩展
    -> 三元运算符 CPP 所返回的结果是变量，而 C 中所返回的是这个变量所存储的值，这就造就了一个特性，CPP可以对特定的三元运算符 ( 引用变量的三元运算符 ) 所返回的结果进行赋值操作

    -> bool 类型的支持

    -> 类型转换检测增强，对于类型转换必须严格执行

    -> 函数书写性检测
    
    -> CPP 下所声明在全局作用域下的成员 ( 全局变量 ) 默认情况下都是内部链接属性 ?????????????好像不是????????????????





STL
    -> 算法
        
        -> 查找算法


        -> 


        -> 

        -> 


        -> 

    -> 迭代器 

            