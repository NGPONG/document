


#include <iostream>
    -> 该文件还包含 include 着一些比较常用的头文件，如：stdlib.h 
    -- namespace：std
        -> cout << xxx << xxx << endl
            -> count：输出
            -> endl：
                -> 在 stdout 里面写入换行符，换行符的类型可以自动匹配适应当前 os 的类型，例如windows下为 \r\n，linux下位 \n
                -> 立即刷新文件缓冲区

标准输入流
    -> #include <iostream> -> namespace std;
    -> cin

    -> cin.get()
        -> 从文件缓冲区 stdin 中读取所输入的一个 char 字符，以 \n 作为本次从 stdin 缓冲区中取出数据的结束标识符 ( 能够接收到 \n 字符 )
        -> 由于此操作是从 stdin 中取出数据，也就意味着在调用该函数时会有一个阻塞的过程等待着我们的 input 设备去录入即将要输入到缓冲区中的数据

    -> cin.get(char *str,int size)
        -> 从文件指针 stdin 所指向的文件的缓冲区内获取 size 字节的数据（如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的执行并等待用户终端 input 设备把数据去输入到 stdin 缓冲区，并以 \n 字符作为本次输入的结束），以 \n 作为此次从 stdin 缓冲区中取出数据的结束标识符，把所读取到的内容填充至形参 str 所指向的内存空间中
        -> 该函数从缓冲区 stdin 中获取数据时会忽略掉 \n 字符，也就是说在调用完成该函数后，stdin 缓冲区中其实还留有着一个 \n 字符
        -> 该函数所给定的参数 str 必须为一个字符数组以保证写入权限，如果给定的是一个字符指针形式的字符串的话，该函数则会调用失败，因为该函数会逐地址写入所录入的字符
        -> 该函数是较为安全的，至始至终都会为 str 所指向的空间保留最后一位的字节内容以录入 '\0'，如果超出，则截断最后一位所采集到的数据以保证在录入 '\0' 字符时候，str 所指向的内存空间的足够
        
    -> cin.getline(char *str,int size)
        -> 从文件指针 stdin 所指向的文件的缓冲区内获取 size 字节的数据（ 如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的执行并等待用户终端 input 设备把数据去输入到 stdin 缓冲区，并以 \n 字符作为本次输入的结束 ），以 \n 作为此次从 stdin 缓冲区中取出数据的结束标识符，把所读取到的内容填充至形参 str 所指向的内存空间中
        -> 该函数会从 stdin 中获取到本次所录入的一整段字符串 ( 包括 \n )，但是在把该字符再写入到 str 所指向的内存空间当中前会先删除掉所获取到的该字符串结尾的 \n 字符
        -> 该函数所给定的参数 str 必须为一个字符数组以保证写入权限，如果给定的是一个字符指针形式的字符串的话，该函数则会调用失败，因为该函数会逐地址写入所录入的字符
        -> 该函数是较为安全的，至始至终都会为 str 所指向的空间保留最后一位的字节内容以录入 '\0'，如果超出，则截断最后一位所采集到的数据以保证在录入 '\0' 字符时候，str 所指向的内存空间的足够

    -> cin.ignore(int size)
        -> 删除掉 stdin 缓冲区内前 size 个字节的数据，如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的调用等待用户输入，当输入了 \n 后则意为本次输入的结束

    -> cin.peek()
        -> 查看 stdin 缓冲区内前1个字节的数据（仅查看，不删除），如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的调用等待用户输入，当输入了 \n 后则意为本次输入的结束

    -> cin.putback(char _ch)
        -> 把上一次从 stdin 中获取到的一个字符再放回 stdin 缓冲区对应该字符的原位置中，需要注意的是，我们不应该把该函数的使用当成是往 stdin 缓冲区内的首部插入一个字符的数据，不正当的使用会造成 stdin 缓冲区数据的清空

    -> cin >> expression
        -> 从文件指针 stdin 所指向的文件的缓冲区内获取数据（如果 stdin 缓冲区内并没有有效数据的存储，则阻塞程序的执行并等待用户终端 input 设备把数据去输入到 stdin 缓冲区，并以 \n 字符作为本次输入的结束），以 \n 或者 \0 作为此次从 stdin 缓冲区中取出数据的结束标识符，并把所读取到的数据写入到 expression 所指向的内存空间当中
        -> 我们要保证 expression 的类型和本次从 stdin 中所获取到的数据的类型是一致的，否则 stdin 缓冲区会出现错误，比如说，expression 所指定的类型为 int 类型，但是 stdin 缓冲区所留有的类型却是一个字符类型，这时候 stdin 缓冲区就会出现错误，那么当我们下一次再去 stdin 缓冲区中获取数据时，就永远都无法获取到真实的、本应该存在在 stdin 缓冲区中的数据，针对这种情况，我们可以使用 cin.clear() 和 cin.sync() 去重置一次缓冲区中的数据以解决这个问题

    -> cin.fail()
        -> 根据 stdin 缓冲区中的错误标识来判断 stdin 缓冲区中是否发生了错误，如果该标识是一个发生错误的状态，则该函数返回的结果则为 1，否则为 0，当然，我们可以手动的调用 cin.sync() 函数来重置这个标识

    -> cin.clear()
        -> 清空 stdin 缓冲区中的数据
    
    -> cin.sync()
        -> 重置/复原 stdin 缓冲区错误的标识，简而言之，如果 cin.fail() 调用时获取到的结果为 1，那么在调用完这个函数后再去调用 cin.fail() 则获取到的结果则为 0







-> 结构体的扩展
    -> 提供了函数的支持 ( 在结构体中所声明的函数不在当前结构体所对应存储的内存段当中，即不会纳入内存对齐的考量范围 )
        -> 构造函数 拷贝构造函数 移动构造函数 析构函数的支持
        -> 我们对于结构体中的函数成员可以声明为定义亦或者一个链接符号形式的声明，但是不能同时存在同一个函数的声明和定义在同一个结构体当中
               当我们为结构体中的成员函数声明为链接符号形式的声明的时候，我们必须要保证在 全局作用域 下能够为该符号链接声明一个具体的定义，否则在当前结构体中，关乎到该声明的使用将都会使编译不通过

    -> this 指针的支持

    -> 友元成员的支持

    -> 运算符重载函数的支持

    -> 静态成员的支持，和类中的概念一样

    -> 结构体中的成员提供了访问修饰符的支持，并且默认情况下的访问修饰符为：public

    -> 在构造一个结构体类型的时候，我们为这个结构体所构造的普通成员变量是允许在声明的同时存在其定义的，而对于结构体中的函数，我们同样也可以存在声明和定义，需要注意的是，我们对于一个结构体中的成员函数进行声明的时候，那么我们还需要在外部通过 :: 引用作用域的手段来把当前在结构体中所定义的函数声明链接为具体的一个定义

    -> 在 cpp 中是允许空结构体的存在的，对于一个没有任何声明的结构体来说，其实例还是会在内存中占用 1 bytes 的空间大小，原因是因为 cpp 需要保证每一个类的实例在内存中都会是独一无二的存在




CPP对C的一些扩展
    -> 三元运算符 CPP 所返回的结果是变量，而 C 中所返回的是这个变量所存储的值，这就造就了一个特性，CPP可以对特定的三元运算符 ( 引用变量的三元运算符 ) 所返回的结果进行赋值操作

    -> bool 类型的支持

    -> 类型转换检测增强，对于类型转换必须严格执行

    -> 函数书写性检测
    
    -> CPP 下所声明在全局作用域下的成员 ( 全局变量 ) 默认情况下都是内部链接属性 ?????????????好像不是????????????????





STL
    -> 容器
        -> pair


            -> pair 的使用

             
        -> set/multiset
            -> set 是 STL 所提供的一种支持任意类型的存储性功能的容器，其内部采用 红黑树 作为实现，其拥有一个十分重要的特性即是，set 内部维护的树所新增的节点，由于二叉树的平衡性，它都会依据该节点的 键值 进行自动的排序（默认是正序排序，也可认为的指定排序的规则），这里需要扩充一下的是，set 中的节点内部所存有的数据既可作为 键 也可以作为 值，二者放在 set 中的节点元素而言并不是分开的一种概念，并且对于 set 来说，它不允许出现重复的键值，对于用户重复插入的键值，set 会保证此次的插入操作是一个无效操作，简而言之就是插入失败
            -> set 内部所维护的这颗 红黑树 和其它容器一样，都是存储在堆中的，并且由容器本身去负责管理这棵树在堆中所使用内存的申请和释放
            -> set 由于使用的是 红黑树 作为存储模型，故使用 set 去针对节点的键值进行搜索时，是非常快的，但是相应的，为了保证 set 内部所维护的这颗 红黑树 的 二叉平衡性，set 并不提供针对节点的键值进行修改的操作，具体体现则为其对外仅提供了 只读性质的迭代器，要作为补充的是，set 所提供的并不是一种提供随机访问性的迭代器，其只能够完成单步自增/自减的操作，那么我们不妨在总结一下，set 所提供的迭代器是一种 只读单步自增/减 的迭代器
            -> 由于一个棵本身也可以作为一张链表来看待，故 set 容器与 list 容器存在相同的一点是，当对容器中的节点进行插入操作或者删除操作的时候，所操作的元素永远都是存在针对性的，即这些新增和删除的操作并不会引起整棵树的内存置换
            -> 相对 set 而言还有另一种容器跟它相呼应，那就是 multiset，作为 multiset 而言，它和 set 所存在的唯一的区别就是 multiset 允许节点的键值重复，其余相较于 set 不管是功能性而言还是内置结构都是一模一样的

            -> set 初始化构造
                -> set 可以指定两种虚拟类型，其中 
                    -> T 则为节点键值的具体类型
                    -> F 则为指定 set 的排序规则的二元仿函数类型，其默认值为一个提供了 正序排序 的功能的二元仿函数 [less<K>]，如有需要，我们可以显示的指定它
                -> 
                -> set<T,F = less<T>>()                       默认构造，构建一个空的 set 容器
                -> set<T,F = less<T>>((V _begin, V _end)      该构造函数是一个存在虚拟类型为 V 的模板函数，V 的具体化用于接收能够指示一段线性数组 [begin, end) 开闭区间的迭代器(隶属于容器的)亦或者地址，并使用它来完成当前 set 容器内部所维护的红黑树的初始化工作)
                -> set(const set &__s)                        拷贝构造函数，将已有 set 容器实例内部所维护的红黑树的节点拷贝至当前 set 容器实例内部所维护的红黑树当中

                template<class _Ty>
                struct __DESC {
                  constexpr bool operator()(const _Ty &left, const _Ty &right) {
                    return left > right;
                  }
                };

                void fun_constructor(void) {
                  /* set<T,F = less<T>>() */
                  set<int> __s_nor;

                  /* set<T,F = less<T>>((V _begin, V _end) */
                  int nums[5] = { 3, 1, 5, 2, 4 };
                  set<int, __DESC<int>> __s(nums, nums + sizeof(nums) / sizeof(int));

                  /* set(const set &__s) */
                  set<int, __DESC<int>> __s_des(__s);
                }

            -> set 的重新赋值
                -> set &operator=(const set &__s)     拷贝赋值运算符，依据已有 set 的实例内部所维护的红黑书的节点去重新构造当前 set 容器实例本身内部所维护的红黑树
                -> void swap(set &__s)                交换目标 set 容器与当前 set 容器内部指向着存在于堆中的红黑树的指针，并重新更新双方容器内部所维护的红黑树的 size

                int nums_01[5] = { 3, 1, 5, 2, 4 };
                set<int> __s_01(nums_01, nums_01 + sizeof(nums_01) / sizeof(int));

                int nums_02[5] = { 9, 6, 10, 8, 7 };
                set<int> __s_02(nums_02, nums_02 + sizeof(nums_02) / sizeof(int));

                /* void swap(set &__s) */
                __s_01.swap(__s_02);

                /* set &operator=(const set &__s) */
                __s_01 = __s_02;

            -> set 的大小操作
                -> size_t size()                    返回 set 容器内部所维护的红黑树的节点个数
                -> bool empty()                     判断是否是一个空容器（无任何节点的链接）

                int nums[5] = { 3, 1, 5, 2, 4 };
                set<int> __s(nums, nums + sizeof(nums) / sizeof(int));

                /* size_t size() */
                int cout = __s.size();

                /* bool empty() */
                bool flag = __s.empty();

            -> 插入
                -> pair<set<T>::iterator, bool> insert(T _key)    向 set 容器内部所维护的红黑树中新增一个节点，并赋予该节点的键值为 _key，最后返回能够标识当前所插入的节点在整个数中的位置的迭代器和是否插入成功所结合而成的 pair

                int nums[5] = { 3, 1, 5, 2, 4 };
                set<int> __s(nums, nums + sizeof(nums) / sizeof(int));

                /* pair<set<T>::iterator, bool> insert(T _key) */
                pair<set<int>::iterator, bool> result = __s.insert(0x400);

            -> 删除
                -> void clear()                                                                             删除 set 容器内部所维护的红黑树的所有的节点
                -> set<T>::const_iterator erase(set<T>::const_iterator start, set<T>::const_iterator end)   set 容器内部所维护的红黑树中删除迭代器 start 和 迭代器 end 所指向的下标之间的所有的节点，最后返回只想当前所操作元素的下一个元素的迭代器
                -> set<T>::const_iterator erase(set<T>::const_iterator pos)                                 set 容器内部所维护的双向循环链表中删除迭代器 pos 所指向的节点，最后返回只想当前所操作元素的下一个元素的迭代器
                -> void erase(T _key)                                                                       set 容器内部所维护的红黑树中删除对应键值 _key 的节点

                int nums[5] = { 3, 1, 5, 2, 4 };
                set<int> __s(nums, nums + sizeof(nums) / sizeof(int));

                /* void erase(set<T>::const_iterator pos) */
                __s.erase(__s.begin(), ++__s.begin());

                /* void erase(set<T>::const_iterator start, set<T>::const_iterator end) */
                __s.erase(__s.begin());

                /* void erase(T _key) */
                __s.erase(5);

                /* void clear() */
                __s.clear();

            -> 查找
                -> set<T>::const_iterator find(T _key)                                              在 set 内部所维护的红黑树中查找相符合键值 _key 的结点并返回第一次找到该结点所在下标的迭代器，若不存在匹配键值 _key 的节点，则返回指向最后一个元素的后一个位置的迭代器，即 set<int>.end() 的调用结果
                -> size_t count(T _key)                                                             在 set 内部所维护的红黑树中查找相符合键值 _key 的结点的个数
                -> set<T>::const_iterator lower_bound(T _key)                                       在 set 内部所维护的红黑树中查找相符合 目标节点键值 >= _key 的结点并返回该结点所在下标的迭代器，若不存在，则返回指向最后一个元素的后一个位置的迭代器，即 set<int>.end() 的调用结果
                -> set<T>::const_iterator upper_bound(T _key)                                       在 set 内部所维护的红黑树中查找相符合 目标节点键值 > _key 的结点并返回该结点所在下标的迭代器，若不存在，则返回指向最后一个元素的后一个位置的迭代器，即 set<int>.end() 的调用结果
                -> pair<set<int>::const_iterator, set<int>::const_iterator> equal_range(T _key)     依据指定的键值 _key 返回 lower_bound 和 upper_bound 调用所获取到的 迭代器 的组合值 pair，其中 first 为 lower_bound 调用结果所获取到的迭代器，second 为 upper_bound 调用结果所获取到的迭代器

                int nums[5] = { 3, 1, 5, 2, 4 };
                set<int> __s(nums, nums + sizeof(nums) / sizeof(int));
                
                /* set<T>::const_iterator find(T _key) */
                set<int>::const_iterator it_find = __s.find(2);
                
                /* size_t count(T _key) */
                size_t count = __s.count(3);
                
                /* set<T>::const_iterator lower_bound(T _key) */
                set<int>::const_iterator it_lower = __s.lower_bound(3);
                
                /* set<T>::const_iterator upper_bound(T _key) */
                set<int>::const_iterator it_uppler = __s.upper_bound(3);
                
                /* pair<set<int>::const_iterator, set<int>::const_iterator> equal_range(T _key) */
                pair<set<int>::const_iterator, set<int>::const_iterator> _res = __s.equal_range(3);

        -> map
            -> map 是 STL 所提供的一种以键值对形式而存在的存储性功能的容器，和 set 一样，其内置的数据模型也是根据 红黑树 来进行实现的；虽然 map 和 set 的内置的数据模型的实现使用的都是红黑树，但是存在较大不同的是，对于 map 来说是能够细分出来当前节点的 键 和 值，具体来说，每一个节点其实都是一个 pair<const K,V> 类型，以 K 作为该节点的键(第一元素)，以 V 作为该节点的实值(第二元素)，并且我们每次为 map 内部所维护的树新增的节点，map 都会遵循二叉树的平衡性，根据该节点的 键（K） 进行自动的排序（默认是正序排序，也可认为的指定排序的规则），这里需要强调的是，在 map 中的这颗 红黑树 其搜索依据是根据每个元素中独立出 值 的 键 所进行的，也就是说我们针对 map 节点中的 键 进行搜索操作时，其速度是相当的快的，并且 map 为了保证这个红黑树的平衡性，每个节点 pair<const K,V> 中作为 键 而存在的模板虚拟类型 k 都使用了 const 修饰符进行修饰，以保证我们无法修改每个节点中的 键，但是对于值而言，我们是可以进行任意修改的，因为它并不作为这颗二叉树的排序依据而存在
            -> map 中每个节点是不允许出现重复的 键 的，对于用户重复插入相同的 键，map 会保证此次的插入操作是一个无效操作(对于数组式的插入操作，如果树中已存在相同的 键，则会更新当前 键 所对应的值)，简而言之就是插入失败
            -> map 内部所维护的这颗 红黑树 和其它容器一样，都是存储在堆中的，并且由容器本身去负责管理这棵树在堆中所使用内存的申请和释放
            -> 和 set 存在区别的是，map 所提供迭代器并不是一种存粹的只读访问迭代器，map 对于其 键 的只读体现仅在于每个节点的 键 类型使用了 const 关键字进行了修饰（pair<const K,V>），并且它也不是一种提供随机访问性的迭代器，其只能够完成单步自增/自减的操作
            -> 由于一个棵本身也可以作为一张链表来看待，故 map 容器与 list 容器存在相同的一点是，当对容器中的节点进行插入操作或者删除操作的时候，所操作的元素永远都是存在针对性的，即这些新增和删除的操作并不会引起整棵树的内存置换
            -> 相对 map 而言还有另一种容器跟它相呼应，那就是 multimap，作为 multimap 而言，它和 map 所存在的唯一的区别就是 multimap 允许节点的键值重复，其余相较于 map 不管是功能性而言还是内置结构都是一模一样的

            -> map 初始化构造
                -> map 可以指定三种虚拟类型，其中
                    -> K 则为节点的 键 的具体类型
                    -> V 则为节点的 值 的具体类型
                    -> F 则为指定 map 的排序规则的二元仿函数类型，其默认值为一个提供了 正序排序 的功能的二元仿函数 [less<K>]，如有需要，我们可以显示的指定它
                -> map<K, V, F = less<K>>()                   默认构造，构建一个空的 map 容器
                -> map(const set &__m)                        拷贝构造函数，将已有 map 容器实例内部所维护的红黑树的节点拷贝至当前 map 容器实例内部所维护的红黑树当中

                template<class _Ty>
                struct __DESC {
                  constexpr bool operator()(const _Ty &left, const _Ty &right) {
                    return left > right;
                  }
                };

                void fun_constructor(void) {
                  /* map<K, V, F = less<K>>() */
                  map<string, int, __DESC<string>> __m_nor;

                  /* set(const set &__s) */
                  map<string, int, __DESC<string>> __m_des(__m_nor);
                }

            -> map 的重新赋值
                -> map &operator=(const map &__m)     拷贝赋值运算符，依据已有 map 的实例内部所维护的红黑书的节点去重新构造当前 map 容器实例本身内部所维护的红黑树
                -> void swap(map &__m)                交换目标 map 容器与当前 map 容器内部指向着存在于堆中的红黑树的指针，并重新更新双方容器内部所维护的红黑树的 size

                map<string, int> __m_src;
                __m_src["C"] = 3;
                __m_src.insert(make_pair("A", 1));
                __m_src.insert(map<string, int>::value_type("B", 2));

                map<string, int> __m_des;

                /* void swap(set &__s) */
                __m_src.swap(__m_des);

                /* set &operator=(const set &__s) */
                __m_src = __m_des;

            -> map 的大小操作
                -> size_t size()                    返回 map 容器内部所维护的红黑树的节点个数
                -> bool empty()                     判断是否是一个空容器（无任何节点的链接）

                map<string, int> __m;
                
                /* size_t size() */
                int cout = __m.size();
                
                /* bool empty() */
                bool flag = __m.empty();
                
            -> 插入
                -> pair<map<K,V>::iterator, bool> insert(pair<const K,V> __p)    向 map 容器内部所维护的红黑树中新增一个节点，并赋予该节点的键为对组 __p 的第一元素，该节点的值为对组 __p 的第二元素，最后返回能够标识当前所插入的节点在整个数中的位置的迭代器和是否插入成功所结合而成的对组
                -> V &operator[](const K &_key)                                  向 map 容器内部所维护的红黑树中依据所指定的 键 _key 搜索是否存在该节点，如不存在，则依据 map 所指定的 值 的类型并调用其默认构造去创建一个默认的 值 并与键 _key 进行绑定，然后往树种新增一个节点，最后返回该 值 的引用

                map<string, int> __m;

                /* pair<map<K,V>::iterator, bool> insert(pair<const K,V> __p) */
                pair<map<string, int>::iterator, bool> result_01 = __m.insert(pair<string, int>("C", 3));
                pair<map<string, int>::iterator, bool> result_02 = __m.insert(make_pair("A", 1));
                pair<map<string, int>::iterator, bool> result_03 = __m.insert(map<string, int>::value_type("D", 4));

                /* V &operator[](const K &_key) */
                __m["B"] = 2;

            -> 删除
                -> void clear()                                                                 删除 map 容器内部所维护的红黑树的所有的节点
                -> map<K,V>::iterator erase(map<K,V>::iterator start, map<K,V>::iterator end)   map 容器内部所维护的红黑树中删除迭代器 start 和 迭代器 end 所指向的下标之间的所有的节点，最后返回指向当前所操作元素的下一个元素的迭代器
                -> map<K,V>::iterator erase(map<K,V>::iterator pos)                             map 容器内部所维护的红黑树中删除迭代器 pos 所指向的节点，最后返回指向当前所操作元素的下一个元素的迭代器
                -> void erase(K _key)                                                           map 容器内部所维护的红黑树中删除对应键 _key 的节点

                map<string, int> __m;
                __m["C"] = 3;
                __m["A"] = 1;
                __m["D"] = 4;
                __m["B"] = 2;

                /* map<K,V>::iterator erase(map<K,V>::iterator pos) */
                __m.erase(__m.begin(), ++(++__m.begin()));

                /* map<K,V>::iterator erase(map<K,V>::iterator start, map<K,V>::iterator end) */
                __m.erase(__m.begin());

                /* void erase(K _key) */
                __m.erase("C");

                /* void clear() */
                __m.clear();

            -> 查找
                -> map<K,V>::iterator find(K _key)                                              在 map 内部所维护的红黑树中查找相符合键值 _key 的结点并返回第一次找到该结点所在下标的迭代器，若不存在匹配键值 _key 的节点，则返回指向最后一个元素的后一个位置的迭代器，即 map<K,V>.end() 的调用结果
                -> size_t count(K _key)                                                         在 map 内部所维护的红黑树中查找相符合键值 _key 的结点的个数
                -> map<K,V>::iterator lower_bound(K _key)                                       在 map 内部所维护的红黑树中查找相符合 目标节点键 >= _key 的结点并返回该结点所在下标的迭代器，若不存在，则返回指向最后一个元素的后一个位置的迭代器，即 map<K,V>.end() 的调用结果
                -> map<K,V>::iterator upper_bound(K _key)                                       在 map 内部所维护的红黑树中查找相符合 目标节点键 > _key 的结点并返回该结点所在下标的迭代器，若不存在，则返回指向最后一个元素的后一个位置的迭代器，即 map<K,V>.end() 的调用结果
                -> pair<map<K,V>::iterator, map<K,V>::iterator> equal_range(K _key)             依据指定的键值 _key 返回 lower_bound 和 upper_bound 调用所获取到的迭代器对组 pair，其中 first 为 lower_bound 调用结果所获取到的迭代器，second 为 upper_bound 调用结果所获取到的迭代器

                map<string, int> __m;
                __m["C"] = 3;
                __m["A"] = 1;
                __m["D"] = 4;
                __m["B"] = 2;
                
                /* map<K,V>::iterator find(K _key) */
                map<string, int>::iterator it_find = __m.find("B");
                
                /* size_t count(K _key) */
                size_t count = __m.count("A");
                
                /* map<K,V>::iterator lower_bound(K _key) */
                map<string, int>::iterator it_lower = __m.lower_bound("C");
                
                /* map<K,V>::iterator upper_bound(T _key) */
                map<string, int>::iterator it_uppler = __m.upper_bound("C");
                
                /* pair<map<K,V>::iterator, map<K,V>::iterator> equal_range(K _key) */
                pair<map<string, int>::iterator, map<string, int>::iterator> _res = __m.equal_range("C");

    -> 仿函数
        -> 重载了函数调用操作符 的类的使用其行为类似于一个函数调用，针对此特性我们通常也称这种类为：函数对象、仿函数，并且，根据函数调用操作符所重载的函数所录入的形参数量去划分该仿函数的元级，即该仿函数是一个几元仿函数，对于大多数情况而言，我们更多使用的是 一元仿函数（unary functor）和 二元仿函数（binary functor）
        -> 仿函数的定义通常有一条并不成文的规定，我们在定义仿函数的时候通常是不需要去定义该类的构造和析构
        -> 仿函数更多的和 STL 绑定起来使用，在 STL 中，通过仿函数可以非常方便的去为 某一种容器亦或者某算法 去提供我们所自定义的操作逻辑
        -> 由于仿函数的真正核心是属于一个类中的成员函数，故对于仿函数的使用其实都能够享有 内联函数 所带来的好处的，对比一般的函数调用而言可能在某些情况下仿函数会更显示出性能优势，除此之外，使用仿函数能够把一个函数的调用也进行抽象化，即增强了代码的 oop 性和通用性，并且也是因为 类 的本身，仿函数是可以拥有属于自己的状态的，如有需要的话

        -> 谓词
            -> 如果仿函数其内部 函数调用操作符所重载的函数 的返回值为 bool 类型，那么我们也可以称这个仿函数为：谓词，并且根据仿函数的具体元数来划分这个谓词是几元谓词

        -> 内建仿函数
            -> STL 为了保证统一性，其内建了一些仿函数，它们大致划分为：算数类函数对象、关系运算类函数对象、逻辑运算类仿函数，这些由 STL 内建的仿函数都划分在 functional 这个头文件当中

            6个算数类函数对象,除了negate是一元仿函数，其他都是二元仿函数
            template<class T> T plus<T>             加法仿函数
            template<class T> T minus<T>            减法仿函数
            template<class T> T multiplies<T>       乘法仿函数
            template<class T> T divides<T>          除法仿函数
            template<class T> T modulus<T>          取模仿函数
            template<class T> T negate<T>           取反仿函数

            6个关系运算类函数对象,每一种都是二元仿函数
            template<class T> bool equal_to<T>      等于
            template<class T> bool not_equal_to<T>  不等于
            template<class T> bool greater<T>       大于
            template<class T> bool greater_equal<T> 大于等于
            template<class T> bool less<T>          小于
            template<class T> bool less_equal<T>    小于等于

            逻辑运算类运算函数,not为一元仿函数，其余为二元仿函数
            template<class T> bool logical_and<T>   逻辑与
            template<class T> bool logical_or<T>    逻辑或
            template<class T> bool logical_not<T>   逻辑非

            #include <set>
            #include <vector>
            #include <iostream>
            #include <algorithm>
            #include <functional>
            using namespace std;

            template<class T>
            class set_printer {
            public:
              void operator()(const T &_val) {
                cout << _val << endl;
              }
            };
            void foo(void) {
              set<int, greater<int>> __s;
              __s.insert(4);
              __s.insert(2);
              __s.insert(5);
              __s.insert(1);
              __s.insert(3);
              
              vector<int> __v;
              __v.push_back(3);
              __v.push_back(5);
              __v.push_back(1);
              __v.push_back(4);
              __v.push_back(2);
              sort(__v.begin(), __v.end(), less<int>());
              
              for_each(__s.begin(), __s.end(), set_printer<int>());
              for_each(__v.begin(), __v.end(), set_printer<int>());
            }

    -> 适配器
        -> 仿函数适配器
            -> binder2nd bind2nd(const _Function &__f_binary, const _Type &__val)
                -> 参数：
                    -> __f_binary：需要是一个二元仿函数(所重载的函数调用操作符的函数需要声明为 常函数，因为最终会通过一个常函数来调用仿函数)并且继承自 binary_function<T1 arg_01, T2 arg_02, R ret>
                    -> __val：需要和 __f_binary 进行绑定的值
                -> 返回值：
                    -> binder2nd：一个一元仿函数，其所实现的重载函数调用操作符的函数的返回值同步至所指定的仿函数 __f_binary，形参列表接收一个所指定的二元仿函数 __f_binary 的第一个形参的类型的形参 __val_src 的输入，并在其内部实现中又调用了我们所录入的仿函数 __f_binary，并在调用 __f_binary 时会输入两个参数，它们分别是 __val_src 和 bind2nd 构造时所录入的实参 __val
                -> 使用场景：
                    -> 在某些 API 需要指定一个一元仿函数但是现有只有二元仿函数时，可以使用 bind2nd 进行适配工作
                class print_m : public binary_function<int, int, void> {
                public:
                  void operator()(int _val_01, int _val_02) const {
                    cout << _val_01 + _val_02 << endl;
                  }
                };
                void foo_functor(void) {
                  int nums[5] = { 1, 2, 3, 4, 5 };
                  vector<int> __v(nums, nums + (sizeof(nums) / sizeof(int)));

                  for_each(__v.begin(), __v.end(), bind2nd(print_m(), 1000));
                }

        -> 取反适配器
            -> unary_negate not1(const _Function &__f_unary)
                -> 参数：
                    -> __f_unary：需要一个返回值为 bool 类型的一元仿函数并且继承自 unary_function<T1 arg, R ret>
                -> 返回值：
                    -> unary_negate：一个一元仿函数，重载的函数调用操作符的函数的返回值和形参列表同步至所指定的仿函数 __f_unary，并且其内部实现中会调用返回所录入的一元仿函数 __f_unary 的取反结果
            -> binary_negate not1(const _Function &__f_binary)
                -> 参数：
                    -> __f_binary：需要一个返回值为 bool 类型的二元仿函数并且继承自 binary_function<T1 arg_01, T2 arg_02, R ret>
                -> 返回值：
                    -> binary_negate：一个二元仿函数，重载的函数调用操作符的函数的返回值和形参列表同步至所指定的仿函数 __f_binary，并且其内部实现中会调用返回所录入的二元仿函数 __f_binary 的取反结果
            -> 使用场景：
                -> 当我们针对某种返回 bool 类型的仿函数的真实取值结果并不满意时，我们可以通过 not 适配器的适配作用在不更改原仿函数的源代码的前提下完成对其取值结果的取反工作
            void foo_NOT(void) {
              int nums[5] = { 3, 2, 4, 1, 5 };
              vector<int> __v(nums, nums + (sizeof(nums) / sizeof(int)));

              sort(__v.begin(), __v.end(), not2(less<int>()));

              vector<int>::iterator _result = find_if(__v.begin(), __v.end(), not1(bind2nd(greater<int>(), 2)));
              cout << *_result << endl;
            }

        -> 函数适配器
            -> pointer_to_unary_function ptr_fun(unary_function invoker)
                -> 参数：
                    -> unary_function：接收一个返回值为任意类型，但是只有一个任意类型形参的函数指针
                -> 返回值：
                    -> pointer_to_unary_function：一个 一元仿函数，所重载的函数调用操作符的函数是一个形参列表和返回值类型同步至函数指针并且声明为 cost 的常函数，其内部实现中会调用函数指针 invoker
            -> pointer_to_unary_function ptr_fun(unary_function invoker)
                -> 参数：
                    -> binary_function：接收一个返回值为任意类型，但是有两个任意类型形参的函数指针
                -> 返回值：
                    -> pointer_to_binary_function：一个 二元仿函数，所重载的函数调用操作符的函数是一个形参列表和返回值类型同步至函数指针并且声明为 cost 的常函数，其内部实现中会调用函数指针 invoker
            -> 使用场景：
                -> 将一个普通的函数转换为 所重载的函数调用操作符的函数声明为 const 的仿函数

        -> 成员函数适配器
            -> mem_fun_ref_t mem_fun_ref(member_function_none invoker)
                -> 参数：
                    -> member_function_none：接受一个任意类型返回值但是无形参的某个类的 [成员函数]
                -> 返回值：
                    -> mem_fun_ref_t：一个 一元仿函数，所重载的函数调用操作符的函数的返回值同步至成员函数 invoker，形参列表接收一个 成员函数 所在类的类型的形参 _src，所指定的成员函数 invoker 依赖形参 _src 的实例化完成其调用操作
            -> mem_fun1_ref_t mem_fun_ref(member_function_unary invoker)
                -> 参数：
                    -> member_function_unary：接受一个任意类型返回值但是只有一个形参的某个类的 [成员函数]
                -> 返回值：
                    -> mem_fun1_ref_t：一个 二元仿函数，所重载的函数调用操作符的函数的返回值同步至成员函数 invoker，形参列表接收 成员函数 所在类的类型的形参 _src 和 成员函数 第一个形参的类型的形参 _arg，所指定的成员函数 invoker 依赖形参 _src 的实例化并在调用时录入形参 _arg 完成其调用操作

            -> 使用场景：
                -> 该适配器能够将一个成员函数一种仿函数以供调用，其内部实现依赖于成员函数和函数指针之间的转换关系来完成，简而言之该函数的调用还是要依赖于成员函数所在类型实例的本身才能够完成调用
            class Person {
            public:
              Person(int _age)
                : m_age(_age){};
            public:
              void speak(string _words) {
                cout << _words << " age = " << this->m_age << endl;
              }
              void Do() {
                cout << "DO! AGE = " << this->m_age << endl;
              }
            
            public:
              int m_age;
            };
            void foo_member_function(void) {
              vector<Person> __v;
              __v.push_back(Person(1));
              __v.push_back(Person(2));
              __v.push_back(Person(3));
              __v.push_back(Person(4));
              __v.push_back(Person(5));
            
              for_each(__v.begin(), __v.end(), bind2nd(mem_fun_ref(Person::speak), "HELLO,WORLD"));
            
              for_each(__v.begin(), __v.end(), mem_fun_ref(Person::Do));
            }


    -> 算法
        -> STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成

        -> 遍历算法
            -> _Function for_each(_InputIterator start, _InputIterator end, _Function _fn)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至所指定的 一元仿函数或者函数指针 当中，最后会返回所指定的 一元仿函数或者函数指针
                void printer_for_each(const int &_val) {
                  cout << _val << endl;
                }
                void foo_for_each(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 10; ++i) {
                    __v.push_back(i + 1);
                  }

                  void (*invoker)(const int &) = for_each(__v.begin(), __v.end(), printer_for_each);
                }
            -> void transform(_InputIterator start, _InputIterator end, _OutputIterator start_des, _UnaryOperation unary_op)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至所指定的 返回值和形参类型为容器中的元素类型的一元仿函数或者函数指针 unary_op 当中，并依照它的返回结果 [重新赋值] 给迭代器 start_des 所指向的目标容器中
                -> 该函数的调用必须要保证目标迭代器 __result 所指向的容器中是含有 [有效元素] 的，否则会调用失败
                int f_transform(int &_val) {
                  return _val + 1;
                }
                void foo_transform(void) {
                  vector<int> __v_src;
                  for (size_t i = 0; i < 10; ++i) {
                    __v_src.push_back(i + 1);
                  }

                  vector<int> __v_des;
                  __v_des.resize(__v_src.size());
                  transform(__v_src.begin(), __v_src.end(), __v_des.begin(), f_transform);
                }
        
        -> 查找算法
            -> iterator_pos find(iterator start, iterator end, T _val)
                -> 在容器指定范围(迭代器 start 和 end 划分的范围)内的元素中查找值为 _val 的元素并返回第一次找到该元素所在下标的 [目标容器类型的迭代器]，若不存在，则返回指向最后一个元素的后一个位置的迭代器
                void foo_find(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 10; ++i) {
                    __v.push_back(i);
                  }

                  vector<int>::iterator _pos = find(__v.begin(), __v.end(), 4);
                  if (_pos != __v.end()) cout << *_pos << endl;
                }
            -> iterator_pos find_if(iterator start, iterator end, _Function _fn)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至所指定的 返回值为 bool 类型的一元仿函数或者函数指针 _fn 当中，当 _fn 所返回的结果为 true 时，则该函数返回当前元素所在下标的 [目标容器类型的迭代器]，若不存在，则返回指向最后一个元素的后一个位置的迭代器
                void foo_find_if(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 10; ++i) {
                    __v.push_back(i);
                  }

                  vector<int>::iterator _result = find_if(__v.begin(), __v.end(), [](int &_val) { return _val > 3; });
                  if (_result != __v.end()) cout << *_result << endl;
                }
            -> iterator_pos adjacent_find(iterator start, iterator end)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，并寻找间隔相邻的并且值重复的元素，如果存在，则返回所重复元素的上一个元素所在下标的 [目标容器类型的迭代器]，若不存在，则返回指向最后一个元素的后一个位置的迭代器
                void foo_adjacent_find(void) {
                  vector<int> __v;
                  __v.push_back(1);
                  __v.push_back(2);
                  __v.push_back(3);
                  __v.push_back(3);
                  __v.push_back(4);

                  vector<int>::iterator _result = adjacent_find(__v.begin(), __v.end());
                  if (_result != __v.end()) cout << *_result << endl;
                }
            -> bool binary_search(iterator start, iterator end, const T &_val)
                -> 使用二分查找法查找容器指定范围(迭代器 start 和 end 划分的范围)内的元素，并判断是否存在值为 _val 的元素，如果存在则返回 true，如果不存在则返回false
                -> 由于该算法使用的是二分查找法，为了该算法的运行不会失效，我们需要保证指定的容器内部所存储的元素是一个 有序序列
                void foo_binary_search(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 10; ++i) {
                    __v.push_back(i);
                  }

                  bool _result = binary_search(__v.begin(), __v.end(), 3);
                  cout << _result << endl;
                }
            -> int binary_search(iterator start, iterator end, const T &_val)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，并统计值为 _val 的元素所出现的次数并返回
                void foo_count(void) {
                  vector<int> __v;
                  __v.push_back(1);
                  __v.push_back(2);
                  __v.push_back(3);
                  __v.push_back(3);
                  __v.push_back(4);

                  int _count = count(__v.begin(), __v.end(), 3);
                }
            -> int count_if(iterator start, iterator end, _Function _fn)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至所指定的 返回值为 bool 类型的一元仿函数或者函数指针 _fn 当中，并统计 _fn 返回值为 true 的次数，最后返回所统计的结果
                void foo_count_if(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 10; ++i) {
                    __v.push_back(i);
                  }

                  int _count = count_if(__v.begin(), __v.end(), [](int &_val) { 
                    return _val > 5; 
                  });
                  cout << _count << endl;
                }

        -> 排序算法
            -> void sort(iterator start, iterator end, _Function _fn)
                -> 对容器内指定范围(迭代器 start 和 end 划分的范围)内的元素依照返回值为 bool 类型，形参类型为容器中的元素的值的类型的二元仿函数或函数指针 去进行排序
                void foo_sort(void) {
                  vector<int> __v;
                  __v.push_back(4);
                  __v.push_back(1);
                  __v.push_back(5);
                  __v.push_back(2);
                  __v.push_back(3);

                  sort(__v.begin(), __v.end(), [](int &_left, int &_right) { return _left > _right; });
                }
            -> void random_shuffle(iterator start, iterator end)
                -> 随机置乱容器指定范围(迭代器 start 和 end 划分的范围)内的元素的原始次序
                void foo_random_shuffle(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 5; ++i) {
                    __v.push_back(i);
                  }

                  random_shuffle(__v.begin(), __v.end());

                  for_each(__v.begin(), __v.end(), [](int &_val) { cout << _val << endl; });
                }
            -> void reverse(iterator start, iterator end)
                -> 反转容器中指定范围(迭代器 start 和 end 划分的范围)内的元素的次序
                void foo_reverse(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 5; ++i) {
                    __v.push_back(i);
                  }

                  reverse(__v.begin(), __v.end());
                }

        -> 拷贝/替换/合并
            -> void merge(iterator src_start_1, iterator src_end_1, iterator src_start_2, iterator src_end_2, iterator des_start)
                -> 合并指定范围内(两个容器的开始和起始迭代器 src_start_1、src_end_1、src_start_2、src_end_2) 的两个容器的元素，并重新赋值给目标容器(迭代器 des_start 所指向的容器)当中
                -> 我尽量要保证原始合并的两个数据源是有序序列，否则合并后的结果将可能会出现相较之前的乱序
                -> 目标容器在合并前要保证其内部元素中是含有 [有效元素] 的，否则会调用失败
                void foo_merge(void) {
                  vector<int> __v_src_1;
                  __v_src_1.push_back(1);
                  __v_src_1.push_back(2);
                  __v_src_1.push_back(3);
                  __v_src_1.push_back(4);
                  __v_src_1.push_back(5);

                  vector<int> __v_src_2;
                  __v_src_2.push_back(6);
                  __v_src_2.push_back(7);

                  vector<int> __v_des;
                  __v_des.resize(__v_src_1.size() + __v_src_2.size());
                  merge(__v_src_1.begin(), __v_src_1.end(), __v_src_2.begin(), __v_src_2.end(), __v_des.begin());
                }
            -> void copy(iterator src_start, iterator src_end, iterator des_start)
                -> 拷贝原始容器中指定范围(迭代器 start 和 end 划分的范围)内的元素并重新赋值给目标容器(迭代器 des_start 所指向的容器)当中
                -> 目标容器在拷贝前要保证其内部元素中是含有 [有效元素] 的，否则会调用失败
                void foo_copy(void) {
                  vector<int> __v_src;
                  for (size_t i = 0; i < 5; ++i) {
                    __v_src.push_back(i);
                  }
                
                  vector<int> __v_des;
                  for (size_t i = 5; i < 10; ++i) {
                    __v_des.push_back(i);
                  }
                  copy(__v_src.begin(), __v_src.end(), __v_des.begin());
                
                  copy(__v_des.begin(), __v_des.end(), ostream_iterator<int>(cout, " "));
                }
            -> void replace(iterator start, iterator end, const T &_old_val, const T &_new_val)
                -> 查找容器中指定范围(迭代器 start 和 end 划分的范围)内值为 _old_val 的元素，并修改其值为 _new_val
                void foo_replace(void) {
                  vector<int> __v;
                  __v.push_back(1);
                  __v.push_back(2);
                  __v.push_back(2);
                  __v.push_back(3);
                  __v.push_back(4);

                  replace(__v.begin(), __v.end(), 2, 0x400);
                }
            -> void replace_if(iterator start, iterator end, function _fn, const T &_new_val)
                -> 遍历容器指定范围(迭代器 start 和 end 划分的范围)内的元素，把它们作为实参逐个输入至所指定的 返回值为 bool 类型，形参类型为容器中的元素的值的类型的一元仿函数或者函数指针 _fn 当中并调用，当该 _fn 返回 true 时，则当前所操作的元素的值替换为 _new_val
                bool m_replace(int &_old_val) {
                  return _old_val > 2;
                }
                void foo_replace_if(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 5; ++i) {
                    __v.push_back(i);
                  }

                  replace_if(__v.begin(), __v.end(), m_replace, 0x400);
                }
            -> void swap(Container c_src, Container c_des)
                -> 交换两个容器(相同容器类型)的内部用于管控数据空间的指针所指向的地址
                void foo_swap(void) {
                  vector<int> __v_1;
                  for (size_t i = 0; i < 5; ++i) {
                    __v_1.push_back(i);
                  }

                  vector<int> __v_2;
                  for (size_t i = 5; i < 10; ++i) {
                    __v_2.push_back(i);
                  }

                  swap(__v_1, __v_2);
                }

        -> 算数生成
            -> T accumulate(iterator start, iterator end, const T &_init_val)       <numeric>
                -> 以 _init_val 作为初始化数据，在此基础上累加容器指定范围(迭代器 start 和 end 划分的范围)内的元素的值，最后返回累加后的结果
                void foo_accumulate(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 5; ++i) {
                    __v.push_back(i);
                  }

                  int num = accumulate(__v.begin(), __v.end(), 100);
                  cout << num << endl;
                }
            -> void fill(iterator start, iterator end, const T &_val)
                -> 容器指定范围(迭代器 start 和 end 划分的范围)内的元素的值替换为 _val
                void foo_fill(void) {
                  vector<int> __v;
                  for (size_t i = 0; i < 5; ++i) {
                    __v.push_back(i);
                  }

                  fill(__v.begin(), __v.begin() + 2, 0x400);
                }

        -> 集合算法
            -> iterator set_intersection(iterator src_start_1, iterator src_end_1, iterator src_start_2, iterator src_end_2, iterator des_start)
                -> 该算法提供查找并集的功能
                -> 查找指定范围内(两个容器的开始和起始迭代器 src_start_1、src_end_1、src_start_2、src_end_2) 的两个容器的元素中元素的值相同的元素，并把它重新赋值给目标容器(迭代器 des_start 所指向的容器)当中，最后会返回目标容器的 结束迭代器(end())
                -> 我尽量要保证原始的两个容器的数据源是有序序列，否则目标容器所获取到的结果将可能会出现乱序
                -> 目标容器在赋值前要保证其内部元素中是含有 [有效元素] 的，否则会调用失败
                void foo_set_intersection(void) {
                  vector<int> __v_src_1;
                  vector<int> __v_src_2;
                  for (size_t i = 0; i < 10; ++i) {
                    __v_src_1.push_back(i);
                    __v_src_2.push_back(i + 5);
                  }

                  vector<int> __v_des;
                  __v_des.resize(__v_src_1.size(), __v_src_2.size());

                  vector<int>::iterator i_end = set_intersection(__v_src_1.begin(), __v_src_1.end(), __v_src_2.begin(), __v_src_2.end(), __v_des.begin());
                }
            -> iterator set_union(iterator src_start_1, iterator src_end_1, iterator src_start_2, iterator src_end_2, iterator des_start)
                -> 该算法提供查找交集的功能
                -> 去除掉，指定范围内(两个容器的开始和起始迭代器 src_start_1、src_end_1、src_start_2、src_end_2) 的两个容器中，值重复的元素并进行合并，并把合并后的结果重新赋值给目标容器(迭代器 des_start 所指向的容器)当中，最后会返回目标容器的 结束迭代器(end())
                -> 我尽量要保证原始的两个容器的数据源是有序序列，否则目标容器所获取到的结果将可能会出现乱序
                -> 目标容器在合并前要保证其内部元素中是含有 [有效元素] 的，否则会调用失败
                void foo_set_union(void) {
                  vector<int> __v_src_1;
                  vector<int> __v_src_2;
                  for (int i = 0; i < 10; i++) {
                    __v_src_1.push_back(i);
                    __v_src_2.push_back(i + 5);
                  }

                  vector<int> __v_des;
                  __v_des.resize(__v_src_1.size() + __v_src_2.size());

                  vector<int>::iterator i_end = set_union(__v_src_1.begin(), __v_src_1.end(), __v_src_2.begin(), __v_src_2.end(), __v_des.begin());
                }
            -> iterator set_difference(iterator src_start_1, iterator src_end_1, iterator src_start_2, iterator src_end_2, iterator des_start)
                -> 该算法提供查找差集的功能
                -> 查找容器指定范围(迭代器 src_start_1 和 src_end_1 划分的范围)内 [相较于] 容器指定范围(迭代器 src_start_2 和 src_end_2 划分的范围)内，元素的值不同的元素，并把结果重新赋值给目标容器(迭代器 des_start 所指向的容器)当中，最后会返回目标容器的 结束迭代器(end())
                -> 我尽量要保证原始的两个容器的数据源是有序序列，否则目标容器所获取到的结果将可能会出现乱序
                -> 目标容器在赋值前要保证其内部元素中是含有 [有效元素] 的，否则会调用失败
                void foo_set_difference(void) {
                  vector<int> __v_src_1;
                  vector<int> __v_src_2;

                  for (int i = 0; i < 10; i++) {
                    __v_src_1.push_back(i);
                    __v_src_2.push_back(i + 5);
                  }

                  vector<int> __v_des;
                  __v_des.resize(max(__v_src_1.size(), __v_src_2.size()));

                  vector<int>::iterator i_end = set_difference(__v_src_1.begin(), __v_src_1.end(), __v_src_2.begin(), __v_src_2.end(), __v_des.begin());

                  /* vector<int>::iterator i_end = set_difference(__v_src_2.begin(), __v_src_2.end(), __v_src_1.begin(), __v_src_1.end(), __v_des.begin()); */
                }

    -> 迭代器 
        -> iterator：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式
        -> 迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题
        -> 迭代器的种类
            -> 输入迭代器	    提供对数据的只读访问	                                        只读，支持++、==、！=
               输出迭代器	    提供对数据的只写访问	                                        只写，支持++
               前向迭代器	    提供读写操作，并能向前推进迭代器	                              读写，支持++、==、！=
               双向迭代器	    提供读写操作，并能向前和向后操作	                              读写，支持++、--，
               随机访问迭代器	 提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器	 读写，支持++、--、[n]、-n、<、<=、>、>=
        -> 每一种容器的每一种不同的模板类型都由其对应着的迭代器

            