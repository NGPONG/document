# *C Programming language*

<br/>

## 目录

- [变量](#变量)
    - [变量的定义和变量的声明](#变量的定义和变量的声明)
    - [全局变量和局部变量](#全局变量和局部变量)
    - [extern 关键字](#extern)
    - [变量](#变量)
- [常量](#常量)
- [静态成员](#静态成员)
- [基础数据类型](#基础数据类型)
    - [原码 反码 补码](#原反补)
    - [整型](#整型)
    - [实型](#实型)
    - [Char](#Char)
    - [sizeof](#sizeof)
- [常量](#常量)
- [常量](#常量)


<br/>

### 变量
<span id="变量"></span>

---
#### 变量的定义和变量的声明
<span id="变量的定义和变量的声明"></span>

在 C 语言中，是需要严格区分 <kbd>变量的定义</kbd> 和 <kbd>变量的声明</kbd> 的，我们先来看下如何对一个变量进行定义或者声明

```c
int main(void){

    // Variable definitions
    int varriable_def = 10;

    // Variable declaration
    int varriable_decl;
}
```

可以看到，我们对于一个变量如果在声明的过程中指定了其具体的值，那么这个变量就会提升为 [[变量的定义]]，反之，我们只是单纯的声明了一个变量的类型和其变量名，那么这种方式就称为 [[变量的声明]]

但是，变量的定义 和 变量的声明 的区别不仅于此，最关键的部分还是对于两者的定义编译器是否为之开辟内存空间的问题

对于 [[变量的定义]] 来说，编译器会为我们所定义的变量开辟一块与之对应的内存空间进行存储，而对于 [[变量的声明]] 来说它编译器是不会为它开辟一块内存空间的

其次，在 c 语言中，一个变量成员的使用必须要存在其定义，如果不存在的话，则编译器在编译源程序的时候，编译器则会找到这个变量的声明，并将其隐式提升为定义，并根据这个变量所处的内存段赋予相应的默认值 (在 [[栈]] 上则默认为一个随机数)

<br/>

#### 全局变量和局部变量
<span id="全局变量和局部变量"></span>

局部变量: 局部变量声明在函数体内，其作用域由此变量的声明开始，直至该函数体的结束，对于普通的局部变量而言 ( 未使用 [[extern]] 关键字的局部变量 )，如果我们只是声明了一个局部变量，那编译器在编译的过程中仅会尝试在变量的定义位置开始直至当前函数体的结束符 [[}]] 之间寻找该变量的定义，如果不存在，则编译器会赋予它一个随机数

对于一般的局部变量而言，其一般存储在内存的 [[栈]] 上，也就意味着其生命周期在出了该函数体外就会结束掉

全局变量: 全局变量声明在函数体外，其作用域默认情况下由此成员的定义开始直至当前文件的结束，对于全局变量而言，如果我们只是声明了一个全局变量，那编译器在编译的过程中会先从当前全局变量的定义位置开始直至当前文件的结束中寻找该变量的定义，如果不存在，则会从其它需要链接的文件中尝试寻找该变量的定义 ( 这种情况也是间接的提升了全局变量的作用域 )，如果都不存在，则编译器会赋予它一个默认值

对于一般的全局变量而言，其存储在内存的 [[.bss]] 或 [[.rodata]] 段上，也就意味着其生命周期会延续到当前程序的结束

!!! danger 注意
    对于不同的编译器来说，这方面的实现可能会有所不同，就 [[GCC]] 而言，其符合着以上所说的这一规范，而对于 [[MSVC]] 而言，这个规范仅仅适用于全局变量，对于局部变量来说，其在使用前必须要有其定义，否则会编译错误

<br/>

#### extern 关键字
<span id="extern"></span>

该关键字能够用于扩展 [[函数/变量]] 的可见性，而使用了该关键字的成员 [[只能够用作于声明]]，具体的作用就是在编译器编译步骤至链接的过程中，会在其他文件 ( 也有可能是当前文件 ) 中寻找符合使用了当前该关键字的成员声明的定义，以至使用了该关键字的声明能够映射到找到的相应文件的成员定义当中，从而间接实现了声明的可见性

前面说到，变量在使用前必须要存在定义，如果在使用的时候并没有对该变量的定义的话，编译器则会找到其声明，并将其隐式提升为定义，并赋予其相应的默认值，而使用了该关键字的第一大特性就是，[[它会阻住编译器对于变量进行定义的隐式提升效果]]，也就是说，如果我们对某一个变量使用了该关键字进行了声明后，如果该变量在某处进行了使用，则源程序会在编译的过程中报错，因为编译器不会将其声明隐式提升为定义

该关键字如果给变量使用的话，其可以作用于局部变量和全局变量
- 局部变量
    - 局部变量使用该关键字的时候，该变量不可以用作于定义
    - 对于局部变量来说，当我们在局部变量使用了该关键字后，该局部变量的具体定义能够映射至当前函数外的任意位置，乃至其它文件中，也就是间接的提升了其作用域
- 全局变量
    - 全局变量使用该关键字的时候，该变量可以用作于定义
    - 对于全局变量来说，使用了该关键字的成员的定义和局部变量一样，其作用域同样也会有一种隐式提升的作用，其实这点就使用了 [[extern]] 关键字的全局变量和 普通的全局变量 来说是非常类似的，但是我们需要注意的是，它们两种声明方式所带来的后果其实是不同的，就 普通的全局变量 来说，其还是一种变量成员，即遵循 [[如果仅存在声明而没有定义的情况下，该声明会隐式提升成定义]] ，而对于使用了 [[extern]] 关键字的全局变量来说，[[它会阻住编译器对于变量进行定义的隐式提升效果]]，也就是说，如果一个声明为 [[extern]] 关键字的全局变量，如果再找不到其定义令他的声明隐式提升为定义的情况下，编译器编译的时候i会报错

而该关键字给函数使用的话其实无太大效果，因为我们所声明的函数或者是我们所定义的函数在编译器进行编译的过程中，都会默认的为所声明的函数加上该关键字 [[extern]]

```c
Session 1：
*******main.c
int main(void) {
    
    extern int a;

    printf("%d\n", a);

    system("pause");
    return EXIT_SUCCESS;
}

int a = 10;



Session 2:
*******main.c
int main(void) {
    
    extern int a;

    printf("%d\n", a);

    system("pause");
    return EXIT_SUCCESS;
}

*******test.c
int a = 10;



Session 3:
*******main.c
extern int a;

int main(void) {

    printf("%d\n", a);

    system("pause");
    return EXIT_SUCCESS;
}

*******test.c
int a = 10;
```

<br/>

### 常量
<span id="常量"></span>

---

C 语言中的常量是通过关键字 [[const]] 来完成，当我们定义了一个常量，就意味着我们无法通过正常途径去修改这个定义为常量的成员的值，但是我们需要记住的是，当我们把一个常量定义为 [[局部的]]，那么 [[这个常量无法修改的特性是由编译器在编译源程序的过程中所决定的]]，其实更具体点来说，这个变量还是和普通的变量一样存储在 [[栈]] 上，但是因为它使用了 [[const]] 的关键字，所以编译器在编译的时候就会检查这个关键字所定义的变量是否存在修改的情况，由于还是存储在 [[栈]] 上，这也就意味着我们是可以在程序运行时通过 [[间接修改 (指针)]] 的方式去修改这个常量的值，其实简而言之，定义为局部的常量是一种 [[伪常量]]

```c
int main(void){

    const int a = 10;
    return 0;
}
```

!!! INFO
    常量的定义，关键字 [[const]] 并不一定需要放在左值表达式的最左侧，对于 [[const]] 关键字来说，其所存放的位置可以在左值表达式的任意位置，对于普通的常量来说我们放在什么位置也好，其实都是没有区别的，而对于 [[指针类型的常量]] 来说，[[const]] 关键字所写入的位置能够决定 [[指针类型的常量]] 的一些额外特性

那么当我们把 [[const]] 的关键字使用在 [[全局变量]] 身上的时候，那么该常量就会存储在内存的 [.rodata] 段中，也就是说该常量不能被修改的特性是受到 [[系统内核级]] 的保护的，其实也就是我们不能通过指针来实现间接修改，它是真正意义上，[[长存性]] 的常量

```c
#include <stdio.h>

const int a = 10;
int main(void){

    printf("%d\n",a);
    return 0;
}
```

除此之外，常量的定义我们还能在 [[函数的参数]] 身上使用，其实对于参数身上使用，其特性也是符合 [[局部常量]] 的那种特性，但是通过这种方式我们能够达成一个 [[约定俗成]] 的概念，即 [[该参数不能够修改]] 的概念

```c
#include <stdio.h>

void fun_test(const int a){

    printf("%d\n",a);
}

int main(void){

    fun_test(10);
    return 0;
}
```

<br/>

### 静态成员
<span id="静态成员"></span>

---

静态成员使用 [[static]] 关键字来完成定义，它可以使用于 [[函数]] 和 [[变量]]，其存储在内存的 [[.data]] 段或者 [[.bss]] 段中，意味着其生命周期会延续到程序的结束

当静态成员定义为 [[全局成员]] 的时候，意味着该成员的作用域从定义位置开始，到本文件的结束，并且我们不能通过外部声明提升其作用域

```c
#include<stdio.h>

static void fun_test(void){

    printf("Hello,World!");
}

static int a = 10;

int main(void){

    return 0;
}
```

当静态成员定义为 [[局部成员]] 的时候，该成员的作用域从定义位置开始，直至当前函数体的结束，需要注意的是，由于它是静态的，所以它的生命周期会延续到程序的结束，也就是说当我们定义了一个静态的局部变量，当我们第一次操作它并改变了相应的值，那么当我们第二次访问该函数的时候，这个静态局部变量的值就是我们改编后的值

```c
#include<stdio.h>

static void fun_test(void){

    static int a = 0;
    a++;
    printf("Hello,World!");
}

int main(void){

    for (size_t i = 0; i < 5; i++) {

        fun_test();
	}

    return 0;
}
```

<br/>

### 基础数据类型
<span id="基础数据类型"></span>

---

#### 原码 反码 补码
<span id="原反补"></span>

计算机对于数值的计算都是通过 [[补码]] 来完成的，即我们一个普通的数字要经过 [[原码]] -> [[反码]] -> [[补码]] 的过程才能交由计算机去读取或者是计算

- 原码: 一个数的原始二进制数，例如 [[32]] 的原码 则为 [[0010 0010]]，并且把 [[最高位]] 作为 [[符号位]]，如果是 [[0]] 即 [[正数]]，如果是 [[1]] 即 [[负数]]

- 反码: 如果原码为正数，那么反码则不变，如果原码为负数，则除了原码的符号位以外，其余全部位全部取反即为反码

- 补码: 如果原码为正数，那么补码则不变，如果原码为负数，则为反码数 [[+1]] 即为补码


!!! INFO
    - 在 C 中，对于基本的数据类型来说是需要区分 [[有符号类型]] 和 [[无符号类型]] 的，即 [[最高位]] 是否用来充当符号位而不参与实际运算
    - 关键字 [[signed]] 所修饰的类型即为 [[有符号类型]]，而我们不使用该关键字所声明的变量的类型默认都为 [[有符号类型]]
    - 关键字 [[unsigned]] 所修饰的类型即为 [[无符号类型]]


<br/>

#### 整型
<span id="整型"></span>

有符号整型:

| Name      | Size                                                                                            | Length                                   | example              |
| --------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------- | -------------------- |
| int       | 4 Bytes                                                                                         | - 2147483648 ~ 2147483647                 | [[int a = 10]]       |
| short     | 2 Bytes                                                                                         | - 32768 ~ 32767                           | [[short a = 10]]     |
| long      | [[Windows]] 下统一为 4 Bytes，而 [[Linux]] 下，[[64位系统]] 为 8 Bytes，[[32位系统]] 为 4 Bytes       | - 2147483648 ~ 2147483647                 | [[long a = 10]]      |
| long long | 8 Bytes                                                                                         | - 9223372036854775808 ~ 9223372036854775807 | [[long long a = 10]] |

无符号整型:

| Name               | Size                                                                                            | Length                   | example                       |
| ------------------ | ----------------------------------------------------------------------------------------------- | ------------------------ | ----------------------------- |
| unsigned int       | 4 Bytes                                                                                         | 0 ~ 4294967295           | [[unsigned int a = 10]]       |
| unsigned short     | 2 Bytes                                                                                         | 0 ~ 65535                | [[unsigned short a = 10]]     |
| unsigned long      | [[Windows]] 下统一为 4 Bytes，而 [[Linux]] 下，[[64位系统]] 为 8 Bytes，[[32位系统]] 为 4 Bytes | 0 ~ 4294967295           | [[unsigned long a = 10]]      |
| unsigned long long | 8 Bytes                                                                                         | 0 ~ 18446744073709551615 | [[unsigned long long a = 10]] |

!!! info
    整型数据在内存中占的字节数与所选择的操作系统有关，虽然 C 语言标准中没有明确规定整型数据的长度，但 long 类型整数的长度不能短于 int 类型， short 类型整数的长度不能长于 int 类型

<br/>

#### 实型
<span id="实型"></span>

| Name   | Size    | Length                         | example           |
| ------ | ------- | ------------------------------ | ----------------- |
| float  | 4 Bytes | - 3.4 * 10^38 ～ 3.4 * 10^38   | [[float a = 10]]  |
| double | 8 Bytes | - 1.7 * 10^-308 ~ 1.7 * 10^308 | [[double a = 10]] |

<br/>

#### Char
<span id="Char"></span>

char 在 C 中除了能够表示一个字符以外，它还能够表示一个 [[1 Bytes]] 大小的整型数据，因为每个 char 类型本身就是一个 [[ASCII]] 字符，即每个字符都有一个在 [[1 Bytes]] 大小一类的数字

除了使用 char 来表示一个字符以外，我们还通常用它来 [[解析内存地址结构]]，原因是因为 char 类型本身只是占 [[1 Bytes]]，即计算机中的基本内存单元，可以更好地去操控

| Name          | Size    | Length     | example                    |
| ------------- | ------- | ---------- | -------------------------- |
| unsigned char | 1 Bytes | 0 ~ 255    | [[unsigned char ch = 'A']] |
| signed char   | 1 Bytes | -128 ~ 127 | [[char ch = 97]]           |

<br/>

#### sizeof
<span id="sizeof"></span>

[[sizeof]] 是一种关键字，它可以获取一个 [[数据类型]] 或者 [[已经定义好数据类型的变量]] 其所占用内存空间的具体大小，以字节为单位

[[sizeof]] 关键字的返回值为 [[size_t]] 类型，在 [[32位操作系统]] 下认作为 [[unsigned int]] 类型

```c
#include<stdio.h>

struct MyStruct {

    int value1;
    char value2;
};

int main(void){

    // 取 已经定义好数据类型的变量
    int a = 10;
    size_t size_a = sizeof(a);
    printf("size of a = %d\n",size_a);

    // 取 数据类型
    size_t size_double = sizeof(double);
    printf("size of double = %d\n",size_double);

    // 取 结构体
    size_t size_struct = sizeof(struct MyStruct);
    printf("size of struct = %d\n",size_struct);

    // 取 指针或者是指针所指向的变量
    int value = 10;
    int ptr_value = &a;
    printf("size of pointer = %d\n",ptr_value);
    printf("size of value = %d\n",*ptr_value);

    return 0;
}
```

<br/>

### 指针
<span id="指针"></span>

---

#### 内存单元
<span id="内存单元"></span>

内存单元是计算机中内存最小的存储单位，其大小为 [[1 Bytes]] ，而每一个 [[内存单元]] 都有一个唯一的编码，这个编码的长度可能是 8 位 ( 32 位系统 ) 或 16 位 ( 64 位系统 )，对于这个编码，更为亲民的称呼则为 [[地址]]，而指针是什么？ [[指针的实质其实就是这个地址]]，更具体来说的话，指针是存储了一个变量其所对应内存空间中首地址的变量，也就是指向了一个地址

<br/>

#### 变量在内存中的存储模型
<span id="变量在内存中的存储模型"></span>

在程序编译的过程中，就已经为我们所定义的变量按照变量的数据类型所对应的字节大小规划好了它们所属的内存空间，举个例子，比如说我们定义了一个占用内存空间为 [[4 Bytes]] 的 [[int]] 类型的变量，其存储的值为 [[0x12345678]] ，那么它在内存空间中就有相应的、连续的 [[4个内存单元]] 的存储空间，如下图

```c

                8765 4321 Bit      TOP
               +---------+          ^
               |         |          |
               |1000 0111|          |
               |         |          |
0x00000004<----+---------+          |
               |         |          |
               |0110 0101|          |
               |         |          |
0x00000003<----+---------+          |
               |         |          |
               |0100 0011|          |
               |         |          |
0x00000002<----+---------+          |
               |         |          |
               |0010 0001|          |
               |         |          |
0x00000001<----+---------+          v
                                   LOW

```

通过上图我们可以总结出几点结论

1. 对于一个变量而言，其在内存空间中所使用的是一块 [[地址连续]] 的内存空间，比如说一个 [[int]] 类型占用 [[4 Bytes]]，那么其在内存空间中就是占用了 4 个 [[内存单元]]，且每个内存单元之间是相间一起的，也就是 [[地址连续]]

2. 变量所对应的内存空间的地址是连续的，而且其地址总是会从 [[低位 -> 高位]] 的形式来往上递增，除此之外，需要我们注意的是，[[只要我们去操作一个变量，不管是读取还是写入，操作也是从最低为开始进行的]]，也就是最低位的那 [[1 Bit]]

3. 除此之外，我们会发现一个数在转换为 [[二进制]] 的数值的时候，其最右边的值则对应的最低位，在上图则为 [[0010 0001]]，而最左边的值则为它的最高位，即 [[1000 0111]]

<br/>

#### 获取一个变量其所在内存空间的首地址
<span id="获取一个变量其所在内存空间的首地址"></span>

在 c 语言中，通过关键字 [[&]] 即可获取一个变量所在内存空间的首地址

```c
#include<stdio.h>

int main(void){

    int a = 10;
    printf("%p\n",&a);

    return 0;
}
```

<br/>

#### 指针变量的定义
<span id="指针变量的定义"></span>

指针由于其所存储的是一个变量在内存空间的首地址，故我们定义指针的时候，做左值的操作只需要赋予相应变量的在内存空间中的首地址即可获取到一个 [[安全的指针变量]]

```c
int main(void){

    int a = 20;
    int *ptr = &a;

    return 0;
}
```

定义指针，通过 [[*]] 号来进行定义，一旦在定义变量的过程中，类型与变量名之间出现了 [[*]]，那么编译器就会认为这个定义过程是在定义一个 [[指针变量]]，而上面的代码中，即为定义了一个类型为 [[int *]] 的指针变量 [[p]]

!!! INFO
    一个指针变量在定义完成后，其所指向的内存地址并不是不能改变的，如果有需要，我们是可以在适当的时候改变其指向另一块合法的内存地址


<br/>

#### 指针和地址
<span id="指针和地址"></span>

当一个指针变量定义完成后，[[我们直接使用这个指针变量名的时候即为获取这个指针变量所存储的内存地址，即这个指针所指向的地址]]，而指针既然是一个指针变量，那么它也有所对应的内存空间的地址，我们该如何获取它呢？[[对指针变量名使用 & 操作符即为获取到这个指针变量在内存空间中的首地址]]

这里需要区分两个地址的概念，一个是指针本身在内存空间中的首地址，一个是指针所指向的其它变量在内存空间中的首地址，如下图

```c
TOP                         8765 4321 Bit
 ^                         +---------+--------+                      +---------+
 |                         |         |        |                      |         |
 |                         |1000 0111|        |                      |0000 0000|
 |                         |         |        |                      |         |
 |         0x00000004 <--------------+        |                      +---------+-------> 0x87654324
 |                         |         |        |                      |         |
 |                         |0110 0101|        |                      |0000 0000|
 |                         |         |        |                      |         |
 |         0x00000003 <--------------+        +--------------------> +---------+-------> 0x87654323
 |                         |         |        |                      |         |
 |                         |0100 0011|        |                      |0000 0000|
 |                         |         |        |                      |         |
 |         0x00000002 <--------------+        |                      +---------+-------> 0x87654322
 |                         |         |        |                      |         |
 |                         |0010 0001|        |                      |0001 0100|
 |                         |         |        |                      |         |
 v         0x00000001 <----+---------+--------+                      +---------+-------> 0x87654321
LOW             ^                                                                            ^
                |                                                                            |
                |                                                                            |
                |                                                                            |
                +                                                                            +
      Pointer: ptr -> 0x87654321                                                        Int: a -> 20

```



<br/>

#### 寻址操作
<span id="寻址操作"></span>

根据某个变量的内存空间的首地址能够找到它的存储区域并完成对这块内存区的读写操作，这个操作就叫做 [[寻址]]，而放在指针身上的更贴切的称呼则为：[[指针的解引用]]

解引用操作我们通过操作符 [[*]] 来完成，该操作符能够通过一个给定的合法地址，该合法地址通常是一个变量在内存区域中的首地址，找到这个变量在内存中的具体位置，然后再 [[根据解引用变量的数据类型的大小从首地址往后读取具体个字节的内存单元]] ，再把整体读取到的内存单元拿出来 ( [[即找到内存地址所代表的具体变量]] )，以完成对该内存首地址所指向的内存区域的读写操作，如以下代码

```c
#include<stdio.h>

int main(void){

    int a = 10;
    *(&a) = 20;

    return 0;
}
```

我们通过操作符 [[&]] 拿到了变量 [[a]] 的内存首地址，然后再通过操作符 [[*]] 对该地址进行解引用，找到变量 [[a]] 在内存中的首地址，由于变量 [[a]] 的类型为 [[int]] 即 [[4 Bytes]]，于是，[[*]] 操作符再根据首地址往后读取 [[4 Bytes]] 大小的内存单元，到此为止，我们就可以拿到变量 [[a]] 本身以完成对它的间接读写操作了

上面的示例是直接通过一个变量的地址来进行解引用操作，对于指针变量的使用也是如此，前面说过，指针变量当定义完成后，直接使用指针变量名则是获取这个指针变量所存储的某个变量在内存空间中的首地址吗，即通过 [[*]] 所解引用的即是指针变量所存储的某个变量的内存地址，先来看下使用

```c
#include<stdio.h>

int main(void){

    short a = 10;
    short *p = &a;
    *p = 20;

    return 0;
}
```

以上则是指针变量使用的方式，在前面说到，对于直接对一个地址解引用操作的时候，所解引用的具体字节是根据这个地址本身所映射的变量来决定的，比如说这个地址是属于 [[int]] 类型变量地址的话，那解引用操作所读取的字节则为 [[4 Bytes]]，而对于直接通过一个指针变量来解引用操作的时候，[[具体所读取的字节是通过指针的类型]] 来决定的，在这里，指针的类型为 [[short *]]，即 [[4 Bytes]]，但是还需要注意的是，指针所指向的变量是一个 [[short]] 类型，即本身在内存空间中占用 [[2 Bytes]]，而指针类型又是一个 [[4 Bytes]]，所以本身是不符合常理的

先不要急，我们先拆分来看看这个 [[解引用的表达式]] ，他其实拆分出来分别为 [[p]] 和 [[*p]]，[[p]] 的过程即获取这个指针变量内部所存储的某个变量的内存地址，这时候其实我们对于这个指针变量 [[p]] 本身的类型需要去掉一颗 [[*]]，即 [[short *]] -> [[short]]，在第二步操作的时候则是根据第一步操作所转换掉的类型 ( [[short]] ) 来决定接下来要往内存中读取的字节数，即 [[2 Bytes]]，也就是变量 [[a]] 本身在内存中所存储的 [[完整的]] 数据

!!! 
    简而言之，在指针变量使用的时候，我们需要先对于指针变量本身的类型先去掉一个 [[*]] 来看待即可，这一规则包括 [[数组]] 和 [[多级指针]] 都应遵守

<br/>

#### 指针的类型
<span id="指针的类型"></span>

一个指针变量也有属于它的类型的，如: [[int *]]、[[short *]]、[[char *]]、……

那么指针的类型具体有什么作用呢？ [[指针的类型能够决定指针变量所存储的地址的步长]]

这里还要提及一个步长的概念， [[步长能够决定解引用时所需读取的字节数和对于地址做算数偏移时需要相对于步长数进行偏移]] ，即一个读还有一个是内存地址的偏移

我们先来看一下读：

前面说到，操作符 [[*]] 进行解引用的时候，能够通过所给定的某个变量在内存中的首地址，找到这块变量完整的内存空间以完成对该变量的读写操作，那么这里就有一个疑问，首先一个变量的首地址我们是知道的，因为操作符 [[*]] 所解引用的就是一个变量在内存中的首地址，接下来，假设这个地址为 [[0x00000001]]，并且其所映射的变量是一个 [[short]] 类型的变量，即所存储的内存空间的大小为 [[2 Bytes]]，所以这个变量在内存中具体所占用的地址为： [[0x00000001]] 、 [[0x00000002]]，那么编译器是如何知道操作符 [[*]] 在定位到 [[0x00000001]] 后，需要读取两个字节的数据呢？这个就是靠的 [[读的步长]]

接下来看下内存地址的偏移：

我们还是假定一个 [[short]] 类型的变量，并且其在内存中的首地址为 [[0x00000001]]，我们不妨对这个地址进行 [[+ 1]] 操作，即 [[0x00000001 + 1 = ?]] ，该算数表达式在正常情况下其答案为 [[0x00000002]]，然而它实际上是一个内存地址，对于内存地址进行常量算术操作 ( [[偏移]] ) 应该以其步长作为基准，即 [[0x00000001 + 1 * 步长 = 0x00000003]]

那么步长到底怎么来， [[单纯以一个变量的地址作为衡量的话，那步长就为这个内存地址所映射的变量的数据类型所占用的具体内存空间的大小]] ，如下面代码获取到步长的方式则是以 [[内存地址所映射的变量的类型]] 来决定的

```c
int main(void){

    short a = 10;
    printf("%p\n",&a + 1);

    return 0;
}
```

而步长放在一个指针变量身上的话，步长的参考就不能依照指针变量内部所存储的内存地址所映射到的变量的数据类型来决定的了，对于指针变量来说，步长需要参考指针变量本身的类型来，假设这个指针变量为 [[short *]]，即步长为 [[4]] ( 指针类型在内存中都是占用 4 Bytes 大小的空间 )，而指针所指向的变量是一个 [[short]] 类型，即本身在内存空间中占用 [[2 Bytes]]，而指针类型又是一个 [[4 Bytes]]，所以本身是不符合常理的，我们先以指针变量的类型 [[short *]] 为基础，我们发现因为这里存在一颗 [[*]] 导致这个类型变成了一个指针类型，其实一个指针变量名在定义好后，当我们直接使用这个变量名的时候，其步长的参考要以原有类型先去掉一颗 [[*]]，再以去掉 [[*]] 后的指针类型作为下一次步长判断的基准，就拿刚刚的例子来说，我们有个 [[short *]] 的指针变量内部存储着一个 [[short]] 类型变量的首地址，当我们尝试对这个指针进行解引用的时候，首先是使用了指针变量名，即 [[short *]] -> [[short]]，其次就是通过解引用操作符 [[*]] 对这个地址进行解引用，在找到了这个变量在内存中的首地址后，所以指针变量名其实在使用的过程中，就需要先去掉一颗 [[*]]，即 [[short *]] -> [[short]]，下一步操作即为 [[*]] 操作符的解引用操作，根据上一步剩下的 [[short]] 类型，即 [[2 Bytes]] 来决定步长为 [[2]]，在解引用操作后相应的类型还需要去掉，即 [[short]] -> [[无]]，这种方式不只是针对一级指针，对于多级指针同样也是如此，还是假设我们有如下代码

```c
int main(void){

    short a = 10;
    short *p = &a;
    short **pp = &p;
}
```

我们声明了一个二级指针 [[pp]]，我们尝试对 [[pp]] 进行两次解引用操作 -> [[**pp]]，首先 [[pp]] 为指针类型 [[short **]]，在使用了 [[pp]] 后，该类型要变成 [[short **]] -> [[short *]]，即 [[4 Bytes]]，也就是步长为 [[4]]，在第一次解引用 -> [[*pp]] 的时候，由于此次操作的步长为 [[4]] ，那就是此次解引用通过 [[pp]] 内部存储的是指针变量 [[p]] 在内存中的首地址完整地读取到了 [[p]] 指针变量的内容 ( 指针 [[p]] 类型为 [[int *]]，即 [[4 Bytes]] )，由于此次解引用用了一个 [[*]]，即原本的类型变为 [[short **]] -> [[short *]] -> [[short]]，那么下一次步长则为 [[2]]，那么在第二次解引用的时候 [[**pp]] ，由于步长为 [[2]]，即此次解引用完整的读取到了 [[a]] 变量的完整内容 ( a 变量的类型为 [[short]]，即 [[2 Bytes]] )，那么第二次解引用又使用了一颗 [[*]]，即类型变为 [[short **]] -> [[short *]] -> [[short]] -> [[无]]

那么对于 [[数组]] 或者是 [[多维数组]]，由于数组名本身也是一个指向数组首元素的指针，故也需应用上面所说的规则，只是对于数组来说原本指针类型的 [[*]] 替换为 <kbd>[num]</kbd> 罢了

<bd/>

#### 指针的大小
<span id="指针的大小"></span>

前面说到，指针也属于一个变量，只是他在内存中所存储的是另一个变量在内存中的首地址，那么，既然它是一个变量，也就是说它也有属于他所占用的内存空间的大小

- 在 32 位 系统上，由于内存地址为 8 位 [[0x00000001]] ，即 4 个字节，所以 [[在32位系统上的指针类型的大小则为 4 Bytes]]

- 在 64 位 系统上，由于内存地址为 16 位 [[0x0000000000000001]] ，即 8 个字节，所以 [[在64位系统上的指针类型的大小则为 8 Bytes]]

既然不管是什么指针类型在相同系统架构下所占用的内存空间的大小是相同的，那么我们可以理解为任何指针类型之间的互转都不会出现数据丢失的问题，当然这个数据丢失仅仅只是针对指针内部所存储的内存地址是否保证完整性，但是需要注意的是我们转换后的指针类型是否符合该指针在解引用操作时所需要的步长，否则数据丢失的可能会出现在解引用操作上

在这里需要扩充下，当我们直接通过关键字 [[sizeof]] 填入一个指针变量的时候，所获取到的则为指针类型所对应的大小 [[4 Bytes or 8 Bytes]]，当我们去 [[对指针进行解引用操作的时候]] 获取到的才是指针所指向的变量其所对应的内存空间的大小

```c
#include<stdio.h>

int main(void){

    int a = 10;
    int *p = &a;

    printf("size of pointer = %d\n",sizeof(p));
    printf("size of a = %d\n",sizeof(*p));

    return 0;
}
```

<br/>

#### 地址的算数运算
<span id="地址的算数运算"></span>

当我们对一个内存地址又或者称为指针进行算数运算的时候，这种算术运算并不是简单的算数运算，而是以当前地址所以指向的内存空间首地址整体的存储长度为单位来计算的，简而言之就是运算的同时需要以 [[类型的步长]] 为基准进行计算

- 对于地址和常数进行算术
    - 除 / 乘 : 这两种操作符是不合法的，不允许存在的
    - 加 / 减 : 地址 +/- 常数 * 步长

- 对于地址和地址进行算数
    - 除 / 乘 : 这两种操作符是不合法的，不允许存在的
    - 加 / 减 : (地址1 +/- 地址2) / 步长
        - 地址计算的前提必须是两个地址所映射的变量的数据类型是相同的，两个毫不相干的变量进行内存地址的减法运算，虽然语法和编译器都能够成立该表达式，但是实际做法是毫无意义的，因为我们不知道减出来的结果的地址具体指向是什么东西
        - 该算式的真正运用其实在一个数组中，因为数组中的元素的类型都是相同，并且其内存地址是连续的存储空间，对于人为来说可以更好的控制运算的成果具体所偏移的位置， [[运用在数组中通常用来获取某个下标的元素到某个下标的元素之间所偏移的长度]]
    - 比较运算 : 对于地址的比较运算，语法上是合理的，而且编译器也允许，但是如果我们针对两个毫无相干的变量的内存地址进行比较运算实际是毫无意义的，所以它的真正运用其实在一个数组中，因为数组中的元素的类型都是相同，并且其内存地址是连续的存储空间，所以具体的逻辑作为开发人员来说更好的把控

<br/>

#### 泛型指针
<span id="泛型指针"></span>

泛型指针的类型为 [[void *]]，对于泛型指针来说， [[它可以转换为任意类型的指针]] ，比如说 [[void *]] 可以转换为 [[int *]]

由于泛型指针是泛型的，所以泛型指针在定义后，编译器是不知道它所指向的是何种类型的变量内存地址，即无法知道解引用操作时所需要的步长，所以具体要用某一个泛型指针进行解引用的时候，我们必须要先把它转换成相符类型类型的指针定义才能进行解引用操作

```c
int main(void) {

	int a = 100;
	void *p_void = &a;
	int *p = (int *)p_void;

	printf("%d\n", *p);
	return 0;
}
```

<br/>

#### 野指针
<span id="野指针"></span>

野指针即指针所指向的地址可能是实际存在又或者是不存在的地址，我们对一个野指针进行了解引用操作后，报错方式在 [[windows]] 下 或者是 [[Linux]] 下都不同，但不管如何，野指针的存在肯定是需要杜绝的，如下代码则是一个教科书级别的野指针定义方式

```c
int main(void){

    int a = 10;
    int *p = &a + 1;

    printf("%d\n",*p);

    return 0;
}
```

<br/>

#### 空指针
<span id="空指针"></span>

空指针即指针所指向的地址为 [[0]] -> [[0x00000000]]，也是一个无效的地址，但是它对比野指针来说，它的出现通常用来判断指针的有效性，在某种程度上对比野指针来说更有实际意义

在 c 中空指针的定义通常通过一个宏定义 [[NULL]] ( [[#define NULL ((void *)0)]] ) 来定义

```c
int main(void){

    int *p = malloc(sizeof(int));
    if(p == NULL){

        return -1;
    }

    *p = 20;
    printf("%d\n",*p);

    free(p);

    return 0;
}
```

<br/>

#### const 修饰指针变量
<span id="const修饰指针变量"></span>

前面对于 [[const]] 的特性提到过，它可以放在左值表达式的任意位置，而该特性对于指针变量来说，放在不同的位置都会有不同的含义

- const int *p : 可以修改 [[p]] 指向另外一个变量在内存中的首地址，但是不可以根据 [[p]] 当前所指向的某个变量在内存中的首地址解引用来修改该变量的值
- int const *p : 可以修改 [[p]] 指向另外一个变量在内存中的首地址，但是不可以根据 [[p]] 当前所指向的某个变量在内存中的首地址解引用来修改该变量的值
- int * const p : 可以根据 [[p]] 当前所指向的某个变量在内存中的首地址解引用来修改该变量的值，但是不可以修改 [[p]] 指向另外一个变量在内存中的首地址
- const int *const p : 不可以根据 [[p]] 当前所指向的某个变量在内存中的首地址解引用来修改该变量的值，并且还不可以修改 [[p]] 指向另外一个变量在内存中的首地址

把指针变量修饰为 [[const]] 常用于函数的形参部分，其目的用来限制当前函数上下文内，形参列表中的某个指针变量是要遵循某种规则进行该函数上下文逻辑的书写

<br/>

#### 多级指针
<span id="多级指针"></span>

多级指针从一级指针开始都称为多级指针，那么多级指针是如何定义的？我们都知道一级指针是指向具体某个变量在内存中的首地址，而二级指针则为指向这个一级指针在内存中的首地址，三级指针则为指向这个二级指针在内存中的首地址，依次类推，来看以下代码则为定义了一个 [[4级指针]]

```c
int main(void) {

    int a = 10;
    int *p = &a;
    int **pp = &p;
    int ***ppp = &pp;
    int ****pppp = &ppp;

    printf("%d\n",****pppp);

    return 0;
}
```

在这里，我们通过这个4级指针的解引用再复习一下步长的定义，首先这里指针 [[[pppp]]] 的类型则为 [[[int ****]]]，当我们使用了 [[pppp]] 这个指针名的时候，原有的类型需要先降一颗 [[*]]，即 [[int ****]] -> [[int ***]] ，然后进行第一次解引用操作 [[*pppp]]，这次解引用操作依照上一次所得到的类型来决定步长，由于 [[int ***]] 也是一个指针类型，故为 [[4 Bytes]]，所以步长为 4，所以此次解引用是能够完整读取到指针 [[ppp]] 在内存中的完整内容的，那么在此次解引用完成后，由于使用了一个 [[*]] ，所以原有的类型还需要降一颗 [[*]]，即 [[int ****]] -> [[int ***]] -> [[int **]]，那么进行第二次解引用操作，[[**pppp]] ，此次解引用的步长则依据上一个步骤所得到的类型来决定，即 [[int **]] -> [[4 Bytes]]，那么此次解引用操作后由于又使用了一颗 [[*]]，故原有的类型就变为 [[int ****]] -> [[int ***]] -> [[int **]] -> [[int *]]，那么进行第三次解引用操作 [[***pppp]]，此次则依据 [[int *]] 来决定步长，即 4，于是此次解引用能够完整地读取到指针变量 [[p]] 在内存中的所有内容，那么在此次解引用操作结束后，还需要去掉一颗 [[*]]，即 [[int ****]] -> [[int ***]] -> [[int **]] -> [[int *]] -> [[int]]，那么进行第四次解引用操作 [[****pppp]] 的时候，则以 [[int]] 类型的长度作为步长，即能够完整地读取到变量 a 在内存中的所有内容，即 [[10]]

<br/>

### 内存4区模型
<span id="内存4区模型"></span>

---

内存在 [[程序运行时]] ，整体可以分为以下几个区域

- 静态存储区: 静态存储区即源程序还未加载到内存前 ( [[运行前]] ) 就已经通过编译器分配好具体每个内存段具体所需要分配的字节数，然后在程序正式运行时，内核系统会把刚刚通过编译器所分配的每个内存区的存储信息加载到相应的内存区中，它们的占用空间大小是固定的，就算在程序运行期间也不能随意修改
    - 代码段 [[.text]] :
        - 该空间用于存储二进制化后的代码，存放 [[CPU执行的机器指令]]
        - 代码区是可共享的 [[即另外的执行程序能够访问到它]] ，使该内存区可用于共享的目在于，对频繁被执行的程序，只需要在内存中保有一份它的可执行二进制指令即可
        - 代码区是只读的，使其只读的原因在于防止其它程序会 意外地/恶意地 修改了它的指令码，另外，在代码区还会规划局部变量的一些相关信息
    - 数据段 :
        - .data
            - 存储 [[值初始化为非0]] 的 [[全局变量]] 和 [[静态变量]]
            - 在编译器进行 [[链接]] 的过程中，会把该段设定为 [[读写权限]]
        - .bss 
            - [[存储未初始化 (包括0)]] 的 [[全局变量]] 和 [[静态变量]]，再系统内核加载程序执行前，该段中的数据整体都会 [[被内核初始化为 0/NULL ]]
            - 在编译器进行 [[链接]] 的过程中，会把该段设定为 [[读写权限]]
        - .rodata
            - 只读数据段，存储使用 [[const关键字修饰的全局常量]] 和 使用 [[char 类型指针所修饰的字符串常量]]
            - 在编译器进行 [[链接]] 的过程中，会把该段设定为 [[只读权限]]

- 动态存储区：动态存储去即可以在程序运行时进行动态扩展的区域
    - stack:
        - 栈由系统自动管理，自动分配，自动释放
        - 栈中的内存地址由 [[高地址向低地址延伸]]，并且最遵循着 [[FILO first in last out]] 的存储原则
        - 栈的大小在Windows下默认为 [[1M ~ 10M]]，而在Linux下默认为 [[8M ~ 16M]]
        - 关于 [[stack]] 和 [[stack frame]] 之间的关系，请查看 [函数这一章节](#函数) 

    - heap:
        - 堆由开发人员进行管理和维护，对于堆空间的申请我们需要手动的分配和释放，如果在一个程序运行时向堆中申请了某块空间后并未主动释放，则该空间的生命周期会延续到程序的结束
        - 堆空间的大小默认为 [[1.3 G]]，如果超出后还会在此基础上增加，理论上在硬件能够支持的范围内，堆的空间大小可认为无限大

下图以 [[32位 Linux os]] 为基础所展示的内存4区存储模型

```c
						+-------+----------------+  --> 4 Gigabyte	   		Top
						|		|	   			 |	 		 		 		 |
	  Kernel space ←----+		|    			 |					 		 |
						|		|      			 |	 		 		 		 |
						+-------+----------------+	--> 3 Gigabyte	 		 |
								|			  |	 |					 		 |
						+-------+     stack   |	 |					 		 |
						|		|			  v	 |					 		 |
						|		+----------------+	 		 		 		 |
						|       |				 |							 |
						|		|	Stand Lib	 |					 		 |
						|		|				 |					 		 |
						|		+----------------+					 		 |
						|		|	   		  ↑	 |	 		 		 		 |
						|		|  			  |	 |					 		 |
						|		|      		  |	 |	 		 		 		 |
						|		|	   heap	  |	 |					 		 |
						|		|	   		  |	 |	 		 		 		 |
						|		|  			  |	 |					 		 |
						|		|     		  |  |	 		 		 		 |
		User space ←----+		+----------------+					 		 |
						|		|     		 	 |					 		 |
						|		|	  .bss		 +-----+	 		 		 |
						|		|				 |	   |			 		 |
						|		+----------------+	   +-> Read & Write		 |
						|		|     	 	 	 |	   |					 |
						|	 	|	  .data		 +-----+			 		 |
						|	    |                |					 		 |
						|		+----------------+			 		 		 |
						|		|     			 |	   		 	 	 		 |
						|		|	 .rodata	 +-----+			 		 |
						|		|				 |	   |   			 		 |
						|		+----------------+	   +-> Read only 		 |
						|		|				 |	   |			 		 |
						+-------+     .text	 	 +-----+	 		 		 |
								|				 |					 		 |
								+----------------+	--> 0 Gigabyte     	    Low	
```

<br/>

### 数组
<span id="数组"></span>

---

#### 数组的定义
<span id="数组的定义"></span>

数组就是一段存储着多个相同类型数据的内存空间，默认定义下其存储在栈上，在这段内存空间中，数组的每个成员的内存地址都是连续且有序的，[[成员于成员之间相互间隔了 1 个步长的偏移量]]，如以下代码则为我们定义了一个 <kbd>int []</kbd> 类型的数组

```c
int main(void){

    int arrary[3] = {1,2,3};

    return 0;
}
```

对于上面代码中所定义的数组，其在内存的结构如下图

```c
TOP
 ^                                        +---------------------------->   +---------+------------+
 |                                        |                                |0000 0000|            |
 |                                        |                0x0000000B <----+---------+ 0x00000008 |
 |                                        |                                |0000 0000|            |
 |                                        |                0x0000000A <----+---------+     ~      +---> arrary[2] == 3
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000009 <----+---------+ 0x0000000B |
 |                                        |                                |0000 0011|            |
 |                                        |                0x00000008 <----+---------+------------+
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000007 <----+---------+ 0x00000004 |
 |   int arrary[3] = {1,2,3} <------------+                                |0000 0000|            |
 |                                        |                0x00000006 <----+---------+     ~      +---> arrary[1] == 2
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000005 <----+---------+ 0x00000007 |
 |                                        |                                |0000 0010|            |
 |                                        |                0x00000004 <----+---------+------------+
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000003 <----+---------+ 0x00000000 |
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000002 <----+---------+     ~      +---> arrary[0] == 1
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000001 <--------------+ 0x00000003 |
 |                                        |                                |0000 0001|            |
 v                                        +------------>   0x00000000 <----+---------+------------+
LOW
```

<br/>

#### 数组和指针
<span id="数组和指针"></span>

当我们定义好一个数组后，如 [在上一小节](#数组的定义) 的代码中所定义的数组变量 [[arrary]]，这个数组变量 [[arrary]] 在内存中所存放的数据并不是当前数组在内存中的一段内存 ( 整个数组本身 )，而是 [[存放的当前数组中首元素在内存中的首地址]]，也就意味着当我们当都使用这个数组名 [[arrary]] 的时候，获取到的则为当前数组首元素的地址，即 <kbd> arrary == &arrary[0]</kbd>

既然数组变量内部所存放的是当前数组首元素的地址，那是不是就和 [[指针的定义]] 是类似的了？是的，对于数组名来说，我们在 [[大部分情况]] 下可以把它看成是一个指向当前数组首元素的指针，具体来讲的话，这个指针是一个指针常量，即 [[arrary == int * const arrary]] ，也就是说我们可以根据 [[arrary]] 当前所指向的首元素在内存中的首地址解引用来修改该变量的值，但是不可以修改 [[arrary]] 指向另外一处内存地址

当然，上面强调了在 [[大部分情况下]] 我们是可以把数组名看操作是一个指向当前数组首元素的指针的，而在以下两种情况使用数组名的时候，它所代表的则为这一整个数组的本身，即这个数组在内存中所存储的一整段内容

- sizeof: 当我们使用 [[sizeof]] 关键字引用于数组名的时候 [[sizeof(arrary)]]，所获取的长度并不是指针的长度 [[4 Bytes]]，而是获取的一整个数组所占用的内存段的长度
- &: 当我们通过该操作符对于数组名进行操作的时候 [[&arrary]] ，所获取到的地址的类型并不是当前指向当前数组首元素首地址指针的类型 [[int *]]，而是代表着一整个数组的类型，意味着，其步长就不能按照原有指针类型的 [[4 Bytes]] 来计算了，而是要以当前一整个数组所占用的内存段的长度来计算了，也就是说当我们使用该算数表达式 [[&arrary + 1]] ，返回的结果就不是当前数组第二个元素在内存中的首地址了，而是需要偏移过一整个数组的长度来计算
    - 当我们我们单独输出 [[arrary]] [[即数组首元素的地址]] 的时候和使用 [[&arrary]] 所输出的地址是一样的，但这只是一个错觉，这两者间是两个完全不同的关系，首先 [[arrary]] 就代表着数组首元素的地址 <kbd>&arrary[0]</kbd> 但是 [[&arrary]] 代表着的却是一整个数组的地址，但是为什么 [[&arrary]] 的结果和 <kbd>&arrary[0]/arrary</kbd> 的结果是一样的呢？现在先抛出一个问题，数组的本身是跨越好 [[n]] 个存储单元的，怎么表示这几个存储单元组成的整体呢？如果你是编译器，你会怎么做？呃，取其第一个存储单位的值来代表会比较好点，没错，编译器是这么做的，所以两者的值会是相同的相同

在单独使用一个定义好了的数组的数组名的时候，既然它是一个指向数组首元素地址的指针，那是不是意味着我们可以直接通过 [[*]] 操作对数组名进行解引用操作？答案是的，并且其也遵循在 [指针步长](#指针的类型) 这一小节中所强调的对于解引用时所需遵循的规律，还是拿最初所定义的 [[arrary]] 来说，[[arrary]] 作为一个数组变量，其类型为 <kbd>int []</kbd>，当我们使用这个数组名的时候，原来的类型就需要先去掉一个 <kbd>[]</kbd>，即 <kbd>int []</kbd> -> <kbd>int</kbd>，然后我们再进行解引用操作，即 [[*arrary]]，这时候其步长就需要参考 [[int]] 类型，即 [[4 Bytes]]，那么数组首元素的类型也是 [[int]] 类型，即此次解引用操作 [[*arrary]] 是能够完整的读取到这个数组首元素在内存中所存储的内容的，当然这里所解引用的是数组首元素的内容，那么对于其它下标的内容我们同样可以通过偏移的方式来获取，因为前面说到数组中的每个元素之间都是相隔且连续的，如我们想取下标为 [[1]] 的元素的内容那么我们直接在首地址的基础上再往后偏移 [[1]] 位即可获取到，如: [[*(arrary + 1)]] 即为获取当前数组下标为 [[1]] 的元素的内容

我们都知道，<kbd>[n]</kbd> 是取数组下标为 [[n]] 的元素的内容，其实 <kbd>[]</kbd> 可以看作是一种语法糖的形式，其实它的实质也是通过对于数组名的偏移和解引用的操作来访问到具体某个下标的元素，即 <kbd>arrary[n]</kbd> 可以看作为 [[*(arrary + n)]] 的简写形式

虽然数组名其在大多数情况下都代表着一个指向当前数组首元素地址的指针，但是对于指针和数组我们是不能把它们混在一起的，数组名代表着指向数组首元素地址的指针这只是属于数组的一种特性，而数组本身是作为一段连续且有序的内存存储空间，对比指针来说，指针只是一个指向具体某个变量在内存的首地址的变量，其次，对于普通的指针来说，其做 [[++]] 操作是允许的，而数组名虽然也是存储着其首元素的内存地址，而做 [[++]] 操作的时候是不允许的，因为数组是一个 [[指针常量]]，最后，一个数组虽然只是声明，但是我们也能够对它进行解引用操作，因为一个数组一旦声明后编译器就能够为它初始化一段线性连续的内存用于存储，只是解引用后的结果可能是一个随机数罢了，而对于指针来说，我们只是声明的情况下我们对它解引用的时候是一种危险的操作，因为我们并未指定该指针的具体指向，故该指针可能是一个空指针抑或是编译器把这种指针初始化为了一个野指针

<br/>

#### 数组的初始化
<span id="数组的初始化"></span>

如果我们只是声明了一个数组而没有定义，那么当我们访问数组某个下标的元素的时候，只能够获取到该数组对应存储区中编译器所赋予的默认值，原因是因为我们没有进行 [[数组的初始化操作]] ，编译器帮我们进行了一次隐式初始化操作，而对于人为的进行数组的初始化操作，我们只能通过在定义数组的时候就需要进行，并且需要注意的是，不管是人为的进行初始化也好还是隐式进行初始化，一个数组一旦经历过初始化的过程就不能再改变这个数组其内部所存储的当前数组首元素的地址，原因是数组在初始化完成后，数组名是一个 [[指针常量]]

```c
int main(void){

    // init arrary
    int arrary[3] = {0};
    return 0;
}
```

<br/>

#### 多维数组
<span id="多维数组"></span>

对于多维数组来说，不管是多少维的数组，我们都需要把所定义的多维数组名当成是一个一维数组来看，其实包括编译器也是这么认为的，只是这个一维数组名由原来是指向具体某个变量在内存中的首地址的指针变成了 [[这个数一维数组名是指向下一维度数组在内存中的首地址的指针]] ，但离不开的是，不管是一维数组也好还是多维数组，数组名总是一个指向当前数组首元素内存地址的指针

其实对于 [[多维]] 的概念是一种抽象形式，对于多维数组来说，其内存存放布局同样还是遵循着数组的规律，每个实质的元素之间的地址都是相间且连续的，而对于编译器来说，我们通过了一个 [[多维]] 的定义，把一个 [[一维]] 的数组划分了不同的维度去供我们或者运行时使用，我们先来上一个定义三维数组的代码，以带出更多需要重点关注的问题

```c
int main(void){

    int arrary[4][3][2] = 
    {
        {
            { 1,2 }, { 3,4 }, { 5,6 }
        },

        {
            { 7,8 }, { 9,10 }, { 11,12 }
        },

        { 
            { 13,14 }, { 15,16 }, { 17,18 }
        },

        {
            { 19,20 }, { 21,22 }, { 23,24 }
        } 
    };
}
```

我们定义了一个类型为 <kbd>int [4][3][2]</kbd> 三维数组 [[arrary]] , 但上面说到，不管多少维的数组也好，我们都需要从一维的角度去看待它，那么我们可以理解为，[[arrary]] 其实其本质为存放了 [[4]] 个 <kbd>int [3][2]</kbd> 数组类型的一维数组，事实也是如此，既然虽然它的 [[arrary]] 的类型可以表达为 <kbd>int [4][3][2]</kbd> ，但它同样也可表达成 <kbd>int [][3][2]</kbd>，除此之外，[[arrary]] 既然是一个一维数组，那么 [[arrary]] 也是一个指向当前数组首元素的地址的指针，即指向的当前数组下一维度类型为 <kbd>int [3][2]</kbd> 的数组，如下

```c
{
    { 1,2 }, { 3,4 }, { 5,6 }
}
```

[[arrary]] 所指向的是一个类型为 <kbd>int [3][2]</kbd> 数组的首地址，对于它来说我们同样也需要把它当成是一个一维数组来看待，即该数组内部所存储的指向当前数组首元素的首地址的指针，即一个类型为 <kbd>int [2]</kbd> 的数组，如下

```c
{ 1,2 }
```

对于它来说可能就非常的眼熟了，就是普通一维数组的定义方式，但是我们同样还需要进一步往下进行确认，即该类型为 <kbd>int [2]</kbd> 的数组其内部所存储的是当前数组首元素的首地址，即类型为 [[int]] 的元素，即 [[1]] 的首地址

通过上面的解析我们会发现一种规律，即 <kbd>int [4][3][2]</kbd> 指向了 <kbd>int [3][2]</kbd> 指向了 <kbd>int [2]</kbd> 指向了 <kbd>int</kbd>，所以我们可以理解为，一个多维数组在定义好后，这个多维数组所存储的地址其实为这个多维数组中，最低维度数组首元素的首地址，如上面的代码则为 三级数组 指向了 二级数组 指向了一级数组 指向了 实体元素，即最低维度数组首元素的首地址，其实我们对于所定义的这个类型为 <kbd>int [4][3][2]</kbd> 的三维数组 [[arrary]] 尝试解引用也是这个结果，首先 [[arrary]] 在使用的时候，要先去掉数组的一个维度，即 <kbd>int [4][3][2]</kbd> -> <kbd>int [3][2]</kbd>，然后进行解引用操作 [[*arrary]] 的时候，解引用所需的步长参考这按照类型 <kbd>int [3][2]</kbd> 来决定，即 [[24 Bytes]]，那么在此次解引用操作结束后，由于使用了一次 [[*]] 操作符，故原有的类型还需要再降一维度，即 <kbd>int [4][3][2]</kbd> -> <kbd>int [3][2]</kbd> -> <kbd>int [2]</kbd>，那么在进行下一次解引用操作的时候 [[**arrary]] 就参考类型 <kbd>int [2]</kbd> 来决定此次解引用操作所需的步长，也就是 [[8 Bytes]]，那么在此次解引用操作结束后，数组再降一级维度，即 <kbd>int [4][3][2]</kbd> -> <kbd>int [3][2]</kbd> -> <kbd>int [2]</kbd> -> [[int]] ，那么在最后一次解引用操作的时候，解引用所需的步长类型参考就按照 [[int]] 类型来，通过这样就能够拿到了最低维度数组首元素的完整数据了

最后，针对于刚刚所定义的多维数组再做一次巩固
```c
arrary				：第一个大组的首地址，在大多数情况下，其值位指向当前元素首元素的地址，在某些情况下代表着这整个三维数组 arrary
&arrary + 1 		：步长为整个三维数组的长度进行偏移一位
arrary + 1			：第二大组的首地址
arrary[0] 			：第一个大组的内容
&arrary[0] + 1		：第二大组的首地址
arrary[0] + 1 		：第一个大组的第二个小组的首地址
arrary[0][0]		：第一个大组的第一个小组的内容
&arrary[0][0] + 1	：第一个大组的第二个小组的首地址
arrary[0][0] + 1  	：第一个大组的第一个小组的第二个元素的首地址
arrary[0][0][0]		：第一个大组的第一个小组的第二个元素的内容
```

<br/>

#### 指针数组
<span id="指针数组"></span>

指针数组，即数组中的元素是其它变量在内存中的首地址，所以我们需要取到实际值的时候需要做两次解引用操作，第一次解引用操作根据数组中某个元素的首地址获取到该元素内部所存放的其他变量在内存中的首地址，第二次解引用操作则是获取上一步所获取到的某个变量在内存中的首地址所映射到的完整的存储空间，即实际值，如下代码，则为定义了一个类型为 <kbd>int *[]</kbd> 类型的指针数组

```c
#include<stdio.h>

int main(void) {

	int a = 10;
	int b = 20;

	int *arrary[2] = { &a,&b };

	printf("%d\n", *arrary[0]);
	printf("%d\n", **(arrary + 1));

	return 0;
}
```

对于指针数组来说，其实他是可以作为一个二级指针所存在的，二级指针所指向的则为一级指针在内存中的首地址，而一级指针内部所存储的才是具体某个变量在内存中的首地址，而指针数组也是如此，指针数组名在定义完成后其内部所存储的则为指向数组首元素的首地址的指针，而数组首元素内部所存储的还是具体某个值在内存中首地址

对于指针数组来说，当我们使用了指针数组名后，原有的类型需要变为 <kbd>int *[]</kbd> -> [[int *]]，在做第一次解引用的时候，即 [[*arrary]] 的解引用所需的步长参考则按照 [[int *]] 来决定，即 [[4 Bytes]]，在此次解引用完成后，所获取到的则为具体某个变量在内存中的首地址，而指针数组的类型需要变为 <kbd>int *[]</kbd> -> [[int *]] -> [[int]] ，那么在下一次解引用的时候 [[**arrary]]，则解引用所需的步长参考则由上一步所计算出来的类型来决定，即 [[int]] ，也就是 [[4 Bytes]]，那么在第二次解引用的时候就能够完整地读取到该变量的值了

!!!INFO
    指针数组的本质还是一个数组，只是其内部的元素的值为某个变量在内存中的首地址

<br/>

#### 数组指针
<span id="数组指针"></span>

数组指针，即一个指针变量指向的是一个数组，先来看下数组指针的定义方式和具体使用

```c
#include<stdio.h>

int main(void){

    int arrary[2][3] = 
	{
		{ 1,2,3 }, { 4,5,6 }
	};

	int (*p_arrary)[3] = arrary;

	printf("%d\n", *(*(p_arrary + 1) + 2));     // Print 6
	printf("%d\n", (*p_arrary)[1]);			    // Print 2

    return 0;
}
```

以上代码则为定义了一个类型为 <kbd>int (*)[3]</kbd> 的数组指针 [[p_arrary]]，我们发现其定义方式和 [[指针数组]] 非常的类似，但是却截然不同，数组指针的定义通过 [[()]] 提升了 [[*]] 的优先级，即 [[*]] 和 [[p_arrary]] 组成了一个指针的定义，而剩下的类型 [[int]] 和 <kbd>[3]</kbd> 则构成了指针 [[p_arrary]] 的类型，也就是说指针 [[p_arrary]] 的指针类型为 <kbd>int [3]</kbd>，区别于指针数组的定义，指针数组并没有使用 [[()]] 来提升 [[*]] 的优先级，所以所定义的指针数组名则和 <kbd>[]</kbd> 就构成了数组的定义，而数组的类型则为 [[type *]]

对于数组指针来说，它是一个指向一整个数组在内存中的首地址的指针，即对于数组指针的定义可以接受一个数组在内存中的首地址，如上面代码，我们定义了一个类型为 <kbd>int [2][3]</kbd> 的二维数组并使用一个类型为 <kbd>int (*)[3]</kbd> 的数组指针接收二维数组首元素的地址 <kbd>类型为 int [3] 的一维数组</kbd> ，但是需要注意的是，数组指针的定义通常用于修饰一个多维数组，虽然对于一个单纯的一维数组我们也能够使用数组指针进行定义，比如说上面的代码，如下面的代码，我们以一个类型为 <kbd>int (*)[3]</kbd> 的数组指针接受了类型为 <kbd>int [3]</kbd> 类型的数组的定义

```c
#include<stdio.h>

int main(void){

    int arrary[3] = { 1,2,3 };

	int (*p_arrary)[3] = arrary;

	printf("%d\n", *(*p_arrary));               // Print 1
	printf("%d\n", *((*p_arrary) + 1));	        // Print 2

    return 0;
}
```

虽然这种做法语法上是能够支持，但是不推荐，我们不妨思考，为什么需要数组指针？拿回最初定义的二维数组 [[p_arrary]] 来作为案例，当这个二维数组定义给一个类型为 <kbd>int (*)[3]</kbd> 的数组指针的时候，使用数组指针去偏移一位能够恰好能够偏移一整个一维数组的地址，即这个二维数组的第二个元素，为什么？因为我们所定义的数组指针的类型为 <kbd>int (*)[3]</kbd>，即 <kbd>int (*)[3]</kbd> -> <kbd>int [3]</kbd>，反观二维数组中每个元素可以看成是一个一维数组，具体来说是一个类型为 <kbd>int [3]</kbd> 的一维数组，所以我们使用一个数组指针操作多维数组的时候能够非常好的切合

既然数组指针的定义能够映射到具体的多维数组，就拿最开始所定义的数组 [[arrary]] 和 数组指针 [[p_arrary]]来说，是否就意味着 [[arrary]] 的时候和 [[p_arrary]] 的时候就完全一样的呢？答案是否定的，在大部分情况下数组指针可以当成多维数组来使用，但并不意味着数组指针就代表着一个多维数组，就拿获取元素的个数来说，对于数组指针它并不知道其所指向的数组中具体有几个元素，只能够知道低维数组中的元素的个数，原因是我们直接通过 [[sizeof]] 关键字获取数组指针的具体占用直接大小的时候，只能获取到 [[4 Bytes]]，因为它是一个指针的定义，而对于一个原生的多维数组的时候，如 [[arrary]]，我们通过 [[sizeof]] 获取它的总长度是能够正常获取到的

!!!INFO
    数组指针严格来说他已经不能算是一个数组的定义，它是一个指向一个整个数组在内存中的首地址的指针


<br/>

#### 数组作为函数的形参
<span id="数组作为函数的形参"></span>

当一个数组作为函数的形参的时候，原有的数组在形参中的类型表示会退化成指针的形式以表示对应的数组

- [[一维数组]] --> [[一级指针]]

- [[多维数组]] --> [[数组指针]]

- [[指针数组]] --> [[二级指针]]