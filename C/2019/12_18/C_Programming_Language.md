# *C Programming language*

<br/>


## 目录

- [变量](#变量)
    - [变量的定义和变量的声明](#变量的定义和变量的声明)
    - [全局变量和局部变量](#全局变量和局部变量)
    - [extern 关键字](#extern)
    - [不具名的变量和具名的变量](#不具名的变量和具名的变量)
- [常量](#常量)
- [静态成员](#静态成员)
- [基础数据类型](#基础数据类型)
    - [原码 反码 补码](#原反补)
    - [整型](#整型)
    - [Boolen](#Boolen)
    - [实型](#实型)
    - [Char](#Char)
    - [sizeof](#sizeof)
- [指针](#指针)
    - [内存单元](#内存单元)
    - [变量在内存中的存储模型](#变量在内存中的存储模型)
    - [获取一个变量其所在内存空间的首地址](#获取一个变量其所在内存空间的首地址)
    - [指针变量的定义](#指针变量的定义)
    - [指针和地址](#指针和地址)
    - [寻址操作](#寻址操作)
    - [指针的类型](#指针的类型)
    - [指针的大小](#指针的大小)
    - [地址的算数运算](#地址的算数运算)
    - [泛型指针](#泛型指针)
    - [野指针](#野指针)
    - [空指针](#空指针)
    - [const 修饰指针变量](#const修饰指针变量)
    - [多级指针](#多级指针)
- [内存4区模型](#内存4区模型)
  - [User Space](#User_Space)
  - [Kernel Space](#Kernel_Space)
  - [模型图](#四区模型图)
- [数组](#数组)
    - [数组的定义](#数组的定义)
    - [数组和指针](#数组和指针)
    - [数组的初始化](#数组的初始化)
    - [多维数组](#多维数组)
    - [指针数组](#指针数组)
    - [数组指针](#数组指针)
    - [数组作为函数的形参](#数组作为函数的形参)
- [字符串](#字符串)
    - [字符串在 c 中的定义](#字符串在c中的定义)
    - [c 标准库所提供的针对于字符串操作的 API](#c标准库所提供的针对于字符串操作的API)
- [heap](#heap)
- [函数](#函数)
    - [函数的声明和定义](#函数的声明和定义)
    - [栈与栈帧](#栈与栈帧)
    - [关于函数的返回值问题](#关于函数的返回值问题)
    - [函数指针](#函数指针)
- [结构体](#结构体)
    - [结构体的声明和定义](#结构体的声明和定义)
    - [结构体的内存地址](#结构体的内存地址)
    - [关于结构体的内存对齐的问题](#关于结构体的内存对齐的问题)
    - [关于结构体的深浅拷贝的问题](#关于结构体的深浅拷贝的问题)
    - [关于结构体中包含自身结构体类型的成员的问题](#关于结构体中包含自身结构体类型的成员的问题)
- [共用体](#共用体)
- [文件](#文件)
    - [在 c 语言中三种特殊的系统文件](#在c语言中三种特殊的系统文件)
    - [文件缓冲区](#文件缓冲区)
    - [文件指针](#文件指针)
    - [C 标准库中的文件操作](#C_标准库中的文件操作)
    - [Linux 系统库中的文件操作](#linux_系统库中的文件操作)
- [特殊的关键字](#特殊的关键字)
    - [typedef](#typedef)
    - [register](#register)
    - [volatile](#volatile)
- [编译](#编译)
    - [编译时所经历的 4 个步骤](#编译时所经历的4个步骤)
    - [GCC](#GCC)
    - [头文件](#头文件)
- [预处理指令](#预处理指令)
    - [头文件引入](#头文件引入)
    - [宏](#宏)
    - [条件编译](#条件编译)
- [库的制作](#库的制作)
- [位运算](#位运算)
    - [位逻辑运算符](#位逻辑运算符)
    - [移位运算符](#移位运算符)
- [关于系统提供给我们的API中，形参为 format 时需要注意的问题](#形参format)
- [系统库](#系统库)
  - [Console](#Console.h)
  - [Windows.h](#Windows.h)
  - [stdlib.h](#stdlib.h)
- [进程与线程](#进程与线程)
  - [task struct](#task_struct)
  - [什么是进程](#什么是进程)
  - [进程的创建](#进程的创建)
  - [进程的状态](#进程的状态)
  - [特殊的进程](#特殊的进程)
  - [守护进程的创建](#守护进程的创建)
  - [什么是线程](#什么是线程)
  - [线程模型](#线程模型)
  - [再聊 PID PGID TGID PPID SID](#再聊-pid-pgid-tgid)
  - [线程与进程的开销](#线程与进程的开销)
  - [选择进程还是线程？](#选择进程还是线程)
  - [进程的使用](#进程的使用)
  - [线程的使用](#线程的使用)
  - [线程同步](#线程同步)
- [进程间通信](#IPC)
  - [进程间通信的种类](#进程间通信的种类)
- [pipe ( 管道 )](#pipe管道)
  - [管道的特性](#管道的特性)
  - [管道的使用](#管道的使用)
  - [改变管道的默认阻塞行为](#改变管道的默认阻塞行为)
  - [管道的读写行为](#管道的读写行为)
- [FIFO](#fifo111)
  - [FIFO的特性](#FIFO的特性)
  - [FIFO的使用](#FIFO的使用)
  - [FIFO的阻塞和读写行为](#FIFO的阻塞和读写行为)
- [共享映射区](#共享映射区)
  - [共享映射区的使用](#共享映射区的使用)
- [信号](#信号_signal)
  - [信号的一些基本概念和特性](#信号的一些基本概念和特性)
  - [信号的状态和处理方式](#信号的状态和处理方式)
  - [信号的基本使用](#信号的基本使用)
  - [未决信号集和阻塞信号集](#未决信号集和阻塞信号集)
  - [信号集的使用](#信号集的使用)
- [Socket 编程](#Socket-编程)
  - [关于 Socket 的一些基本概念](#关于-Socket-的一些基本概念)
  - [大小端字节序转换 API](#大小端字节序转换-API)
    - [校验本机字节序的类别](#校验本机字节序的类别)
    - [整形数据的字节序转换](#整形数据的字节序转换)
    - [IP地址的转换](#IP地址的转换)
  - [Socket API](#Socket-API)
  - [IO 多路复用](#IO-多路复用)
    - [linux中的IO模型](#linux中的IO模型)
    - [什么是IO多路复用](#什么是IO多路复用)
    - [select](#selectapi)
    - [poll](#pollapi)
    - [epoll](#epollapi)
    - [再谈 select poll epoll](#再谈selectpollepoll)

<br/>

### 变量
<span id="变量"></span>

---
#### 变量的定义和变量的声明
<span id="变量的定义和变量的声明"></span>

在 C 语言中，是需要严格区分 <kbd>变量的定义</kbd> 和 <kbd>变量的声明</kbd> 的，我们先来看下如何对一个变量进行定义或者声明

```c
int main(void){

    // Variable definitions
    int varriable_def = 10;

    // Variable declaration
    int varriable_decl;
}
```

可以看到，我们对于一个变量如果在声明的过程中指定了其具体的值，那么这个变量就会提升为 [[变量的定义]]，反之，我们只是单纯的声明了一个变量的类型和其变量名，那么这种方式就称为 [[变量的声明]]

变量的定义 和 变量的声明 的区别最关键的部分还是对于两者的定义编译器是否为之开辟内存空间的问题，但这只是一个理论上的结论，**在 c 语言中，一个变量的使用，规定都需要以定义的形式而存在，如使用的仅仅只是一种 声明 ，则编译器在编译源程序的时候，会找到这个变量的声明所对应的定义，并将当前所使用的声明隐式提升为定义**{style="color:red"}，这一机制我们也可以理解为编译器为变量的声明提供的一种 **隐式提升变量作用域**{style="color:red"} 的作用，归根结底，变量的声明在最终编译完成后，编译器还是会为当前变量分配相应的内存空间，只是对比 变量的定义 来说，开辟内存空间的时机是不同的，需要注意的是，编译器为变量的声明隐式提升作用域的机制会根据变量声明在局部还是声明在全局的不同而不同，详情请看下面

#### 全局变量和局部变量
<span id="全局变量和局部变量"></span>

局部变量: 
- 局部变量声明在函数体内，其作用域由此变量的声明开始，直至该函数体的结束，对于普通的局部变量而言 ( 未使用 [[extern]] 关键字的局部变量 )，如果我们只是声明了一个局部变量，那编译器在编译的过程中仅会在 **当前文件的开始直至当前函数体的结束符 [[}]] 之间**{style="color:red"} 寻找该变量的定义，如果不存在，则赋予一个 **随机数**{style="color:red"}
- 对于一般的局部变量而言，其一般存储在内存的 $stack$ 上，也就意味着其生命周期在出了该函数体外就会结束掉

全局变量: 
- 全局变量声明在函数体外，其作用域默认情况下由此成员的定义开始直至当前文件的结束，对于全局变量而言，如果我们只是声明了一个全局变量，那编译器在编译的过程中会优先从声明当前全局变量的文件开始寻找该变量的定义，如果不存在，则会从 <font color = "red">其它需要链接的文件中尝试寻找该变量的定义</font> ( 这一机制我们可以理解为间接的提升了全局变量的作用域 )，如果都不存在，则编译器会赋予它一个默认值，简而言之，**全局变量在 c 语言下默认情况是一个外部链接属性**{style="color:red"}

- 对于一般的全局变量而言，其存储在内存的 [[.bss]] 或 [[.rodata]] 段上，也就意味着其生命周期会延续到当前程序的结束

!!! danger 注意
    对于不同的编译器来说，这方面的实现可能会有所不同，就 [[GCC]] 而言，其符合着以上所说的这一规范，而对于 [[MSVC]] 而言，这个规范仅仅适用于全局变量，对于局部变量来说，其在使用前必须要有其定义，否则会编译错误

<br/>

#### extern 关键字
<span id="extern"></span>

该关键字能够用于扩展 **函数 / 变量**{style="color:red"} 的可见性，具体的作用就是在编译器编译步骤至链接的过程中，会在其他文件 ( 也有可能是当前文件 ) 中寻找符合使用了当前该关键字的成员声明的定义，以至使用了该关键字的声明能够映射到找到的相应文件的成员定义当中，从而间接实现了声明的可见性，简而言之，**使用了该关键字的成员都能够呈外部链接形式的状态而存在**{style="color:red"}

前面说到，变量在使用前必须要存在定义，如果在使用的时候并没有对该变量的定义的话，编译器则会找到其声明，并将其隐式提升为定义，并赋予其相应的默认值，而使用了该关键字的第一大特性就是，**它会阻住编译器对于变量进行定义的隐式提升效果**{style="color:red"} ，也就是说，如果我们对某一个变量使用了该关键字进行了声明后，如果该变量在某处进行了使用，则源程序会在编译的过程中报错，因为编译器不会将其声明隐式提升为定义

该关键字如果给变量使用的话，其可以作用于局部变量和全局变量
- 局部变量
    - 局部变量使用该关键字的时候，该变量不可以用作于定义
    - 对于局部变量来说，当我们在局部变量使用了该关键字后，该局部变量的具体定义能够映射至当前函数外的任意位置，乃至其它文件中，也就是间接的提升了其作用域
- 全局变量
    - 全局变量使用该关键字的时候，该变量可以用作于定义
    - 对于全局变量来说，使用了该关键字的成员的声明和局部变量一样，其作用域同样也会有一种隐式提升的作用，其实这点就使用了 [[extern]] 关键字的全局变量和 普通的全局变量 来说是非常类似的，但是我们需要注意的是，它们两种声明方式所带来的后果其实是不同的，就 普通的全局变量 来说，其还是一种变量成员，即遵循 **如果仅存在声明而没有定义的情况下，该声明会隐式提升成定义**{style="color:red"} ，而对于使用了 [[extern]] 关键字的全局变量来说，**它会阻住编译器对于变量进行定义的隐式提升效果**{style="color:red"}，也就是说，**一个使用了 [[extern]] 关键字修饰的全局变量 [[声明]] ，如果再找不到其定义令他的声明隐式提升为定义的情况下，编译器编译的时候会报错**{style="color:red"}

而该关键字给函数使用的话其实无太大效果，因为我们所声明的函数或者是我们所定义的函数在编译器进行编译的过程中，都会默认的为所声明的函数加上该关键字 [[extern]]

```c
/* Session 1: */
int main(void) {
    
    extern int a;

    printf("%d\n", a);

    system("pause");
    return EXIT_SUCCESS;
}

int a = 10;



/* Session 2: */
int main(void) {
    
    extern int a;

    printf("%d\n", a);

    system("pause");
    return EXIT_SUCCESS;
}

*******test.c
int a = 10;



/* Session 3: */
extern int a;

int main(void) {

    printf("%d\n", a);

    system("pause");
    return EXIT_SUCCESS;
}

*******test.c
int a = 10;
```

<br/>

#### 不具名的变量和具名的变量
<span id="不具名的变量和具名的变量"></span>

犹如字面意思，具名的变量则为我们具体所声明定义的变量，我们在声明它们的过程中都会指定它们的名字，对于具名的变量而言，其会存储在内存的具体某个位置之中，其生命周期往往会延续到 当前具名变量最原始声明处 的栈帧弹出（函数调用完毕）而随之被释放

而对于不具名的变量而言，其通常存在于字面值亦或者一个函数的返回值，不具名的变量通常会存储在 寄存器 当中以加快运行速度 ( 也有可能存储在内存中 )，比较大的区别是，我们是无法获取到不具名的变量在内存中的地址的，对于不具名的变量而言，其自诞生之初就需要面临着要被销毁的风险，如果我们仅仅只是单独的构造了一个不具名的变量，那么其存在是无任何意义的 ( 一经声明就要被销毁 ) ，除非我们在构造了一个不具名的变量后 显式的拷贝 ( **在 cpp 中为移动语义**{style="color:red"} ) 这个不具名的变量所存储的数据到一个新的变量亦或者已存在的变量身上，那么这个不具名的变量还有存在的意义

如下面的代码分别构造立了不具名的变量和具名字的变量

```c
int fun_test(void) {
    int a = 0x400;      /* 具名的变量 a */
    return a;           /* 具名的变量 a 拷贝给了函数返回值所构造的不具名的临时变量 */
}

int main(void) {
    int b = 0x100;      /* 具名的变量 b */
    int c = fun_test(); /* 函数返回值所构造的不具名的临时变量拷贝给了具名的变量 c */
    fun_test();         /* 函数返回值所构造的不具名的临时变量声明在当前作用域内，由于并没有显著的使用一个新的变量亦或者已有的变量由于接收不具名的变量的拷贝，故该不具名的变量没有任何的意义 */
}
```

!!! INFO PS
    在 cpp 中由于的引入了 **左右值和引用**{style="color:red"} 的概念，使不具名的变量和具名的变量有了一个更加细分的关系，但不管怎么说也好，不具名的变量总是会在声明之初都需要面临着要被销毁的风险，而具名的变量其生命周期也总是要延续到原始声明该变量的栈帧的弹出而自行销毁，关于 cpp 中的更多细节特性这里就不进行展开了



<br/>

### 常量
<span id="常量"></span>

---

C 语言中的常量是通过关键字 [[const]] 来完成，当我们定义了一个常量，就意味着我们无法通过正常途径去修改这个定义为常量的成员的值，但是我们需要记住的是，当我们把一个常量定义为 **局部的**{style="color:red"}，那么 **这个常量无法修改的特性是由编译器在编译源程序的过程中所决定的**{style="color:red"} ，其实更具体点来说，这个变量还是和普通的变量一样存储在 [[栈]] 上，但是因为它使用了 [[const]] 的关键字，所以编译器在编译的时候就会检查这个关键字所定义的变量是否存在修改的情况，由于还是存储在 [[栈]] 上，这也就意味着我们是可以在程序运行时通过 [[间接修改 (指针)]] 的方式去修改这个常量的值，其实简而言之，定义为局部的常量是一种 [[伪常量]]

```c
int main(void){

    const int a = 10;
    return 0;
}
```

!!! INFO
    常量的定义，关键字 [[const]] 并不一定需要放在左值表达式的最左侧，对于 [[const]] 关键字来说，其所存放的位置可以在左值表达式的任意位置，对于普通的常量来说我们放在什么位置也好，其实都是没有区别的，而对于 [[指针类型的常量]] 来说，[[const]] 关键字所写入的位置能够决定 [[指针类型的常量]] 的一些额外特性

那么当我们把 [[const]] 的关键字使用在 [[全局变量]] 身上的时候，那么该常量就会存储在内存的 [.rodata] 段中，也就是说该常量不能被修改的特性是受到 [[系统内核级]] 的保护的，其实也就是我们不能通过指针来实现间接修改，它是真正意义上，[[长存性]] 的常量

```c
#include <stdio.h>

const int a = 10;
int main(void){

    printf("%d\n",a);
    return 0;
}
```

除此之外，常量的定义我们还能在 [[函数的参数]] 身上使用，其实对于参数身上使用，其特性也是符合 [[局部常量]] 的那种特性，但是通过这种方式我们能够达成一个 [[约定俗成]] 的概念，即 [[该参数不能够修改]] 的概念

```c
#include <stdio.h>

void fun_test(const int a){

    printf("%d\n",a);
}

int main(void){

    fun_test(10);
    return 0;
}
```

<br/>

### 静态成员
<span id="静态成员"></span>

---

静态成员使用 [[static]] 关键字来完成定义，它可以使用于 [[函数]] 和 [[变量]]，其存储在内存的 [[.data]] 段或者 [[.bss]] 段中，意味着其生命周期会延续到程序的结束

当静态成员定义为 [[全局成员]] 的时候是一种 <font color = "red">内部链接属性</font> 的变量，意味着该成员的作用域从定义位置开始，到本文件的结束，并且我们不能通过外部声明提升其作用域

```c
#include<stdio.h>

static void fun_test(void){

    printf("Hello,World!");
}

static int a = 10;

int main(void){

    return 0;
}
```

当静态成员定义为 [[局部成员]] 的时候，该成员的作用域从定义位置开始，直至当前函数体的结束，需要注意的是，由于它是静态的，所以它的生命周期会延续到程序的结束，也就是说当我们定义了一个静态的局部变量，当我们第一次操作它并改变了相应的值，那么当我们第二次访问该函数的时候，这个静态局部变量的值就是我们改编后的值

```c
#include<stdio.h>

static void fun_test(void){

    static int a = 0;
    a++;
    printf("Hello,World!");
}

int main(void){

    for (size_t i = 0; i < 5; i++) {

        fun_test();
	}

    return 0;
}
```

对于上面 [[static]] 关键字所修饰的都是 <font color = "red">成员的定义</font>，相对的，我们同样可以使用该关键去修饰一个 <font color = "red">成员的声明</font>，当我们使用 [[static]] 关键字应用于成员的声明的时候，就意味 <font color = "red">该声明只能够尝试在当前文件的作用域中查找符合当前声明的定义，也就意味着该声明不能将作用域扩散至其它的编译单元之中</font>，此外，还有一点需要注意的是，<font color = "red">我们对于一个静态成员的声明，那么其所映射的相应的定义也应当使用静态标识符来进行修饰，否则会编译报错 ( gcc )</font>

这里对于修饰为 [[static]] 的成员声明再补充两句，我们对于一个成员的声明主要目的就是想让这个声明能够再编译阶段扩展器作用域到其它编译单元 ( 文件 ) 中以寻找符合该声明的定义，而当我们对于一个成员的声明添加了 [[static]] 关键字后，我们原有所期望的对于成员声明的目的就无法达成了，故，使用 [[static]] 关键字去修饰成员的声明的时候，实则是没有什么意义的，该声明的作用只能够限定在当前编译单元的作用域中扩展符合该声明的定义，那么既然作用域是限定在当前编译单元了，为什么我们不直接使用定义的方式而是使用声明的方式呢？


```c
#include<stdio.h>

static void fun_test();
static int a;

void fun_test() {

	printf("OK!\n");
}
int a = 1024;

int main(void) {

	fun_test();

    printf("%d\n",a);

	return 0;
}
```


<br/>

### 基础数据类型
<span id="基础数据类型"></span>

---

#### 原码 反码 补码
<span id="原反补"></span>

计算机对于数值的计算都是通过 [[补码]] 来完成的，即我们一个普通的数字要经过 [[原码]] -> [[反码]] -> [[补码]] 的过程才能交由计算机去读取或者是计算

- 原码: 一个数的原始二进制数，例如 [[32]] 的原码 则为 [[0010 0010]]，并且把 [[最高位]] 作为 [[符号位]]，如果是 [[0]] 即 [[正数]]，如果是 [[1]] 即 [[负数]]

- 反码: 如果原码为正数，那么反码则不变，如果原码为负数，则除了原码的符号位以外，其余全部位全部取反即为反码

- 补码: 如果原码为正数，那么补码则不变，如果原码为负数，则为反码数 [[+1]] 即为补码


!!! INFO
    - 在 C 中，对于基本的数据类型来说是需要区分 [[有符号类型]] 和 [[无符号类型]] 的，即 [[最高位]] 是否用来充当符号位而不参与实际运算
    - 关键字 [[signed]] 所修饰的类型即为 [[有符号类型]]，而我们不使用该关键字所声明的变量的类型默认都为 [[有符号类型]]
    - 关键字 [[unsigned]] 所修饰的类型即为 [[无符号类型]]


<br/>

#### 整型
<span id="整型"></span>

有符号整型:

| Name      | Size                                                                                            | Length                                   | example              |
| --------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------- | -------------------- |
| int       | 4 Bytes                                                                                         | - 2147483648 ~ 2147483647                 | [[int a = 10]]       |
| short     | 2 Bytes                                                                                         | - 32768 ~ 32767                           | [[short a = 10]]     |
| long      | [[Windows]] 下统一为 4 Bytes，而 [[Linux]] 下，[[64位系统]] 为 8 Bytes，[[32位系统]] 为 4 Bytes       | - 2147483648 ~ 2147483647                 | [[long a = 10]]      |
| long long | 8 Bytes                                                                                         | - 9223372036854775808 ~ 9223372036854775807 | [[long long a = 10]] |

无符号整型:

| Name               | Size                                                                                            | Length                   | example                       |
| ------------------ | ----------------------------------------------------------------------------------------------- | ------------------------ | ----------------------------- |
| unsigned int       | 4 Bytes                                                                                         | 0 ~ 4294967295           | [[unsigned int a = 10]]       |
| unsigned short     | 2 Bytes                                                                                         | 0 ~ 65535                | [[unsigned short a = 10]]     |
| unsigned long      | [[Windows]] 下统一为 4 Bytes，而 [[Linux]] 下，[[64位系统]] 为 8 Bytes，[[32位系统]] 为 4 Bytes | 0 ~ 4294967295           | [[unsigned long a = 10]]      |
| unsigned long long | 8 Bytes                                                                                         | 0 ~ 18446744073709551615 | [[unsigned long long a = 10]] |

!!! info
    整型数据在内存中占的字节数与所选择的操作系统有关，虽然 C 语言标准中没有明确规定整型数据的长度，但 long 类型整数的长度不能短于 int 类型， short 类型整数的长度不能长于 int 类型

<br/>

#### Boolen
<span id="Boolen"></span>

在 c 标准定义中，是不存在 [[bool]] 类型和 [[true / false]] 的，c 标准对于 [[true / false]] 的定义为 [[0为假]] [[非0为真]]，如果一定要使用 [[true / false]] 这种写法，可以引入 [[stdbool.h]] 这个头文件，该头文中实现了 [[BOOLEAN]] 和 [[TRUE / FALSE]] 的宏定义，把 [[BOOLEAN]] 定义为 int 类型，并把 [[TRUE]] 定义为 [[1]]，[[FALSE]] 定义为 [[0]]


<br/>

#### 实型
<span id="实型"></span>

| Name   | Size    | Length                         | example           |
| ------ | ------- | ------------------------------ | ----------------- |
| float  | 4 Bytes | - 3.4 * 10^38 ～ 3.4 * 10^38   | [[float a = 10]]  |
| double | 8 Bytes | - 1.7 * 10^-308 ~ 1.7 * 10^308 | [[double a = 10]] |

<br/>

#### Char
<span id="Char"></span>

char 在 C 中除了能够表示一个字符以外，它还能够表示一个 [[1 Bytes]] 大小的整型数据，因为每个 char 类型本身就是一个 [ASCII](https://www.ascii-code.com/) 字符，即每个字符都有一个在 [[1 Bytes]] 大小一类的数字

除了使用 char 来表示一个字符以外，我们还通常用它来 [[解析内存地址结构]]，原因是因为 char 类型本身只是占 [[1 Bytes]]，即计算机中的基本内存单元，可以更好地去操控

| Name          | Size    | Length     | example                    |
| ------------- | ------- | ---------- | -------------------------- |
| unsigned char | 1 Bytes | 0 ~ 255    | [[unsigned char ch = 'A']] |
| signed char   | 1 Bytes | -128 ~ 127 | [[char ch = 97]]           |

<br/>

#### sizeof
<span id="sizeof"></span>

[[sizeof]] 是一种关键字，它可以获取一个 [[数据类型]] 或者 [[已经定义好数据类型的变量]] 其所占用内存空间的具体大小，以字节为单位

[[sizeof]] 关键字的返回值为 [[size_t]] 类型，在 [[32位操作系统]] 下认作为 [[unsigned int]] 类型

```c
#include<stdio.h>

struct MyStruct {

    int value1;
    char value2;
};

int main(void){

    // 取 已经定义好数据类型的变量
    int a = 10;
    size_t size_a = sizeof(a);
    printf("size of a = %d\n",size_a);

    // 取 数据类型
    size_t size_double = sizeof(double);
    printf("size of double = %d\n",size_double);

    // 取 结构体
    size_t size_struct = sizeof(struct MyStruct);
    printf("size of struct = %d\n",size_struct);

    // 取 指针或者是指针所指向的变量
    int value = 10;
    int ptr_value = &a;
    printf("size of pointer = %d\n",ptr_value);
    printf("size of value = %d\n",*ptr_value);

    return 0;
}
```

<br/>

### 指针
<span id="指针"></span>

---

#### 内存单元
<span id="内存单元"></span>

内存单元是计算机中内存最小的存储单位，其大小为 [[1 Bytes]] ，而每一个 [[内存单元]] 都有一个唯一的编码，这个编码的长度可能是 8 位 ( 32 位系统 ) 或 16 位 ( 64 位系统 )，对于这个编码，更为亲民的称呼则为 [[地址]]，而指针是什么？ [[指针的实质其实就是这个地址]]，更具体来说的话，指针是存储了一个变量其所对应内存空间中首地址的变量，也就是指向了一个地址

<br/>

#### 变量在内存中的存储模型
<span id="变量在内存中的存储模型"></span>

在程序编译的过程中，就已经为我们所定义的变量按照变量的数据类型所对应的字节大小规划好了它们所属的内存空间，举个例子，比如说我们定义了一个占用内存空间为 [[4 Bytes]] 的 [[int]] 类型的变量，其存储的值为 [[0x87654321]] ，那么它在内存空间中就有相应的、连续的 [[4个内存单元]] 的存储空间，如下图

```c
                             8765 4321 Bit       TOP
                            +-----------+         ^
                            |           |         |
                            | 1000 0111 |         |
                            |           |         |
0x00000004<-----------------------------+         |
                            |           |         |
                            | 0110 0101 |         |
                            |           |         |
0x00000003<-----------------------------+         |
                            |           |         |
                            | 0100 0011 |         |
                            |           |         |
0x00000002<-----------------------------+         |
                            |           |         |
                            | 0010 0001 |         |
                            |           |         |
0x00000001<-----------------+-----------+         v
                                                 LOW
```

通过上图我们可以总结出几点结论

1. 对于一个变量而言，其在内存空间中所使用的是一块 [[地址连续]] 的内存空间，比如说一个 [[int]] 类型占用 [[4 Bytes]]，那么其在内存空间中就是占用了 4 个 [[内存单元]]，且每个内存单元之间是相间一起的，也就是 [[地址连续]]

2. 变量所对应的内存空间的地址是连续的，而且其地址总是会从 [[低位 -> 高位]] 的形式来往上递增，除此之外，需要我们注意的是，[[只要我们去操作一个变量，不管是读取还是写入，操作也是从最低为开始进行的]]，也就是最低位的那 [[1 Bit]]

3. 除此之外，我们会发现一个数在转换为 [[二进制]] 的数值的时候，其最右边的值则对应的最低位，在上图则为 [[0010 0001]]，而最左边的值则为它的最高位，即 [[1000 0111]]

<br/>

#### 获取一个变量其所在内存空间的首地址
<span id="获取一个变量其所在内存空间的首地址"></span>

在 c 语言中，通过关键字 [[&]] 即可获取一个变量所在内存空间的首地址

```c
#include<stdio.h>

int main(void){

    int a = 10;
    printf("%p\n",&a);

    return 0;
}
```

<br/>

#### 指针变量的定义
<span id="指针变量的定义"></span>

指针由于其所存储的是一个变量在内存空间的首地址，故我们定义指针的时候，做左值的操作只需要赋予相应变量的在内存空间中的首地址即可获取到一个 [[安全的指针变量]]

```c
int main(void){

    int a = 20;
    int *ptr = &a;

    return 0;
}
```

定义指针，通过 [[*]] 号来进行定义，一旦在定义变量的过程中，类型与变量名之间出现了 [[*]]，那么编译器就会认为这个定义过程是在定义一个 [[指针变量]]，而上面的代码中，即为定义了一个类型为 [[int *]] 的指针变量 [[p]]

!!! INFO
    一个指针变量在定义完成后，其所指向的内存地址并不是不能改变的，如果有需要，我们是可以在适当的时候改变其指向另一块合法的内存地址


<br/>

#### 指针和地址
<span id="指针和地址"></span>

当一个指针变量定义完成后，[[我们直接使用这个指针变量名的时候即为获取这个指针变量所存储的内存地址，即这个指针所指向的地址]]，而指针既然是一个指针变量，那么它也有所对应的内存空间的地址，我们该如何获取它呢？[[对指针变量名使用 & 操作符即为获取到这个指针变量在内存空间中的首地址]]

这里需要区分两个地址的概念，一个是指针本身在内存空间中的首地址，一个是指针所指向的其它变量在内存空间中的首地址，如下图

```c
TOP                         8765 4321 Bit
 ^                         +---------+--------+                      +---------+
 |                         |         |        |                      |         |
 |                         |1000 0111|        |                      |0000 0000|
 |                         |         |        |                      |         |
 |         0x00000004 <--------------+        |                      +---------+-------> 0x87654324
 |                         |         |        |                      |         |
 |                         |0110 0101|        |                      |0000 0000|
 |                         |         |        |                      |         |
 |         0x00000003 <--------------+        +--------------------> +---------+-------> 0x87654323
 |                         |         |        |                      |         |
 |                         |0100 0011|        |                      |0000 0000|
 |                         |         |        |                      |         |
 |         0x00000002 <--------------+        |                      +---------+-------> 0x87654322
 |                         |         |        |                      |         |
 |                         |0010 0001|        |                      |0001 0100|
 |                         |         |        |                      |         |
 v         0x00000001 <----+---------+--------+                      +---------+-------> 0x87654321
LOW             ^                                                                            ^
                |                                                                            |
                |                                                                            |
                |                                                                            |
                +                                                                            +
      Pointer: ptr -> 0x87654321                                                        Int: a -> 20

```



<br/>

#### 寻址操作
<span id="寻址操作"></span>

根据某个变量的内存空间的首地址能够找到它的存储区域并完成对这块内存区的读写操作，这个操作就叫做 [[寻址]]，而放在指针身上的更贴切的称呼则为：[[指针的解引用]]

解引用操作我们通过操作符 [[*]] 来完成，该操作符能够通过一个给定的合法地址，该合法地址通常是一个变量在内存区域中的首地址，找到这个变量在内存中的具体位置，然后再 [[根据解引用变量的数据类型的大小从首地址往后读取具体个字节的内存单元]] ，再把整体读取到的内存单元拿出来 ( [[即找到内存地址所代表的具体变量]] )，以完成对该内存首地址所指向的内存区域的读写操作，如以下代码

```c
#include<stdio.h>

int main(void){

    int a = 10;
    *(&a) = 20;

    return 0;
}
```

我们通过操作符 [[&]] 拿到了变量 [[a]] 的内存首地址，然后再通过操作符 [[*]] 对该地址进行解引用，找到变量 [[a]] 在内存中的首地址，由于变量 [[a]] 的类型为 [[int]] 即 [[4 Bytes]]，于是，[[*]] 操作符再根据首地址往后读取 [[4 Bytes]] 大小的内存单元，到此为止，我们就可以拿到变量 [[a]] 本身以完成对它的间接读写操作了

上面的示例是直接通过一个变量的地址来进行解引用操作，对于指针变量的使用也是如此，前面说过，指针变量当定义完成后，直接使用指针变量名则是获取这个指针变量所存储的某个变量在内存空间中的首地址吗，即通过 [[*]] 所解引用的即是指针变量所存储的某个变量的内存地址，先来看下使用

```c
#include<stdio.h>

int main(void){

    short a = 10;
    short *p = &a;
    *p = 20;

    return 0;
}
```

以上则是指针变量使用的方式，在前面说到，对于直接对一个地址解引用操作的时候，所解引用的具体字节是根据这个地址本身所映射的变量来决定的，比如说这个地址是属于 [[int]] 类型变量地址的话，那解引用操作所读取的字节则为 [[4 Bytes]]，而对于直接通过一个指针变量来解引用操作的时候，[[具体所读取的字节是通过指针的类型]] 来决定的，在这里，指针的类型为 [[short *]]，即 [[4 Bytes]]，但是还需要注意的是，指针所指向的变量是一个 [[short]] 类型，即本身在内存空间中占用 [[2 Bytes]]，而指针类型又是一个 [[4 Bytes]]，所以本身是不符合常理的

先不要急，我们先拆分来看看这个 [[解引用的表达式]] ，他其实拆分出来分别为 [[p]] 和 [[*p]]，[[p]] 的过程即获取这个指针变量内部所存储的某个变量的内存地址，这时候其实我们对于这个指针变量 [[p]] 本身的类型需要去掉一颗 [[*]]，即 [[short *]] -> [[short]]，在第二步操作的时候则是根据第一步操作所转换掉的类型 ( [[short]] ) 来决定接下来要往内存中读取的字节数，即 [[2 Bytes]]，也就是变量 [[a]] 本身在内存中所存储的 [[完整的]] 数据

!!! 
    简而言之，在指针变量使用的时候，我们需要先对于指针变量本身的类型先去掉一个 [[*]] 来看待即可，这一规则包括 [[数组]] 和 [[多级指针]] 都应遵守

<br/>

#### 指针的类型
<span id="指针的类型"></span>

一个指针变量也有属于它的类型的，如: [[int *]]、[[short *]]、[[char *]]、……

那么指针的类型具体有什么作用呢？ [[指针的类型能够决定指针变量所存储的地址的步长]]

这里还要提及一个步长的概念， [[步长能够决定解引用时所需读取的字节数和对于地址做算数偏移时需要相对于步长数进行偏移]] ，即一个读还有一个是内存地址的偏移

我们先来看一下读：

前面说到，操作符 [[*]] 进行解引用的时候，能够通过所给定的某个变量在内存中的首地址，找到这块变量完整的内存空间以完成对该变量的读写操作，那么这里就有一个疑问，首先一个变量的首地址我们是知道的，因为操作符 [[*]] 所解引用的就是一个变量在内存中的首地址，接下来，假设这个地址为 [[0x00000001]]，并且其所映射的变量是一个 [[short]] 类型的变量，即所存储的内存空间的大小为 [[2 Bytes]]，所以这个变量在内存中具体所占用的地址为： [[0x00000001]] 、 [[0x00000002]]，那么编译器是如何知道操作符 [[*]] 在定位到 [[0x00000001]] 后，需要读取两个字节的数据呢？这个就是靠的 [[读的步长]]

接下来看下内存地址的偏移：

我们还是假定一个 [[short]] 类型的变量，并且其在内存中的首地址为 [[0x00000001]]，我们不妨对这个地址进行 [[+ 1]] 操作，即 [[0x00000001 + 1 = ?]] ，该算数表达式在正常情况下其答案为 [[0x00000002]]，然而它实际上是一个内存地址，对于内存地址进行常量算术操作 ( [[偏移]] ) 应该以其步长作为基准，即 [[0x00000001 + 1 * 步长 = 0x00000003]]

那么步长到底怎么来， [[单纯以一个变量的地址作为衡量的话，那步长就为这个内存地址所映射的变量的数据类型所占用的具体内存空间的大小]] ，如下面代码获取到步长的方式则是以 [[内存地址所映射的变量的类型]] 来决定的

```c
int main(void){

    short a = 10;
    printf("%p\n",&a + 1);

    return 0;
}
```

而步长放在一个指针变量身上的话，步长的参考就不能依照指针变量内部所存储的内存地址所映射到的变量的数据类型来决定的了，对于指针变量来说，步长需要参考指针变量本身的类型来，假设这个指针变量为 [[short *]]，即步长为 [[4]] ( 指针类型在内存中都是占用 4 Bytes 大小的空间 )，而指针所指向的变量是一个 [[short]] 类型，即本身在内存空间中占用 [[2 Bytes]]，而指针类型又是一个 [[4 Bytes]]，所以本身是不符合常理的，我们先以指针变量的类型 [[short *]] 为基础，我们发现因为这里存在一颗 [[*]] 导致这个类型变成了一个指针类型，其实一个指针变量名在定义好后，当我们直接使用这个变量名的时候，其步长的参考要以原有类型先去掉一颗 [[*]]，再以去掉 [[*]] 后的指针类型作为下一次步长判断的基准，就拿刚刚的例子来说，我们有个 [[short *]] 的指针变量内部存储着一个 [[short]] 类型变量的首地址，当我们尝试对这个指针进行解引用的时候，首先是使用了指针变量名，即 [[short *]] -> [[short]]，其次就是通过解引用操作符 [[*]] 对这个地址进行解引用，在找到了这个变量在内存中的首地址后，所以指针变量名其实在使用的过程中，就需要先去掉一颗 [[*]]，即 [[short *]] -> [[short]]，下一步操作即为 [[*]] 操作符的解引用操作，根据上一步剩下的 [[short]] 类型，即 [[2 Bytes]] 来决定步长为 [[2]]，在解引用操作后相应的类型还需要去掉，即 [[short]] -> [[无]]，这种方式不只是针对一级指针，对于多级指针同样也是如此，还是假设我们有如下代码

```c
int main(void){

    short a = 10;
    short *p = &a;
    short **pp = &p;
}
```

我们声明了一个二级指针 [[pp]]，我们尝试对 [[pp]] 进行两次解引用操作 -> [[**pp]]，首先 [[pp]] 为指针类型 [[short **]]，在使用了 [[pp]] 后，该类型要变成 [[short **]] -> [[short *]]，即 [[4 Bytes]]，也就是步长为 [[4]]，在第一次解引用 -> [[*pp]] 的时候，由于此次操作的步长为 [[4]] ，那就是此次解引用通过 [[pp]] 内部存储的是指针变量 [[p]] 在内存中的首地址完整地读取到了 [[p]] 指针变量的内容 ( 指针 [[p]] 类型为 [[int *]]，即 [[4 Bytes]] )，由于此次解引用用了一个 [[*]]，即原本的类型变为 [[short **]] -> [[short *]] -> [[short]]，那么下一次步长则为 [[2]]，那么在第二次解引用的时候 [[**pp]] ，由于步长为 [[2]]，即此次解引用完整的读取到了 [[a]] 变量的完整内容 ( a 变量的类型为 [[short]]，即 [[2 Bytes]] )，那么第二次解引用又使用了一颗 [[*]]，即类型变为 [[short **]] -> [[short *]] -> [[short]] -> [[无]]

那么对于 [[数组]] 或者是 [[多维数组]]，由于数组名本身也是一个指向数组首元素的指针，故也需应用上面所说的规则，只是对于数组来说原本指针类型的 [[*]] 替换为 <kbd>[num]</kbd> 罢了

<bd/>

#### 指针的大小
<span id="指针的大小"></span>

前面说到，指针也属于一个变量，只是他在内存中所存储的是另一个变量在内存中的首地址，那么，既然它是一个变量，也就是说它也有属于他所占用的内存空间的大小

- 在 32 位 系统上，由于内存地址为 8 位 [[0x00000001]] ，即 4 个字节，所以 [[在32位系统上的指针类型的大小则为 4 Bytes]]

- 在 64 位 系统上，由于内存地址为 16 位 [[0x0000000000000001]] ，即 8 个字节，所以 [[在64位系统上的指针类型的大小则为 8 Bytes]]

既然不管是什么指针类型在相同系统架构下所占用的内存空间的大小是相同的，那么我们可以理解为任何指针类型之间的互转都不会出现数据丢失的问题，当然这个数据丢失仅仅只是针对指针内部所存储的内存地址是否保证完整性，但是需要注意的是我们转换后的指针类型是否符合该指针在解引用操作时所需要的步长，否则数据丢失的可能会出现在解引用操作上

在这里需要扩充下，当我们直接通过关键字 [[sizeof]] 填入一个指针变量的时候，所获取到的则为指针类型所对应的大小 [[4 Bytes or 8 Bytes]]，当我们去 [[对指针进行解引用操作的时候]] 获取到的才是指针所指向的变量其所对应的内存空间的大小

```c
#include<stdio.h>

int main(void){

    int a = 10;
    int *p = &a;

    printf("size of pointer = %d\n",sizeof(p));
    printf("size of a = %d\n",sizeof(*p));

    return 0;
}
```

<br/>

#### 地址的算数运算
<span id="地址的算数运算"></span>

当我们对一个内存地址又或者称为指针进行算数运算的时候，这种算术运算并不是简单的算数运算，而是以当前地址所以指向的内存空间首地址整体的存储长度为单位来计算的，简而言之就是运算的同时需要以 [[类型的步长]] 为基准进行计算

- 对于地址和常数进行算术
    - 除 / 乘 : 这两种操作符是不合法的，不允许存在的
    - 加 / 减 : 地址 +/- 常数 * 步长

- 对于地址和地址进行算数
    - 除 / 乘 : 这两种操作符是不合法的，不允许存在的
    - 加 / 减 : (地址1 +/- 地址2) / 步长
        - 地址计算的前提必须是两个地址所映射的变量的数据类型是相同的，两个毫不相干的变量进行内存地址的减法运算，虽然语法和编译器都能够成立该表达式，但是实际做法是毫无意义的，因为我们不知道减出来的结果的地址具体指向是什么东西
        - 该算式的真正运用其实在一个数组中，因为数组中的元素的类型都是相同，并且其内存地址是连续的存储空间，对于人为来说可以更好的控制运算的成果具体所偏移的位置， [[运用在数组中通常用来获取某个下标的元素到某个下标的元素之间所偏移的长度]]
    - 比较运算 : 对于地址的比较运算，语法上是合理的，而且编译器也允许，但是如果我们针对两个毫无相干的变量的内存地址进行比较运算实际是毫无意义的，所以它的真正运用其实在一个数组中，因为数组中的元素的类型都是相同，并且其内存地址是连续的存储空间，所以具体的逻辑作为开发人员来说更好的把控

<br/>

#### 泛型指针
<span id="泛型指针"></span>

泛型指针的类型为 [[void *]]，对于泛型指针来说， [[它可以转换为任意类型的指针]] ，比如说 [[void *]] 可以转换为 [[int *]]

由于泛型指针是泛型的，所以泛型指针在定义后，编译器是不知道它所指向的是何种类型的变量内存地址，即无法知道解引用操作时所需要的步长，所以具体要用某一个泛型指针进行解引用的时候，我们必须要先把它转换成相符类型类型的指针定义才能进行解引用操作

```c
int main(void) {

	int a = 100;
	void *p_void = &a;
	int *p = (int *)p_void;

	printf("%d\n", *p);
	return 0;
}
```

<br/>

#### 野指针
<span id="野指针"></span>

野指针即指针所指向的地址可能是实际存在又或者是不存在的地址，我们对一个野指针进行了解引用操作后，报错方式在 [[windows]] 下 或者是 [[Linux]] 下都不同，但不管如何，野指针的存在肯定是需要杜绝的，如下代码则是一个教科书级别的野指针定义方式

```c
int main(void){

    int a = 10;
    int *p = &a + 1;

    printf("%d\n",*p);

    return 0;
}
```

<br/>

#### 空指针
<span id="空指针"></span>

空指针即指针所指向的地址为 [[0]] -> [[0x00000000]]，也是一个无效的地址，但是它对比野指针来说，它的出现通常用来判断指针的有效性，在某种程度上对比野指针来说更有实际意义

在 c 中空指针的定义通常通过一个宏定义 [[NULL]] ( [[#define NULL ((void *)0)]] ) 来定义

```c
int main(void){

    int *p = malloc(sizeof(int));
    if(p == NULL){

        return -1;
    }

    *p = 20;
    printf("%d\n",*p);

    free(p);

    return 0;
}
```

<br/>

#### const 修饰指针变量
<span id="const修饰指针变量"></span>

前面对于 [[const]] 的特性提到过，它可以放在左值表达式的任意位置，而该特性对于指针变量来说，放在不同的位置都会有不同的含义

- const int *p : 可以修改 [[p]] 指向另外一个变量在内存中的首地址，但是不可以根据 [[p]] 当前所指向的某个变量在内存中的首地址解引用来修改该变量的值
- int const *p : 可以修改 [[p]] 指向另外一个变量在内存中的首地址，但是不可以根据 [[p]] 当前所指向的某个变量在内存中的首地址解引用来修改该变量的值
- int * const p : 可以根据 [[p]] 当前所指向的某个变量在内存中的首地址解引用来修改该变量的值，但是不可以修改 [[p]] 指向另外一个变量在内存中的首地址
- const int *const p : 不可以根据 [[p]] 当前所指向的某个变量在内存中的首地址解引用来修改该变量的值，并且还不可以修改 [[p]] 指向另外一个变量在内存中的首地址

把指针变量修饰为 [[const]] 常用于函数的形参部分，其目的用来限制当前函数上下文内，形参列表中的某个指针变量是要遵循某种规则进行该函数上下文逻辑的书写

<br/>

#### 多级指针
<span id="多级指针"></span>

多级指针从一级指针开始都称为多级指针，那么多级指针是如何定义的？我们都知道一级指针是指向具体某个变量在内存中的首地址，而二级指针则为指向这个一级指针在内存中的首地址，三级指针则为指向这个二级指针在内存中的首地址，依次类推，来看以下代码则为定义了一个 [[4级指针]]

```c
int main(void) {

    int a = 10;
    int *p = &a;
    int **pp = &p;
    int ***ppp = &pp;
    int ****pppp = &ppp;

    printf("%d\n",****pppp);

    return 0;
}
```

在这里，我们通过这个4级指针的解引用再复习一下步长的定义，首先这里指针 [[[pppp]]] 的类型则为 [[[int ****]]]，当我们使用了 [[pppp]] 这个指针名的时候，原有的类型需要先降一颗 [[*]]，即 [[int ****]] -> [[int ***]] ，然后进行第一次解引用操作 [[*pppp]]，这次解引用操作依照上一次所得到的类型来决定步长，由于 [[int ***]] 也是一个指针类型，故为 [[4 Bytes]]，所以步长为 4，所以此次解引用是能够完整读取到指针 [[ppp]] 在内存中的完整内容的，那么在此次解引用完成后，由于使用了一个 [[*]] ，所以原有的类型还需要降一颗 [[*]]，即 [[int ****]] -> [[int ***]] -> [[int **]]，那么进行第二次解引用操作，[[**pppp]] ，此次解引用的步长则依据上一个步骤所得到的类型来决定，即 [[int **]] -> [[4 Bytes]]，那么此次解引用操作后由于又使用了一颗 [[*]]，故原有的类型就变为 [[int ****]] -> [[int ***]] -> [[int **]] -> [[int *]]，那么进行第三次解引用操作 [[***pppp]]，此次则依据 [[int *]] 来决定步长，即 4，于是此次解引用能够完整地读取到指针变量 [[p]] 在内存中的所有内容，那么在此次解引用操作结束后，还需要去掉一颗 [[*]]，即 [[int ****]] -> [[int ***]] -> [[int **]] -> [[int *]] -> [[int]]，那么进行第四次解引用操作 [[****pppp]] 的时候，则以 [[int]] 类型的长度作为步长，即能够完整地读取到变量 a 在内存中的所有内容，即 [[10]]

<br/>

### 内存4区模型
<span id="内存4区模型"></span>

---

在 [[32]] 位 linux 中，可执行程序 ( [[ELF]] ) 在运行时 ( **进程**{style="color:red"} ) 都会被内核为其分配 [[0 ~ 4 Gigabyte]] 虚拟内存地址的空间，这块空间整体上来说分为两大块，即 [[kernel space]] 和 [[User space]]

<br/>

#### $User$ $Space$
<span id = "User_Space"></span>

对于 User Space 来说，他是能够提供给用户进行使用的，针对它来说，其划分为了

- 静态存储区: 静态存储区即源程序还未加载到内存前 ( **运行前**{style="color:red"} ) 就已经通过编译器分配好具体每个内存段具体所需要分配的字节数，然后在程序正式运行时，内核系统会把刚刚通过编译器所分配的每个内存区的存储信息加载到相应的内存区中，它们的占用空间大小是固定的，就算在程序运行期间也不能随意修改
    - 代码段 [[.text]] :
        - 该空间用于存储二进制化后的代码，存放 **CPU执行的机器指令**{style="color:red"}
        - 代码区是可共享的 **即另外的执行程序能够访问到它**{style="color:red"}，使该内存区可用于共享的目在于，对频繁被执行的程序，只需要在内存中保有一份它的可执行二进制指令即可
        - 代码区是只读的，使其只读的原因在于防止其它程序会 意外地/恶意地 修改了它的指令码，另外，在代码区还会规划局部变量的一些相关信息
    - 数据段 :
        - .data
            - 存储 **值初始化为非0**{style="color:red"} 的 **全局变量**{style="color:red"} 和 **静态变量**{style="color:red"}
            - 在编译器进行链接的过程中，会把该段设定为 **读写权限**{style="color:red"}
        - .bss 
            - **存储未初始化 ( 包括0 )**{style="color:red"} 的 **全局变量**{style="color:red"} 和 **静态变量**{style="color:red"}，再系统内核加载程序执行前，该段中的数据整体都会 **被内核初始化为 0 / NULL**{style="color:red"}
            - 在编译器进行链接的过程中，会把该段设定为 **读写权限**{style="color:red"}
        - .rodata
            - 只读数据段，存储使用 **const关键字修饰的全局常量**{style="color:red"} 和 使用 **char 类型指针所修饰的字符串常量**{style="color:red"}
            - 在编译器进行链接的过程中，会把该段设定为 **只读权限**{style="color:red"}

- 动态存储区：动态存储去即可以在程序运行时进行动态扩展的区域
    - stack:
        - 栈由系统自动管理，自动分配，自动释放
        - 栈中的内存地址由 **高地址向低地址延伸**{style="color:red"}，并且最遵循着 [[FILO]] **first in last out**{style="color:red"} 的存储原则
        - 栈的大小在Windows下默认为 [[1M ~ 10M]]，而在Linux下默认为 [[8M ~ 16M]]
        - 关于 [[stack]] 和 [[stack frame]] 之间的关系，请查看 [函数这一章节](#函数) 

    - heap:
        - 堆由开发人员进行管理和维护，对于堆空间的申请我们需要手动的分配和释放，如果在一个程序运行时向堆中申请了某块空间后并未主动释放，则该空间的生命周期会延续到程序的结束
        - 堆空间的大小默认为 [[1.3 G]]，如果超出后还会在此基础上增加，理论上在硬件能够支持的范围内，堆的空间大小可认为无限大
        - 关于 [[heap]] 的具体使用，请查看 [heap 这一章节](#heap) 

<br/>


#### $Kernel$ $Space$
<span id = "Kernel_Space"></span>

对于 Kernel Space 来说，它是受到到内核级的保护的，即用户无法对该空间中的数据进行读写，否则会发生 [[sequence error]] 的错误

Kernel Space 通常是以功能模块进行划分，具体能够细分为:
- 内存管理模块
- 进程管理模块 ( **`PCB`** )
- 设备驱动管理模块
- VFS 虚拟文件系统

<br/>

#### 存储模型
<span id = "四区模型图"></span>

下图以 [[32位 Linux os]] 为基础所展示的内存4区存储模型

```c
						+-------+----------------+  --> 4 Gigabyte	   		Top
						|		|	   			 |	 		 		 		 |
	  Kernel space ←----+		|    			 |					 		 |
						|		|      			 |	 		 		 		 |
						+-------+----------------+	--> 3 Gigabyte	 		 |
								|			  |	 |					 		 |
						+-------+     stack   |	 |					 		 |
						|		|			  v	 |					 		 |
						|		+----------------+	 		 		 		 |
						|       |				 |							 |
						|		|	Stand Lib	 |					 		 |
						|		|				 |					 		 |
						|		+----------------+					 		 |
						|		|	   		  ↑	 |	 		 		 		 |
						|		|  			  |	 |					 		 |
						|		|      		  |	 |	 		 		 		 |
						|		|	   heap	  |	 |					 		 |
						|		|	   		  |	 |	 		 		 		 |
						|		|  			  |	 |					 		 |
						|		|     		  |  |	 		 		 		 |
		User space ←----+		+----------------+					 		 |
						|		|     		 	 |					 		 |
						|		|	  .bss		 +-----+	 		 		 |
						|		|				 |	   |			 		 |
						|		+----------------+	   +-> Read & Write		 |
						|		|     	 	 	 |	   |					 |
						|	 	|	  .data		 +-----+			 		 |
						|	    |                |					 		 |
						|		+----------------+			 		 		 |
						|		|     			 |	   		 	 	 		 |
						|		|	 .rodata	 +-----+			 		 |
						|		|				 |	   |   			 		 |
						|		+----------------+	   +-> Read only 		 |
						|		|				 |	   |			 		 |
						+-------+     .text	 	 +-----+	 		 		 |
								|				 |					 		 |
								+----------------+	--> 0 Gigabyte     	    Low	
```

<br/>

### 数组
<span id="数组"></span>

---

#### 数组的定义
<span id="数组的定义"></span>

数组就是一段存储着多个相同类型数据的内存空间，默认定义下其存储在栈上，在这段内存空间中，数组的每个成员的内存地址都是连续且有序的，[[成员于成员之间相互间隔了 1 个步长的偏移量]]，如以下代码则为我们定义了一个 <kbd>int []</kbd> 类型的数组

```c
int main(void){

    int arrary[3] = {1,2,3};

    return 0;
}
```

对于上面代码中所定义的数组，其在内存的结构如下图

```c
TOP
 ^                                        +---------------------------->   +---------+------------+
 |                                        |                                |0000 0000|            |
 |                                        |                0x0000000B <----+---------+ 0x00000008 |
 |                                        |                                |0000 0000|            |
 |                                        |                0x0000000A <----+---------+     ~      +---> arrary[2] == 3
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000009 <----+---------+ 0x0000000B |
 |                                        |                                |0000 0011|            |
 |                                        |                0x00000008 <----+---------+------------+
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000007 <----+---------+ 0x00000004 |
 |   int arrary[3] = {1,2,3} <------------+                                |0000 0000|            |
 |                                        |                0x00000006 <----+---------+     ~      +---> arrary[1] == 2
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000005 <----+---------+ 0x00000007 |
 |                                        |                                |0000 0010|            |
 |                                        |                0x00000004 <----+---------+------------+
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000003 <----+---------+ 0x00000000 |
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000002 <----+---------+     ~      +---> arrary[0] == 1
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000001 <--------------+ 0x00000003 |
 |                                        |                                |0000 0001|            |
 v                                        +------------>   0x00000000 <----+---------+------------+
LOW
```


!!! INFO 注意
    在 $C99$ 标准中是不允许对 $VLA$ 进行初始化的，即我们无法在声明一个数组的时候，通过一个运行时中的变量来指定数所声明的而长度

<br/>

#### 数组和指针
<span id="数组和指针"></span>

当我们定义好一个数组后，如 [在上一小节](#数组的定义) 的代码中所定义的数组变量 [[arrary]]，这个数组变量 [[arrary]] 在内存中所存放的数据并不是当前数组在内存中的一段内存 ( 整个数组本身 )，而是 [[存放的当前数组中首元素在内存中的首地址]]，也就意味着当我们当都使用这个数组名 [[arrary]] 的时候，获取到的则为当前数组首元素的地址，即 <kbd> arrary == &arrary[0]</kbd>

既然数组变量内部所存放的是当前数组首元素的地址，那是不是就和 [[指针的定义]] 是类似的了？是的，对于数组名来说，我们在 [[大部分情况]] 下可以把它看成是一个指向当前数组首元素的指针，具体来讲的话，这个指针是一个指针常量，即 [[arrary == int * const arrary]] ，也就是说我们可以根据 [[arrary]] 当前所指向的首元素在内存中的首地址解引用来修改该变量的值，但是不可以修改 [[arrary]] 指向另外一处内存地址

当然，上面强调了在 [[大部分情况下]] 我们是可以把数组名看操作是一个指向当前数组首元素的指针的，而在以下两种情况使用数组名的时候，它所代表的则为这一整个数组的本身，即这个数组在内存中所存储的一整段内容

- sizeof: 当我们使用 [[sizeof]] 关键字引用于数组名的时候 [[sizeof(arrary)]]，所获取的长度并不是指针的长度 [[4 Bytes]]，而是获取的一整个数组所占用的内存段的长度
- &: 当我们通过该操作符对于数组名进行操作的时候 [[&arrary]] ，所获取到的地址的类型并不是当前指向当前数组首元素首地址指针的类型 [[int *]]，而是代表着一整个数组的类型，意味着，其步长就不能按照原有指针类型的 [[4 Bytes]] 来计算了，而是要以当前一整个数组所占用的内存段的长度来计算了，也就是说当我们使用该算数表达式 [[&arrary + 1]] ，返回的结果就不是当前数组第二个元素在内存中的首地址了，而是需要偏移过一整个数组的长度来计算
    - 当我们我们单独输出 [[arrary]] [[即数组首元素的地址]] 的时候和使用 [[&arrary]] 所输出的地址是一样的，但这只是一个错觉，这两者间是两个完全不同的关系，首先 [[arrary]] 就代表着数组首元素的地址 <kbd>&arrary[0]</kbd> 但是 [[&arrary]] 代表着的却是一整个数组的地址，但是为什么 [[&arrary]] 的结果和 <kbd>&arrary[0]/arrary</kbd> 的结果是一样的呢？现在先抛出一个问题，数组的本身是跨越好 [[n]] 个存储单元的，怎么表示这几个存储单元组成的整体呢？如果你是编译器，你会怎么做？呃，取其第一个存储单位的值来代表会比较好点，没错，编译器是这么做的，所以两者的值会是相同的相同

在单独使用一个定义好了的数组的数组名的时候，既然它是一个指向数组首元素地址的指针，那是不是意味着我们可以直接通过 [[*]] 操作对数组名进行解引用操作？答案是的，并且其也遵循在 [指针步长](#指针的类型) 这一小节中所强调的对于解引用时所需遵循的规律，还是拿最初所定义的 [[arrary]] 来说，[[arrary]] 作为一个数组变量，其类型为 <kbd>int []</kbd>，当我们使用这个数组名的时候，原来的类型就需要先去掉一个 <kbd>[]</kbd>，即 <kbd>int []</kbd> -> <kbd>int</kbd>，然后我们再进行解引用操作，即 [[*arrary]]，这时候其步长就需要参考 [[int]] 类型，即 [[4 Bytes]]，那么数组首元素的类型也是 [[int]] 类型，即此次解引用操作 [[*arrary]] 是能够完整的读取到这个数组首元素在内存中所存储的内容的，当然这里所解引用的是数组首元素的内容，那么对于其它下标的内容我们同样可以通过偏移的方式来获取，因为前面说到数组中的每个元素之间都是相隔且连续的，如我们想取下标为 [[1]] 的元素的内容那么我们直接在首地址的基础上再往后偏移 [[1]] 位即可获取到，如: [[*(arrary + 1)]] 即为获取当前数组下标为 [[1]] 的元素的内容

我们都知道，<kbd>[n]</kbd> 是取数组下标为 [[n]] 的元素的内容，其实 <kbd>[]</kbd> 可以看作是一种语法糖的形式，其实它的实质也是��过对于数组名的偏移和解引用的操作来访问到具体某个下标的元素，即 <kbd>arrary[n]</kbd> 可以看作为 [[*(arrary + n)]] 的简写形式

虽然数组名其在大多数情况下都代表着一个指向当前数组首元素地址的指针，但是对于指针和数组我们是不能把它们混在一起的，数组名代表着指向数组首元素地址的指针这只是属于数组的一种特性，而数组本身是作为一段连续且有序的内存存储空间，对比指针来说，指针只是一个指向具体某个变量在内存的首地址的变量，其次，对于普通的指针来说，其做 [[++]] 操作是允许的，而数组名虽然也是存储着其首元素的内存地址，而做 [[++]] 操作的时候是不允许的，因为数组是一个 [[指针常量]]，最后，一个数组虽然只是声明，但是我们也能够对它进行解引用操作，因为一个数组一旦声明后编译器就能够为它初始化一段线性连续的内存用于存储，只是解引用后的结果可能是一个随机数罢了，而对于指针来说，我们只是声明的情况下我们对它解引用的时候是一种危险的操作，因为我们并未指定该指针的具体指向，故该指针可能是一个空指针抑或是编译器把这种指针初始化为了一个野指针

<br/>

#### 数组的初始化
<span id="数组的初始化"></span>

如果我们只是声明了一个数组而没有定义，那么当我们访问数组某个下标的元素的时候，只能够获取到该数组对应存储区中编译器所赋予的默认值，原因是因为我们没有进行 [[数组的初始化操作]] ，编译器帮我们进行了一次隐式初始化操作

而对于人为的进行数组的初始化操作，我们只能通过在定义数组的时候就需要进行，并且需要注意的是，不管是人为的进行初始化也好还是隐式进行初始化，一个数组一旦经历过初始化的过程就不能再改变这个数组其内部所存储的当前数组首元素的地址，原因是数组在初始化完成后，数组名是一个 [[指针常量]]

需要注意的是，我们认为的对数组进行初始化操作，哪怕我们只是在当前初始化的过程中仅仅只是指定了初始化一个元素，编译器也会使没有指定初始化值的元素都赋上一个初始化值 [[0]]

```c
int main(void){

    // init arrary
    int arrary[3] = {0};
    return 0;
}
```

<br/>

#### 多维数组
<span id="多维数组"></span>

对于多维数组来说，不管是多少维的数组，我们都需要把所定义的多维数组名当成是一个一维数组来看，其实包括编译器也是这么认为的，只是这个一维数组名由原来是指向具体某个变量在内存中的首地址的指针变成了 [[这个数一维数组名是指向下一维度数组在内存中的首地址的指针]] ，但离不开的是，不管是一维数组也好还是多维数组，数组名总是一个指向当前数组首元素内存地址的指针

其实对于 [[多维]] 的概念是一种抽象形式，对于多维数组来说，其内存存放布局同样还是遵循着数组的规律，每个实质的元素之间的地址都是相间且连续的，而对于编译器来说，我们通过了一个 [[多维]] 的定义，把一个 [[一维]] 的数组划分了不同的维度去供我们或者运行时使用，我们先来上一个定义三维数组的代码，以带出更多需要重点关注的问题

```c
int main(void){

    int arrary[4][3][2] = 
    {
        {
            { 1,2 }, { 3,4 }, { 5,6 }
        },

        {
            { 7,8 }, { 9,10 }, { 11,12 }
        },

        { 
            { 13,14 }, { 15,16 }, { 17,18 }
        },

        {
            { 19,20 }, { 21,22 }, { 23,24 }
        } 
    };
}
```

我们定义了一个类型为 <kbd>int [4][3][2]</kbd> 三维数组 [[arrary]] , 但上面说到，不管多少维的数组也好，我们都需要从一维的角度去看待它，那么我们可以理解为，[[arrary]] 其实其本质为存放了 [[4]] 个 <kbd>int [3][2]</kbd> 数组类型的一维数组，事实也是如此，既然虽然它的 [[arrary]] 的类型可以表达为 <kbd>int [4][3][2]</kbd> ，但它同样也可表达成 <kbd>int [][3][2]</kbd>，除此之外，[[arrary]] 既然是一个一维数组，那么 [[arrary]] 也是一个指向当前数组首元素的地址的指针，即指向的当前数组下一维度类型为 <kbd>int [3][2]</kbd> 的数组，如下

```c
{
    { 1,2 }, { 3,4 }, { 5,6 }
}
```

[[arrary]] 所指向的是一个类型为 <kbd>int [3][2]</kbd> 数组的首地址，对于它来说我们同样也需要把它当成是一个一维数组来看待，即该数组内部所存储的指向当前数组首元素的首地址的指针，即一个类型为 <kbd>int [2]</kbd> 的数组，如下

```c
{ 1,2 }
```

对于它来说可能就非常的眼熟了，就是普通一维数组的定义方式，但是我们同样还需要进一步往下进行确认，即该类型为 <kbd>int [2]</kbd> 的数组其内部所存储的是当前数组首元素的首地址，即类型为 [[int]] 的元素，即 [[1]] 的首地址

通过上面的解析我们会发现一种规律，即 <kbd>int [4][3][2]</kbd> 指向了 <kbd>int [3][2]</kbd> 指向了 <kbd>int [2]</kbd> 指向了 <kbd>int</kbd>，所以我们可以理解为，一个多维数组在定义好后，这个多维数组所存储的地址其实为这个多维数组中，最低维度数组首元素的首地址，如上面的代码则为 三级数组 指向了 二级数组 指向了一级数组 指向了 实体元素，即最低维度数组首元素的首地址，其实我们对于所定义的这个类型为 <kbd>int [4][3][2]</kbd> 的三维数组 [[arrary]] 尝试解引用也是这个结果，首先 [[arrary]] 在使用的时候，要先去掉数组的一个维度，即 <kbd>int [4][3][2]</kbd> -> <kbd>int [3][2]</kbd>，然后进行解引用操作 [[*arrary]] 的时候，解引用所需的步长参考这按照类型 <kbd>int [3][2]</kbd> 来决定，即 [[24 Bytes]]，那么在此次解引用操作结束后，由于使用了一次 [[*]] 操作符，故原有的类型还需要再降一维度，即 <kbd>int [4][3][2]</kbd> -> <kbd>int [3][2]</kbd> -> <kbd>int [2]</kbd>，那么在进行下一次解引用操作的时候 [[**arrary]] 就参考类型 <kbd>int [2]</kbd> 来决定此次解引用操作所需的步长，也就是 [[8 Bytes]]，那么在此次解引用操作结束后，数组再降一级维度，即 <kbd>int [4][3][2]</kbd> -> <kbd>int [3][2]</kbd> -> <kbd>int [2]</kbd> -> [[int]] ，那么在最后一次解引用操作的时候，解引用所需的步长类型参考就按照 [[int]] 类型来，通过这样就能够拿到了最低维度数组首元素的完整数据了

最后，针对于刚刚所定义的多维数组再做一次巩固
```c
arrary				：第一个大组的首地址，在大多数情况下，其值位指向当前元素首元素的地址，在某些情况下代表着这整个三维数组 arrary
&arrary + 1 		：步长为整个三维数组的长度进行偏移一位
arrary + 1			：第二大组的首地址
arrary[0] 			：第一个大组的内容
&arrary[0] + 1		：第二大组的首地址
arrary[0] + 1 		：第一个大组的第二个小组的首地址
arrary[0][0]		：第一个大组的第一个小组的内容
&arrary[0][0] + 1	：第一个大组的第二个小组的首地址
arrary[0][0] + 1  	：第一个大组的第一个小组的第二个元素的首地址
arrary[0][0][0]		：第一个大组的第一个小组的第二个元素的内容
```

<br/>

#### 指针数组
<span id="指针数组"></span>

指针数组，即数组中的元素是其它变量在内存中的首地址，所以我们需要取到实际值的时候需要做两次解引用操作，第一次解引用操作根据数组中某个元素的首地址获取到该元素内部所存放的其他变量在内存中的首地址，第二次解引用操作则是获取上一步所获取到的某个变量在内存中的首地址所映射到的完整的存储空间，即实际值，如下代码，则为定义了一个类型为 <kbd>int *[]</kbd> 类型的指针数组

```c
#include<stdio.h>

int main(void) {

	int a = 10;
	int b = 20;

	int *arrary[2] = { &a,&b };

	printf("%d\n", *arrary[0]);
	printf("%d\n", **(arrary + 1));

	return 0;
}
```

对于指针数组来说，其实他是可以作为一个二级指针所存在的，二级指针所指向的则为一级指针在内存中的首地址，而一级指针内部所存储的才是具体某个变量在内存中的首地址，而指针数组也是如此，指针数组名在定义完成后其内部所存储的则为指向数组首元素的首地址的指针，而数组首元素内部所存储的还是具体某个值在内存中首地址

对于指针数组来说，当我们使用了指针数组名后，原有的类型需要变为 <kbd>int *[]</kbd> -> [[int *]]，在做第一次解引用的时候，即 [[*arrary]] 的解引用所需的步长参考则按照 [[int *]] 来决定，即 [[4 Bytes]]，在此次解引用完成后，所获取到的则为具体某个变量在内存中的首地址，而指针数组的类型需要变为 <kbd>int *[]</kbd> -> [[int *]] -> [[int]] ，那么在下一次解引用的时候 [[**arrary]]，则解引用所需的步长参考则由上一步所计算出来的类型来决定，即 [[int]] ，也就是 [[4 Bytes]]，那么在第二次解引用的时候就能够完整地读取到该变量的值了

!!!INFO
    指针数组的本质还是一个数组，只是其内部的元素的值为某个变量在内存中的首地址

<br/>

#### 数组指针
<span id="数组指针"></span>

数组指针，即一个指针变量指向的是一个数组，先来看下数组指针的定义方式和具体使用

```c
#include<stdio.h>

int main(void){

    int arrary[2][3] = 
	{
		{ 1,2,3 }, { 4,5,6 }
	};

	int (*p_arrary)[3] = arrary;

	printf("%d\n", *(*(p_arrary + 1) + 2));     // Print 6
	printf("%d\n", (*p_arrary)[1]);			    // Print 2

    return 0;
}
```

以上代码则为定义了一个类型为 <kbd>int (*)[3]</kbd> 的数组指针 [[p_arrary]]，我们发现其定义方式和 [[指针数组]] 非常的类似，但是却截然不同，数组指针的定义通过 [[()]] 提升了 [[*]] 的优先级，即 [[*]] 和 [[p_arrary]] 组成了一个指针的定义，而剩下的类型 [[int]] 和 <kbd>[3]</kbd> 则构成了指针 [[p_arrary]] 的类型，也就是说指针 [[p_arrary]] 指向的内存地址所映射的数据类型为 <kbd>int [3]</kbd>，区别于指针数组的定义，指针数组并没有使用 [[()]] 来提升 [[*]] 的优先级，所以所定义的指针数组名则和 <kbd>[]</kbd> 就构成了数组的定义，而数组的类型则为 [[type *]]

对于数组指针来说，它是一个指向一整个数组在内存中的首地址的指针，即对于数组指针的定义可以接受一个数组在内存中的首地址，如上面代码，我们定义了一个类型为 <kbd>int [2][3]</kbd> 的二维数组并使用一个类型为 <kbd>int (\*)[3]</kbd> 的数组指针接收二维数组首元素的地址 <kbd>类型为 int [3] 的一维数组</kbd> ，但是需要注意的是，数组指针的定义通常用于修饰一个多维数组，虽然对于一个单纯的一维数组我们也能够使用数组指针进行定义，比如说上面的代码，如下面的代码，我们以一个类型为 <kbd>int (*)[3]</kbd> 的数组指针接受了类型为 <kbd>int [3]</kbd> 类型的数组的定义

```c
#include<stdio.h>

int main(void){

    int arrary[3] = { 1,2,3 };

	int (*p_arrary)[3] = arrary;

	printf("%d\n", *(*p_arrary));               // Print 1
	printf("%d\n", *((*p_arrary) + 1));	        // Print 2

    return 0;
}
```

虽然这种做法语法上是能够支持，但是不推荐，我们不妨思考，为什么需要数组指针？拿回最初定义的二维数组 [[p_arrary]] 来作为案例，当这个二维数组定义给一个类型为 <kbd>int (*)[3]</kbd> 的数组指针的时候，使用数组指针去偏移一位能够恰好能够偏移一整个一维数组的地址，即这个二维数组的第二个元素，为什么？因为我们所定义的数组指针的类型为 <kbd>int (*)[3]</kbd>，即 <kbd>int (*)[3]</kbd> -> <kbd>int [3]</kbd>，反观二维数组中每个元素可以看成是一个一维数组，具体来说是一个类型为 <kbd>int [3]</kbd> 的一维数组，所以我们使用一个数组指针操作多维数组的时候能够非常好的切合

既然数组指针的定义能够映射到具体的多维数组，就拿最开始所定义的数组 [[arrary]] 和 数组指针 [[p_arrary]]来说，是否就意味着 [[arrary]] 的时候和 [[p_arrary]] 的时候就完全一样的呢？答案是否定的，在大部分情况下数组指针可以当成多维数组来使用，但并不意味着数组指针就代表着一个多维数组，就拿获取元素的个数来说，对于数组指针它并不知道其所指向的数组中具体有几个元素，只能够知道低维数组中的元素的个数，原因是我们直接通过 [[sizeof]] 关键字获取数组指针的具体占用直接大小的时候，只能获取到 [[4 Bytes]]，因为它是一个指针的定义，而对于一个原生的多维数组的时候，如 [[arrary]]，我们通过 [[sizeof]] 获取它的总长度是能够正常获取到的

!!!INFO
    数组指针严格来说他已经不能算是一个数组的定义，它是一个指向一个整个数组在内存中的首地址的指针


<br/>

#### 数组作为函数的形参
<span id="数组作为函数的形参"></span>

当一个数组作为函数的形参的时候，原有的数组在形参中的类型表示会退化成指针的形式以表示对应的数组

- [[一维数组]] --> [[一级指针]]

```c
int arrary[3] --> int *arrary
```

- [[多维数组]] --> [[数组指针]]
```c
int arrary[3][2] --> int (*arrary)[2]
```

- [[指针数组]] --> [[二级指针]]
```c
char *strs[] --> char **strs
```

<br/>

### 字符串
<span id="字符串"></span>

---

#### 字符串在 c 中的定义
<span id="字符串在c中的定义"></span>

字符串是一段 [[char]] 类型的连续存储空间，也就是一个 char 类型的数组，在 c 语言中，字符串并没有具体的 [[string]] 类型进行定义，而是使用类型 <kbd>char []</kbd> 或者是 [[char *]] 用于定义一个字符串的类型

一个标准的字符串定义，尾元素的值必须为 [[\0]] 才能够构成一个字符串的定义，如下面的代码

```c
int main(void){

    char str[] = {'H','e','l','l','o','w','\0'};
}
```

以上代码则为我们定义了一个字符数组，并让字符数组的尾元素的值置为 [[\0]] 以构成字符串的定义，但是在 c 语言中对于字符串的赋值还有更简便的方式 --> [[""]]，通过 [[""]] 所填写的字符集则为一个标准的字符串定义，通常也称之为 [[字符串常量]]，其会内存中空间中自动开辟一块空间用于存储我们写录入的字符组，并会额外添加 [[1 Bytes]] 大小的内存单元以为该字符组的结尾添加一个 [[\0]] 标识符，最后返回这块内存空间的地址，其通常用来作为表达式的右值出现，并且它所返回的是一个地址，也就意味着我么能够使用  <kbd>char []</kbd> 或者是 [[char *]] 类型的定义来接收这个地址，比较特殊的是，所开辟的这块内存空间在内存中的具体位置会根据这类型的不同定义而不同

- char [ ]
    - 因为字符串是内存中一段连续的char空间，所以理当我们是可以使用char数组来定义一个字符串变量
    - 使用字符串数组所修饰的字符串常量，其具体的存储位置只是根据其定义的不同而不同，比如说把这个字符串数组定义在一个函数作用域内，那么这个字符串就是存储在 [[stack]] 上，比如说使用的 static 所修饰，或是声明称全局，那么它就会被放在 [[.data]] 段中

```c
#include<stdio.h>

int main(void){

    char str[] = "Hello,World!";
    printf("%s\n",str);

    return 0;
}
```

- char *
    - 该方式所修饰的字符串，同样也是一段内存空间连续的字符，但是区别于数组的是，由于其本身是指针，所以我们不能使用 [[sizeof]] 去获取该字符串的具体的长度
    - [[char *]] 所修饰的一个字符串常量，会存储在内存的 [[.rodata]] 段中，也就是说，这种方式所修饰的字符串是只读的 [[const char *]] ，即我们可以修改指针变量去指向其他地址，却不能够修改指针变量当前所指向的地址在内存中的内容，除此之外，还有一个特性，由于 .rodata 段中的数据的生命周期会延续到程序的结束，也就是说通过该方式所定义的字符串，如果所赋值的字符串是相同的话，则不同的指针变量会指向同一块内存空间，比如说定义了两个字符串：[[char *str1 = "Hello"; char *str2 = "Hello";]] 这时候这两个 char 类型指针所指向的地址其实是同一个的

```c
#include<stdio.h>

int main(void){

    char *str = "Hello,World!";
    printf("%s\n",str);

    return 0;
}
```

其实，不管是通过 [[char *]] 定义一个字符串也好还是通过一个 <kbd>char []</kbd>，其本质都是一样的， [[char *]] 在定义完成后始终指向字符串首元素的内存地址，并且后面字符的内存地址也是连续的存储空间，而数组本身也是一个指针常量，指向数组首元素的内存地址，但是对于数组或指针，它们之间在类型上还是存在的一些独有的特性，具体就看使用的时候进行取舍了

<br/>

#### c 标准库所提供的针对于字符串操作的 API
<span id="c标准库所提供的针对于字符串操作的API"></span>

#### int sprintf(char *str, const char *format, ...)
##### <string.h>

将 [format形参](#形参format) 所提供的格式化模板再结合所录入的可变参数 [[...]] 生成一个新的字符串，并把这个字符串的数据拷贝到字符指针 [[str]] 所指向的内存空间当中，如果成功返回 [[0]]，如果失败则返回 [[-1]]

如果 [[str]] 所指向的内存段在保证内存空间充足的前体现下，该函数会在写入完成后在结尾添加 [[\0]] 字符串结束标识符

```c
#include <stdio.h>

int main(void){

	char *hello = "Hello";
	char *world = "world";

	char str[64] = { 0 };
	sprintf(str, "%s,%s", hello, world);

    printf("%s\n",str);

    return 0;
}
```

<br/>

#### int sscanf(const char *str, const char *format, ...)
##### <string.h>

将 [format形参](#形参format) 所提供的格式化模式从字符指针 [[str]] 所指向的内存空间中取出数据，并依次写入到所指定的可变参数 [[...]] 所使用的内存空间当中，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    int a, b, c, d;
	char *str = "1 + 2 + 3 = 6";

	sscanf(str, "%d + %d + %d = %d", &a, &b, &c, &d);

	printf("a = %d, b =%d, c = %d, d = %d\n", a, b, c, d);

    return 0;
}
```

<br/>


#### size_t strlen(char const *str) --> <string.h>

获取一个字符串真实有效长度（不包含 [[\0]] )

```c
#include <stdio.h>
#include <string.h>

int main(){

    char *str = "Hello,World!";
	size_t len = strlen(str);

	printf("%d\n", len);

    return 0;
}
```

<br/>

#### char *strstr(char *source_str, char *sub_str)
##### <string.h>

自左向右检索字符串 [[source_str]] 中，字符串 [[sub_str]] 第一次出现的位置，如果存在，则返回出现位置开始的地址，**该地址并不是一个新的地址，而是相对于字符串 [[source_str]] 首地址进行 [[n]] 位偏移的地址**{style="color:red"} ，如果不存在，则返回空指针

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *source_str = "Hello,World!";
	char *sub_str = "Wo";

	char *find_str = strstr(source_str, sub_str);

	printf("%s\n", find_str);

    return 0;
}
```

```c
+---+
| 0 |
+---+ <---+ 0x00ee7b3B
| d |
+---+ <---+ 0x00ee7b3A
| l |
+---+ <---+ 0x00ee7b39
| r |
+---+ <---+ 0x00ee7b38
| o |
+---+ <---+ 0x00ee7b37
| W |
+---+ <---+ 0x00ee7b36 <----+ find_str
| , |
+---+ <---+ 0x00ee7b35
| o |
+---+ <---+ 0x00ee7b34
| l |
+---+ <---+ 0x00ee7b33
| l |
+---+ <---+ 0x00ee7b32                                     +---+
| e |                                                      | o |
+---+ <---+ 0x00ee7b31                                     +---+ <---+ 0x00ee7b51
| H |                                                      | W |
+---+ <---+ 0x00ee7b30 <----+ source_str                   +---+ <---+ 0x00ee7b50 <----+ sub_str
```

<br/>

#### char *strchr(const char *source_str, int sub_char)
##### <string.h>

自左向右检索字符串 [[source_str]] 中，字符 [[sub_char]] 第一次出现的位置，如果存在，则返回出现位置开始的地址，**该地址并不是一个新的地址，而是相对于字符串 [[source_str]] 首地址进行 [[n]] 位偏移的地址**{style="color:red"} ，如果不存在，则返回空指针

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *source_str = "Hello,World!";
	char sub_char = 'l';

	char *find_str = strchr(source_str, sub_char);

	printf("%s\n", find_str);

    return 0;
}
```

```c
+---+
| 0 |
+---+ <---+ 0x00ee7b3B
| d |
+---+ <---+ 0x00ee7b3A
| l |
+---+ <---+ 0x00ee7b39
| r |
+---+ <---+ 0x00ee7b38
| o |
+---+ <---+ 0x00ee7b37
| W |
+---+ <---+ 0x00ee7b36 
| , |
+---+ <---+ 0x00ee7b35 
| o |
+---+ <---+ 0x00ee7b34
| l |
+---+ <---+ 0x00ee7b33
| l |
+---+ <---+ 0x00ee7b32 <----+ find_str                                 
| e |                                                      
+---+ <---+ 0x00ee7b31                                     +---+
| H |                                                      | W |
+---+ <---+ 0x00ee7b30 <----+ source_str                   +---+ <---+ sub_char
```

<br/>

#### char *strcpy(char *dest, const char *src)
##### <string.h>

把字符串 [[src]] 中的所有数据数据拷贝到字符串 [[dest]] 中 ( 字符指针 [[src]] 所指向的内存空间中存储的数据拷贝到字符指针 [[dest]] 所指向的内存空间中 )，并返回 [[dest]] 所指向的首地址

该函数的使用是不太安全的，因为我们需要保证 [[dest]] 所指向的内存段的大小要满足于 [[src]] 所指向的内存段，就算 [[dest]] 所指向的内存段的大小小于 [[src]] 所指向的内存段，该函数还是会调用成功，但是可能会产生 [[野指针]] 的数据

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str_source = "Hello,World!";
	char str_cpy[32] = { 0 };

	strcpy(str_cpy, str_source);

	printf("source = %s\n",str_source);
	printf("copy   = %s\n",str_cpy);

    return 0;
}
```

<br/>

#### char *strncpy(char *dest, const char *src, size_t n)
##### <string.h>

把字符串 [[src]] 中的 [[n]] [[Bytes]] 的数据拷贝到字符串 [[dest]] 中 ( 字符指针 [[src]] 所指向的内存空间中存储的前 [[n]] [[Bytes]] 的数据拷贝到字符指针 [[dest]] 所指向的内存空间中 )，并返回 [[dest]] 所指向的首地址

该函数较于 [[strcpy]] 函数是安全的，因为该函数在拷贝的过程中能够指定具体需要从 [[str]] 中拷贝 [[n]] 个 [[bytes]] 的数据，这样就能够减少发生 [[野指针]] 数据的可能

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str_source = "Hello,World!";
	char str_cpy[32] = { 0 };

	strncpy(str_cpy, str_source, strlen(str_source));

	printf("source = %s\n",str_source);
	printf("copy   = %s\n",str_cpy);

    return 0;
}
```

<br/>

#### char *strcat(char *dest, const char *src)
##### <string.h>

把字符串 [[src]] 中的有效数据 ( 不包含 [[\0]] ) 全部追加写入到字符串 [[dest]] 所指向的内存空间当中，并在 [[dest]] 字符串有效数据的末尾添加 [[\0]] 字符，最后会返回 [[dest]] 所指向的首地址

该函数是不安全的，因为我们需要保证 [[dest]] 所指向的内存段要有足够的空间去追加 [[src]] 所指向的内存空间里面的数据，就算 [[dest]] 所指向的内存段的大小并没有足够的空间去追加 [[src]] 所指向的内存空间段里面的数据，该函数还是会调用成功，但是可能会产生 [[野指针]] 的数据

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str_source = "World!";
	char str_dest[16] = "Hello,";
	strcat(str_dest, str_source);

	printf("%s\n", str_dest);
    return 0;
}
```

<br/>

#### char *strncat(char *dest, const char *src, size_t n)
##### <string.h>

把字符串 [[src]] 中前 [[n]] [[Bytes]] 的有效数据 ( 不包含 [[\0]] ) 追加写入到字符串 [[dest]] 所指向的内存空间当中，并在 [[dest]] 字符串有效数据的末尾添加 [[\0]] 字符，最后会返回 [[dest]] 所指向的首地址

该函数较于 [[strcat]] 函数是安全的，因为该函数在调用的过程中能够决定具体需要从 [[str]] 中读取 [[n]] 个 [[bytes]] 的数据再追加到 [[dest]] 所指向的内存空间当中，这样就能够减少发生 [[野指针]] 数据的可能

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str_source = "World!";
	char str_dest[16] = "Hello,";
	strcat(str_dest, str_source, strlen(str_source));

	printf("%s\n", str_dest);
    return 0;
}
```

<br/>

#### int strcmp(const char *str1, const char *str2)
##### <string.h>

挨个比较 [[str1]] 字符串和 [[str2]] 字符串中每个字符的 [[ASCII 码]] 大小
- 如果所有字符都是相同则返回 [[0]] 
- 如果 [[str1]] 中的某个字符 [[>]] [[str2]] 中的某个字符则返回 [[1]]
- 如果 [[str1]] 中的某个字符 [[<]] [[str2]] 中的某个字符则返回 [[-1]]

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str1 = "abc";
	char *str2 = "adc";
	int result = strcmp(str1, str2);

	printf("result = %d\n", result);

    return 0;
}
```

<br/>

#### int strncmp(const char *s1, const char *s2, size_t n)
##### <string.h>

挨个比较 [[str1]] 字符串和 [[str2]] 字符串中前 [[n]] 个字符的 [[ASCII 码]] 大小

- 如果所有字符都是相同则返回 [[0]] 
- 如果 [[str1]] 中的某个字符 [[>]] [[str2]] 中的某个字符则返回 [[1]]
- 如果 [[str1]] 中的某个字符 [[<]] [[str2]] 中的某个字符则返回 [[-1]]

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str1 = "abc";
	char *str2 = "adc";
	int result = strcmp(str1, str2, strlen(str1));

	printf("result = %d\n", result);

    return 0;
}
```

<br/>

#### char *strtok(char *str, const char *delim)
##### <string.h>

根据字符串 [[delim]] 所给定的字符 ( **可以给定字符串进行多字符匹配，需要注意的是，该函数至始至终都是按照一个字符一个字符去匹配的，而不会根据一串字符串**{style="color:red"} ) 去分割 [[str]] 字符串中的内容，并返回分割后前置的结果的首地址 ( <span style = "color:red">该地址并不是一个新的地址，而是相对于字符串 [[str]] 首地址进行 n 位偏移的地址</span> )，并且会在原有字符串 [[str]] 的基础上，形成分割的部分所映射的内存空间置为 [[\0]]，如果字符串 [[str]] 中没有任何内容以供分隔符 [[delim]] 做分割，则该函数会直接返回 [[str]] 所指向的首地址，举个例子，给定原始字符串为 [["Hello.World.NGPONG"]] 并使用 [["."]] 作为分隔符，则调用一次后的结果则为 [["Hello\0"]] ，而原始字符串的内容则变成 [["Hello\0World.NGPONG"]]

该函数所对应的源文件中保有一个 [[静态变量]] ，该静态变量会保存在上一次调用成功该函数后，所分割的剩余的内容，比如说，给定原始字符串为 [["Hello.World.NGPONG"]] 并使用 [["."]] 作为分隔符，则调用一次后的结果则为 [["Hello\0"]]，而原始字符串的内容则变成 [["Hello\0World.NGPONG"]] ，而在该函数调用完成后，其内部的静态变量所存储的则为 [["World.NGPONG"]]，当我们对于参数 [[str]] 指定为 [[NULL]] 的时候，此次分割操作所需的字符串数据源则采纳上一次分割后所剩下的结果来充当，即 [["World.NGPONG"]]，我们可以采纳这一特性去循环的分割一个字符串中的所有内容，直至该函数的结果返回 [[NULL]] ( 当找不到任何分隔符 [[delim]] 在原始字符串中找不到任何数据进行分割的时候，则返回所传入的 [[str]] 所指向的首地址 ) ，则表示已经没有任何内容以供分割

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char str[] = "He.ll.oW.or.ld!";

	printf("%s\n", strtok(str, "."));

	char *str_split = NULL;
	while (1) {

		str_split = strtok(NULL, ".");
		if (str_split == NULL) {
		
			printf("end of strtok");
			return;
		}
		printf("%s\n", str_split);
	}

    return 0;
}
```
```c
+---+                                                           +---+
| 0 |                                                           | 0 |
+---+ <---+ 0x00ee7b3F                                          +---+ <---+ 0x00ee7b3F
| . |                                                           | 0 |
+---+ <---+ 0x00ee7b3E                                          +---+ <---+ 0x00ee7b3E
| d |                                                           | d |
+---+ <---+ 0x00ee7b3D                                          +---+ <---+ 0x00ee7b3D
| l |                                                           | l |
+---+ <---+ 0x00ee7b3C                                          +---+ <---+ 0x00ee7b3C
| . |                                                           | 0 |
+---+ <---+ 0x00ee7b3B                                          +---+ <---+ 0x00ee7b3B
| r |                                                           | r |
+---+ <---+ 0x00ee7b3A                                          +---+ <---+ 0x00ee7b3A
| o |                                                           | o |
+---+ <---+ 0x00ee7b39                 +-+RESULT+->             +---+ <---+ 0x00ee7b39
| . |                                                           | 0 |
+---+ <---+ 0x00ee7b38                                          +---+ <---+ 0x00ee7b38
| W |                                                           | W |
+---+ <---+ 0x00ee7b37                                          +---+ <---+ 0x00ee7b37
| o |                                                           | o |
+---+ <---+ 0x00ee7b36                                          +---+ <---+ 0x00ee7b36
| . |                                                           | 0 |
+---+ <---+ 0x00ee7b35                                          +---+ <---+ 0x00ee7b35
| l |                                                           | l |
+---+ <---+ 0x00ee7b34                                          +---+ <---+ 0x00ee7b34
| l |                                                           | l |
+---+ <---+ 0x00ee7b33                                          +---+ <---+ 0x00ee7b33
| . |                                                           | 0 |
+---+ <---+ 0x00ee7b32                                          +---+ <---+ 0x00ee7b32
| e |                                                           | e |
+---+ <---+ 0x00ee7b31                                          +---+ <---+ 0x00ee7b31
| H |                                                           | H |
+---+ <---+ 0x00ee7b30 <----+ str                               +---+ <---+ 0x00ee7b30 <----+ str      
```

<br/> 

#### int atoi(const char *str)
##### <string.h>

将字符串转换为整型，如果成功则返回转换成功后的数字，如果失败则返回 [[0]]

该函数会整体扫描 [[str]] 字符串，并跳过空格字符，直到遇到数字或正负号才作为转换依据的开始，而遇到非数字或结束符 [[\0]] 才作为转换依据的结束

```c
#include <stdio.h>
#include <string.h>

int main(void) {

	char *str = "   1024a";

	int i = atoi(str);

	return 0;
}
```

<br/> 

#### int atof(const char *str)
##### <string.h>

将字符串转换为浮点型，如果成功则返回转换成功后的数字，如果失败则返回 [[0]]

该函数会整体扫描 [[str]] 字符串，并跳过空格字符，直到遇到数字或正负号才作为转换依据的开始，而遇到非数字或结束符 [[\0]] 才作为转换依据的结束

```c
#include <stdio.h>
#include <string.h>

int main(void) {

	char *str = "   1024a";

	float i = atof(str);

	return 0;
}
```

<br/> 

#### int atol(const char *str)
##### <string.h>

将字符串转换为长整型，如果成功则返回转换成功后的数字，如果失败则返回 [[0]]

该函数会整体扫描 [[str]] 字符串，并跳过空格字符，直到遇到数字或正负号才作为转换依据的开始，而遇到非数字或结束符 [[\0]] 才作为转换依据的结束

```c
#include <stdio.h>
#include <string.h>

int main(void) {

	char *str = "   1024a";

	long i = atol(str);

	return 0;
}
```

<br/> 

#### int toupper(char _ch)
##### <ctype.h>

将字符 [[_ch]] 转换大写并返回转换后字符

```c
#include <stdio.h>
#include <ctype.h>

int main(void) {
    char _ch = toupper('a');
	return 0;
}
```

<br/> 

#### int tolower(char _ch)
##### <ctype.h>

将字符 [[_ch]] 转换小写并返回转换后字符

```c
#include <stdio.h>
#include <ctype.h>

int main(void) {
    char _ch = tolower('a');
	return 0;
}
```

<br/>

#### void *memset(void *ptr, int value, size_t n)
##### <string.h>

初始化指针 [[ptr]] 所指向的内存段中前 [[n]] 的 [[Bytes]] 的值为 [[value]]

由于该函数是按 [[Bytes]] 来进行初始化我们所预设的值 [[value]]，故 [[value]] 的真实取值范围为 [[0 ~ 255]]，即 [[1111 1111]] ，举个例子，比如说我们设置 int 的类型 4 个字节的值为 63，那么这个 int 类型在内存中所真实存储的数据如下图

```c
+---------+
|0011 1111|
+---------+
|0011 1111|
+---------+
|0011 1111|
+---------+
|0011 1111|
+---------+
```

```c
#include <stdio.h>
#include <string.h>

int main(void){

 	char str[8] = { 0 };
	memset(str, 65, sizeof(str) - 1);

	printf("%s\n", str);

    return 0;
}
```

<br/>

#### void *memcpy(void *dest, const void *src, size_t n)
##### <string.h>

将 [[src]] 所指向的内存空间中的前 [[n]] 个 [[Bytes]] 的数据拷贝到 [[dest]] 所指向的内存空间中

虽然该函数对于拷贝的效率比较高，但是对于 [[dest]] 和 [[src]] 所指向的内存空间中存在 **重叠区域**{style="color:red"} 的问题时，该函数可能会出现错误

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str_source = "Hello,World!";
	char str_dest[64] = { 0 };

	memcpy(str_dest, str_source, strlen(str_source));

	printf("%s\n", str_dest);

    return 0;
}
```

<br/>

#### void *memmove(void *dest, const void *src, size_t n)
##### <string.h>

将 [[src]] 所指向的内存空间中的前 [[n]] 个 [[Bytes]] 的数据拷贝到 [[dest]] 所指向的内存空间中

该函数和 [[memcpy]] 的功能是一致的，但是该函数在对于 [[dest]] 和 [[src]] 所指向的内存空间中存在 **重叠区域**{style="color:red"} 的问题时，该函数任然能够正常执行，而就效率而言，该函数任然要低于 [[memcpy]]

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str_source = "Hello,World!";
	char str_dest[64] = { 0 };

	memmove(str_dest, str_source, strlen(str_source));

	printf("%s\n", str_dest);

    return 0;
}
```

<br/>

#### int memcmp(const void *buffer1, const void *buffer2, size_t n)
##### <string.h>

挨字节比较 [[buffer1]] 所指向的内存空间和 [[buffer2]] 所指向的内存空间中前 [[n]] 个字节的大小

- 如果所有字节都相同，则返回 [[0]] 
- 如果 [[buffer1]] 所指向的内存空间中的某个字节 [[>]] [[buffer2]] 所指向的内存空间中的某个字节，则返回 [[1]]
- 如果 [[buffer1]] 所指向的内存空间中的某个字节 [[<]] [[buffer2]] 所指向的内存空间中的某个字节，则返回 [[-1]]

```c
#include <stdio.h>
#include <string.h>

int main(void){

    /*
	0000 0000
	0000 0000
	0000 0000
	0001 1001
	*/
	int a = 25; 

	/*
	0000 0000
	0000 0000
	0000 0000
	0011 1001
	*/
	int b = 57;

	int result = memcmp(&a, &b, sizeof(int));

    return 0;
}
```


<br/>

### heap
<span id="heap"></span>

---

前面在内存4区中说到，关于堆的管理由开发人员进行维护和释放，在 c 中，对于 [[heap]] 的管理操作由以下几个函数来完成

#### void *malloc(size_t size)
##### <corecrt_malloc.h>

该函数能够在堆中申请 [[size]] 个内存单元的存储空间，如果成功，则返回指向这段存储空间中的首地址的万能指针，意味着在这个首地址往后的 [[size]] 个 ( 包括首地址 ) 字节的地址都是成功申请且安全可用的，如果申请失败，则返回一个空指针

所申请 [[size]] 个内存单元中的地址是 [[连续]] 的，通过这一特性，我们通常把所申请的内存空间用于当作 [[数组]] / [[结构体]] / [[字符串]] 来使用

该函数如果 [[size]] 指定的字节大小为 [[0]] 的时候，还是能够成功申请的，但是一旦我们尝试对所返回的地址进行任意写入操作的时候，我们在后面尝试通过 [[free]] 函数释放这块内存空间的时候就会出现错误，当然这种情况并不仅仅针对我们申请了 [[0 Bytes]] 的空间，而是我们所使用的内存空间不能够大于所申请的内存空间，否则该内存段在调用 [[free]] 函数释放的时候则会出现错误

```c
int main(void) {

    int *nums = malloc(sizeof(int) * 4);
	if (nums == NULL) {
	
		perror("heap error");
		return -1;
	}
	nums[0] = 1;
	nums[1] = 2;
	nums[2] = 3;
	nums[3] = 4;

	for (size_t i = 0; i < 4; i++) {

		printf("%d\t", *(nums + i));
	}

	free(nums);

    return 0;
}
```

<br/>

#### void free(void *ptr)
##### <corecrt_malloc.h>

根据指向堆中所申请的一段存储空间的首地址 [[ptr]] 的指针释放掉其所对应申请的空间

在成功调用完该函数后，ptr 所对应所指向的内存空间不会立即释放，只是标记为释放，并未真正释放，简而言之就是程序放弃了对这块内存空间的使用权限，内核系统会在适当的时候会真正的释放掉这块内存空间所使用的诗句或者是填充为其他数据

对于一个空指针来说该函数是能够成功调用的，并且可以反复进行调用，但是对于非空指针并且是一个已经进行过 [[free 函数调用的指针]] 来说，重复调用则会出现错误

[[ptr]] 必须是一个真实有效的指针，并且 [[它所指向的地址必须为在堆中所申请的内存空间的首地址]] ，比如说申请了 20 个字节的空间，返回地址为 [[0x00000001]]，这时候我们尝试让这个指针偏移1位 ( 指针类型为 [[char *]] )，那指针所指向的地址则为 [[0x00000002]]，这时候我们使用这个指针调用这个 [[free]] 函数的时候则会出错，原因是当前指针的地址并不是所申请的内存空间的首地址 [[0x00000001]] ，造成这种问题的原因是因为每次在堆中申请空间后，都会有一种记录表记录着当前所申请的内存大小，还有其对应的内存单元的首地址，我们申请空间的时候所返回的指针指向的地址为 [[0x00000001]] ，那么那张表中就是记录着 [[0x00000001]] 这时候我们使用 [[0x00000002]] 的地址区释放，就会报错了，因为在表中找不到相应的映射 

```c
#include<stdio.h>

struct Person {

    char *name;
    int age;
};

int main(void){

    struct Person *pers = malloc(sizeof(struct Person[2]));
    if (pers == NULL) {
        
        perror("heap error");
        return -1;
    }

    pers[0].name = "NGPONG";
    pers[0].age = 23;

    pers[1].name = "TEST";
    pers[1].age = 999;

    printf("pers[0] name = %s\n", pers[0].name);
    printf("pers[0] age = %d\n", pers[0].age);
    printf("pers[1] name = %s\n", pers[1].name);
    printf("pers[1] age = %d\n", pers[1].age);

    free(pers);

    return 0;
}
```

<br/>

#### void *calloc(size_t nmemb, size_t size)
##### <corecrt_malloc.h>

该函数能够在堆中申请 [[size]] 个内存单元的存储空间，如果成功，则返回指向这段存储空间中的首地址的万能指针，意味着在这个首地址往后的 [[size * nmemb]] 个 ( 包括首地址 ) 字节的地址都是成功申请且安全可用的，如果申请失败，则返回一个空指针

该函数的使用和 [[malloc]] 一致，故这里不做额外的讲解

```c
#include<stdio.h>

int main(void){

	char *str = calloc(sizeof(char), 64);
	if (str == NULL) {
		
		perror("heap error");
		return -1;
	}

	memcpy(str, "Hello,World!", 13);
	printf("%s\n", str);

	free(str);

    return 0;
}
```

<br/>

#### void *realloc(void *ptr, size_t size)
##### <corecrt_malloc.h>

该函数能够重新分配 [[ptr]] 在堆中可用内存空间的大小，如果重新申请成功，该函数则返回在堆中新分配的内存空间的首地址 ( 可能是原始 [[ptr]] 所指向的地址 ) ，如果申请失败，则返回 [[NULL]]

- 如果指定的 [[ptr]] 所指向的地址所代表的内存段的后面还留有连续的空间，那么就会在已有地址基础上增加内存，[[并返回原始 ptr 所指向的地址]]
- 如果指定的 [[ptr]] 所指向的地址的后面没有连续的空间，那么该函数会在堆中重新申请一块连续的内存，[[并把 ptr 旧内存空间所存储的值拷贝到新申请的内存空间中，同时释放 ptr 所指向的旧内存空间，最后返回新申请的内存的地址]]
- 如果指定的 [[ptr]] 原有的内存空间大小要小于所指定的 [[size]] ，则会根据原有 [[ptr]] 所申请的内存空间去保留 [[size]] 个内存单元，余后的内存空间全部都释放掉，最后返回原始 [[ptr]] 所指向的地址

```c
#include<stdio.h>

int main(void){

	char *str = calloc(sizeof(char), 13);
	if (str == NULL) {
		
		perror("heap error");
		return -1;
	}

	memcpy(str, "Hello,World!", 13);
	printf("%s\n", str);

	str = realloc(str, 32);
	if (str == NULL) {

		perror("heap error");
		return -1;
	}

	memcpy(str, "realloc memtest!", 32);
	printf("%s\n", str);

	free(str);

    return 0;
}
```


<br/>

### 函数
<span id="函数"></span>

---

#### 函数的声明和定义
<span id="函数的声明和定义"></span>

在 c 中，函数的定义和其他语言类似，也是要遵循 **返回值**{style="color:red"} **函数名**{style="color:red"} **参数**{style="color:red"} **函数体**{style="color:red"} 的格式进行一个函数的定义，存在着一点不同的是，，以下代码则为我们定义了一个函数

```c
#include<stdio.h>

int fun_test(void){

    printf("fun_test ok!");
    return 0;
}

int main(void){

    fun_test();
    return 0;
}
```

!!!INFO
    这里需要额外扩充几点
    - 在 c 中，函数的定义通常以 **int类型的返回值作为当前函数调用的状态**{style="color:red"}，如果返回 **0 则代表成功**{style="color:red"}，返回 **非 0 则代表失败**{style="color:red"}
    - 一个函数一旦定义成功，其会存储在内存的 [[.text]] 段当中
    - 在 c 中可以对 [[parameter]] 列表中使用 [[void]] 以强调该函数是一个无参的函数，虽然使用了该方式后对编译器进行编译的时候没有什么影响，甚至我们把函数定义为无参函数也同样可以传参数进去，但通过这种方式定义一个无参的函数能够让开发人员更好的注意到该函数在参数上的特性


在 c 中，对于一个函数的调用，必须要存在该函数的定义，如果一个函数并没有进行过定义而我们还是尝试使用了这个函数的话，则会出现编译级的错误

此外，如果函数的定义并不在调用该函数代码那一行之前进行的定义，则需要有一个函数的声明; 由于函数的声明是只能够在全局作用域下进行，并且对于编译器来说在编译阶段都会为其添加上 [extern 关键字](#extern) ，也就是说， **函数的声明呈一个外部链接形式的状态**{style="color:red"} ，以便在编译器对调用了该函数声明代码进行编译的时候，据此声明进行逐文件 ( 包括当前文件的任意位置 ) 检查是否有符合该声明的函数的定义，如果有的话，则会把该声明隐式提升为所映射定义的函数的定义，否则会出现编译级的错误

那么如果调用函数的代码在定义函数之前，并且调用函数代码之前也没有进行过函数的声明，**则编译器以默认的格式为我们添加一个函数的声明**{style="color:red"}，这个格式则为 **返回值为 int 类型，函数名相同，没有参数**{style="color:red"}，这种方式也称作 **函数的隐式声明**{style="color:red"}，但是这个隐式声明存在一点情况需要注意，比如我们在主函数中调用了一个函数 [[void fun_Test()]] ，这个函数是定义在 main 函数的后面，而 main 函数之前也没有声明过此函数，这时候在编译的时候，由于隐式的帮我把添加一个当前函数的声明 [[int fun_Test()]]，这时候继续编译的时候就会报错了，为什么？因为隐式声明的函数和 fun_Test 函数本身定义的返回值是不一样的，一个是 [[int]] ，一个是 [[void]] ，这时候就会出现函数的重载的情况，但是在 c 中函数是无法重载的，所以就会造成编译错误 **重定义 : 不同的基类型**{style="color:red"}

在 c 中，**不管是函数的声明也还还是函数的定义，都不能存在重载的情况**{style="color:red"}，这是 c 语言本身所不支持的，并且，函数的定义不能在相同函数 [[signature]] 的基础上进行重复定义，而函数的声明是支持在相同函数 [[signature]] 的基础上进行重复定义的

```c
#include<stdio.h>

int fun_test(char *str);

int main(void){

    char *str = "Hello,World!";
    fun_test(str);

    return 0;
}

int fun_test(char *str){

    printf("%s\n",str);
}
```

<br/>

#### 栈与栈帧
<span id="栈与栈帧"></span>

什么是栈 ?

栈是计算机系统负责维护的一块动态内存区域，它属于数据结构中的一种，限定仅在表尾进行插入或删除操作的线性表，按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据

!!! 

    这里被叫做压栈，但实际上栈的存储结构由于是高地址向低地址延伸，所以其存储模型是倒过来的，故压栈其实称为 [[顶栈]] 个人认为更为合适

把栈简单理解成集合也不为过，而作为集合中的元素就是帧 ( frame ) ，具体来讲则是 [[栈帧]]

在栈中，始终有一个指针指向栈顶 ( [[最上级栈帧]] ) ，它是 [[ESP(X86) / RSP(X64)]] 寄存器

<span style="color:red">栈是从高地址向低地址延伸</span>，区别于之前所讨论到的二进制数据在内存中的存在方式 ( [[由低向高衍生]] ) ，关于栈为什么要设计从从高地址向低地址衍生的原因，可以参考这篇 [文章](https://www.zhihu.com/question/29520755) 的讨论内容


什么是栈帧

栈帧是栈中所存储的元素，每个所压入栈的栈帧可以代表着一个函数的调用，栈帧也叫过程活动记录，是 [[编译器用来实现 过程 / 函数 调用的一种数据结构]] ，每一次函数的调用，都会把函数中的一些信息一次压入一个栈帧内做一次独立的封装 ( 栈帧 ) ，然后再把这个 栈帧 压入至线程栈上，以供处理器进行调用，当一个栈帧在压入线程栈的那一刻我们可以理解为这是一个函数生命周期的开始，当一个函数调用结束后 ( 具体来说执行了 [[ret 指令]] ) 并返回相应的值 (压栈前代码执行段的地址) ，这个栈帧内所压入的数据会依次 出栈 直至自身 ( 压入线程栈中的栈帧 ) 弹出，并依照出栈的顺序依次释放掉其所使用的内存空间 ( 只是标记为释放，并未真正释放，简而言之就是程序放弃了对这块内存空间的使用权限，在适当的时候会真正的释放或填充为其他数据 ) ，也就是一个函数的生命周期的结束

每个栈帧之间是相互独立的存在，一个独立的栈帧中大致包括

- 函数的返回地址
- 函数的形参
- 函数的非静态局部变量以及编译器自动生成的其他临时变量
- 函数调用的上下文
- 调用函数前代码执行段的地址

<span style="color:red">在一个函数中所定义的非静态局部变量会依代码顺序至上而下的压入栈帧中</span>，<span style="color:red">而一个函数中的形参在默认的 [[调用惯例]] 下会按定义顺序从右至左的压入栈帧中</span>，需要注意的是，它们的地址始终都是从高位到低位进行定义存储的，此外，函数的形参由右至左从高位到低位默认偏移4个字节的内存地址，如果形参的类型大于4个字节，则偏移对应类型存储空间大小的地址，比如说形参为 [[char a,double b,int c]] ,那么它们的内存空间地址则为

- a : 0x00000000
- b : 0x00000004
- c : 0x0000000C

在一个栈帧中，始终有一个指针指向栈帧的底部，他就是 [[EBP]] 寄存器， 前面说到，栈帧是栈里面所压入的元素，而栈帧之间是相互独立的存在的，当我们调用一次函数的时候，就会把当前函数的一些信息依次压入栈中，那么是如何做到不同栈帧之间的独立性呢？就是依靠的两个指针 [[Stack Pointer]] [[Frame Pointer]] ，当函数在调用的时候，内核会封装好函数的信息到一个栈帧中并将其压入栈内，[[Stack Pointer]] 会相应的往后偏移 [[4 (X32) / 8 (X86)]] 位，使得 [[Stack Pointer]] 位于栈帧的顶部，此外， [[Frame Pointer]] 也会移动至 [[Current Stack Frame]] 身上，以此来划定一个栈帧所存在的范围

以下则为栈帧和栈的存储示意图

```c
   TOP	       STACK BOTTOM
    ↑	        	↑
    |	        	|  	   
    |	        	+-------------------------------------------------------------------+
    |	        	|	**********************											|			
    |	        	|	*     More Frame     *   										|			
    |	        	|	**********************  										|
    |	        	|																	|														
    |	        	|	+--------------------+--> Frame Pointer: EBP 					|
    |	         	|	|  Return Address    |											|
    |	        	|	|  Function Content  +--> Function Name: main  					|			
    |	        	|	|  Local variable	 |   										|			
    |	        	|	|  Parameter     	 |  										|			
    |	        	|	+--------------------+--> Stack Pointer: ESP(X86) / RSP(X64)    |				
    |	        	|	   																|	    	
   LOW              +																	+        
                    |
                    ↓
                STACK TOP
```

<br/>

#### 关于函数的返回值问题
<span id="关于函数的返回值问题"></span>

由于一个函数内部的大部分定义的生命周期都活动在一个栈帧的范围内，也就是说在一个函数调用结束后，也就是栈帧出栈后，栈帧内部所使用的存储空间会被标记为释放，所以关于函数的返回值有一些需要进行注意的地方

- 返回普通的变量
    - 这种方式返回是没任何问题的，因为返回的普通变量的值只是对于当前调用函数上下文中某个内存空间所映射的值拷贝到另一个调用者栈帧中的工作

- 返回指针
    - 当我们需要返回指针变量的时候，切记， [[所返回的指针的指向不能是当前所调用函数上下文中的任何一个变量的信息]] ，包括形参、局部变量、使用 [[const]] 所修饰的局部变量、…… 等一切非静态的变量，因为一个函数在调用完成后，其所对应的栈帧也会出栈，并且所使用的内存空间也会被标记为销毁，虽然我们在第一次调用完一个返回指向当前调用函数上下文信息局部变量的指针的时候，这个指针所对应的内存空间的值在后面还是可以继续读取到，毕竟这个指针的内存地址是一个已被标记为销毁的状态，也就是程序只是放弃了对这块内存空间的使用权限，但不意味着马上销毁，意味着系统内核可能会在未来的某个时刻中将这个内存地址所占用的空间真正的释放掉或填充为其他数据，所以需要谨记的是，当使用指针作为函数返回值的时候，一定不能返回当前调用函数上下文中的任何信息的指针

- 返回数组
    - 从语法上是不可行的，所以我们只能够返回一个指针

!!! danger 注意
    需要我们注意的是，函数的返回值具体来说并不是 $callee$ 所处栈帧上下文中所存储的内容，而是会以一个 <font color = "red">当前返回值类型的临时变量</font> 的形式转存在到函数的 $caller$ 所处栈帧的作用域内，当一个函数调用完毕并返回后，如果我们并没有 <font color = "red">显式</font> 的使用一个 新的 / 已被初始化好的 变量去拷贝调用函数所返回的临时变量在内存中的字节，则该临时变量会在函数调用完毕后也会随之释放
    
    需要强调的是，作为这个函数返回值的临时变量的释放时机和在当前栈帧作用域内所声明的临时变量不同，我们在一个函数中所声明的存储在栈中的临时变量其释放时机是跟随着当前栈帧的出栈而随之释放，而对于函数的返回值所构造出来的临时变量来说，其虽然也是在当前栈帧作用域内所存储的一个内容，但是它的释放往往需要跟随着在完成作为临时变量的使命后 ( 把字节拷贝到作为一个表达式中的左值的变量身上 ) 才会随之释放，当然如果没有显示的指定它所需要完成使命的目标则会直接释放，这里需要扩展以下，在 [[cpp]] 中由于引入了 左值右值引用 的概念，故我们是可以延续这个临时变量的生命周期的，不过这里就不作另外的探讨了

<br/>

#### 函数指针
<span id="函数指针"></span>

一个函数在编译器进行编译后，它也有属于它的地址，这个地址就是属于该函数的一个入口，相对的，他也是有属于它的类型，比如说我们定义了一个函数

```c
#include<stdio.h>

void fun_test(int a) {

    printf("Hello,World!%d",a);
}
```

那么这个函数 [[fun_test]] 的类型就是 [[void (int)]]，既然它有属于它的类型，并且还有一个函数的入口地址，所以我们可以通过一个指针变量来修饰一个函数，而用于修饰函数的指针变量就称为 [[函数指针]]

当我们声明了一个函数指针，那么我们应该怎么样获取一个函数的入口地址以作函数指针的右值？通过 [[&函数名]] / [[单纯的使用函数名]] 即可获取到函数的入口地址，需要注意的是，虽然我们可以通过 [[&函数名]] 拿到函数的入口地址，并把它交给一个函数指针作为存储，但是如果我们单纯的使用 [[&函数名]] 打印函数的入口地址的时候，会发现其和存储在函数指针中的地址是不同的，不过这也没关系，我们只需要理解这种方式是能够正确地拿到某个函数的入口地址即可

当我们已经定义好一个函数指针后，其使用方式也和普通指针存在着一些区别，普通指针的使用方式我们还需要使用操作符 [[*]] 对地址进行解引用后才能操作指针变量内部存储的地址所对应的内存空间，而函数指针在定义好后，我们只需要像普通函数一样使用即可以完成对其所指向的函数首地址的调用，以下代码则为我们定义了一个函数指针并对它进行使用

<span id="code01"></span>
```c
#include<stdio.h>

int fun_test(char a,short b){

    printf("Hello,World!%d",a + b);
}

int main(void){

    int (*invoker)(char,short) = fun_test;
    invoker('a',256);

}
```

通过上面展示函数指针的定义方式，我们发现函数指针的定义和 [[数组指针]] 的定义方式也是类似，也是通过 [[( )]] 来提升了操作符 [[*]] 的优先级，在以上代码中，即 [[*invoker]] 组成了指针的定义，而其函数的类型就是 [[int (char,short)]]

除了能够定义一个函数指针外，我们还能够定义一个函数指针的数组，如下面的代码

```c
#include<stdio.h>

int fun_test1(void){

    printf("Hello,World1!");
}

int fun_test2(void){

    printf("Hello,World2!");
}

int fun_test3(void){

    printf("Hello,World3!");
}

int main(void){

    int (*invokers[3])(char,short);
    invokers[0] = fun_test1;
    invokers[1] = fun_test2;
    invokers[2] = fun_test3;

    for (size_t i = 0; i < sizeof(invokers) / sizeof(int (*)()); i++) {

        (*(invokers + 1))();
    }
}
```

以上面代码则为函数指针数组的定义和使用，我们发现函数指针数组的定义方式也是通过 [[( )]] 来把 <kbd>*invokers[3]</kbd> 结合为指针数组，而这种类型也是符合 [[指针数组]] 类型的定义，所以，函数指针数组其实就是一个指针数组，每个元素类型是 [[函数指针]] 的类型

最后需要补充的是，我们在声明一个函数指针的同时，也能够声明该函数指针具体的 <font color = "red">调用惯例</font> 的，就拿刚刚再 [上面](#code01) 所书写的代码来说，我们声明的函数指针类型为 [[int (*)(char,short)]] 二我们只需要在构成指针的 [[*]] 操作符的前面添加一个 预期调用惯例 即可完成对于 使用自定义的调用惯例去修饰一个函数指针的调用，如下面的代码

```c
#include<stdio.h>

__stdcall int fun_test(char a,short b){

    printf("Hello,World!%d",a + b);
}

int main(void){

    int (__stdcall *invoker)(char,short) = fun_test;
    invoker('a',256);

}
```


<br/>

### 结构体
<span id="结构体"></span>

---

有时我们需要将不同类型的数据组合成一个题有结构的整体，比如说一个学生身上的结构有 [[学号]] [[姓名]] [[性别]] [[年龄]] [[地址]] 等属性，那么如果我们单独定义以上的属性变量是一个比较繁琐过程，数据不便于管理，在 c 语言中给出了另一种构造数据类型，他叫做 [[结构体]] ，它是C语言面向对象的一种体现

结构体也是类型的一种，不过它是一种复合类型，即一个类型中包含了多种类型的定义，既然一个结构体类型的定义是通过开发人员来完成，那么我们其实也可以把结构体理解为一种自定义的类型

<br/>

#### 结构体的声明和定义
<span id="结构体的声明和定义"></span>

在 c 中，不管是声明也好还是定义，通过关键字 [[struct]] 才能够构成结构体类型的定义

关于结构体的声明和定义，我们需要先区分开来 [[结构体类型]] 与 [[结构体变量]] 

结构体类型即我们所自定义的结构体的类型，我们为某一种结构体数据类型所声明的内部存储结构模型就为声明一个结构体的类型，下面的代码则为声明了一种结构体类型 [[struct Person]]

```c
struct Person{

    char *name;
    char *address;
    int age;
    int ID;
}

int main(void){

    return 0;
}
```

!!! INFO 注意
    1. 在 c 语言中所声明的结构体类型我们必须要保证该结构体中至少含有一个成员，在 c 语言中不能存在以空结构体的类型存在
    2. 所声明的结构体类型中，对于非函数类型的成员只能够用作于声明，不能有其定义
    3. 我们所声明的结构体类型其 有效作用域 从它所定义的位置开始到本文件结束

当我们声明好了一个 [[结构体类型]] 后，我们就能够使用所声明的结构体类型去声明或定义一个结构体变量了


*关于结构体变量的声明有以下三种方式*

- 普通声明方式

```c
struct Person {

    int Age;
    int Gender;
    char Name[24];
};

int main(void){

    struct Person per;
}
```

- 声明结构体类型的同时声明了结构体变量，该方式所声明的结构体变量是全局变量

```c
#include<stdio.h>

struct Person {

	int Age;
	int Gender;
	char *Name;
} per, *p_per;

int main(void) {

	per.Age = 22;
	per.Gender = 1;
	per.Name = "NGPONG";

	p_per = &per;

	printf("person age = %d\n", p_per->Age);
	printf("person gender = %s\n", p_per->Gender == 1 ? "男" : "女");
	printf("person age = %s\n", p_per->Name);

	printf("per address = %p\n", &per);
	printf("p_per value = %p\n", p_per);

	return 0;
}
```

- 匿名结构体
    - 匿名结构体类型的声明方式是不需要指定结构体类型的类型名的，也就是说我们在声明一个匿名结构体类型的同时，必须要声明它的结构体变量
    - 所声明的匿名结构体变量则为声明了一个全局的匿名结构体变量

```c
#include<stdio.h>

struct {

    int Age;
    int Gender;
    char Name[24];
} per;

int main(void){

	per.Age = 22;
	per.Gender = 1;
	per.Name = "NGPONG";

    printf("%d\n",per.Age);

    return 0;
}
```

*关于结构体变量的定义有以下两种方式* ( 这里所说的定义指的是结构体变量初始化的过程，对于一个结构体变量进行初始化的左值操作语法只有一种，那就是在声明结构体变量的过程中通过 [[{ }]] 为结构体类型中的每个成员的顺序由上至下挨个进行预赋值 )

- 普通定义方式，声明结构体变量的同时进行定义

```c
struct Person {

    int Age;
    int Gender;
    char Name[24];
};

int main(void){

    struct Person per = {22,1,"NGPONG"};
}
```

- 声明结构体类型的同时定义了结构体变量，该方式所定义的结构体变量是全局变量
```c
#include<stdio.h>

struct Person {

	int Age;
	int Gender;
	char *Name;
} per = {22,1,"NGPONG"}, *p_per = &per;

int main(void) {

	printf("person age = %d\n", p_per->Age);
	printf("person gender = %s\n", p_per->Gender == 1 ? "男" : "女");
	printf("person age = %s\n", p_per->Name);
	printf("per address = %p\n", &per);
	printf("p_per value = %p\n", p_per);

	return 0;
}
```


<br/>

#### 结构体的内存地址
<span id="结构体的内存地址"></span>

不得不说，结构体的内存地址和数组之间是存在相似性的，首先，当我们去获取结构体变量的地址和获取结构体变量中首个 ( 最上部 ) 成员的地址发现它们是一样的，但是它们却完全不相同，当我们直接获取一个结构体变量的地址的时候，这个地址的步长则是以结构体本身的类型作为参考，而对于结构体首个成员的地址的步长参考的话，则是以该成员本身的类型来作为参考，如下面代码

```c
struct Person {

    int Age;
    int Gender;
    char Name[24];
};

int main(void){

    struct Person per = {22,1,"NGPONG"};
}
```

当我们直接获取结构体变量 [[per]] 的内存地址的时候，该地址的步长参考则按照结构体本身的类型来，即 [[struct Person]]，而对于结构体首个成员 [[Age]] 的地址的步长参考的话，则是以该成员本身的类型来作为参考，即 [[int]]

回过头来，刚才谈到结构体变量的地址和结构体首个成员的地址是相同的，那是不是意味着一个结构体变量就是一段连续的线性存储空间，其总大小就是结构体类��中所有成员大小的总和呢？对于数组来说，是的，数组中每个元素之间的地址互相之间偏移一个具体类型的单位，即步长，而对于结构体来说，该问题的答案就是 [[不一定]] 了，对于结构体其内部的成员所存放的内存首地址和所存放的长度还存在一个 [[地址补齐]] 的概念，在下一个节点会详细的探讨这一个概念

这里说到结构体的地址，不得不谈及结构体指针的概念，同样，既然我们能够获取到一个结构体变量的内存地址，那我们同样可以使用该结构体类型的指针用于接受，还是如上面的代码，假设我们使用了一个指针 [[struct Person *p_per]] 接受了结构体变量 [[per]] 的内存地址后，我们对于该结构体类型的指针 [[p_per]] 想去取结构体变量中某个成员的值得时候只需要解引用即可，如 [[(*per).Age]] 就是获取结构体成员 [[Age]] 在内存中所存储的值，除此之外，对于 [[(*per).Age]] 操作在 [[c]] 中有一个语法糖作为支持，即 [[(*per).Age]] --> [[per->Age]]

```c
#include<stdioh>

struct Person {

    int Age;
    int Gender;
    char Name[24];
} per = {22,1,"NGPONG"};

int main(void){

    struct Person *p = &per;
    printf("Person Age = %d\n",p->Age);
    printf("Person Gender = %d\n",p->Gender);
    printf("Person Name = %s\n",p->Name);

    return 0;
}
```

<br/>

#### 关于结构体的内存对齐的问题
<span id="关于结构体的内存对齐的问题"></span>

什么是内存补齐？在开始前先开一下内存补齐所带来的效果，如下面代码

```c
struct Postion {
    char x;
    int y;
};
```

在上面的代码中，我们声明了一个结构体类型 [[struct Person]] ，该结构体中有两个类型的成员分别为 [[char]] 和 [[int]]，按道理来说该结构体类型所占用的总字节应该为 [[5 Bytes]]，然而实际上的结果却为 [[8 Bytes]]，这个就是发生了 [[内存对齐]]

那么内存对齐到底有什么用呢？

尽管内存是以内存单元作为单位，即字节，但是大部分处理器并不会按一个内存单元来存取内存，它一般会以 [[2 Bytes]] / [[4 Bytes]] / [[8 Bytes]] / [[6 Bytes]] / [[32 Bytes]] 为单位来存取内存，我们将上述这些存取单位称为 [[内存的存取粒度]] ，我们假定现在考虑 [[4 Bytes 存取粒度]] 的处理器 ( 32位系统 ) 去取一个 [[int]] 类型变量的时候，该处理器只能从地址为4的倍数的内存开始读取数据，假如没有内存对齐机制，数据可以任意存放，假定该 [[int]] 类型变量在内存中的首地址为 [[0x00000001]] 那么其在内存中所占用的内存段分别为

```c
+--------+
|        |
+--------+ +---> 0x00000007
|        |
+--------+ +---> 0x00000006
|        |
+--------+ +---> 0x00000005 +--------+
|00000000|                           |
+--------+ +---> 0x00000004          |
|00000000|                           |
+--------+ +---> 0x00000003          +----> INT
|00000000|                           |
+--------+ +---> 0x00000002          |
|00000000|                           |
+--------+ +---> 0x00000001 +--------+
|        |
+--------+ +---> 0x00000000

```

那么当 CPU 去取内存中的数据的时候，我们假定 CPU 需要先从 [[0x00000000]] 地址开始，开始读取 4 个字节，也就是  [[0x00000000]] [[0x00000001]] [[0x00000002]] [[0x00000003]] ，但是 int 类型变量的首地址在 [[0x00000001]] 上，所以 CPU 本次读取需要剔除掉不需要的字节，保留后三位字节，即剔除掉 [[0x00000000]] 字节上的数据，紧接着 CPU 进行第二次访问内存的时候，从刚刚结束的位置开始，又从内存中读取了 [[4 Bytes]]，也就是 [[0x00000004]] [[0x00000005]] [[0x00000006]] [[0x00000007]] ，因为 int 类型总共只有 [[4 Bytes]] ，而 CPU 在第一次读取的时候已经访问了 [[3 Bytes]] ，故本次需要剔除掉 [[0x00000005]] [[0x00000006]] [[0x00000007]] 这 [[3 Bytes]] ，最后 CPU 再把两次读取后所剩下的结果进行合并再交给寄存器已完成本次对于该 [[int 类型变量]] 所存储的数据的访问工作，而在这个工作之中发生了两次访问内存的工作，增加了多余的工作量，我们可以把此次工作归纳为下图

![v2-3f40af513a94901b36ceb5387982277e_hd](https://i.imgur.com/LkIu3y1.jpg)

那么现在假设使用了内存对齐的机制，那么这个int类型的数据只能存放在按照对齐规则的内存中，比如说 [[0x00000000]] 地址开始的内存，这时候 CPU 就能够一次性把这 [[4 Bytes]] 的数据取出来再交到寄存器手上以完成读取工作，而且不需要做额外的操作，提升了工作效率

![v2-361e2d16876ce8383c9e6ea2dca34474_hd](https://i.imgur.com/VNKvS8q.jpg)

经过刚刚上面所说，我们发现内存对齐前和内存对齐后无非就是改变了 int 类型数据在内存中的首地址就能带来很高的效益，没错，内存对齐的主要思想就是能把一个数据的首地址按照一定的规则合理分配到某个地址上以增加 CPU 的读取效率，那么这个规则是什么样的？

首先再开始前，需要明白两个概念
- 对齐模数 : 每个特定平台上的编译器都有自己的默认 对齐模数 ，$GCC$ 中默认为 [[4]]， $MSVC$ 中默认为 [[8]] ，该值通常呈 $x^2$ 进行变更，我们可以通过以下两个语句对 对齐模数 进行变更或查看
    - #pragma pack(n) : 修改对齐模数为 [[n]]
    - #pragma pack(show) : 查看当前对齐模数，<font color = "red">仅需编译即可</font>
- 对齐单位 : 对齐模数 和当前结构体中 <font color = "red">最大长度成员的字节数</font> 两者间进行对比 ( 如果成员为数组，则取的是数组具体类型的单位，比如说某个成员为 <kbd>int [4]</kbd> 的类型，则使用它的 [[int]] 类型作为对比项 ) ，<font color = "red">取长度更小的那个作为对齐单位</font>

首先，结构体中第一个成员在内存中的首地址并无规定，即它的 [[offset]] 为 [[0]]，我们可以理解为从 [[0]] 开始，但并不一定是从 [[0]] 地址开始，而 <font color = "red">首成员具体所占用的字节长度视下一个成员而定</font> ，如果只有一个成员，那么该结构体的大小就是该成员的大小，而该成员所占用的内存空间的长度也就是该成员具体类型的长度

第一个成员以后的每个成员在内存中的首地址所在的位置，亦或者说往后成员相对于当前结构体的 [[offset]] 都是 <font color = "red">当前成员的大小 ( 如果为数组，仅取数组最低维度的元素的类</font>  和 <font color = "red">当前结构体的对齐单位</font> 进行对比 ( 如果所对比的成员的类型是一个 struct，则需要从该结构体内部的成员开始逐个对比，包括对齐单位也是获取的当前结构体成员的对齐单位，而不是取的包括当前结构体成员的结构体的对齐单位 ) ，取更小那个的整数倍作为该成员的首地址，<font color = "red">如有需要，编译器会在成员与成员之前填充空的字节</font>

在最后，该结构体还需要进行二次偏移，结构体的总大小会偏移为当前结构体的 [[对齐单位]] 的整数倍，具体至结构体中每个成员的 <font color = "red">真实字节大小</font> 的总和的近似值，比如说该结构体的 [[对齐单位]] 为 [[4]] ，结构体中所有成员的这真实字节长度为 [[14]] ，则结构体的总大小会偏移至 [[16(4的整数倍)]]，<font color = "red">如有需要编译器会在最末一个成员之后加上填充空的字节</font>


```c
#pragma pack(4)

/*
占用大小: 6 Bytes
对齐单位: 1
*/
struct student {

	char a;					// 0x00000000               1
	char b;					// 0x00000001               1
	char c;					// 0x00000002               1
	char d;					// 0x00000003               1
	char e;					// 0x00000004               1
	char f;				    // 0x00000005               1
};

/*
占用大小: 16 Bytes
对齐单位: 4
*/
struct person {

	char g;					// 0x00000000 ~ 0x00000003	 4
	int i;					// 0x00000004 ~ 0x00000007	 4
	struct student stu;		// 0x00000008 ~ 0x0000000E	 8
};
```

<br/>

#### 关于结构体的深浅拷贝的问题
<span id="关于结构体的深浅拷贝的问题"></span>

当我们定义了如下两个结构体

```c
#include<stdio.h>
#include<string.h>

struct Person {

    char *name;
    int age;
};

int main(void){

    struct Person tom;
    tom.name = malloc(sizeof(char) * 128);
    strcpy(tom.name, "Tom");
    tom.age = 18;

    struct Person jerry;
    jerry.name = malloc(sizeof(char) * 256);
    strcpy(jerry.name, "Jerry");
    jerry.age = 30;

    tom = jerry;

    free(tom.name);
    free(jerry.name);

    return 0;
}
```

当我们想让 [[tom = jerry]] 的时候，由于 [[=]] 操作符的特性，[[jerry]] 结构体变量中的值都会拷贝到 [[tom]] 身上，这个没什么问题，但是因为 [[jerry]] 和 [[tom]] 中的 [[name]] 都是在堆中申请的内存，所以当我们在最后释放的时候就会出现错误了，如下面代码

```c
free(tom.name);
free(jerry.name);
```

为什么最后释放的时候会发生错误？原因是因为 [[=]] 操作符所做的赋值操作其实都是 [[浅拷贝]] 操作，也就是 [[把右值逐字节拷贝到左值身上]] ，这时候就会出现问题，因为 [[tom = jerry]] ，所以就意味着， [[jerry 在堆中申请的内存地址也是逐字节拷贝到了 tom 身上]]，也就是说 [[tom]] 的 [[name]] 属性和 [[jerry]] 的 [[name]] 属性指向的都是同一块堆中的地址，这时候我们 [[free]] 操作的时候，就会出现重复释放一块相同的堆地址的情况，于是就会出现错误了，其次，原先 [[tom]] 的 [[name]] 属性也是在堆中申请的内存，在做完浅拷贝操作后，原来 [[tom]] 在堆中为 [[name]] 属性所申请的内存地址就给覆盖掉了，我们找不回来，这时候就会出现 [[内存泄漏]] 的问题

为了解决 [[=]] 操作符所存在的浅拷贝的问题而导致的这两种结构体变量重复释放相同的堆地址所引发的错误的问题，我们需要进行深拷贝操作，如下面代码

```c
#include<stdio.h>
#include<string.h>

struct Person {

    char *name;
    int age;
};

int main(void){

    struct Person tom;
    tom.name = malloc(sizeof(char) * 128);
    strcpy(tom.name, "Tom");
    tom.age = 18;

    struct Person jerry;
    jerry.name = malloc(sizeof(char) * 256);
    strcpy(jerry.name, "Jerry");
    jerry.age = 30;

    realloc(tom.name, strlen(jerry.name) + 1);
    strcpy(tom.name, jerry.name);
    tom.age = jerry.age;

    free(tom.name);
    free(jerry.name);

    return 0;
}
```

上面的代码就是一次深拷贝操作，<font color = "red">深拷贝</font> 简而言之就是深度拷贝，并不是只是单纯的像浅拷贝一样只是单纯的拷贝变量本身所存在的字节而不考虑某个变量所指向的另一块内存地址的内容

<br/>

#### 关于结构体中包含自身结构体类型的成员的问题
<span id="关于结构体中包含自身结构体类型的成员的问题"></span>

在一个结构体中，结构体中的成员是无法声明为当前结构体类型，因为在此刻，当前结构体的类型编译器还未确定具体大小，故无法嵌套自身的类型，但是结构体中的成员可以声明为当前结构体类型的指针，因为指针的类型是恒定的，如下面的代码

```c
struct Person {

    char *name;
    int age;
    struct Person *per;
};
```

<br/>

### 共用体
<span id="共用体"></span>

---

共用体是能够在同一个存储空间存储不同类型数据的类型，共用体的声明和使用离不开 [[union]] 关键字，和 [[struct]] 的定义类似，共用体对于开发人员来世也是一种自定义的复合类型，如下代码则为声明了一个共用体类型

```c
union object{

    char var;
    short int_16;
    int int_32;
};

int main(void){

    union object obj;
    obj.int_32 = 0x87654321;
}
```

通过上面的代码则能够声明一个共用体的基础数据类型，而我们在代码中就能够通过所定义的共用体类型名去声明或者定义一个共用体变量，当一个共用体变量被声明出来后，当我们定义了一个共用体变量，并为其中的某个成员进行赋值后，其在内存中的存储方式如下图

```c
+-----------+								Top
|			|								 |
| 1000 0111	+----+							 |
|			|	 |							 |
+-----------+	 |							 |
|			|	 |							 |
| 0110 0101	|	 +--> int_32 (int)			 |
|			|	 |							 |
+-----------+	 |							 |
|			|	 |							 |
| 0100 0011	+----|---+						 |
|			|	 |	 |						 |
+-----------+	 |	 +--> int_16 (short)	 |
|			+----+	 |						 |
| 0010 0001	+--------|-----> var (char)		 |
|			+--------+						 |
+-----------+								low
```

通过上图其实可以看出，我们在共用体当中虽然定义了三种变量类型，[[char var]] [[short int_16]] [[int int_32]] ，但是实际上只分配了 4 个内存单元，也就是在定义共用体数据结构中的 [[int]] 类型成员的大小，通过这点也延伸出了一条需要重点掌握的信息，即 [[一个共用体类型所占用的内存空间大小为该共用体类型中所占用字节大小最大的成员的字节大小]] ，当然这点是相对来说的，我们对于大部分共用体来说都可以套用这一条定论，但是共用体和结构体一样，同样存在着 [[内存对齐]] 的问题，关于内存对齐的详解在 [结构体这一章](#关于结构体的内存对齐的问题) 中已经说的很详细，对于共用体来说同样遵循着这一定律

此外，虽然我们在共用体类型 [[union object]] 中声明了三种成员的类型，但是它们所使用的内存空间都是一样的，都是一个 [[4 Bytes]] 大小的内存空间，并且每个成员的首地址都是从同一个内存单元开始的，即同一个内存首地址，也就是说， [[所声明的一个共用体变量的本身和共用体变量其内部的成员的内存首地址都是一致的，都是指向该共用体变量所占用内存空间段的首地址]] 

既然共用体中的成员使用的都是同一个内存空间，那么我们可以理解为 [[只要任意修改了一个成员的值，那么其它成员也会受到影响]] ，事实也是如此，在上面的代码中我们仅仅修改了 [[int_32]] 变量的值，而整个内存空间的数据都变了，这时候如果我们再去取其中的 [[var]] 变量的时候，也就是一个占用一个内存单元的 [[char]] 类型的成员，其结果则为 [[0010 0001]]，虽然同一内存段可以用来存放几种不同类型的成员，但是在 [[瞬时]] 中，对于共用体中某个类型成员所存放的数据只针对 [[它]] 起作用  ( 其余类型由于占用空间问题，可能会出现占用空间大小之间的偏差问题 )

<br/>

### 文件
<span id="文件"></span>

---

文件具有不同的类型，其分类总体分为以下两类

- 磁盘文件 : 指一组相关数据的有序集合,通常存储在外部介质，如磁盘上，使用时才调入内存，对于磁盘文件来说，还分以下两种不同类型的文件
    - 文本文件 : 基于字符编码的文件
    - 二进制文件 : 基于值编码的文件
- 设备文件 : 设备能够归纳为文件一类是以 [[linux]] 系统的视角来看待的，**在 [[linux]] 中，万物皆可称之为文件，因为linux在底层上把文件和设备都统一了起来使用 [[inode]] 进行管理**{style="color:red"} ，设备文件具体映射到计算机的各类设备上，如：键盘 / 屏幕 / 显卡 / 声卡 / 网卡 / ……

<br/>

#### 在 c 语言中三种特殊的系统文件
<span id="在c语言中三种特殊的系统文件"></span>

在 c 语言中，应用程序在启动的时候会默认的打开三种特殊的 **系统文件**{style="color:red"} ，这三种系统文件会分别映射到所对应的不同的 **文件缓冲区**{style="color:red"} 当中，而这些文件缓冲区又能够映射到不同的 **I/O 设备**{style="color:red"} 身上，所以以抽象概念上来说这三种系统文件是属于 **设备文件**{style="color:red"}

- stdin : Standard Input
    - 标准输入 --> 标准输入流 ( 标准输入文件缓冲区 ) --> 键盘 
- stdout：Standard Output
    - 标准输出 --> 标准输出流 ( 标准输出文件缓冲区 ) --> 屏幕
- stderr：Standard Error
    - 标准错误 --> 标准错误流 ( 标准错误文件缓冲区 ) --> 屏幕

以上三种特殊的系统文件以 **文件指针**{style="color:red"} 的形式存在于 [[libc]] 之中，对于引入了 [[libc]] 的源程序可以直接通过关键字获取并操作对应缓冲区的内容，在可执行程序的首次运行时，os 会基于 [[file descriptor]] ( **linux下万物皆文件，包括输入输出设备**{style="color:red"} ) 的封装调用为相关的文件指针赋值，它们的生命周期会延续至程序的退出而关闭，当然，开发者可以在运行时可以手动的选择关闭它们，以下代码截至头文件 [[stdio.h]] 之中，它展示了这三种特殊系统文件在 c 标准库中的存在形式
```c
/* Standard streams.  */
extern FILE *stdin;     /* Standard input stream.  */
extern FILE *stdout;    /* Standard output stream.  */
extern FILE *stderr;    /* Standard error output stream.  */
```

相较于 系统调用 而言，它们的存在则由文件的文件描述符来进行定义，在一个可执行程序运行时，这三种特殊的系统文件总是会最优先先被加载出来，即占用了 [[PCB 文件描述符表]] 最初始三个下标的序列，以下代码截至头文件 [[unistd.h]] 之中，它直观的展示了这三种特殊系统文件在 linux 系统 I/O 库中的不一样的存在形式

```c
/* Standard file descriptors.  */
#define	STDIN_FILENO	0	/* Standard input.  */
#define	STDOUT_FILENO	1	/* Standard output.  */
#define	STDERR_FILENO	2	/* Standard error output.  */
```

需要补充一点的是，这三种系统文件不是与计算机的外部存储进行沟通的，而是和计算机的 **I/O 设备**{style="color:red"} 进行沟通，既然所沟通的对象并不是外部存储设备，那么为什么又要把他们称之为存储在外部存储概念上的 文件 呢？ 以 [[Linux]] 作为背景，在 linux 下万物皆可称之为文件 ( 因为在底层上 Linux 把 文件 和 设备 统一起来用 [[inode]] 来管理) ，包括输入输出设备，而在这里， [[stdin]] , [[stdout]] , [[stderr]] 都不是映射到一个系统上真实存在的文件，以抽象概念来说，默认情况 ( 也可以通过 [[pipeline]] 技术重定向 [[I/O]] 的位置 ) 下它们映射到的是我们的键盘和看得见的屏幕 ( console )

在这里可能会有疑问，上面对于三种在应用程序启动的过程中就为应用程序所绑定的三种东西时称为 [[stream]] ，时又称之为 [[文件]] ，其实不管是哪种说法，都是正确的，首先它们的确是一种以流的形式所存在，都映射到逻辑概念上的数据流，但是以 os ( linux ) 的目光来看待，它们的确是文件，而我们与文件在进行沟通的时候，两者之间中间有个桥梁，那就是 [[stream]]，即 [[stream]] 是基于 [[文件]] 所存在的，关于文件缓冲区的内容会在 [下一章](#文件缓冲区) 进行详解

<br/>

#### 文件缓冲区
<span id="文件缓冲区"></span>

在开始前我们先了解，缓冲区是什么？

缓冲区其实是一个宏观的概念，用于临时置放输出或输入资料的内存区域，我们都可以把这块内存区域称之为缓冲区，抽象至我们在代码上用于临时存放所采集的 [[I/O]] 数据的数据结构，我们都可以称它为缓冲区，以更深的角度来看的话，缓冲区的概念还需要映射到具体的物理设备，对于物理设备的一次访问操作，我们有一块内存区域去尽可能地存放os与物理设备正在沟通的两者间所需要的 I/O 数据，这块内存区域就叫做缓冲区

对于缓冲区来说，始终都会遵守的一个原则：[[预读入，缓输出]]

那么，什么是文件缓冲区？

在开始说明之前，需要强调的是，[这里](#文件缓冲区) 所指的文件缓冲区的概念，包括 [上面](#在c语言中三种特殊的系统文件) 所提到的，都是仅在 [[libc]] 之中存在的，由于 [[gcc]] 在对源程序执行 [[link]] 阶段时都会默认的为我们链接至 [[glibc]] 库，故对于一个 c 程序而言我们默认它对于文件的 I/O 操作都会依赖于文件缓冲区而进行，但是，**系统调用是不会依赖于文件缓冲区的，不可否认的是，[[libc]] 中的文件 I/O 操作最终还是会落定在系统调用身上，只是 [[libc]] 在其上层为我们提供了一层缓冲区以提升读写的性能**{style="color:red"}，简而言之，文件缓冲区的内容由用户态所提供，并由它最终同步到内核态去完成文件的 I/O 操作

文件缓冲区的概念就是缓冲区这个概念跟深一步的解答了，前面说到，缓冲区其更深一次的解答其实是需要映射到具体的物理设备的，我们可以认为，一切关乎到 I/O 操作的文件 ( 需要注意， [[文件]] 不单指以外部存储作为媒介存储在 OS 上的文件，还包括其余的外部 I/O 设备 ) 都有或即将有一个属于自己的缓冲区，那么，为什么它们需要这么一块缓冲区？前面说到，缓冲区是用于临时存放输入输出数据的内存区域，它们这些 I/O 设备关于输入输出的数据为什么不可以以更直接的方式和 CPU 进行沟通，而是又通过一层文件缓冲区，把其对应的输入输出数据存放在里面，CPU 在去里面读取，然后进行计算。在这里，我认为使用 [[HDD]] 来解释是最为合适的，首先我们要明白 HDD 的构造，其内部由多个盘片组成，盘片通过中心圆向外扩散划分了多条磁道，而磁道又通过从盘片圆形外部扩散至中心圆的一条条直线划分了扇区 ( 一个扇区的大小为 [[512 Bytes]] ) ，这些扇区用于存放我们的计算机所产生的数据，那么通过什么来读取这些扇区的数据呢？通过一条 [[震臂]] 还有一块 [[磁头]] 去完成，振臂通过不断地左右伸缩，盘片又通过转动，来完成磁头的寻道工作 ( 找到扇片 ) ，其实简而言之说了这么多，也就是想表明磁盘的 [[I/O操作]] 其实就是一个 [[机械式物理的过程]] ，那么对于时间而言，这种一次寻道 ( 物理访问 ) 的工作是极其消耗时间 ( 对比电的速度 ) 的，为此，我们对于某个存储在 HDD 上的 I/O 操作 ( 拷贝数据等等 ) ，就需要使用到一个 [[文件缓冲区]] （ 默认情况下 os 会为它申请一个 [[4096 Bytes]] 的大小 ） ，当我们需要从 HDD 上读取数据的时候，HDD 就会尽可能地把数据写入到缓冲区里面去，直到缓冲区被填满了后再由程序读取出来进行其他的操作 ( 不一定是缓冲区填满后才进行读取，但是大部分情况下是如此 ) ，对于写入操作的话也是如此，程序也会尽可能地把数据写入到其所对应的缓冲区里面去，直至缓冲区满了或到了适当的时候再写回到 HDD 里面去，回过头来， [[文件缓冲区]] 肯定不单指的是硬盘，像键盘也有属于自己的缓冲区 ( stdin ) ，包括屏幕也有自己的缓冲区（ 抽象上来说为 stdout ），其工作原理和使用缓冲区的原因也是大同小异

这里还要提及一个 [[文件指针]] 的概念 ( [后面](#文件指针) 会讲到 )，在 [[libc]] 中，我们对于一个文件的 [[I/O 操作]] 都由一个指向文件描述信息 [[文件指针]] 来完成，这个文件指针的类型为 [[FILE *]]，而 [[FILE]] 其实就是用于描述文件信息的结构体类型，前面说到，一切关乎到 [[I/O 读写]] 的文件都有或即将有一个属于自己的缓冲区，那么我们可以理解为，每个成功定义的 [[FILE *]] 的都有一块属于自己的缓冲区

关于这个把 [[文件缓冲区上的数据刷新到具体媒介身上]] 的工作我们会把它称为 [[文件缓冲区的刷新]]，文件缓冲区的刷新其实就是把文件缓冲区中的数据拉出来，并清空当前缓冲区里面的数据，再把从文件缓冲区上取出来的数据交由适当的媒介，那么什么时候才会刷新这个文件缓冲区？前面说到，缓冲区的刷新会在适当的时候进行刷新，这种刷新机制是os以默认的设定下来帮我们自动完成的，当然我们可以认为的进行刷新，人为的刷新就需要使用到 c 中的函数 [[fflush]] 函数来完成，这里讨论的是 os 自动的帮我们刷新缓冲区的机制，关于这种刷新的机制其实还有具体的刷新的方式来区分，我们把它归纳为以下几种类别

- 行缓冲：当接收到 [[\n]] 字符的时候进行一次缓冲区的刷新工作，类比 [[stdin 标准输入流]] ，其具体映射到键盘的操作身上
- 全缓冲：对于文件的读写操作，当缓冲区被填满的时候就会进行一次缓冲区的刷新工作
- 无缓冲：只要缓冲区中存在数据，就会立刻刷新到相应的文件当中， [[perror 文件缓冲区]] 则遵循这一原则


最后，我们再看一下文件缓冲区模型图

```c
                                           memory
                                      +---------------+
                                      |               |
                                      |   8192 Bytes  |
                 +--------+           |   +--------+  |       +---------+
+-------+        |        |           |   |        |  |       |         |          +--------+
|process+------> |  libc  | +-----------> | buffer | +------> | sys_exc | +------> |  file  |
+-------+        |        |           |   |        |  |       |         |          +--------+
                 +--------+           |   +--------+  |       +---------+
                                      |               |
                                      +---------------+
```

<br/>

#### 文件指针
<span id="文件指针"></span>

文件指针区别于一般的指针，文件指针所指向的内存地址其实是在 [[heap]] 上 ( 这一特性是由于 [[fopen]] 函数所导致的 ) ，此外，文件指针所指向的地址所映射的存储空间里面所存储的并不是具体某个文件的所有字节内容，而是关于具体某个文件的一些描述性信息，在 c 中，文件指针的类型通过 [[FILE]] 来定义，实际上他就是一个 [[struct]]，其具具体结构图下面的代码

```c
typedef struct
{
    short           level;		    /* 缓冲区"满"或者"空"的程度 */
    unsigned        flags;		    /* 文件状态标志 */
    char            fd;			    /* 文件描述符 */
    unsigned char   hold;		    /* 如无缓冲区不读取字符 */
    short           bsize;		    /* 缓冲区的大小 */
    unsigned char   *buffer;	    /* 数据缓冲区的位置  */
    unsigned        ar;	 		    /* 指针，当前的指向 */
    unsigned        istemp;		    /* 临时文件，指示器 */
    short           token;		    /* 用于有效性的检查 */ 
    unsigned char *read_cur_ptr;    /* 读位置指针 */
    unsigned char *write_cur_ptr;   /* 写位置指针 */
} FILE;
```

虽然 [[FILE]] 结构体内部的成员涵盖了某个文件的许多描述信息，但是在 c 中，使用文件指针操作其所指向的文件的时候都需要通过 c 标准库中所给定的文件操作函数来完成，而不是直接访问这个结构体内部成员的信息

回到刚刚所说到那个 [[FILE]] 结构体身上，可以看出，这个结构体所存放的信息是关于一个具体文件的实际描述性的信息，而 c 标准库所提供的关于文件的操作函数就是通过形参中所指定的文件指针的成员 **[[fd]] ( 文件描述符 )**{style="color:red"}  ( 指向了当前所操作文件的 [[inode]] 节点，而操作系统则能够通过这个唯一的 [[inode]] 节点去索引到磁盘中的具体的扇区信息  ) 去找到具体某个文件，然后再对它实行针对当前函数功能的操作，~~在编写源程序时，开发人员其实不必关心 [[FILE]] 内部的成语那具体细节~~

我们可以理解为每个文件描述符都能够指向一个对应的文件，但并不意味着同一个文件就只能被一个文件描述符所指向，也就是说我们是可以通过一些 **linux 系统 I/O 库**{style="color:red"} 中所提供的 [[API]] 去使多个不同的描述符去指向同一个被打开的文件的，内核对于每个 [[inode]] 节点来说都维护了一个连接计数 ( 这点和 **硬链接计数**{style="color:red"} 有点像，但是硬链接计数所真的对象是以整个操作系统为视角，而现在这个文件描述符的计数的视角仅仅只是以当前源程序为视角 ) ，当在当前可执行程序中打开 ( [[open()]] ) 一个新的文件，则这个文件所对应的 [[inode]] 编号所维护的文件描述符链接计数则为 [[1]]，后续如果由描述符去指向这个文件 ( [[inode]] ) 时，则所对应的文件描述符链接计数则会 [[+1]]，那么相应的，当我们关闭 ( [[close()]] ) 了一个对应的文件描述符，则这个文件描述符所指向的 [[inode]] 编号所维护的文件描述符链接计数则会 [[-1]]，**仅当某一个文件在当前所执行的程序中再没有任何文件描述符所指向时，这个文件才是真正意义上的在当前所运行的可执行程序中被关闭掉了**{style="color:red"}

[前面](#Kernel_Space) 稍微提到过内核中的 **进程管理模块**{style="color:red"}，在进程管理模块中存在一块区域，即 **PCB进程控制块**{style="color:red"}，其实质是一个结构体，在 PCB 中存在着一张 **文件描述符表**{style="color:red"}，它负责记录当前进程所打开的 ( [[fopen()]] / [[open()]] ) 文件的文件描述符 fd 和打开这个文件时所指定的状态 [[flag]]，默认情况下，这张表的长度为 [[1024]]，每当当前进程新打开一个文件 ( [[open()]] ) 时，都会在文件描述符表的 **空闲位置并且是最小的下标**{style="color:red"} 中存入所操作的文件的 [[inode]] 编号和打开这个文件时所指定的 [[flag]] 以进行维护，而对应 [[inode]] 编号所维护的文件描述符链接计数则初始化为 [[1]]，最后返回这个 [[inode]] 编号相对于文件描述符表的下标，而这个下标则为 **文件描述符表 [[fd]]**{style="color:red"}，相对，在一个文件被关闭释放 ( [[fclose]] ) 的时候，这个文件所对应的文件描述符 fd 也随之从这个表中移除，而对应文件的文件描述符链接计数则为 [[-1]]，仅当在某个可执行程序中所打开的文件的文件描述符链接计数为 [[0]] 时，这个文件才真正意义上的从当前可执行文件中被关闭，前面一直所强调的，一个应用程序在运行时所打开的三个系统设备文件 ( stdin, stdout, stderr ) 的文件描述符 fd 则总会占用着这张文件描述符表的前三个下标序列之中

有一点需要我们注意，在 [[FILE]] 的内部会有一种成员会 **记录着当前文件中所操作的某个字符的位置**{style="color:red"}，他们是 [[read_cur_ptr]] [[wite_cur_ptr]] ，在下文中，我们把它们统称为 **文件读写位置指针**{style="color:red"} ; 文件读写位置指针在进行指针偏移的操作时所使用的步长都是使用 [[1 Bytes]] 作为标准，在还未进行过任何读写状态的时候，其起始位置为0，在对文件进行了 读取或写入 操作的时候，文件读写位置指针则会基于此次操作所到达的下标往后进一以保证下一次对于文件进行 读取或写入 操作的时候不会和已操作的位置重叠在一块，我们不管是对文件的读还是写操作，都离不开这个 [[文件读写位置指针]] 它对于当前文件的读写起到了标量的作用，举个例子，一个文本文件中有一段文本 [["abc"]]，当我们第一次通过 [[fgetc]] 函数读取后，文件读写位置指针的矢量就会向后加一，以方便下一次再调用 [[fgetc]] 函数读取到的内容为 [['b']] 而不是原来的 [['a']]

对于文件读写位置指针，我们可以通过 [[fseek]] 函数来手动的调整其位置以保证下一次进行 读取或写入 操作的时候所获取到的数据是我们所预期的数据，这种操作也称之为 **对文件的随机访问操作**{style="color:red"} ，在 c 中，对于文件的随机读写操作时需要注意一个点，那就是当我们通过改变文件读写位置指针的位置去往已有数据的位置当中去写入数据的时候 ( 插入数据 ) ，所写入的数据并不是以追加的形式呈现，而是以覆盖的形式呈现，比如说一个文本文件中的内容为 [[111112222233333]] ，当我们把文件读写位置指针的位置移动至第 [[5]] 个，并且写入 [[BBBBB]] 的时候，文件最终的结果则为 [[11111BBBBB33333]] ，而不是 [[11111BBBBB2222233333]]

最后，C 标准库和 linux 系统 I/O 库，两者之间到底是什么样的关系？就本节对于文件指针的存储结构的刨析其实已经非常的明朗了，C 标准库就是属于 linux 系统 I/O 的一种上层封装，而文件指针中的成员 文件描述符 [[fd]] 就是属于 C 标准库完成对 linux 系统 I/O 库系统调用的开门钥匙

<br/>

#### C 标准库中的文件操作
<span id="C_标准库中的文件操作"></span>

#### FILE *fopen(const char * filename, const char * flag)
##### <stdio.h>

当调用该函数的时候，该函数会根据指定的模式 [[flag]] 和文件的具体位置 [[filename]] 去找到相关的文件并读取文件的描述信息

如果成功读取，则在堆中开辟一块 [[struct FILE]] 大小的内存空间，并根据具体文件的信息创建一个 [[struct FILE]] 写入到刚刚所申请的堆中的地址中，最后返回这个指向堆中地址的 [[FILE *]] 类型的指针，即 [[文件指针]]

如果函数调用失败，也就是打开文件失败，这时候该函数会返回一个 [[空指针]]

该函数并不会把文件的内容一次性全部加载到内存中，该函数的责任只是以对应的模式找到对应文件的信息并创建一个指针指向它

- filename：具体文件的路径 ( 绝对路径 / 相对路径 )
    - 操作系统的某些版本下可能因为该参数导致函数调用失败而返回空指针，如果出现这种情况，需要检查下该参数所给定的路径是否为绝对路径，如果是绝对路径的话需要检查下盘符是否为小写

- flag：打开文件的方式
    - [["r"]] / [["rb"]]：以 [[read only]] 的方式打开一个文本文件，若文件不存在则该函数返回空指针
    - [["w"]] / [["rw"]]：以 [[write only]] 方式打开文件，如果文件存在则删除给定文件并且创建一个新的文件，如果文件不存在则创建一个新的文件
    - [["a"]] / [["ab"]]：以 [[append only]] 方式打开文件，在末尾添加内容，若文件不存在则创建文件，[[append only]] 意味着只能够允许 [[write]] 的操作，而对于 [[read]] 的操作可能会导致失败
    - [["r+"]] / [["rb+"]]：以 [[read & write]] 的方式打开文件，如果文件不存在，则创建一个新的文件
    - [["w+"]] / [["wb+"]]：以 [[read & write]] 的方式打开文件，如果文件存在则删除给定文件并且创建一个新的文件，如果文件不存在则创建一个新的文件
    - [["a+"]] / [["ab+"]]：以 [[append & read & write]] 的方式打开文件，若文件不存在则创建文件，如果文件存在，则在末尾添加内容
    - 参数的后缀为 [["b"]] 则为 [[二进制文件模式]] ，没有则为默认的 [[文本文件模式]] ，且只是在 [[Windows]] 有效，在 [[Linux]] 中用文本文件模式和二进制文件模式的结果是一样的
        - windows：所有的文本文件行都是 [[\r\n]] 作为结尾
            - 文本模式
                - 当读取文件的时候，系统会将所有的 [[\r\n]] 转换成 [[\n]]
                - 当写入文件的时候，系统会将 [[\n]] 转换成 [[\r\n]] 进行写入
            - 二进制模式
                - 以 [[二进制]] 方式打开文件，则读写都不会进行这样的转换
        - Linux：所有的文本文件行都是 [[\n]] 作为结尾
            - 在Unix/Linux平台下，文本模式与二进制模式没有区别，[[\r]] [[\n]] 作为两个字符原样输入输出



```c
#include<stdio.h>

int main(void){

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "w");
    if(fp == 0){

        perror("file pointer error");
        return -1;
    }

    char *str = "Hello,World!";
    fwrite(str,1,strlen(str),fp);

    fclose(fp);

    return 0;
}
```

<br/>

#### int fclose(FILE * stream)
##### <stdio.h>

关闭文件指针 [[stream]] 所指向的被打开的文件，并释放其所占用的内存

每次使用 [[fopen]] 函数所打开的文件都会占用内存资源，如果过多的打开而总不关闭，会占用较多很多内存，并且，一个进程同时打开文件的次数是存在限制的，如果再某一时刻同时打开的文件过多且没有关闭的话，可能会在下一次打开 [[fopen]] 的时候就打开失败了 ( 返回空指针 )

该函数在调用完成后会在其内部针对文件指针指向的文件所打开的文件缓冲区的刷新工作

```c
#include<stdio.h>

int main(void){

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "w");
    if(fp == 0){

        perror("file pointer error");
        return -1;
    }

    fclose(fp);

    return 0;
}
```

<br/>

#### int remove(const char *pathname)
##### <stdio.h>

删除指定路径 [[pathname]] 的文件，成功返回 [[0]]，失败返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    int flag = remove("?c:/Users/NGPONG/Desktop/111.mp4");
    printf("remove %s\n", flag == 0 ? "SUCCESS" : "FAILUTE");

    return 0;
}
```

<br/>

#### int rename(const char *oldpath, const char *newpath)
##### <stdio.h>

重命名文件，旧地址 [[oldpath]] 更改为新地址 [[newpath]]，成功返回 [[0]]，失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    int flag = rename("test.txt", "abc.txt");
    printf("rename %s\n", flag == 0 ? "SUCCESS" : "FAILUTE");

    return 0;
}
```

<br/>

#### int stat(const char *path, struct stat *buf)
##### <sys/types.h> / <sys/stat.h>

该函数能够获取指定路径 [[path]] 所对应的文件信息，如果调用成功，则把填充到类型为 [[struct stat]] 的结构体中去，并返回 [[0]]，如果调用失败，则返回 [[-1]]

对于操作系统而言，打开一个文件 [[fopen]] 总是会消耗较多的资源的，也就是说如果我们真的只是想单纯的查看某个文件的具体信息 ( 比如说文件的具体大小 ) 而不对文件进行其它的读写操作的话，就不推荐使用 [[fopen]] 函数去打开一个文件在获取里面的内容了，而函数 [[stat]] 并不会去打开一个文件的具体内容，仅仅只是获取到该文件具体的描述信息再把信息填充至结构体 [[struct stat]] 当中，所以针对这种情况的话，使用 [[stat]] 函数对比 [[fopen]] 函数就大大的提升了效率

关于 [[struct stat]] 的结构

```c
struct stat {
    dev_t         st_dev;         	//文件的设备编号
    ino_t         st_ino;			//节点
    mode_t        st_mode;   		//文件的类型和存取的权限
    nlink_t       st_nlink;     	//连到该文件的硬连接数目，刚建立的文件值为1
    uid_t         st_uid;         	//用户ID
    gid_t         st_gid;         	//组ID
    dev_t         st_rdev;      	//(设备类型)若此文件为设备文件，则为其设备编号
    off_t         st_size;        	//文件字节数(文件大小)
    unsigned long st_blksize;   	//块大小(文件系统的I/O 缓冲区大小)
    unsigned long st_blocks;    	//块数
    time_t        st_atime;     	//最后一次访问时间
    time_t        st_mtime;    		//最后一次修改时间
    time_t        st_ctime;     	//最后一次改变时间(指属性)
};
```

```c
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>

int main(void){

    struct stat state = { 0 };
    int flag = stat("c:/Users/NGPONG/Desktop/test.txt", &state);

    if (flag == -1) {
    
        perror("file open error");
    }

    printf("file size = %d\n", state.st_size);
    printf("file last at time = %d\n", state.st_atime);
    printf("file last change time = %d\n", state.st_mtime);

    return 0;
}
```

<br/>

#### int fflush(FILE *stream)
##### <stdio.h>

该函数能够立即刷新文件指针所指向的文件所开启的缓冲区，如果成功返回 [[0]]，如果失败则返回 [[-1]]

关于文件缓冲区的内容在 [这一章](#文件缓冲区) 已经有所介绍，这里就不再进行展开了

```c
#include <stdio.h>

int main(void){

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt","w+");
    if(fp == NULL){

        perror("file pointer create error");
        return -1;
    }

    for (size_t i = 0; i < 10; i++) {

        fprintf(fp, "%d\t", (i + 1));
        fflush(fp);
    }

    return 0;
}
```

<br/>

#### int fprintf(FILE * stream, const char * format, ...)
##### <stdio.h>

将 [format形参](#形参format) 所提供的格式化模板再结合所录入的可变参数 [[...]] 生成一个新的字符串的结果并写入到文件指针 [[stream]] 所指向的文件的缓冲区内，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "w");
	if (fp == NULL) {

		perror("fp error");
		return -1;
	}

	fprintf(fp, "Hello,World! My name is %s, I'm %d years old", "NGPONG", 23);

	fclose(fp);

    return 0;
}
```

<br/>

#### int fscanf(FILE * stream, const char * format, ...)
##### <stdio.h>

将 [format形参](#形参format) 所提供的格式化模式从文件指针 [[stream]] 所指向的文件的缓冲区内取出数据，并依次写入到所指定的可变参数 [[...]] 所使用的内存空间当中，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    
	FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
	if (fp == NULL) {

		perror("fp error");
		return 0;
	}

	int age;

	fscanf(fp, "Hello,World! My name is NGPONG, I'm %d years old", &age);

	fclose(fp);

    return -1;
}
```

<br/>

####  char *fgets(char * source, int size, FILE *stream)
##### <stdio.h>

从文件指针 [[stream]] 所指向的文件的缓冲区内获取 [[size]] 字节大小的数据，以文件中的 [['\n']] 作文本次函数调用的读取标识，把所读取到的内容填充至形参 [[souce]] 所指向的内存空间内并返回该内存空间的首地址，如果调用失败，则返回 [[NULL]]

该函数所给定的参数 [[source]] 必须为一个字符数组以保证写入权限，如果给定的是一个字符指针形式的字符串的话，该函数则会调用失败，因为该函数会逐地址写入所录入的字符

该函数在调用前，会先清空所给定的 source 所指向的内存空间的内容，即都赋值为 [[0]]

该函数虽然在文件缓冲区中遇到 [['\n']] 则会作为本次函数调用所需录入字符串的标识，但是在保证 [[source]] 所指向的内存空间结合 [[size]] 所规定的字节大小，在剩余空间允许的情况下也会录入 [['\n']] 字符

该函数是较为安全的，至始至终都会为 [[source]] 所指向的空间保留最后一位的字节内容以录入 [['\0']]，如果超出，则截断最后一位所采集到的数据以保证在录入 [['\0']] 字符时候， [[source]] 所指向的内存空间的足够

```c
#include <stdio.h>

int main(void) {

	FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
	if (fp == NULL) {

		perror("fp error");
		return -1;
	}

	char str[64] = { 0 };
	fgets(str, sizeof(str), fp);

	fclose(fp);
    return 0;
}
```

<br/>

#### int fputs(const char * str, FILE *stream)
##### <stdio.h>

将字符串 [[str]] 写入到文件指针 [[stream]] 所指向文件的缓冲区当中，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void) {

	FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "w");
	if (fp == NULL) {

		perror("fp error");
		return -1;
	}

	char *str = "Hello,World!\n";
	fputs(str, fp);

	fclose(fp);

    return 0;
}
```

<br/>

#### int fgetc(FILE * stream)
##### <stdio.h>

从文件指针 [[stream]] 所指向文件的缓冲区中获取一个字符，如果成功则返回所获取到的字符的 [[ASCII]] 码值，如果函数调用失败，则返回 [[-1]] ，**如果当前文件指针所指向的文件是一个文本文件的话，[[-1]] 的返回值也意味着当前文本文件中的所有的有效内容都已读取完毕**{style="color:red"}

```c
int main(void) {

	FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
	if (fp == NULL) {

		perror("fp error");
		return -1;
	}

	char str[64] = { 0 };
    int index = 0;
    while((*(str + index) = fgetc(fp)) != -1){

        index++;   
    }
    printf("%s\n",str);

	fclose(fp);
    return 0;
}
```

<br/>

#### int fputc(int ch, FILE * stream)
##### <stdio.h>

将字符 [[ch]] 写入到文件指针 [[stream]] 所指向的文件的缓冲区内，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "w");
	if (fp == NULL) {

		perror("fp error");
		return -1;
	}

    char *str = "Hello,NGPONG!\nTEST!";

    for (size_t i = 0; i < strlen(str); i++) {

        fputc(*(str + i),fp);
	}

    fclose(fp);
    return 0;
}
```

<br/>

#### size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)
##### <stdio.h>

把指针 [[ptr]] 所指向的内存空间中的数据划分为 [[nmemb]] 个数据块，每个数据块占用 [[size]] 字节大小 ，逐数据块写入到文件指针 [[stream]] 所指向的文件的缓冲区当中，如果成功，则返回实际写入的数据块的块数，即形参 [[nmemb]] 所录入的值，如果是败则返回 [[0]]

```c
#include <stdio.h>

typedef struct person {

    int age;
    char name[10];
    int gender;
} person_t;

int write(void) {

    person_t per[3] = {
        22,"NGPONG",1,
        11,"wupeng",0,
        100,"NICK",1
    };

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "w");
    if (fp == NULL) {

        perror("fp error");
        return -1;
    }

    int ret = fwrite(per, sizeof(person_t) * 3, 1 , fp); /* 当前写入操作指定了一个数据块的大小为 person_t 结构体类型数组 per 的大小，并且此次操作需要写入1个数据块，如果成功写入，返回值则为 1 */
    int ret = fwrite(per, 1, sizeof(person_t) * 3 , fp); /* 当前写入操作指定了一个数据块的大小为 1 字节，并且此次操作需要写入结构体数组 per 总长度的数据块，如果成功写入，返回值则为 per 数组的总长度 */

    printf("ret = %d\n", ret);

    fclose(fp);

    return 0;
}
```

<br/>

#### size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
##### <stdio.h>

把文件指针中所指向的文件的缓冲区的数据划分为 [[nmemb]] 个数据块，每个数据块占用 [[size]] 字节大小 ，逐数据块写入到指针 [[ptr]] 所指向的内存空间当中，如果成功，则返回实际写入的数据块的块数，即形参 [[nmemb]] 所录入的值，如果 [[返回值 < nmemb & 返回值 > 0]] ，则代表当前所读取得是最后一行的数据，如果返回值为 [[0]] 则代表文件已经读取完毕抑或是当前函数调用失败

```c
#include <stdio.h>

typedef struct person {

    int age;
    char name[10];
    int gender;
} person_t;

int main(void) {

    person_t per[3] = { 0 };

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
    if (fp == NULL) {

        perror("fp error");
        return -1;
    }

    int index = 0;
	while (fread(per + index, 1, sizeof(person_t), fp)) { index++; }

	for (size_t i = 0; i < sizeof(per) / sizeof(*per); i++) {

		printf("person name = %s,age = %d,gender = %d\n", per[i].name, per[i].age, per[i].gender);
	}

    fclose(fp);
    return 0;
}	
```

<br/>

#### int fseek(FILE *stream, long offset, int whence)
##### <stdio.h>

对文件指针 [[stream]] 所存储的 [[文件读写位置指针]] 的位置基于 [[whence]] 位置下进行 [[offset]] 偏移量的移动，如果成功返回 [[0]]，如果失败则返回 [[-1]]

- [[offset]]：调整位置的偏移量 ( 矢量 ) ，当为正整数的时候，则是向后 ( [[+1]] ) 偏移 offset 位，当为负数的时候则为向后 ( [[-1]] ) 偏移 offset 位
    - **文件读写位置指针的默认位置为 [[0]]，并且也不能小于 [[0]]**{style="color:red"} ，这意味着该参数只能够指定正整数的数字，当该参数小于0  的时候，该函数会调用失败，这时候文件读写位置指针的位置则会偏移至当前文件可读写数据的最末尾处，比如说一个文本文件仅有一段话 [[Helloworld]] ，当我们通过 [[fseek]] 函数去移动文件读写位置指针的位置，并指定偏移量小于 0 的话，则文件读写位置指针的位置下标就会偏移至跑 10 ( 可读写数据的最末尾处 )
    - 这里的偏移量是以 [[Bytes]] 作为单位来衡量的，比如说指定 [[offset]] 为 [[10]]，那么其实就意味着是向后偏移 [[10 Bytes]]

- 指定文件读写位置指针所基于的偏移位置，该参数通常使用三种不同的宏定义来指定
    - SEEK_SET：基于文件开头位置
    - SEEK_CUR：基于当前文件读写位置指针所在的位置
    - SEEK_END：基于文件结尾位置

```c
#include <stdio.h>

int main(void){

    /*
    AAAAABBBBBCCCCC
    ↑
    */
    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
    if (fp == NULL) {

        perror("fp error");
        return -1;
    }

    char str[6] = { 0 };

    /*
    AAAAABBBBBCCCCC
         ↑
    */
    fseek(fp, 5, SEEK_SET);

    /*
    AAAAABBBBBCCCCC
              ↑
    */
    fread(str, sizeof(char), 5, fp);

    printf("%s\n", str);

    fclose(fp);
    return 0;
}
```

在 windows 下，当我们对文件进行了一次读取操作后再进行写入，则会出现错误 ( 也有可能不会出错，而且写入函数也返回调用成功，但是数据却没有写入 ) ， 解决这一错误的方式则为在写入前重置一次 [[文件读写位置指针]] 的当前位置 ( [[fseek(FILE *,0,SEEK_CUR)]] ) 即可再次进行正常的写入操作，如下面的代码

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int main(void) {

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r+");
    if (fp == NULL) {
    
        perror("file pointer error");
        return -1;
    }

    char str[6] = { 0 };
    fgets(str, sizeof(str), fp);
    printf("str = %s,file read&write pointer index = %d\n", str, ftell(fp));

    /*
    如果再次写入前没有进行文件读写位置指针的位置的重新矫正，则写入错误
    */
    fseek(fp, 0, SEEK_CUR);

    fwrite("fffff", 1, 5, fp);
    printf("file read&write pointer index = %d\n", ftell(fp));

    fclose(fp);

    return 0;
}
```

<br/>

#### long ftell(FILE *stream)
##### <stdio.h>

获取，计算并返回文件指针 [[stream]] 所存储的 [[文件读写位置指针]] 当前位置到文件起始位置之间的偏移量 ( **以字节为单位**{style="color:red"} )

```c
#include <stdio.h>

int main(void){

    /*
    AAAAABBBBBCCCCC
    ↑
    */
    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
    if (fp == NULL) {

        perror("fp error");
        return -1;
    }

    int fileSize = 0;

    /*
    AAAAABBBBBCCCCC
                   ↑
    */
    fseek(fp, 0, SEEK_END);

    fileSize = ftell(fp);

    printf("file size = %d\n", fileSize);

    fclose(fp);
    return 0;
}
```

<br/>

#### void rewind(FILE *stream)
##### <stdio.h>

回卷文件指针 [[stream]] 所存储的 [[文件读写位置指针]] 的位置到文件起始位置

```c
#include <stdio.h>

int main(void){

    /*
    AAAAABBBBBCCCCC
    ↑
    */
    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
    if (fp == NULL) {

        perror("fp error");
        return -1;
    }

    char str[32] = { 0 };
    /*
    AAAAABBBBBCCCCC
                   ↑
    */
    fread(str, sizeof(char), sizeof(str), fp);

    printf("%s\n", str);
    memset(str, 0, sizeof(str));

    /*
    AAAAABBBBBCCCCC
    ↑
    */
    rewind(fp);

    /*
    AAAAABBBBBCCCCC
         ↑
    */
    fread(str, sizeof(char), 5, fp);
   
    printf("%s\n", str);

    fclose(fp);
    return -1;
}
```

<br/>

#### int feof(FILE * stream)
##### <stdio.h>

判断文件指针 [[stream]] 所指向的文件中文件中，文件读写位置指针的位置是否已经到达文件的结尾，如果是的话则返回 [[1]] 不是的话则返回 [[0]]

之前说到，文件指针其所存储的内存地址所映射的具体内容是一个描述文件信息的 [[struct]] ，而这个 [[struct]] 中有一个成员为 [[文件读写位置指针]] ，而该函数的实现机制是通过文件读写位置指针当前所在的位置去对比当前文件的有效数据的长度来判断是否已经到达文件末尾的

在 c 语言中，**对于 任何文本文件 都会有一个结束标记，其值为 [[-1]]**{style="color:red"} ，这个结束标记我们是不需要手动添加的，并且我们在文本中是看不到的，只有实际在 c 中通过代码读取文本文件的内容时才会发现它的存在，而 c 语言通过一个宏定义 [[EOF]] ( end of file ) 来表示这个值为 -1 的结束标记，但是关于 [[EOF]] 仅仅只是适用于 [[文本文件]] ，对于 [[二进制文件]] 就不能采用这一标准了，**因为对于一个二进制文件来说 [[-1]] 是能够存在且为有效值的**{style="color:red"} ，所以，如果需要准确的获取到当前所操作的文件指针的文件读写位置指针是否已经偏移至文件的结尾的时候，使用该函数更为合适

```c
#include <stdio.h>

int main(void) {

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r+");
    if (fp == NULL) {

        perror("fp errpr");
        return -1;
    }

    while (1) {

        char ch = fgetc(fp);
        if (feof(fp)) {
            
            break;
        }
        printf("%c", ch);
    }

    fclose(fp);
    return 0;
}
```

<br/>

#### linux 系统库中的文件操作
<span id="linux_系统库中的文件操作"></span>

#### int open(const char *filename, int flag, ...)
##### <sys/stat.h> <fcntl.h>

当调用该函数的时候，该函数会根据指定的模式 [[flag]] 和文件的具体位置 [[filename]] 去操作具体的文件，如果成功，则将当前文件的 [[inode]] 编号和为其所指定的 [[flag]] 放入至当前运行内存的 **PCB 进程管理模块**{style="color:red"} 的 **文件描述符表**{style="color:red"} 内进行维护，对应文件的文件描述符链接计数初始化为 [[1]]，最后返回所在 **文件描述符表**{style="color:red"} 的下标，即文件描述符 [[fd]]，如果调用失败，则该函数会返回 [[-1]]

该函数并不会把文件的内容一次性全部加载到内存中，仅仅只会将所需操作的文件的 [[inode]] 编号维护在 **文件描述符表**{style="color:red"} 中，并返回其下标去交由开发人员维护其生命周期

linux 系统 I/O 库相较 C 标准库存在非常大一种特点即是，linux 系统 I/O 库对于文件的操作，在默认情况下并不会为其开启相应的文件缓冲区

- [[filename]] : 具体文件的路径 ( 绝对路径 / 相对路径 )

- [[flag]] : 打开文件的方式
  
    该参数由宏定义的方式进行存在，其值为十六进制数对于 [[open]] 函数的调用，该参数 **必须指定 1 或 多个**{style="color:red"}，对于指定的多个参数，使用 **异或操作符**{style="color:red"} 进行分割
    - [[O_RDONLY]]：以 [[read only]] 的方式打开一个文件，默认情况下若文件不存在则返回 [[-1]]
    - [[O_WRONLY]]：以 [[write only]] 方式打开文件，默认情况下若文件不存在则返回 [[-1]]
    - [[O_RDWR]]：以 [[read & write]] 方式打开文件，默认情况下若文件不存在则返回 [[-1]]

    上述三种参数是互斥的，也就是不可同时使用，但可与下列的参数利用 **异或操作符**{style="color:red"} 组合
    - [[O_CREAT]]：若所操作的文件不存在，则自动创建文件，否则不做任何操作
    - [[O_EXCL]]：若指定了 [[O_CREAT]] 并且文件存在亦或者说所打开的文件是一个符号链接，则报错
    - [[O_APPEND]]：所写入的数据会以附加的方式加入到文件后面
    - [[O_TRUNC]]： 若文件存在并且以可写的方式打开时,则将文件长度清为 0，即原来存于该文件的资料也会消失
    - [[O_NONBLOCK]]：以不可阻断的方式打开文件，也就是无论有无数据读取或等待，都会立即返回进程之中，通常用于映射非阻塞式的 I/O 设备文件操作
    - [[O_SYNC]]：以同步的方式打开文件

- [[...]] : 指定新建文件的权限
coc#_select_confirm()
    仅当当前操作为新建文件时候 [[O_CREAT]] 才需指定当前参数，对于指定的多种权限，使用 **异或操作符**{style="color:red"} 进行分割
    - [[S_IRWXU]]：所有者具有可读、可写及可执行的权限
    - [[S_IRUSR]]：所有者具有可读取的权限
    - [[S_IWUSR]]：所有者具有可写入的权限
    - [[S_IXUSR]]：所有者具有可执行的权限
    - [[S_IRWXG]]：用户组具有可读、可写及可执行的权限
    - [[S_IRGRP]]：用户组具有可读的权限
    - [[S_IWGRP]]：用户组具有可写入的权限
    - [[S_IXGRP]]：用户组具有可执行的权限
    - [[S_IRWXO]]：其他用户具有可读、可写及可执行的权限
    - [[S_IROTH]]：其他用户具有可读的权限
    - [[S_IWOTH]]：其他用户具有可写入的权限
    - [[S_IXOTH]]：其他用户具有可执行的权限

```c
#include <sys/stat.h> 
#include <fcntl.h>

int main(void){
  int _fd = open("text", O_RDONLY);
  if (_fd == -1) {
    perror("E");
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}
```

<br/>

#### int close(int fd)
##### <unistd.h>

释放文件描述符 [[fd]] 在文件描述符表中所占用的空间，并且所对应文件的文件描述符链接计数 [[-1]]

由于 [[PCB 文件描述符表]] 存在限制，当每次使用 [[open]] 函数所打开的文件且不调用 [[close]] 关闭时，则可能会在下一次打开 [[open]] 的时候就打开失败了 ( 返回 [[-1]] )

需要说明的是,当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用 [[close]] 关闭，所以即使用户程序不调用 [[close]]，在终止时内核也会自动关闭它打开的所有文件

```c
#include <unistd.h>

int main(void){
  int _fd = open("text", O_RDONLY);
  if (_fd == -1) {
    perror("E");
    return EXIT_FAILURE;
  }

  close(_fd);

  return EXIT_SUCCESS;
}
```

<br/>

#### long lseek(int fd, long offset, int whence)
##### <unistd.h>

对文件描述符 [[fd]] 所指向文件的 [[文件读写位置指针]] 的位置基于 [[whence]] 位置下进行 [[offset]] 偏移量的移动，如果成功返回 [[偏移后的]]，如果失败则返回 [[-1]]

- [[offset]] : 调整位置的偏移量 ( 矢量 ) ，当为正整数的时候，则是向后 ( [[+1]] ) 偏移 offset 位，当为负数的时候则为向后 ( [[-1]] ) 偏移 offset 位
    - **文件读写位置指针的默认位置为 [[0]]，并且也不能小于 [[0]]**{style="color:red"}，这意味着该参数只能够指定正整数的数字，当该参数小于0  的时候，该函数会调用失败，即文件读写位置指针的位置保持无法改变
    - 这里的偏移量是以 [[Bytes]] 作为单位来衡量的，比如说指定 [[offset]] 为 [[10]]，那么其实就意味着是向后偏移 [[10 Bytes]]

- [[whence]] : 指定文件读写位置指针所基于的偏移位置，该参数通常使用三种不同的宏定义来指定
    - [[SEEK_SET]] : 基于文件开头位置
    - [[SEEK_CUR]] : 基于当前文件读写位置指针所在的位置
    - [[SEEK_END]] : 基于文件结尾位置

```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>

int main(void) {
  /** 
   * AAAAABBBBBCCCCC
   * ^
   */
  int _fd = open("text", O_RDONLY);
  if (_fd == -1) {
    perror("E");
    return EXIT_FAILURE;
  }
  
  /** 
   * AAAAABBBBBCCCCC
   *      ^
   */
  lseek(_fd, 5, SEEK_SET);
  char str[5] = { 0 };
  
  /** 
   * AAAAABBBBBCCCCC
   *           ^
   */
  read(_fd, str, 5);
  printf("%s\n", str);

  memset(str, 0, sizeof(str));

  /** 
   * AAAAABBBBBCCCCC
   *                ^
   */
  read(_fd, str, sizeof(str));
  printf("%s\n",str);

  close(_fd);
  return EXIT_SUCCESS;
}

```

<br/>

#### long read(int fd, const void *buf, size_t size)
##### <unistd.h>

从文件描述符 [[fd]] 所指向的文件中读取 [[size]] 个 [[bytes]] 的数据并放入缓冲区 [[buf]] 当中，如果返回 [[> 0]] 则为所读取到的字节数，如果返回 [[= 0]] 则文件独取完毕，如果返回 [[-1]] 则文件读取失败

```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>

int main(void) {
  int _fd = open("/home/ngpong/code/C/C-Study-03/file_02/text", O_RDONLY);
  if (_fd == -1) {
    return EXIT_FAILURE;
  }

  char buf[5] = { 0 };
  int _size = read(_fd, buf, sizeof(buf));

  printf("%s\n",buf);

  close(_fd);
  return EXIT_SUCCESS;
}
```

<br/>

#### long write(int fd, const void *buf, size_t size)
##### <unistd.h>

将 [[buf]] 缓冲区中的 [[size]] 个 [[bytes]] 的数据写入到文件描述符 [[fd]] 所指向的文件当中，如果成功则返回所写入的字节数，如果失败则返回 [[-1]]

```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>

int main(void) {
  int _fd = open("/home/ngpong/code/C/C-Study-03/file_02/text", O_RDONLY);
  if (_fd == -1) {
    return EXIT_FAILURE;
  }

  char buf[5] = { 0 };
  int _size = write(_fd, buf, sizeof(buf));

  close(_fd);
  return EXIT_SUCCESS;
}
```

<br/>

#### int stat/lstat(const char *filename, struct stat *buf)
##### <sys/stat.h>

依据所指定的路径 [[filename]] 去查看文件的状态信息，并把结果写入至 [[buf]] 缓冲区中，如果成功则返回 [[0]]，如果失败则返回 [[-1]]

[[stat]] 和 [[lstat]] 函数普通使用并无区别，唯一区别仅为当需要查看的文件为 [[链接文件]] 时 ; [[stat]] 函数所查看的是链接文件所指向的文件的详细信息 ; [[lstat]] 函数所查看的是链接文件本身的详细信息

- [[buf]] : 用于存储所查看文件详细信息的缓冲区，其类型为 [[struct stat]]，其结构如下
    ```c
    struct stat {
        dev_t       st_dev;              /* File device number */
        ino_t        st_ino;              /* File serial number */
        mode_t    st_mode;          /* File type and permissions (16 bit) */
        nlink_t        st_nlink;         /* Link count */
        uid_t           st_uid;           /* User ID of the file's owner.	*/
        gid_t      st_gid;                /* Group ID of the file's owner.	*/
        dev_t     st_rdev;              /* Device number, if device */
        off_t           st_size;          /* Size of file, in bytes */
        blksize_t     st_blksize;     /* Optimal block size for I/O */
        blkcnt_t      st_blocks;     /* Number 512-byte blocks allocated */
        time_t        st_atime;       /* Time of last access */
        time_t        st_mtime;      /* Time of last modification */
        time_t        st_ctime;       /* Nsecs of last status change */
	};
    ```

    在这里，我们需要关注一点的是该结构体的 [[st_mode]] 成员，它是用来表示当前文件的文件类型和访问权限，是一个 [[int]] 类型的正整数，即 [[16 bit]] 的存储数据，系统库的设计者把这 [[16 bit]] 分为不同的段用于表示不同的信息，并且每一个段中都提供了值类型为 **8进制**{style="color:red"} 的宏定义让开发者更方便的获取到每一个段中所表示的信息

    -  [[0 ~ 2 bit]] : 其它人权限
       
        [[st_mode]] 存在某 [[1 bit]] 与与下宏定义 ( 除了掩码 ) 一致，则认为拥有这种权限
       -  [[S_IROTH]]  0000004 : 读权限
       - [[S_IWOTH]] 0000002 :   写权限
	   - [[S_IXOTH]] 0000001 : 执行权限
	   - [[S_IRWXO]] 0000007 : 掩码，用于过滤中除其他人权限以外的信息 ( 与 [[st_mode]] 进行一次 **按位与运算**{style="color:red"} 所得到的结果即为筛选后的结果 )

        ```c
        #include <stdio.h>
        #include <sys/stat.h>

        void main(void) {
          struct stat _s;
          if (stat("./text", &_s)) {
            perror("E");
            return;
          }

          if (_s.st_mode & S_IROTH) {
            printf("other read permission\n");
          }
          if (_s.st_mode & S_IWOTH) {
            printf("other write permission\n");
          }
          if (_s.st_mode & S_IXOTH) {
            printf("other execute perssion\n");
          }

          int oth_perssion = _s.st_mode & S_IRWXO;
        }
        ```

    -  [[3 ~ 5 bit]] : 所属组权限
       
        [[st_mode]] 存在某 [[1 bit]] 与与下宏定义 ( 除了掩码 ) 一致，则认为拥有这种权限
	    - [[S_IRGRP]] 0000040 : 读权限
	    - [[S_IWGRP]] 0000020 : 写权限
	    - [[S_IXGRP]] 0000010 :  执行权限
	    - [[S_IRWXG]] 0000070 : 掩码，用于过滤中除其他人权限以外的信息 ( 与 [[st_mode]] 进行一次 **按位与运算**{style="color:red"} 所得到的结果即为筛选后的结果 )
        ```c
        #include <stdio.h>
        #include <sys/stat.h>

        void main(void) {
            struct stat _s;
            if (stat("./text", &_s)) {
              perror("E");
              return;
            }

            if (_s.st_mode & S_IRGRP) {
              printf("group read permission\n");
            }
            if (_s.st_mode & S_IWGRP) {
              printf("group write permission\n");
            }
            if (_s.st_mode & S_IXGRP) {
              printf("group execute perssion\n");
            }

            int grp_perssion = _s.st_mode & S_IRWXU;
        }
        ```
    - [[6 ~ 8 bit]] : 文件所有者权限
      
        [[st_mode]] 存在某 [[1 bit]] 与与下宏定义 ( 除了掩码 ) 一致，则认为拥有这种权限
        - [[S_IRUSR]] 0000400 : 读权限
	    - [[S_IWUSR]] 0000200 : 写权限
	    - [[S_IXUSR]] 0000100 : 执行权限
	    - [[S_IRWXU]] 0000700 : 掩码，用于过滤中除其他人权限以外的信息 ( 与 [[st_mode]] 进行一次 **按位与运算**{style="color:red"} 所得到的结果即为筛选后的结果 )
        ```c
        #include <stdio.h>
        #include <sys/stat.h>

        void main(void) {
            struct stat _s;
            if (stat("./text", &_s)) {
              perror("E");
              return;
            }

            if (_s.st_mode & S_IRUSR) {
              printf("user read permission\n");
            }
            if (_s.st_mode & S_IWUSR) {
              printf("user write permission\n");
            }
            if (_s.st_mode & S_IXUSR) {
              printf("user execute perssion\n");
            }

            int usr_perssion = _s.st_mode & S_IRWXU;
        }
        ```
    -  [[12 ~ 15 bit]] : 文件类型

        如果 [[st_mode]] 最高位的 [[4 bit]] 和一下宏定义一致，则认为当前文件是属于这种类型的文件
	    - [[__S_IFSOCK]] 0140000 : 套接字
	    - [[__S_IFLNK]] 0120000 : 符号链接（软链接）
	    - [[__S_IFREG]] 0100000 : 普通文件
	    - [[__S_IFBLK]] 0060000 : 块设备
	    - [[__S_IFDIR]] 0040000 : 目录
	    - [[__S_IFCHR]] 0020000 : 字符设备
	    - [[__S_IFIFO]] 0010000 : 管道
	    - [[__S_IFMT]] 0170000 : 掩码，用于过滤中除其他人权限以外的信息 ( 与 [[st_mode]] 进行一次 **按位与运算**{style="color:red"} 所得到的结果即为筛选后的结果 )

        ```c
        #include <stdio.h>
        #include <sys/stat.h>

        void main(void) {
          struct stat _s;
          if (stat("./text", &_s)) {
            perror("E");
            return;
          }
        
          switch (_s.st_mode & __S_IFMT) {
          case __S_IFREG:
            printf("ref file\n");
            break;
          case __S_IFDIR:
            printf("dir file\n");
            break;
          case __S_IFBLK:
            printf("blk file\n");
            break;
          case __S_IFCHR:
            printf("chr file\n");
            break;
          case __S_IFSOCK:
            printf("sock file\n");
            break;
          case __S_IFLNK:
            printf("lnk file\n");
            break;
          case __S_IFIFO:
            printf("ifo file\n");
            break;
          defult:
            printf("unknown file\n");
            break;
          }
        }
        ```

        系统库内置了几种宏函数也可以完成文件类型的判断，当然，宏函数内部的实现还是围绕着匹配最高位的 [[4 bit]] 去识别文件的类型去进行展开的，只是宏函数为我们做了一层封装
        - [[S_ISLNK(mode)]] : 是否为链接文件
        - [[S_ISBLK(mode)]] : 是否为块设备
        - [[S_ISCHR(mode)]] : 是否为字符设备
        - [[S_ISREG(mode)]] : 是否为普通文件
        - [[S_ISDIR(mode)]] : 是否为目录文件
        - [[S_ISSOCK(mode)]] :是否为套接字
        - [[S_ISFIFO(mode)]] :是否为管道

        ```c
        #include <stdio.h>
        #include <sys/stat.h>

        void main(void) {
          struct stat _s;
          if (stat("./text", &_s)) {
            perror("E");
            return;
          }

          if (S_ISLNK(_s.st_mode)) {
            printf("lnk file\n");
          } else if (S_ISBLK(_s.st_mode)) {
            printf("blk file\n");
          } else if (S_ISCHR(_s.st_mode)) {
            printf("chr file\n");
          } else if (S_ISREG(_s.st_mode)) {
            printf("reg file\n");
          } else if (S_ISDIR(_s.st_mode)) {
            printf("dir file\n");
          } else if (S_ISSOCK(_s.st_mode)) {
            printf("sock file\n");
          } else if (S_ISFIFO(_s.st_mode)) {
            printf("fifo file\n");
          } else {
            printf("unknown file\n");
          }
        }
        ```


<br/>

#### DIR *opendir(const char *dir_name)
##### <sys/types.h> <unistd.h> <dirent.h>

依据所指定的目录文件路径 [[dir_name]] 去打开一个目录文件，如果成功，则返回 [[DIR]] 类型的指针，如果失败，则返回 [[NULL]]

当函数成功调用，所返回的 [[DIR]] 类型的指针其内部就会有建立出一个数组，它存储着当前目录文件下所有深度为 [[1]] 的文件，而数组中的元素我们也通常也称之为 **目录项**{style="color:red"}，每当我们通过 [[readdir]] 去读取一个 [[DIR]] 指针内部的目录项的时候，每一次成功的读取都会使当前 DIR 指针内部的读取计数自增一，以便下一次进行读取的时候所拿到的结果是一个新的目录项的结果

[[DIR]] 类型有 [[typedef]] 所定义，其所引用的类型为 [[__dirstream]]，该类型存在于 [[glibc]] 标准库之中，由 [[gcc]] 在为源程序进行编译时所自动链接的库之一，简而言之，该类型并不存在于当前编译单元之中，其存在透过 [[typedef]] 所定义的结构体的特性并在 [[link]] 阶段使其存在扩展至了其它的编译单元之中

```c
#include <sys/types.h>
#include <unistd.h>
#include <dirent.h>

int main(void) {
  DIR *root = opendir("./");
  if (root == NULL) {
    perror("E");
    return;
  }

  return 0;
}
```

<br/>

#### struct dirent *readdir (DIR *dir)
##### <sys/types.h> <unistd.h> <dirent.h>

依据已打开的 [[DIR]] 指针去读取其内部的 **目录项**{style="color:red"}，如果成功则返回当前所读取到的类型为 [[dirent]] 的目录项指针，否则返回 [[NULL]]

- [[dirent]] : 用于存储所查看目录项信息的结构体，其结构如下
    ```c
    struct dirent
    {
        ino_t d_ino;                            /* Inode number */
        off_t d_off;                             /* Current position offset in the directory stream */
        signed short int d_reclen;     /* Length of d_name */
        unsigned char d_type;          /* File type */
        char d_name[256];	             /* File name */
    };
    ```
    其中，[[d_type]] 成员系统库内置了以下宏定义提供给外部进行判断使用

    - DT_BLK : 块设备
    - DT_CHR : 字符设备
    - DT_DIR : 目录
    - DT_LNK : 软连接
    - DT_FIFO : 管道
    - DT_REG : 普通文件
    - DT_SOCK : 套接字
    - DT_UNKNOWN : 未知


```c
#include <sys/types.h>
#include <unistd.h>
#include <dirent.h>
#include <string.h>

DIR *root = opendir(path);
if (root == NULL) {
  perror("E");
  return;
}

struct dirent *item = NULL;
while ((item = readdir(root)) != NULL) {
  /* Dont't process unless directory file */
  if (item->d_type == DT_DIR &&
         ((strcmp(item->d_name, ".") == 0) || (strcmp(item->d_name, "..") == 0))) {
        continue;
  }

  switch (item->d_type) {
  case DT_DIR:
    /* do */
    break;
  case DT_REG:
    /* do */
    break;
  default:
    /* do */
    break;
  }
}
closedir(root);
```

<br/>

#### int closedir (DIR *dir)
##### <sys/types.h> <unistd.h> <dirent.h>

关闭所打开的文件目录 [[dir]]，如果成功则返回 [[0]]，失败则返回 [[-1]]

由于每一个成功打开 ( [[opendir]] ) 的文件目录其内部所维护的目录项数组存放于堆中，所以我们要保证每一个打开的文件目录在使用完毕后都需要对其进行关闭，否则可能会发生内存泄漏的问题

```c
#include <sys/types.h>
#include <unistd.h>
#include <dirent.h>

int main(void) {
  DIR *root = opendir("./");
  if (root == NULL) {
    perror("E");
    return;
  }

  closedir(root);

  return 0;
}
```


<br/>

#### int dup(int fd)
##### <sys/types.h> <unistd.h> <fcntl.h>

拷贝文件描述符 [[fd]] 所指向的 [[inode]] 编号，并维护进 PCB 文件描述符符号表的最小下标中，最后返回所操作的下标，即相应的文件描述符，如果失败，则返回 [[-1]]

```c
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>

int main(void) {
  int _fd = open("./test.log", O_WRONLY | O_CREAT, 0644);
  if (_fd == -1) {
    perror("E");
    return;
  }
  write(_fd,"hello",strlen("hello"));  

  int new_fd = dup(_fd);
  write(new_fd,"world",strlen("world"));

  close(_fd);
  close(new_fd);


  return 0;
}
```

<br/>

#### int dup2(int fd_src, int fd_des)
##### <sys/types.h> <unistd.h> <fcntl.h>

拷贝原始文件描述符 [[fd_src]] 所维护的 [[inode]]，并将它写入至目标文件描述符 [[fd_des]] 在文件描述符表中所维护的数据区中，如果 [[fd_des]] 已经维护了某一个 [[inode]]，则先关闭这个文件再进行拷贝操作，最后返回 [[fd_des]] 的值，如果失败，则返回 [[-1]]

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>

int main(void) {
 /* Init */
 /** 
   * 0 STDIN_FILENO    -> stdin
   * 1 STDOUT_FILENO -> stdout
   * 2 STDERR_FILENO  -> stderr
   */


  /* Write data */
  /** 
   * 0 STDIN_FILENO    -> stdin
   * 1 STDOUT_FILENO -> stdout
   * 2 STDERR_FILENO  -> stderr
   * 3 _fd_w                   -> test.log
   */
  int _fd_w = open("./test.log", O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
  if (_fd_w == -1) {
    perror("E");
    return;
  }


  /* Save and redirect stdout fd */
  /** 
   * 0 STDIN_FILENO    -> stdin
   * 1 STDOUT_FILENO -> stdout
   * 2 STDERR_FILENO  -> stderr
   * 3 _fd_w                   -> test.log
   * 4 std_out                -> stdout
   */
  int std_out = dup(STDOUT_FILENO);
  /** 
   * 0 STDIN_FILENO     -> stdin
   * 1 STDOUT_FILENO -> test.log
   * 2 STDERR_FILENO  -> stderr
   * 3 _fd_w                   -> test.log
   * 4 std_out                -> stdout
   */
  dup2(_fd_w, STDOUT_FILENO);


  /* Write to test.log */
  printf("hello,world!\n");
  printf("hello,NGPONG!\n");
  printf("hello,C Langaers!\n");
  fflush(stdout);


  /* Complete close test.log */
  /** 
   * 0 STDIN_FILENO    -> stdin
   * 1 STDOUT_FILENO -> test.log
   * 2 STDERR_FILENO  -> stderr
   * 3
   * 4 std_out                -> stdout
   */
  close(_fd_w);
  /** 
   * 0 STDIN_FILENO   -> stdin
   * 1 
   * 2 STDERR_FILENO -> stderr
   * 3
   * 4 std_out               -> stdout
   */
  close(STDOUT_FILENO);


  /* Resume stdout postion. */
  /** 
   * 0 STDIN_FILENO    -> stdin
   * 1 STDOUT_FILENO -> stdout
   * 2 STDERR_FILENO  -> stderr
   * 3
   * 4 std_out                -> stdout
   */
  int i = dup(std_out);
  /** 
   * 0 STDIN_FILENO    -> stdin
   * 1 STDOUT_FILENO -> stdout
   * 2 STDERR_FILENO  -> stderr
   * 3
   * 4 
   */
  close(std_out);


  /* Read data */
  /** 
   * 0 STDIN_FILENO    -> stdin
   * 1 STDOUT_FILENO -> stdout
   * 2 STDERR_FILENO  -> stderr
   * 3 _fd_r                    -> test.log
   * 4 
   */
  int _fd_r = open("/home/ngpong/code/C/C-Study-03/file_05/test.log", O_RDONLY);
  if (_fd_r == -1) {
    perror("E");
    return;
  }

  char buf[64] = { 0 };
  while ((read(_fd_r, buf, sizeof(buf))) != 0) {
    printf("%s",buf);
  }
  fflush(stdout);
  /** 
   * 0 STDIN_FILENO    -> stdin
   * 1 STDOUT_FILENO -> test.log
   * 2 STDERR_FILENO  -> stderr
   * 3
   * 4 
   */
  close(_fd_r);
}
```

<br/>

#### int fcntl(int fd, int cmd, ...)
##### <sys/types.h> <unistd.h> <fcntl.h>

一个功能强大的 [[API]]，其内置了众多针对于文件进行控制的功能

- [[_fd]] : 需要进行操作的文件的文件描述符
- [[cmd]] : 当前函数需要进行操作的命令，[[fcntl]] 函数的返回值的含义也由该参数的变化而变化
  - [[F_DUPFD]] : 拷贝文件描述符 [[_fd]]，其功能和 [[dup]] 函数一致，成功后返回新的文件描述符，否则返回 [[-1]]
  - [[F_GETFL]] : 获取当前文件描述符所指向的文件在打开 ( [[open()]] ) 时所指定的 [[flag]]，如果成功则返回对应的 [[flag]]，否则返回 [[-1]]
  -  [[F_SETFL]] : 重置当前文件描述符所指向的文件的 [[flag]] 为第三个参数 [[...]] 的指定，成功返回 [[0]]，否则返回 [[-1]]
- [[...]] : 可变参数，依赖于第二个参数的录入去决定是否录入


```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>

int main(void) {
  int _fd = open("./test.log", O_WRONLY);
  if (_fd == -1) {
    perror("E");
    return;
  }
  write(_fd, "WRITE!", strlen("WRITE!"));

  /* Append file flag option */
  int _fl = fcntl(_fd, F_GETFL);
  fcntl(_fd, F_SETFL, _fl | O_APPEND);
  write(_fd, "APPEND!", strlen("APPEND!"));

  /* Redirct file number */
  int _new_fd = fcntl(_fd, F_DUPFD);
  if (_new_fd == -1) {
    perror("E");
    return;
  }
  write(_new_fd, "new fd test\n", strlen("new fd test\n"));

  /* Complete close file */
  close(_fd);
  close(_new_fd);
}
```

<br/>

### 特殊的关键字
<span id="特殊的关键字"></span>

---

#### typedef
<span id="typedef"></span>

该关键字能够给系统现有的数据类型起别名 ( 新的数据类型 ) ，需要注意的是，我们不能给一个已经经过了 [[typedef]] 定义的新的数据类型使用该关键字再次进行定义

通常使用 [[typedef]] 定义过的新类型约定俗成使用 [[_t]] 进行结尾

[[typedef]] 所引用的数据类型如果是 **结构体类型**{style="color:red"}，则可以在当前编译单元之中不存在的，这个不存在的结构体类型可以在编译器进行 [[link]] 阶段时把它扩展至其它的编译单元之中，这里注意的是，是编译器在进行 [[link]] 阶段时才能保有这一特性，也就是说我们要保证这个 [[typedef]] 所定义的新的数据类型在进行定义的时候其存在形式是以指针的形式而存在，并且就算使用这个指针，我们也无法获取当前类型实例里面的具体成员信息，因为仅有指针类型，编译器在进行 [[compile]] 阶段时才能够恒定知道其所占用的具体内存大小，并且由于 [[typedef]] 所引用的类型在当前编译单元之内是不存在的 ( 会在 [[link]] 阶段扩展至其它的编译单元之中 )，所以就算我们能够使用这个指针类型也无法获取其内部的成员信息，否则回在 [[compile]] 阶段时候出错

对于重复定义的 [[typedef]] 语法上是允许的，但是不能允许定义使用了相同名字但是却引用的不同类型的 [[typedef]]，重复仅只是所引用的类型和所定义的类型名是一致的基础上才能进行开展

Struct
```c
#include<stdio.h>

typedef struct Person {

    int Age;
    char *Name;
    int Gender;
} person_t;

int main(void) {

    person_t per = {10,"NGPONG",1};

    return 0;
}
```

Base data type

```c
#include<stdio.h>

typedef int int32_t;

int main(void) {

    int32_t value = 10;
    value++;

    return 0;
}
```

Pointer

```c
#include<stdio.h>

typedef int *p_t;

int main(void) {
    
    int a = 10;
    p_t p = &a;
    (*p)++;

    return 0;
}
```

Arrary

```c
#include<stdio.h>

typedef int arrary_t[3];

int main(void) {
    
    arrary_t arrary = {1,2,3};
    for (size_t i = 0; i < sizeof(arrary) / sizeof(*arrary); i++) {

        printf("arrary[%d] = %d\n", i, arrary[i]);
    }

    return 0;
}
```

Pointer arrary

```c
#include<stdio.h>

typedef int *ptr_arrary_t[3];

int main(void){

    int a = 10;
    int b = 20;
    int c = 30;

    ptr_arrary_t arrary = { &a,&b,&c };
    for (size_t i = 0; i < sizeof(arrary) / sizeof(*arrary); i++) {

        printf("arrary[%d] = %d\n", i, *arrary[i]);
    }

    return 0;
}
```

Arrary pointer

```c
#include<stdio.h>

typedef int (*arrary_ptr_t)[2];

int main(void){

    int arrary[3][2] = {
        {1,2},
        {3,4},
        {5,6}
    };

    arrary_ptr_t arrary_p = arrary;

    for (size_t i = 0; i < sizeof(arrary) / sizeof(*arrary); i++) {

        printf("row = %d\n", i);
        for (size_t j = 0; j < sizeof(*arrary) / sizeof(**arrary); j++) {

            printf("   col = %d val = %d\n", j, *(*(arrary + i) + j));
        }
    }

    return 0;
}
```

Function

```c
#include<stdio.h>

void fun_test() {

    printf("Hello,World!\n");
}

typedef void fun_t();

int main(void){

    fun_t *f_p = fun_test;
    f_p();

    return 0;
}
```

Function pointer

```c
#include<stdio.h>

void fun_test() {

    printf("Hello,World!\n");
}

typedef void (*fun_p_t)();

int main(void){

    fun_p_t fun = fun_test;
    fun();

    return 0;
}

```

<br/>

#### register
<span id="register"></span>

[[register]] 关键字能够用于变量的声明，作用于告诉编译器， [[建议]] 当前变量使用 [[寄存器]] 进行存储，以提升读写的效率

当然， [[register]] 是建议型的指令，而不是命令型的指令，如果 CPU 有空闲寄存器，那么 [[register]] 就生效，如果没有空闲寄存器，那么 [[register]] 无效，所声明的变量则按普通声明的方式来处理

那么我们该如何判断 [[register]] 是否生效？我们都知道一般变量都是存储在 RAM 当中，其都有一个地址去指向这个变量，而如果声明成功的话，变量则存放在寄存器当中，而在寄存器当中这个变量是没有地址的，我们靠这一特性就可以判断该关键字是否其效果

```c
#include <stdio.h>

int main(void){

    register int a = 10;
    a++;
    printf("%d\n",a);

    return 0;
}
```

<br/>

#### volatile
<span id="volatile"></span>

该关键字能够防止编译器对重复使用的变量进行优化，主要集中在硬件领域开发用的较多，举个例子，跑马灯的控制通常都有一个变量作为标识，比如说 [[int flag = 0]] ， 当它等于 [[0]] 时就代表亮了，等于 [[1]] 时就代表熄灭，而硬件在使用的过程当中，因为跑马灯需要重复的关闭和开启，所以这个变量 [[flag]] 会进行重复的赋值，这时候编译器查看到这个变量存在多次赋值的性质的时候，就自动的帮我把程序在中间运行过程中对于该变量 [[flag]] 所赋值的代码都删除掉，而当我们加了这个关键字之后，能够防止编译器对于此处所进行的优化

```c
#include <stdio.h>

int main(void){

    volatile int flag = 0;
    flag = 1;
    flag = 0;
    flag = 1;
    flag = 0;

    flag = 1024;
    printf("%d\n",flag);
    
    return 0;
}
```

<br/>

### 编译
<span id="编译"></span>

---

#### 编译时所经历的 4 个步骤
<span id="编译时所经历的4个步骤"></span>

- 预处理 ( 预处理器 $cpp$ )
    - **头文件**{style="color:red"} 的展开，该阶段不进行文件检查，可以展开任意文件
    - **宏定义**{style="color:red"} 的展开，即进行宏定义替换，将上下文中出现的宏名都替换成所对应的宏值
    - **条件编译**{style="color:red"} 的展开，根据条件来展开指令
    - 替换注释，把注释内容都替换成空行
    - 进行一些最基本的语法检查 ( 宏定义、头文件引入和条件编译的语法 )
    - 将 **源文件**{style="color:red"} 的处理结果生成为 **预处理文件**{style="color:red"}
    - 预处理文件的后缀通常以 [[.i]] 作为结尾

- 编译 ( 编译器 $gcc$ )
    - 对上一步骤所生成的预处理文件再逐行进行一次严格的语法检查，该步骤也是最耗时的一个步骤，是4个处理步骤中最占用时间的一个小节
    - 将 **预处理文件**{style="color:red"} 的处理结果生成为 **汇编文件**{style="color:red"}
    - 汇编文件的后缀通常以 [[.s]] 作为结尾

- 汇编 ( 汇编器 $as$ )
    - 将 **汇编文件**{style="color:red"} 中的汇编指令翻译为二进制编码，并整合为 **二进制文件**{style="color:red"}
    - 二进制文件的后缀通常以 [[.o]] 作为结尾

- 链接 ( 链接器 $ld$ )
    - 数据段合并
    - 数据地址回填
    - 库引入 ( [[windows]] 下可以通过 [[Depend.exe]] 来查看可执行文件具体所引用的库 )
    - 将 **二进制文件**{style="color:red"} 编译为一个 [[可执行程序]]

<br/>

#### GCC
<span id="GCC"></span>

GCC 是一款编译器，其内部完全按照 c 标准来进行的实现，即是一款较为主流且标准的编译器的选择之一，对于 [[GCC]] 的使用而言，其有些参数需要我们进行掌握

#### source

如果 [[source]] 所指定的文件为一个 [[源文件]]，则将文件 [[source]] 编译为 [[可执行文件]]，所生成的可执行文件名为 [[source]] 的文件名

如果 [[source]] 所指定的文件为一个 [[二进制文件]]，则对文件 [[source]] 进行链接操作，并把链接后的结果生成为一个可执行文件，所生成的可执行文件名为 [[source]] 的文件名

```c
gcc source.c

gcc source.o
```

#### -E source.c

对源文件 [[source.c]] 进行预处理，并把预处理的结果输出至在所操控的终端上，如果想把所进行的预处理的结果整合为一个预处理文件，则需要使用到 [[-o]] 指令来指定生成一个预处理文件

```c
gcc -E source.c
```

#### -S source.i

把预处理文件 [[source.i]] 编译为一个汇编文件，所生成的汇编文件名为 [[source]]

```c
gcc -S source.i
```

#### -c source.s

把汇编文件 [[source.s]] 翻译为一个二进制文件，所生成的二进制文件名为 [[source]]

```c
gcc -c source.s
```

#### -o source
指定当前编译操作后所生成文件指定文件名为 [[source]]

```c
gcc source.c -o source

gcc -E source.c -o source.i
gcc -S source.i -o source.s
gcc -c source.s -o source.o
gcc source.o -o source
```

#### -I path

指定当前源文件所使用到的、非系统头文件的路径

```c
gcc source.c -I ./HEADER_PATH/
```

#### -L path

指定编译单元所使用到的自定义库的路径

```c
gcc source.c -L ./LIBRARY_PATH/
```

#### -l library

指定编译单元所使用到的自定义库的名字，需要注意的是，对于库名的指定我们无法指定库的完整文件名，仅需指定库的名字即可

```c
gcc source.c -I ./LIBRARY/
```

#### -g

使用 gdb 进行调试时需要添加的参数，否则无法输出源文件的代码，即全都是二进制符

```c
gcc -g source.c -o source
```


<br/>

#### 头文件
<span id="头文件"></span>

头文件以 [[.h]] 作为文件的后缀，区别于源文件，我们在头文件中所编写的内容只是对于某种内容的声明操作以至于头文件在所被包含的源文件在进行预处理阶段的时候，把所声明的工作整合至源文件当中，对于头文件来说，我们通常使用它来进行

- 包含其它的头文件
- 函数的声明
- 类型的声明
- 变量的声明或定义
- 宏的定义

想要源文件中在预处理阶段引入头文件的内容并把其中的内容合并到源文件当中，则需要通过 [[#include]] 指令去引入具体的某个头文件

头文件的编写工作通常需要以 [[头文件守卫]] 的编写作为开始，<span style="color:red">头文件守卫作用与防止重复包含头头文件，以避免同一个源文件中对于某个具体的头文件进行了重复的展开而导致编译速度过慢或者是可能产生的具体某个成员进行了重复定义的问题 </span>

```c
#ifndef __HEADFILENAME_H__
#define __HEADFILENAME_H__ 

/* head file content */

#endif   
```

<br/>

### 项目构建工具
<span id="项目构建工具"></span>

---

#### makefile
<span id="makefile"></span>

**makefile 是什么**

makefile 是一个类似于 windows 上的批处理文件，其文件名就是 makefile(无后缀)，其内部定义了一系列的规则，这些规则通又能够映射到一些 shell 命令并在合适的情况下执行它们

事实上，makefile 通常用于大型 c/c++ 的项目构建，一个工程中的源文件不计其数，并且按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile 就像一个 shell 脚本一样，其中也可以执行操作系统的命令

<br/>

**make 命令**

make 是一个用来解释 makefile 文件内部锁编写指令的 **_命令工具_**(一般来说，大多数的IDE都有这个命令，比如：Delphi 的 make，Visual C++ 的 nmake，Linux 下 GNU 的 make)

make 命令十分简单，<font color = "red">当我们在一个工程目录下输入 `make` 时，它就会在当前目录下(仅在一级目录下搜索)寻找是否存在文件名为: **_GNUmakefile / Makefile / makefile_** 的文件，如果存在则打开该文件并逐行解析其内部所提前写入的指令，如果不存在则报错并返回</font>

make 还能够执行 makefile 文件中单独的一个 <font color = "red">**target**</font>，其格式为 `make <target>`，关于这点现在说为时过早，后面还会继续提到

<br/>

**makefile 的规则**

makefile 的规则是 makefile 的核心，理解它其实就离掌握 makefile 的编写成功了一大半，其定义如下 : 

```makefile
target [...] : prerequisites [...]
    command
    [...]
    [...]
```

其中: 

- `target` : 它标示着目标文件，当然我们也可以把它当成一个存粹的 `<label>`(标签)，作为一段规则中，它是必不可少的存在，因为<font color = "red">一个目标用来构成一条 makefile 规则</font>

- `prerequisites` : 生成当前规则的 `target` 所依赖 `文件`(以 makefile 所在目录为根进行搜索，默认下仅为一级) 或 `其它target`，可以指定多个

- `command` : 当前规则所执行的命令(shell)

我们其实不难发现，<font color = "red">一段规则其实是在定义一段文件的依赖关系，即 : 构建目标(**_target_**)的前置条件(**_prerequisites_**)是什么，以及如何构建(**_command_**)</font>

事实上，我们还需要细化为 : 

1. 当输入 make 指令后，会在当前把目录下(仅为一级)找到文件名为 makefile/Makefile 的文件，如果找到则开始解释该文件中的规则，如果没找到，则指令报错并返回

2. 默认情况下会翻译由上至下所编写的第一条规则，并设置当前规则的 **_target_** 属于最终目标文件，当然我们还可以强制 make 去执行我们所需执行的 **_targent_** 的规则，即 : `make <target>`

3. 当前所翻译的规则是否存在前置条件(**_prerequisites_**)

     - 不存在 :  检测当前目录下是否存在一个文件其文件名为当前规则的 **_target_**

       - 不存在 : 执行当前规则下的 **_command_**，并设置 **_当前所遍历到的prerequisites_** 为 **_就绪状态_**(如果这一步是由上级 **_prerequisites_** 的遍历所派生下来的话)

       - 存在 : 由于没有前置条件的规则无任何依赖，故会认为该文件是最新的，如果当前规则的 **_target_** 作为 **_最终目标文件_** 而存在，则会提示当前规则 **_target_** 所生成的文件已经是最新，否则会退回到上一步，并设置 **_当前所遍历到的prerequisites_** 为 **_就绪状态_**(如果这一步是由上级 **_prerequisites_** 的遍历所派生下来的话)

     - 存在 : 遍历该规则的前置条件 **_prerequisites_**

        - 所遍历的所有前置条件 **_prerequisites_** 是否已被置为 **_就绪状态_** ? 

          - 是 : 检测当前目录下是否存在一个文件其文件名为当前规则的 **_target_**

            - 是 : 对比所查找到的该文件的修改时间和当前规则下所有已呈现 **_就绪状态_** 的 **_prerequisites_** 所对应文件的修改时间
      
              - 后者中的 **_任意一个条目_** 是大于前者 : 执行当前规则下的 **_command_**，并设置 **_当前所遍历到的prerequisites_** 为 **_就绪状态_**(如果这一步是由上级 **_prerequisites_** 的遍历所派生下来的话)

              - 前者大于后者中的 **_任意一个条目_** : 如果当前规则的 **_target_** 作为 **_最终目标文件_** 而存在，则会提示当前规则 **_target_** 所生成的文件已经是最新，否则会退回到上一步，并设置 **_当前所遍历到的prerequisites_** 为 **_就绪状态_**(如果这一步是由上级 **_prerequisites_** 的遍历所派生下来的话)
      
            - 否 : 直接执行当前规则下的 **_command_**，并设置 **_当前所遍历到的prerequisites_** 为 **_就绪状态_**(如果这一步是由上级 **_prerequisites_** 的遍历所派生下来的话)

          - 否 : 在当前 makefile 中查找是否存在一个使用了以 **_当前所遍历到的prerequisites_** 作为 **_target_** 的规则
      
              - 存在 : 检测当前目录下是否存在一个文件其文件名为当前规则(即 : 当前所遍历的 **_prerequisites_**)
      
                - 不存在 / 存在 : 翻译所找到的这个规则，并回到 **_第三步_** 检测前置条件

              - 不存在 : 检测当前目录下是否存在一个文件其文件名为当前所遍历的 **_prerequisites_**
      
                  - 不存在 : 指令报错并返回

                  - 存在 : 设置 **_当前所遍历到的prerequisites_** 为 **_就绪状态_**，并回到 所遍历的所有前置条件 **_prerequisites_** 是否已被置为 **_就绪状态_** 这一步


这就是整个 make 的依赖性，make 会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件，在找寻的依赖过程中，如果出现错误，比如最后被依赖的文件找不到，那么 make 就会直接退出并报错，而对于所定义的命令的错误，或是编译不成功，make 根本不理，<font color = "red">因为 make 所关注的仅仅只是文件的依赖性</font>

下面展示了 makefile 的一个最基本的用法，请使用它来生成一个 `makefile` 文件，并在终端中使用 `make` 命令以查看生成的顺序

```makefile
1: 2
	touch 1

2: 3 4
	touch 2

3: 5
	touch 3

4: 
	touch 4

5: 
	touch 5

clean:
	@find ./ ! -name "makefile" ! -name "." -exec rm -rf {} \;
	@echo "cleaned"
```

<br/>

**makefile 中的变量**

makefile 文件中可以定义我们所需要的变量，其定义方式呈键值对的格式，即: `name = value`

需要注意的是，<font color = "red">在 makefile 中所定义的变量，make 解释器对其解释的顺序是呈上至下进行翻译的，也就是说如果我们在定义变量的位置之前使用了该变量，那么将无法正确的获取到它</font>

```makefile
object = 2 3

1: $(object)
	touch 1
	@echo "hello,@(object)" # can't not used in string

2: 
	touch 2

3: 
	touch 3

clean:
	@find ./ ! -name "makefile" ! -name "." -exec rm -rf {} \;
	@echo "cleaned"
```

<br/>

**make 隐晦规则的自动推导**

GNU 的 make 很强大，它可以自动推导文件以及文件依赖关系后面的命令，make 在解析 makefile 的过程中，只要看到一个规则的 `target` 呈现的是 `*.o` 的形式，如果该规则的 `prerequisites` 中并无显式的声明 `*.c` 的依赖，则在解释过程中就会自动为我们加上，并且，关于所执行的 `command` 也会自动被推导出来，正如下面的例子

```makefile
cc = gcc
object = main.o common.o

main: $(object)
	$(cc) $(object) -o main

main.o: common.h
common.o: common.h

.PHONY:
clean:
	@find ./ ! -name "makefile" ! -name "." ! -name "*.c" ! -name "*.h" -exec rm -rf {} \;
	@echo "cleaned"
```

<br/>

**引用其它 makefile**

在 makefile 使用 `include` 关键字可以把别的 `makefile`(并无文件名要求) 包含进来，其语法格式为 : `include <filename>`

其中，所指定的 `<filename>` 支持 shell 文件模式，即可以包含一个具体的路径亦或者通配符，此外，我们还在在该参数中引入 makefile 中所定义的变量吗，举个例子，有这样几个 makefile : a.m, b.m, c.m，还有一个文件叫 foo.make ，以及一个变量 $(bar) ，其包含了 e.m 和 f.m ，那么，`include foo.make *.m $(bar)` 其实就等价于 `include foo.make a.m b.m c.m e.m f.m`

在执行 make 命令时，会找寻 `include` 所指出的其它 makefile，并把这些 makefile 的内容展开并安置在当前的位置，这就类似于 c/c++ 中的 `#include` 指令，如果我们在指定其它 makefile 的时候并没有指定路径，那么 make 会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找

- 当前目录(仅为一级)

- 如果 make 执行时，有 `-I` 或 `--include-dir` 参数，那么 make 就会在这个参数所指定的目录下去寻找

- 如果目录 `<prefix>/include`(一般是 : `/usr/local/bin` 或 `/usr/include`)存在的话，make 也会去找

<br/>

**指定 make 搜索 prerequisites 时的目录**

在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中，所以，当 make 需要去找寻文件的依赖关系时，我们是可以直接在 prerequisites 中指定文件的路径的，但最好的方法是把一个路径告诉 make，让 make 在自动去找

Makefile文件中的特殊变量 `VPATH` 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件，如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了，下面的代码指示了 make 在搜索依赖文件时，除了在当前目录寻找外，还要到 `./source` 和 `./header` 目录去找，其中，`:` 用于分隔需要查找的多个路径，值得一提的是，<font color = "red">即便指定了 VPATH，make 的优先寻找目录还是以当前 makefile 所在目录为准</font>

```makefile
#####################
# ├── header
# │   └── common.h
# ├── main.c
# ├── makefile
# ├── mk
# │   └── makefile
# └── source
#     └── common.c
#####################

VPATH = ./source:./header

main: main.o common.o
	cc main.o common.o -o main

common.o: common.h common.c
	cc -c ./source/common.c

main.o: common.h main.c
	cc -c main.c

.PHONY:
clean:
	@find ./ ! -name "header" ! -name "*makefile*" ! -name "mk" ! -name "source" ! -name "." ! -name "*.c" ! -name "*.h" -exec rm -rf {} \;
	@echo "cleaned"
```

另一个设置文件搜索路径的方法是使用make的 `vpath` 关键字(全小写),这和上面提到的那个VPATH变量很类似，但是它更为灵活，它可以指定不同的文件在不同的搜索目录中，这是一个很灵活的功能，它的使用方法有三种

- `vpath <pattern> <directories>` : 为符合模式 `<pattern>` 的文件指定搜索目录 `<directories>`

- `vpath <pattern>` : 清除符合模式 `<pattern>` 的文件的搜索目录

- `vpath` : 清除所有已被设置好了的文件搜索目录

vapth 使用方法中的 `<pattern>` 需要包含 `%` 字符，`%` 的意思是匹配零或若干字符，例如，`%.h` 表示所有以 `.h` 结尾的文件 ; `<pattern>` 指定了要搜索的文件集，而 `<directories>` 则指定了 `<pattern>` 的文件集的搜索的目录(`:` 同样可用于分隔需要查找的多个路径)

```makefile
#####################
# ├── header
# │   └── common.h
# ├── main.c
# ├── makefile
# ├── mk
# │   └── makefile
# └── source
#     └── common.c
#####################

vpath %.c source:bar
vpath %.h header

main: main.o common.o
	cc main.o common.o -o main

common.o: common.h common.c
	cc -c ./source/common.c

main.o: common.h main.c
	cc -c main.c

.PHONY:
clean:
	@find ./ ! -name "header" ! -name "*makefile*" ! -name "mk" ! -name "source" ! -name "." ! -name "*.c" ! -name "*.h" -exec rm -rf {} \;
	@echo "cleaned"
```

<br/>

**make 中的自动化变量**

- `$@` : 获取当前规则中的 **_target_**

- `$<` : 获取当前规则中的第一个 **_prerequisites_**

- `$^` : 获取当前规则中的所有 **_prerequisites_**


<br/>

### 预处理指令
<span id="预处理指令"></span>

---

预处理指令能够为 c 程序在进行 [[编译]] 工作前提供给 [[预处理器 ( Preprocessor )]] 进行一些额外的、我们所续期的预处理工作

<br/>

#### 头文件引入
<span id="头文件引入"></span>

头文件的引入工作通过指令 [[#include]] 来完成，它能够指定在源文件当中去包含某个具体的头文件，使预处理器在预处理阶段把所引入的头文件的内容展开至相应的源文件身上

[[#include "file.h"]] ：表示先在使用了该指令的当前文件的所在目录找 file，如果找不到，再按系统指定的目录检索

[[#include <file.h>]] ：表示直接按系统指定的目录检索 file 文件

<br/>

#### 宏
<span id="宏"></span>

宏的定义工作通过 **宏名**{style="color:red"} **宏值**{style="color:red"} 来完成定义，当我们在代码中使用了一个已经定义好了的宏后，那么在 **预处理阶段**{style="color:red"} 会将在代码中所使用的 宏名 都替换成其所对应的 宏值，这个过程也成为 宏展开 ，关于这点也可以衍生出另外一个问题，**宏定义是没有具体的数据类型的，因为其所做的只不过使对于宏名替换成宏值的一个操作，并不知道其具体的数据类型**{style="color:red"}

我们所定义的宏，默认情况下，其有效范围从当前文件中定义宏的位置开始直至文件的结束，当然也可以通过 [[#include]] 指令来把所定义宏内容的文件包括至其它文件中，也就是把宏的作用域提升至其它文件当中，需要注意的是，我们在一个函数的内部也可以定义宏，并且其作用域并不受函数内部的作用域所限制，也就是说在当前定义了宏的函数往下的函数都可以使用到这个宏

在进行宏定义中，宏值可以引用已定义的宏名，但是所引用的宏名必须要在当前宏定义之前进行声明 ( 编译器是逐行进行编译工作的 )

对于宏的不同定义方式所产生的效果也是不同，如下面则是他们的具体使用方式

- 宏常量
    - [[#define 宏名 宏值]]

    ```c
    #include <stdio.h>

    #define PI 3.14

    int main(void){

        double round_area = PI * 10;
        printf("%e\n",round_area);

        return 0;
    }
    ```

- 宏函数
    - [[#define 宏名(参数) 表达式]]

    - 宏函数对比普通函数的调用的开销更小，因为宏函数的调用是不需要进行入栈和出栈操作，仅仅只是一个 **_表达式替换_**，这种优势可以理解为 [[以空间换时间]]

    - 宏函数的定义一定要针对每个参数还有包括宏函数所定义的整个表达式都要带上括号，以保证这个宏函数定义的一个完整性

    ```c
    #define ADD(x,y) ((x) + (y))

    int main(void){

        printf("result = %d\n",ADD(3,4) * 2);

        return 0;
    }
    ```

    - 关于一些在 **_宏函数的表达式中_** 可使用的特殊定义宏 : 

      - `__VA_ARGS__` : 可将宏函数中的可变参数 `...` 使用该宏来进行表示

      ```c
      #include <stdio.h>

      #define DEBUG(format, ...) \
        printf(format, __VA_ARGS__)

      int main(int argc, char *argv[]) {
        /* printf("%s[%d]", hello,world, 1024); */
        DEBUG("%s[%d]", "hello,world", 1024);
        
        return EXIT_SUCCESS;
      }
      ```

      - `#` : 可以将参数转换为字符串形式，即 `"x"`，需要注意的是，在使用该宏函数的时候，要保证使用了该特殊定义的参数录入不包含特殊字符 `','`

      ```c
      #define DEBUG(msg) #msg

      int main(int argc, char *argv[]) {
        /* const char *msg = "hello1024"; */
        const char *msg = DEBUG(hello1024);
        
        return EXIT_SUCCESS;
      }
      ```

      - `##` : 分隔连接的方式，可以将参数连接至表达式的某个地方

      ```c
      #define DEBUG(format, ...) \
        printf(format, __VA_ARGS__)

      #define FUNCTION(name, arg ,type) void test_##name(type arg)

      /**
       * void test_foo(int val) {
       *   printf("%d", val);
       * }
      */
      FUNCTION(foo, val, int) {
        DEBUG("%d", val);
      }

      - `##__VA_ARGS__` : 当宏函数的调用并无录入可变参数时，并不会在使用了 `#__VA_ARGS__` 可变参数的前面添加 `','`

      ​```c
      #include <stdio.h>

      #define DEBUG(format, ...) \
        printf(format, ##__VA_ARGS__)

      int main(int argc, char *argv[]) {
        /* printf("%s[%d]", "hello,world", 1024); */
        /* 当录入了可变参数的情况，使用特殊宏定义 __VA_ARGS__ 时，会在参数前面添加 ',' */
        DEBUG("%s[%d]", "hello,world", 1024);

        /* printf("hello,world"); */
        /* 当未使用可变参数时，则不会在前面添加 ',' */
        DEBUG("hello,world");
        
        return EXIT_SUCCESS;
      }
      ```

- 编译时定义的宏

  - 我们可以在编译时通过参数 [[-D]] 去指定编译器去创建一个编译级别时的宏 ( $gcc$ )

- 卸载宏

    - [[#undef 宏名]]

    - 当我们可能通过某个头文件所引入的宏我们并不需要使用亦或者是我们所定义的宏需要进行卸载，则可以通过该表达式来指定所需要进行卸载的宏，当某一个宏在一个文件中进行了卸载，则该宏的作用域则在当前卸载宏的文件中将不复存在，即无法使用

    ```c
    #include <stdio.h>

    #define PI 3.14

    #undef PI

    int main(void){

        return 0;
    }
    ```

- 一些系统为我们所定义好的 [[预定义动态宏]]

    - [[__FILE__]]：获取使用了当前宏名所在文件的路径

    - [[__LINE__]]：获取使用了当前宏名所在的行数

    - [[__DATE__]]：获取使用了当前宏名参与编译时的日期

    - [[__TIME__]]：获取使用了当前宏名参与编译时的时间 

    ```c
    #include <stdio.h>

    int main(){

        printf("file address = %s\n", __FILE__);
        printf("line = %d\n", __LINE__);
        printf("date = %s\n", __DATE__);
        printf("time = %s\n", __TIME__);
    }
    ```

<br/>

#### 条件编译
<span id="条件编译"></span>

一般情况下，源程序中的代码的每一行都需参加编译的过程，但有时希望编译的过程只对源程序中的某一行在满足一定条件时才参与编译，这时候我们就需要针对这部分特殊的源程序行进行 [[条件编译]] 的指定

- [[#ifdef MACRO]] ：检测宏名是否存在 

    ```c
    #include <stdio.h>

    #define MACRO 10

    /* #undef MACRO */

    int main(void){

        int a;
    #ifdef MACRO
        a = MACRO;
    #else
        a = 1024;
    #endif

        printf("%d\n",a);
        return 0;
    }
    ```

- [[#ifndef MACRO]] ：检测宏名是否不存在 

    ```c
    #include <stdio.h>

    #define MACRO 10
    #undef MACRO

    int main(void){

        int a;
    #ifndef MACRO
        a = 1024;
    #else
        a = MACRO;
    #endif

        printf("%d\n",a);
        return 0;
    }
    ```

- [[#if 表达式]] ：指定具体为真的表达式

    ```c
    #include <stdio.h>

    #define MACRO 10
    #undef MACRO

    int main(void){

    #if 1
        printf("OK!");
    #endif

        return 0;
    }
    ```


<br/>

<span id="库的制作"></span>

### 库的制作

---

**库既是由源文件所编译而成的二进制文件，亦或者由众多源文件所编译而成的二进制文件的集合**{style="color:red"} ，它是源文件代码的另一种表现形式，只是库中的代码是呈二进制形式而存在的代码

当某个源文件在编译时指定了一个库，那么其在内的编译单元就可以将呈外部链接形式的声明提升至库中的具体定义，故 **对于一个库的使用通常还需要搭配这个库所提供的头文件去进行**{style="color:red"}

库的使用能够提高代码的可重用性，而且还可以提高程序的健壮性，对于重复功能亦或者想隐藏其定义的功能我们可以放入库中提供给开发者去使用，以减少开发者的代码开发量，并且在开发的过程中并不需要关于功能的实现

库具有两种存在形式，它们分别是：静态库 **$static library$**{style="color:red"} 和 共享库 **$share library$**{style="color:red"} 

库的命名规范通常以 [[lib]] 作为开头，往后衔接的就是库的名字 [[name]]，通常而言，[[name]] 也作为这个库的名字，再向后所衔接的就是后缀名，其存在形式以静态库为 [[.a]]，以共享库为 [[.so]]

<br/>

#### **静态库 $static$ $library$**

静态库的命名规范: **lib**{style="color:red"} name **.a**{style="color:red"}，其中，[[name]] 作为静态库的名字，而 [[libname.a]] 则作为静态库的文件名

静态库作为一个普通编译而成的二进制文件存在，即为 [[gcc -c]] 所编译而成的二级制文件亦或者多个二进制文件的打包 ( [[ar]] )，简而言之，静态库就是一种特殊命名规范的二进制代码，**我们是否将这个二进制文件加入到某个源程序的执行代码的一部分，决定了这个二进制文件是否称为静态库**{style="color:red"}

**静态库在某个源程序编译时就已经被加入到源程序的执行代码中，即作为可执行程序的一部分**{style="color:red"} ，这点也是静态库最大的特性

静态库的优缺点：

-   优点
    -   **实现函数本地化，寻址方便，速度快**{style="color:red"} ，我们对于静态库中的函数调用效率和在源程序内的自定义函数的调用效率是相同的
    -   **移植方便**{style="color:red"} ，由于静态库在编译时就被加入到执行代码的一部分，即静态库于源程序在运行时并无瓜葛，即便我们在编译完成源程序后删除了静态库也不影响源程序的继续使用
-   缺点
    -   假设我们有 [[10]] 个可执行文件在编译时都加入了相同的静态库作为执行代码的一部分，那么当这 [[10]] 个执行程序在运行时，在内存中就含有着 [[10]] 份相同静态库的资源信息，这也就造成了 **系统资源的消耗较大，浪费了较多的内存**{style="color:red"}
    -   **静态库对于更新、部署和发布是非常麻烦的**{style="color:red"} ，假设某个静态库被更新了，那么相应的，使用了这个静态库的所有源程序都需要重新进行一次编译，简而言之，**源程序过度依赖于静态库本身**{style="color:red"}

静态库的制作：
- 对于使用 [[gcc -c]] 所编译而成的二级制文件即可作为静态库而存在，需要注意的是，在进行库的编译时，我们需要生成符合静态库命名规范的目标文件
- 当我们存在多个二进制文件，并且想将它们打包为一个二进制文件时，可以使用命令: [[ar -rcs target sources]] ; 其中，[[target]] : 打包后的目标文件路径，[[sources]] : 需要被打包的多个二进制文件

静态库的使用：
- 我们只需要在编译源程序的时候，通过参数 [[-L]] [[-l]] 来指定静态库的路径和静态库名即可，那么在编译器进行编译时，则会把我们所指定的静态库含纳在当前执行代码之中

<br/>

#### **共享库 $share$ $library$**

共享库的命名规范: **lib**{style="color:red"} name **.so**{style="color:red"}，其中，[[name]] 作为共享库的名字，而 [[libname.a]] 则作为共享库的文件名

共享库是通过 **链接器**{style="color:red"} 所编译而成的二进制文件，我们在针对某个源文件进行编译的过程中，同样可以将共享库添加至当前编译单元的一部分，但是存在较大的区别的是，**静态库所添加的是整个库的二进制代码，而对于共享库来说，其添加进编译单元的内容仅仅只是库中的符号链接**{style="color:red"}，就此也能够得出一个结论，**通过链接静态库所生成的可执行程序总是会比链接共享库所生成的可执行程序要大**{style="color:red"}

**共享库在被加载后其存在于内存中，但是它和被链接到的可执行程序并不在一个内存段内，而是独立出来作为共享资源以供使用**{style="color:red"}，而可执行程序对于所链接到的共享库中的功能调用则会依靠其所链接到的共享库中的符号以映射至内存中共享库的具体功能以最终完成调用操作

对于链接了一个共享库的可执行程序在运行前都会使用 **动态载入器 ( $dynamic linker$ )**{style="color:red"} 先检测 **系统库路径亦或者自定义库路径中**{style="color:red"} **是否有其在编译时所指定链接的共享库的存在**{style="color:red"} ，如果不存在则会报错，**这是对于一个链接了共享库的可执行文件对于共享库的第一层依赖关系，也是最后一层依赖关系**{style="color:red"}，那么如果存在，则会依照当前所检测到的共享库的版本，去 **检测内存中是否已存在相同版本的共享库，如果存在，则不加载当前所链接的共享库至内存中，而是以已经存在于内存中的共享库作为调用基准**{style="color:red"}，那么当一个内存中的共享库并没有任何源程序的指向和调用时则会被内核所自动销毁，以至下一次所链接到该共享库的源程序的启动才再次将这个共享库放回至内存当中

共享库的优缺点：

-   优点
    -   **共享库把对一些库函数的链接载入推迟到程序运行的时期**{style="color:red"} ，甚至可以真正做到链接载入完全由程序员在程序代码中控制
    -   可以实现进程之间的资源共享
    -   共享库并不需要将所有的数据都编译进源程序内部，它们的依赖关系仅在源程序第一次启动时需要依赖于共享库本身，这就解决了静态库对程序的更新、部署和发布会带来麻烦，对于共享库的修改，用户只需要更新共享库即可
-   缺点
    -   由于对于共享库的调用都是以本地功能符号的调用作为映射基准，去映射至已存在于内存中的共享库的具体功能，**故对于共享库中的功能调用速度比静态库慢**{style="color:red"}
    -   移植性差，需要把所有用到的动态库都移植

共享库的制作：
- 为了能够在不同的进程间进行共享，在编译成二进制文件时需要使用 [[gcc -c -fpic]] 编译成 **与地址无关的二进制文件**{style="color:red"}
- 通过 **链接器**{style="color:red"} [[gcc --shared]]  将一个二进制文件链接为共享库，在进行库的链接时，我们需要生成符合共享库命名规范的目标文件

共享库的使用：
- 我们只需要在编译源程序的时候，通过参数 [[-L]] [[-l]] 来指定动态库的路径和共享库名即可，那么在编译器进行编译时，则会把我们所指定的共享库中的 **符号链接**{style="color:red"} 含纳在当前执行代码之中

动态载入器 ( $dynamic linker$ )：
- 动态载入器即为链接了共享库的可执行程序在第一次启动时，用于寻找其所链接到的共享库的路径的工具，它由多种不同的对象所组成，就 [[ELF]] 格式的可执行程序而言，动态载入器由 [[ld-linux.so]] 来充当，如果动态载入器在以下路径中都无法显示的找到共享库的路径，则可执行文件在启动时就会出错
  1. [[ELF]] 文件的 [[DT_RPATH]] 段
  2. 环境变量 [[LD_LIBRARY_PATH]]
  3. [[/etc/ld.so.cache]]
  4. [[/lib/]]
  5. [[/usr/lib/]]
  
    

<br/>

### 位运算
<span id="位运算"></span>

---

#### 位逻辑运算符
<span id="位逻辑运算符"></span>

- [[~]]：按位取反
    - 该操作符能够对于一个操作数的二进制数进行逐位取反工作
    - 由于是所有位进行取反工作，即 [[~]] 操作符所计算出来的真实值可能需要参与 [[反码]] [[补码]] 的运算
    ```c
                                                                       
    int a = ~2 ----------> ~ 0000 0010
                                 |
                               RESULT 
                                 |
                                 v                          
                             1111 1101 --INVERSE--> 1| 0000 0010 --COMPLEMENT--> 1| 0000 0011 --REAL--> int a = -3
    ```

<br/>

- [[&]]：位与
    - 对两个操作数的二进制数进行逐位比较，只要存在一个比较位为 [[0]] 则结果为 [[0]]，两个比较位都为 [[1]] 结果才为 [[1]]
    ```c
    int a = 147 & 61 ---->  1001 0011 
                          & 0011 1101
                                |
                              RESULT 
                                |
                                v   
                            0001 0001 --REAL--> int a = 17;
    ```
    - 特殊应用
      
        判断一个数是否为奇数，和 [[1]] 做位与运算，如果结果为 [[1]] 那么这个数就是奇数，原理是通过 **一个数的二进制位的末位如果是 1 那么这个数肯定是奇数**{style="color:red"} 这一特性来判断的

<br/>

- [[|]]：位或
    - 对两个操作数进行逐位比较，只要存在一个比较位为 [[1]] 则结果为 [[1]]，两个比较位都为 [[0]] 结果才为 [[0]]
    ```c
    int a = 147 | 61 ---->  1001 0011 
                          | 0011 1101
                                |
                              RESULT 
                                |
                                v 
                            1011 1111 --REAL--> int a = 191
    ```

    - 特殊应用
      
        将一个二进制数的任意位置置为 [[1]]，如：[[0000 0001]] 想转变为 [[1011 1111]] 的话，只需要把原数与 [[1011 1110]] 做位或运算即可，其实先主要是通过位或操作符能够把只要存在一个比较位为 [[1]] 的话，那么结果位的结果就为 [[1]] 的特性来实现的

<br/>
    
- [[^]]：位异或
    - 对两个操作数进行逐位比较，如果两个比较位相同，则结果位为 [[0]]，只要存在一个比较位不相同，那么结果位则为 [[1]]
    ```c
    int a = 147 ^ 61 ---->  1001 0011 
                          ^ 0011 1101
                                |
                              RESULT 
                                |
                                v 
                            1010 1110 --REAL--> int a = 174
    ```

    - 特殊应用
      
        位异或运算存在一个特性，三个数 [[A]] [[B]] [[C]] 进行异或运算的话其结果如下

        ```c
        A ^ B = C
        A ^ C = B
        B ^ C = A
        ```

        通过这一特性我们就能够两个实现变量之间进行交换

        ```c
        int main(void){

            int a = 20;
            int b = 30;

            a ^= b;
            b ^= a;
            a ^= b;
        }
        ```
<br/>

#### 移位运算符
<span id="移位运算符"></span>

- [[<<]] ：左移运算符

    - 将操作数的每一位都按照运算符右侧的值进行按向左移动，移动后的结果低位不足补 [[0]]
    - 移动的过程中，某一位如果超过最高位的限度，则该位需要摒弃
    - 左移运算的结果，相当于 **原值 * 2^n ( 移动位 )**{style="color:red"} 的结果

    ```c
    int a = 7 << 2 ----> 0000 0111 
                      <<     2
                             |
                           RESULT 
                             |
                             v 
                         0001 1100 --REAL--> int a = 28
    ```

<br/>

- [[>>]] ：右移运算符

    - 将操作数的每一位都按照运算符右侧的值进行按向右移动，移动后，如果原值为无符号位，则高位不足补 [[0]]，而如果原值为有符号位的话，则结果依赖于机器，有可能是使用 [[0]] 来补高位，也有可能是使用 [[符号位]] 来补高位
    - 移动的过程中，某一位如果超过最低位的限度，则该位需要摒弃
    - 右移运算的结果，如果原值位非负数，相当于 **原值 / 2^n ( 移动位 )**{style="color:red"} 的结果

    ```c
    int a = 138 >> 2 ----> 1000 1010 
                        >>     2
                               |
                             RESULT 
                               |
                               v 
                           0010 0010 --REAL--> int a = 34
    ```


<br/>

<span id="形参format"></span>

### 关于系统提供给我们的API中，形参为 [[format]] 时需要注意的问题

---

当我们使用部分 c 标准库所提供出来的 [[API]] 时，特别是针对数据录入的API，经常会函数的形参看到类型为 [[char *]] 参数名为 [[fortmat]] 的格式，并且后面的形参通常为一个可变参数标识符 [[...]] ( **实际上 c 语言中并没有内置可变参数 [[params]] 的标识符，其实现是通过函数形参地址的偏移来找到一个或多个由 [[caller]] 所录入的实参的**{style="color:red"} )，通常拥有该参数的函数功能可以通过 [[format]] 参数中所录入的 [[格式化模板]] ，然后把 [[fortmat]] 后面所跟随的可变参数依照所 [[format]] 中所指定的格式一一录入到一个新的字符串内，那么这个新的字符串可能会直接返回给我们，也可能会写入到文件，或者所指定的目标变量所指向的内存区域当中去，这其实并不重要，我们更需要了解的是上面所提到的 **格式化模板**{style="color:red"} 具体由哪些格式所组成

关于 [[格式化模板]] 其内置了很多标识符以供我们去使用，以下则为常用的一些格式化标识符

- [[%%]]：对于 [[%]] 的转移，以使 [[%]] 不会被认定为一个转移连接符，而是作为一个普通字符进行处理
- [[%d]]：标识一个 10 进制的 signed int 数值
- [[%o]]：标识一个 8 进制的  signed int 数值
- [[%x]]：标识一个 16 进制的 signed int 数值
- [[%u]]：标识一个 10 进制的 unsigned int 数值
- [[%p]]：标识一个内存地址，当然，内存地址也是 [[16进制]] 的数值，所以对于内存地址的格式化操作我们可以使用 [["%x"]] 也可以使用 [["%p"]]
- [[%hd]]：标识一个 signed short 数值
- [[%hu]]：标识一个 unsigned short 数值
- [[%ld]]：标识一个 signed long 数值
- [[%lu]]：标识一个 unsigned long 数值
- [[%lld]]：标识一个 signed long long 数值
- [[%llu]]：标识一个 unsigned long long 数值
- [[%c]]：标识 一个 signed char 字符
- [[%s]]：标识一个字符串，在 c 中，并没有标准字符串 [[string]] 的定义，所以对于格式化字符串操作而言，以 [['\0']] / [['\n']] 作为本次格式化的结束
- [[%f]]：标识 一个 float 数值
- [[%lf]]：标识 一个 double 数值
- [[%(z)x.(m)yk]]
    - [[k]]：格式符类型，为浮点类型，即 [[%f]] / [[%lf]]
    - [[y]]：小数点后面共保留 [[y]] 位进行格式化，如果格式化后的长度不够 [[y]] ，默认情况下使用 [[0]] 进行补正
    - [[m]]：指定 [[y]] 进行长度补正时所使用的数值
    - [[x]]：整体输出保留 [[x]] 位进行格式化，并且对 [[x+1]] 位进行四舍五入，如果格式化后的长度不够 [[x]] ，默认情况下则使用 [[0]] 进行补正
    - [[z]]：指定 [[x]] 进行长度补正时所使用的数值


<br/>

### 系统库
<span id="系统库"></span>

---

#### Console
<span id="Console.h"></span>

[前面](#在c语言中三种特殊的系统文件) 提到过，一个应用程序在启动的时候会打开三种特殊的系统文件，当这三种特殊的系统文件被打开后同时也会开启相对应的 **作为程序与设备之间进行数据沟通的桥梁**{style="color:red"} 的缓冲区，那么在 c 中，这三种系统文件将以宏定义文件指针的形式长存在当前程序运行时的内存当中，它们分别为 [[stdin]] [[stdout]] [[stderr]]，而对于操作控制台的API来说，其实就是针对这几种特殊系统文件的缓冲区 ( 即 [[stdin]] [[stdout]] [[stderr]] ) 进行读写操作


#### int printf(char const* const format, ...)
##### <stdio.h>

将 [format形参](#形参format) 所提供的格式化模板再结合所录入的可变参数 [[...]] 生成一个新的字符串的结果并写入到文件指针 [[stdout]] 所指向的文件的缓冲区内，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    printf("Hello,World!");
    return 0;
}
```

<br/>

#### int scanf(const char * format, ...)
##### <stdio.h>

将 [format形参](#形参format) 所提供的格式化模式从文件指针 [[stdin]] 所指向的文件的缓冲区内取出数据，以 [[\n]] 作为此次从 [[stdin]] 缓冲区中取出数据的结束标识符，取出的数据依次写入到所指定的可变参数 [[...]] 所使用的内存空间当中，如果成功返回 [[0]]，如果失败则返回 [[-1]]

由于此操作是从 [[stdin]] 中取出数据，也就意味着在调用该函数时会有一个阻塞的过程等待着我们的 [[input]] 设备去录入即将要输入到缓冲区中的数据

对于 [[scanf]] 函数来说，录入字符串是存在一定的安全隐患的，比如说用户所输入的数据长度是 10 位，但是我们用于接受从 [[stdin]] 中所采集到的数据的可变参数 <kbd>char []</kbd> 的长度只有 5 位，但是 [[scanf]] 函数也会把所所有数据录入的数据填充进长度仅有五位的字符数组当中，这也就意味着可能会产生 [[野指针]] 的数据，而对于编译器而言，它也认为使用它来录入字符串会存在安全性的问题，故可能在编译的过程中弹出 [[canf 4996]] 的错误，解决这一错误只需定义一个 [[#define _CRT_SECURE_NO_WARNINGS]] 的宏即可解决

```c
#include <stdio.h>

int main(void){

	int a;
	scanf("%d", &a);
	printf("%d\n", a);

    return 0;
}
```

<br/>

#### int getchar()
##### <stdio.h>

从文件缓冲区 [[stdin]] 中读取所输入的一个 [[char]] 字符，以 [[\n]] 作为本次从 [[stdin]] 缓冲区中取出数据的结束标识符 ( 能够接收到 [[\n]] 字符 )

由于此操作是从 [[stdin]] 中取出数据，也就意味着在调用该函数时会有一个阻塞的过程等待着我们的 [[input]] 设备去录入即将要输入到缓冲区中的数据

```c
#include <stdio.h>

int main(void){

    char ch = getchar();
    printf("%c\n",ch);

    return 0;
}
```

<br/>

#### int putchar(int character)
##### <stdio.h>

将字符 [[character]] 写入到文件指针 [[stdout]] 所指向文件的缓冲区当中，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    putchar('o');
    putchar('k');
    putchar('\n');

    return 0;
}
```

<br/>

#### char *gets(char *str)
##### <stdio.h>

从文件指针 [[stdin]] 所指向的文件的缓冲区内获取数据，以 [[\n]] 作为此次从 [[stdin]] 缓冲区中取出数据的结束标识符，把所读取到的内容填充至形参 [[str]] 所指向的内存空间中，如果调用成功则返回这段内存空间的首地址，如果调用失败，则返回 [[NULL]]

该函数会从 [[stdin]] 中获取到本次所录入的一整段字符串 ( 包括 [[\n]] )，但是在把该字符再写入到 [[str]] 所指向的内存空间当中前会先删除掉所获取到的该字符串结尾的 [[\n]] 字符

该函数所给定的参数 [[str]] 必须为一个字符数组以保证写入权限，如果给定的是一个字符指针形式的字符串的话，该函数则会调用失败，因为该函数会逐地址写入所录入的字符

由于此操作是从 [[stdin]] 中取出数据，也就意味着在调用该函数时会有一个阻塞的过程等待着我们的 [[input]] 设备去录入即将要输入到缓冲区中的数据

在函数调用完成后，会根据所录入的数据的结尾添加字符串标识符 [[\0]]

对于 [[gets]] 函数来说，录入字符串是存在一定的安全隐患的，比如说用户所输入的数据长度是 10 位，但是我们用于接受从 [[stdin]] 中所采集到的数据的可变参数 <kbd>char []</kbd> 的长度只有 5 位，但是 [[gets]] 函数也会把所所有数据录入的数据填充进长度仅有五位的字符数组当中，这也就意味着可能会产生 [[野指针]] 的数据

```c
#include <stdio.h>

int main(void){

	char str[32] = { 0 };
	gets(str);

	printf("%s\n", str);

    return 0;
}
```

<br/>

#### int puts(const char *str)
##### <stdio.h>

将字符串 [[str]] 写入到文件指针 [[stdout]] 所指向文件的缓冲区当中，并且所输出的字符串的最后一位会添加一个 [[\n]] 的字符，如果调用成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    puts("Hello,World!");
    return 0;
}
```

<br/>

#### int _getch()
##### <conio.h>

从文件缓冲区 [stdin] 中以 **无回显**{style="color:red"} 的方式读取所输入的一个 [[char]] 字符，无回显的方式意味着该函数不需要以 [[\n]] 作为此次从 [[stdin]] 缓冲区中取出数据的结束标识符，并且我们所键入的字符不会再输入到 [[stdout]] 中显示在控制台上

由于此操作是从 [[stdin]] 中取出数据，也就意味着在调用该函数时会有一个阻塞的过程等待着我们的 [[input]] 设备去录入即将要输入到缓冲区中的数据

```c
#include <stdio.h>
#include <conio.h>

int main(void){

    char ch = _getch();
	printf("%c\n", ch);

    return 0;
}
```

<br/>

#### int kbhit()
##### <conio.h>

以 **非阻塞**{style="color:red"} 的方式检查 [[stdin]] 中是否有新的数据写入，即检查是否有键盘得输入操作，如果有，则返回 [[1]]，如果没有，则返回 [[0]]

```c
#include <stdio.h>
#include <conio.h>

int main(){

    while (1) {

        if (kbhit()) {
        
            printf("%c", _getch());
        }
    }

    return 0;
}
```

<br/>
<br/>

#### Windows.h
<span id="Windows.h"></span>

#### int system(const char *command)

执行系统命令 [[command]]，如果成功返回 [[0]]，如果失败则返回 [[-1]]

该函数会形成阻塞，直至系统命令执行完成或关闭

- [[command]]
    - [[pause]]：控制台程序暂停，形成阻塞，直至用户下一次键入 [[\n]] 则恢复调用
    - [[cls]]：清屏
    - [[cmd]]：打开控制台终端
    - [[mspaint]]：打开 Windows 画图 终端
    - [[calc]]：打开计算器终端

```c
#include <Windows.h>

int main(void){

    system("pause");
    return 0;
}
```

<br/>

#### int Sleep(long millisecond)

当前上下文线程休眠 [[millisecond]] 毫秒，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>
#include <Windows.h>

int main(void){

	Sleep(3000);
	printf("%s\n", "Hello,World!");

    return 0;
}
```

<br/>
<br/>

### *stdlib.h*
<span id="stdlib.h"></span>

#### void srand(int value)

添加一个 **随机数种子**{style="color:red"}，重置函数 [[rand]] 的随机数计数标识，如果在使用函数 [[rand]] 获取随机数之前没有添加随机数种子，则获取到的是一个伪随机数

```c
#include <stdlib>
#include <time.h>

int main(void){

    srand(time(NULL));

    return 0;
}
```

<br/>

#### int rand(void)

获取一个随机数，如果在调用该函数前不进行随机数种子的种植操作 [[srand]] ，则该函数所获取到的随机数是一个伪随机数，伪随机数即不是真正的随机数，虽然每次调用该函数后获取到的随机数都不一样，但程序进行了重启后，我们会发现再次获取随机数的结果和重启前的结果是一模一样的，即不是真正的随机数

```c
#include <stdlib>
#include <time.h>

int main(void){

    srand(time(NULL));
	for (size_t i = 0; i < 10; i++) {

		printf("%d\n", rand());
	}

    return 0;
}
```

<br/>

#### void exit(int code)

退出当前进程，[[code]] 则为退出标识，是正常退出 [[0]] 还是异常退出 [[-1]]，在 [[main]] 函数调用完成后的也是通过该函数来退出进程，并且根据 [[main]] 函数的返回值来赋值 [[code]] 形参

```c
#include <stdlib.h>

int main(void){

    exit(0);
    return 0;
}
```

<br/>

### 进程与线程
<span id="进程与线程"></span>

---

#### task_struct
<span id="task_struct"></span>

在 linux 源代码中，一共出现了三个概念，其分别是 **`task`**, **`process`**, **`thread`**，其实不管哪个都好，其在术语上，都属于一份独一无二的 **`task_struct`** 的结构体的实例，其中，一个进程所所分配的内存的内核态中存在一个 **`PCB 进程控制模块`**，而所谓的 task_struct 结构体的实例则被置放在这里面

关于 **`stack_struct`** 中具体的成员多达数百个，下面仅暂时了一些关键性的成员信息

```c
struct task_struct {
    /**
     * You can easily guess this one when we talk about processes. 
     * Process can be in different states. Namely interruptible, uninterruptible,
     * zombie, stopped etc.
    */
    volatile long state;

    /* this is related to debugging a process. To trace system calls carried out by a process. */
    unsigned int ptrace;	

    /* Nice value for specifying process priority */
    int static_prio;	

    /**
     * The programmer can specify the cpu core where he wants the process to
     * run - or allowed to run - this is where cpu affinity is set
    */
    int nr_cpus_allowed;	

    /**
     * As we know that task_struct fields can point to other structures (ie: similar to task_struct), 
     * this mm field points to another structure called mm_struct. This is the memory description 
     * for a particular process. Basically the physical memory pages and memory address space 
     * allocated to the process
    */
    struct mm_struct *mm;	

    /**
     * These fields are used to hold signals and exit codes when the process exits. 
     * This will let the parent process know how the child died
    */
    int exit_code;
    int exit_signal;	

    /* The signal that is sent when the parent dies */
    int pdeath_signal;	

    /* This is again another structure pointing to parent process, and any children this process has */
    struct task_struct	*parent;
    struct task_struct	*children;

    /**
     * user time, system time, collective user time spent by process and its children, 
     * total system time spent by process and children
    */
    u64 utime;
    u64 stime;
    u64 cutime;
    u64 cstime;
   
    /* user id variables available to the process */
    kuid_t  loginuid;	

    /* open file information - again another structure */
    struct files_struct *files;	

    /* handlers related to certain signals, signals that are pending etc. */
    struct signal_struct  *signal;	

    /* process identifier */
    int pid;

    /* group identifier, usually it is the PID of the parent process */
    int pgid;

    /* thread group identifier */
    int tgid
}
```

<br/>

 #### 什么是进程
<span id="什么是进程"></span>

**进程是操作系统资源分配的最小单位**{style="color:red"}

进程其本质上是动态的，它会随着CPU执行指令而不断变化；linux 内核从设计上去保证每个进程都有自己的权利和权限，**一个进程所产生的问题不会影响系统中运行的其他进程，这是因为每个进程都有自己隔离的地址空间**{style="color:red"}

进程其实就是一个 `task_struct` 结构体的实例，这个结构体中拥有一个成员用于标识针对于当前操作系统而言的唯一身份标识 **`PID`**，**`PID`** 由内核所分配，并在一个进程在退出时对其进行释放以供重用

在 linux 中任何一个进程的创建，都需要依赖于一个父级进程 ( 上帝进程除外，即 **`PID == 1`** ) ，正如我们所编写的程序，在启动后其父级进程就是作为 **`caller`** 的终端，即 **`bash`**，**那么一个进程除了会拥有一个 `PID` 去标识它在这个操作系统中的唯一身份外，还拥有一个 `PPID` ( 父进程的 `PID` ) 用于标识当前进程的父级依赖关系**{style="color:red"}

不可否认的是，进程其地址空间是以父进程作为模型而 clone 出来的，其中拷贝了包括沿用用户态的众多信息如父进程的 **地址空间、页表、堆、栈 ( 堆栈仅仅只是使用父进程中所衍生出来的虚拟内存地址 )、信号 ( 阻塞信号集和信号的 **`Action`** )**{style="color:red"} 等等，但并不意味着子进程内核态中的所有内容也是从父进程中进行延伸出来的，正如内核态中的 **`PCB 进程控制模块`** 中所存储的 **`task_struct`**，由于每一个进程在当前操作系统中都需要保证仅有一份实例，故这份 **`task_struct`** 实例的内容自然也仅属于新进程本身

虽然子进程在用户态中的众多数据都会从其父进程中 clone 出来，但需要注意的是，这里所延伸出来的方式是以 **`copy`** 的形式而进行，也就是说也许子进程和父进程的地址空间的信息看似是相同的，其实实际上二者毫不相干，因为所延生出来的仅仅只是一个虚拟内存的地址，而具体的，这个新进程所使用的新的物理内存页会重新映射一遍这些虚拟内存地址，这同样也符合一个进程在操作系统中的设计理念

需要扩充的是，对于 PCB 模块中的文件描述符表虽然子进程也会从父进程中 clone 出来，虽然这个文件描述符表所存储的数据可能 **`值`** 是一致，但是存储这个值的地址空间所映射到的物理内存页和原有父进程中的关系是毫不相干的，但是这里有一点问题是，由于文件描述符所指向的是 **`inode`**，也就是说值相同的两个文件描述符往往都能够映射到同一个文件身上，也就意味着，父进程中所衍生出去的子进程，子进程是可以使用其在被创建出来前，父进程中所保有的文件描述符表和其所指向的文件的，但是不同进程之间的文件描述符表是不进行共享的，逻辑上的共享仅仅只是相同的值都能够映射到同一个文件身上罢了

对于任何进程 ( 除了上帝进程 ) 的创建都需要依赖于一个父进程的调用，这种关系向下延伸可以蔓延为一颗树的关系，通常我们也称它为 **`进程树`**，我们可以使用命令 **`pstree`** 去查看这棵树的具体内容

<br/>

 #### 进程的创建
<span id="进程的创建"></span>

在一个进程在被真正被创建出来之前，需要经历两次系统调用

其一则为 **`clone()`**，该系统调用以旧 ( 父 ) 进程作为模型 ( 包括了父进程的地址空间还有 **`Page Table`** 的信息 ) 并 clone 出一个新的子进程，即生成了属于它的 **`task_struct`**  ( 在这里，��核已经为该进程创建了 **`kernel mode`** )，顺带的会校验当前系统的资源负载，最后会设置其独一无二的 **`PID`** 和与之相关联的父进程的 **`PPID`**

其二则为 **`execve()`**，该系统调用能够将新进程中的可执行文件替换为新进程所对应的二进制文件，并使用一个或者多个物理内存页去拷贝新进程的地址空间, **`Page Table`** 和用户态中的内容替换至子进程当中 ( 原有新进程所 clone 至旧进程的地址空间数据回收释放 )

当这两个系统调用完毕后，一个新进程真正意义上的被创建出来，当一个新进程被创建出来后，会设置其信号为 **`pending`** 并等待任务调度器 **`scheduler`** 的调度；在这里要扩充一点的是，新进程的信号并不会继承自旧进程当中，假设父进程中尚有几个还未执行的信号还未发生时，子进程对其继承将会引起错乱

对于 **`Page Table`** 的拷贝是及其麻烦且对于时间开销非常之大的事情，因为这些页表可能存在于物理内存中，也有可能再当前进程的可执行映像中，还有一些可能在swap文件中，要找到它们实属一件较为困难的工作，但是针对于某些子进程来说，它所需要完成的事情可能并不需要涉及到一些内存的写入操作，这时候就不需要在进行 **`Page Table`** 的拷贝工作了，这种技术也称为 **`COW`** ( $Copy$ $On$ $Write$ )，在未发生写入操作之前，父进程和子进程都会沿用一块共享的虚拟内存空间以保证新进程创建时的执行效率和时间开销，以下这段话摘自这篇 [文章](https://www.tldp.org/LDP/tlk/)  当中

> Cloning a process's virtual memory is rather tricky. A new set of vm_area_struct data structures must be generated together with their owning mm_struct data structure and the cloned process's page tables. None of the process's virtual memory is copied at this point. That would be a rather difficult and lengthy task for some of that virtual memory would be in physical memory, some in the executable image that the process is currently executing and possibly some would be in the swap file. Instead Linux uses a technique called ``copy on write`` which means that virtual memory will only be copied when one of the two processes tries to write to it. Any virtual memory that is not written to, even if it can be, will be shared between the two processes without any harm occuring. The read only memory, for example the executable code, will always be shared. For copy on write to work, the writeable areas have their page table entries marked as read only and the vm_area_struct data structures describing them are marked as copy on write. When one of the processes attempts to write to this virtual memory a page fault will occur. It is at this point that Linux will make a copy of the memory and fix up the two processes' page tables and virtual memory data structures.

<br/>

 #### 进程的状态
<span id="进程的状态"></span>

进程运行时的生命周期内会呈现着不同的状态，了解这些状态对于系统问题的排查将会起到非常重要的作用

```text
                                  Receive SIGKILL signal          Parent process recycles resources
                                            ^                                    ^
                                            |           +--------+               |
                                         +--+---------->+ Reaped +<--------------+---+
                                         |              +--------+                   |
                                   +-----+----+                                 +----+----+
+----------------------------------+Stopped(T)|              +----------------->+Zombie(Z)|
|                                  +-----+----+              |                  +----+----+
|                                        ^                   +-> Dynamic run error   ^
|         Receives the SIGSTOP signal <--+                   |                       +--> Process finishes with exit() system call
|                                        +----------------+  |  +--------------------+
|                                                         |  |  |
|                               Waiting for resource      |  |  |  Waiting for event toggled or wake up signal
|                           (I/O operation to complete)   |  |  |    (like a certain amount of time to pass)
|                                        ^                |  |  |                    ^
|   +----------------------+             |             +--+--+--+-+                  |                        +------------------------+
|   |Interruptible Sleep(S)+<------------+-------------+Running(R)+------------------+----------------------->+Uninterruptible Sleep(D)|
|   +----------+-----------+                           +-+------+-+                                           +------------+-----------+
|              |                                         ^      |                                                          |
|              |                                         |      |                                                          |
|              |                                         |      |                                                          |
|              |                           cpu scheduler |      | context switch                                           |
|              |                                         |      |                                                          |
|              |                                         |      v                                                          |
|              |                                      +--+------+-+                                                        |
|              +-----------------+------------------->+Runnable(R)+<------------------------+------------------------------+
|                                |                    +-----+-----+                         |
|                                v                          ^                               v
|                   Operation complete and ready            |              Event happened or receive a signal
|                                                           |
+------------------------+----------------------------------+
                         |
                         v
              Receive SIGCONT signal
```

- **`Runnable(R)`** : 就绪状态

    就绪状态的状态标志 **`state`** 的值为 **`TASK_RUNNING`**
    
    此时，程序已被挂入运行队列，处于准备运行状态，一旦获得 CPU 使用权，即可进入 **`Running(R)`**
- **`Running(R)`** : 运行状态
  
  当进程属于正在 **`Running(R)`** 时，其 **`state`** 的值并不发生改变，仍然为 **`TASK_RUNNING`**，并在当前运行的时间片结束后，返回至 **`Runnable(R)`**
- **`Interruptible Sleep(S)`** : 可中断等待状态

    状态标志 **`state`** 的值为 **`TASK_INTERRUPTIBL`**
    
    当处在 **`Running(R)`** 的进程尝试着等待某个事件的触发而进入到 **`Interruptible Sleep(S)`**，一旦事件被触发或者接收到 唤醒信号，进程会立即结束等待并进入 **`Runnable(R)`**
- **`Uninterruptible Sleep(D)`** : 不可中断等待状态

    状态标志 **`state`** 的值为 **`TASK_UNINTERRUPTIBL`**
    
    当处在 **`Running(R)`** 的进程尝试着等待某个资源的准备完成和有效时则进入到 **`TASK_UNINTERRUPTIBL`**，一旦某个资源准备完成，进程会立即结束等待并进入 **`Runnable(R)`**，需要注意的是，当前状态无法被信号或者中断所唤醒，只有当它申请的资源有效时才能被唤醒，所发送的信号仅当其被唤醒时才开始检查

    当某个进程正尝试去处理某些数据时，却接收到了 **`SIGKILL`** 信号而导致进程的终止，这显然是不合理的，故 linux 中使用这一状态的进程来表示这一情景，举个例子，比如当进程需要对磁盘进行读写，而此刻正在DMA中进行着数据到内存的拷贝，如果这时进程休眠被打断 ( **`SIGKILL`** ) 那么很可能会出现问题，所以这时我们就需要这个进程是处在一个不可被打断的状态下才能够保证安全性
- **`Stopped(T)`** : 挂起状态

    状态标志 **`state`** 的值为 **`TASK_STOPPED`**
    
    当处在 **`Runnable(R)`** 的进程收到一个 **`SIGSTOP`** 信号后，就进入 **`Stopped(T)`**
    
    当再当前状态中收到 **`SIGCONT`** 信号时，又会恢复至 **`Runnable(R)`**

    当再当前状态中收到 **`SIGKILL`** 信号时，则当前进程完全移除并自动回收
- **`Zombie(Z)`** : 终止状态
  
  状态标志 **`state`** 的值为 **`TASK_DEAD`**
  
  进程因完成了 **`exit()`** 的系统调用亦或者异常结束，并且其所占用的资源需要父进程进行回收时所产生的状态；除了 **`task_struct`** 的以及少数资源外，系统对它不再予以理睬，所以这种状态也叫做 **`僵死状态`**，即进程成为了 **`僵尸进程`**

<br/>

 #### 特殊的进程
<span id="特殊的进程"></span>

*Orphan*

当一个子进程的直接父进程因一些特殊原因而被结束 ( 如 : 调用了 **`exit()`** 系统调用亦或者异常结束 )，那么这个子进程就会被认作为一个孤儿进程；**`kernel`** 会将这个孤儿进程转交给 **`init`** 或 **`systemd`** 进程进行收养，并也通过它们来完成对这个孤儿进程的资源回收工作

<br/>

*Zombie*

当一个进程在触发了一次  **`exit()`** 的系统调用亦或者异常结束后，那么其所占用的系统资源则处于一个等待父进程进行资源回收的状态，如果父进程并没有显式的该已经 **`"死亡"`** 的进程进行资源回收 ( **`wait()`** / **`waitpid()`** )，则这个进程就会被认作为一个僵尸进程

僵尸进程会一直占用着这些未被回收的资源，并且无法通过 **`SIGKILL`** 信号进行强制结束，仅当以下两种途径才能够真正意义上的结束掉这个僵尸进程 : 
1. 当其直接父进程的结束 ( 调用了 **`exit()`** 亦或者异常结束 )，这个僵尸进程又会被认作为 **`Orphan process`**，即被 **`init`** 或 **`systemd`** 进程收养为子进程，并由它们来完成对僵尸进程的资源释放工作
2. 直接父进程显式的调用了 **`wait()`** / **`waitpid()`** 进行僵尸子进程的资源回收

<br/>

<span id = "DaemonDaemon"></span>

*Daemon(computing)*

守护 ( Daemon ) 进程，是Linux中的后台服务进程，它们通常采用以 d 结尾来命名，其独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件

守护进程 **没有控制终端**{style="color:red"}，**不能直接和用户交互**{style="color:red"} 并且 不受用户的 **登录 / 注销**{style="color:red"} 影响

关于守护进程如何创建，请查看 [这里](#守护进程的创建)

<br/>

 #### 守护进程的创建
<span id="守护进程的创建"></span>

1. 由于要依赖于会话 ( **`setsid()`** ) 的特性，故我们需要构建出一个子进程 ( **`fork()`** ) 并且主进程退出，使这个子进程作为守护进程创建的基准
2. 子进程调用 **`setsid()`** 以构建一个新的会话，使当前子进程成为一个会话的会长，也成为一个进程组的组长，同时，新创建的会话会丢弃原有的控制终端，使当前进程并不会依赖于控制终端
3. 改变当前进程的工作目录 ( **`chdir`** ) 以保证工作目录的丢失守护进程的运行不受影响
4. 由于子进程会继承于父进程的文件操作掩码 ( **`mask`** )，故最好使用 **`unmask()`** 以重置掩码，保证守护进程 ( 子进程 ) IO 操作的灵活性
5. 关闭和终端操作有关的文件描述符 **`STDIN`** **`STDOUT`** **`STDERR`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>

void handler(int _sig) {
  int fd_w = open("./log", O_WRONLY | O_CREAT | O_APPEND, 0644);
  if (fd_w < 0) {
    perror("open file error");
    exit(EXIT_FAILURE);
  }

  static int idx = 0;
  char *buff = malloc(32);
  if (buff == NULL) {
    perror("memory error");
    exit(EXIT_FAILURE);
  }
  memset(buff, 0x0, 32);

  sprintf(buff, "[%d]\n", ++idx);

  /* strlen(xx) + 1 means ensure writed full bytes('\0') */
  write(fd_w, buff, strlen(buff) + 1);

  free(buff);
  close(fd_w);
}
void foo(void) {
  int pid = fork();
  if (pid < 0) {
    perror("create child process error\n");
    exit(EXIT_FAILURE);
  } else if (pid == 0) {
    /* Improve child process to be session leader. */
    int sid = setsid();
    /* Reset file mask */
    umask(0000);
    /* Registered a clock */
    signal(SIGALRM, handler);

    struct itimerval time_value;
    time_value.it_value.tv_sec = 0;
    time_value.it_value.tv_usec = 1 * 1000;
    time_value.it_interval.tv_sec = 1;
    time_value.it_interval.tv_usec = 0;
    setitimer(ITIMER_REAL, &time_value, NULL);

    printf("server [%d] started\n", getpid());
    while (true) {
      sleep(1);
    }
  }
}

int main(int argc, char *argv[]) {
  foo();
  
  return EXIT_SUCCESS;
}

```

<br/>

 #### 什么是线程
<span id="什么是线程"></span>

**进程是CPU的最小调度单位**{style="color:red"}

不得不提的是，在 linux 下其实本并没有线程，只是为了迎合开发者口味，搞了个 **`轻量级进程`** 出来，他就是所谓的 **`Thread`**；在 linux 中，一个 **`Thread`** 会被当作是一个 **`Process`** 来看待，它同样也是一个 **`task_struct`** 结构体的实例，也拥有一个 **`PID`** 来作为当前操作系统而言的唯一身份标识 **`PID`**，**`kernel`** 并不针对线程去提供针对性的调度

线程的创建同样需要依赖于一个父级进程，这个父级进程也可能是作为源程序所启动的第一个进程所派生下来的子进程也可能是第一个进程本身，但无论如何，**线程的创建往往都需要依赖于一个进程，但是不管该线程的创建是往下延续到多少层级的进程派生，其父进程 **`PPID`** 始终都是源程序所启动的第一个进程的 **`PID`**<span></span>**{style="color:red"}，我们可以理解为当前源程序的最上级进程的 **`PID`**；相对的，**对于线程来说区分它到底是属于哪个进程往下的派生通过一个属性 **`TGID`** 来确定，属于同一进程下派生出来的线程其 **`TGID`** 都为派生者的 **`PID`**<span></span>**{style="color:red"}，并且，**即便是往下延续派生了多个子线程 ( 例如，子线程中又创建了子线程 )，它们任然是属于一种同组平级的关系**{style="color:red"}，简而言之，一个线程组下的所有子线程，无论它们的创建到底是具体到了哪个层级来完成，它们都是属于一个平级的关系

需要扩充的是，同一进程下的所有线程在调用 **`getpid()`** 时所获取到的 **`PID`** 是一样的， 因为对于多线程的程序来说，**`getpid()`** 系统调用获取的实际上是 **`TGID`**，因此隶属同一进程的多个线程看起来 **`PID`** 相同

线程的创建过程和进程一致，也是以父进程作为模型 **`clone`** 出来的，但是该系统调用区别于进程的创建，**`clone`** 是最大共享的 **`clone`**，这个共享，是 **地址空间 、Page Table、堆、栈、PCB中的文件描述符表、信号 ( 所共享的仅仅只是信号的 **`Action`**，并不包括未决信号集，而对于阻塞信号集也仅仅只是做了一份拷贝的动作并在此基础上作为每个线程的独立延伸  )**{style="color:red"} 的共享，这里需要区别与进程，线程是真正意义上的虚拟内存共享，这就是为什么线程会被称为 **`轻量级线程`** 的原因；不可否认的是，线程的创建的确是免去了进程创建需要拷贝地址空间和页表的工作，也就是在一定程度上，线程创建的时间开销是小于进程的，但，这并不是绝对的，并不意味着线程和进程在创建上的时间开销是呈几何倍的差距，实际只有很小，关于这点在后面的节点还会提到

线程的诞生往往需要以一个父进程为基准所延伸出来，它和父进程共享使用同一块地址空间，所以，线程的存在是需要依赖于一个父进程的，父进程的消亡随之而来的也会销毁且回收至当前进程下所延伸出来所有子线程，反之，一个线程所出现内存错误会导致延伸当前线程的主线程 ( 进程 ) 也会随同崩溃

最后需要说明的是线程中的信号，在线程中的信号所绑定的 Action 是能够与父级进程和父进程中所派生下来的其他子进程去进行共享的，简而言之，**一个线程组内的任意一个线程 ( 包括父进程 ) 所绑定的信号 Action 会一并同步至当前线程组内的所有线程之中 ( 包括父进程 )**{style="color:red"}，所以，在多线程开发模型中为了保证一个进程下所派生的所有线程间的信号 Action 并不会呈一个污染的状态，故更推荐使用 [sigwait](#sigwaitinfo) 去完成信号 Action 的注册工作；需要注意的是，**子线程与父进程之间的信号共享的也仅仅只是信号所绑定的 Action，对于未决信号集和屏蔽信号集来说，每个线程都是一个独立的存在**{style="color:red"}，简而言之，每个线程都可以拥有属于自己本身的未决信号集和屏蔽信号集，需要扩充的是，在多线程开发模型中对于线程的屏蔽信号集的设定更正确的做法则为使用遵守 **`NPTL`** 规范的 [pthread_sigmask()](#pthread_sigmask) 函数去进行

需要补充的是，对于平常信号的发送我们常使用的是 **`kill()`** 函数来完成，但是由于该函数所遵循的是 **POSXI** 的实现，故在多线程开发模型中使用的时候，如果针对某一个线程去发送某一个信号时线程已经对所发送的信号进行了屏蔽，那么该信号会发送至其父级线程中去，关于更多信息请查看 [kill()](#kill_fun)

<br/>

 #### 线程模型
<span id="线程模型"></span>

线程模型大体上可以分为以下几种

1. **`1 : 1`**
   
    Linux 2.6 默认使用 **`NPTL`** 线程库就是属于 1 : 1  的线程模型，即一个用户线程对应一个内核线程，内核负责每个线程的调度，可以调度到其他处理器上面
    - 优点
      - 实现简单
    - 缺点
      - 对用户线程的大部分操作都会映射到内核线程上，引起用户态和内核态的频繁切换
      - 内核为每个线程都映射调度实体，如果系统出现大量线程，会对系统性能有影响
2. **`n : 1`**

    顾名思义，n : 1 线程模型中，多个用户线程对应到同一个内核线程上，线程的创建、调度、同步的所有细节全部由进程的用户空间线程库来处理
    - 优点
      - 用户线程的很多操作对内核来说都是透明的，不需要用户态和内核态的频繁切换。使线程的创建、调度、同步等非常快
    - 缺点
      - 由于多个用户线程对应到同一个内核线程，如果其中一个用户线程阻塞，那么该其他用户线程也无法执行
      - 内核并不知道用户态有哪些线程，无法像内核线程一样实现较完整的调度、优先级等
3. **`n : n`**

    n : 1 线程模型是非常轻量的，问题在于多个用户线程对应到固定的一个内核线程，而 n : n 线程模型解决了这一问题；**`m`** 个用户线程对应到 **`n`** 个内核线程上，通常 **`m > n`** ，由IBM主导的 **`NGPT`** 采用了多对多的线程模型，不过现在已废弃
    - 优点
      - 兼具多对一模型的轻量
      - 由于对应了多个内核线程，则一个用户线程阻塞时，其他用户线程仍然可以执行
      - 由于对应了多个内核线程，则可以实现较完整的调度、优先级等
    - 缺点
      - 实现复杂

以下这段话介绍了关于 Linux 2.6 默认使用的 **`NPTL`** 线程库

> POSIX (portable operating system interface) is a set of standards governing operating systems(based on unix). There needs to be a standard for interoperability.  There is a standard for programming interface, for shell and for almost everything in the operating system. Similarly, there is a standard for threads as well.  The initial thread implementation in Linux, did not fully comply with POSIX standard.

> There were some major reasons why Linux initial thread implementation did not comply with POSIX. One main reason is PID. Earlier implementation of threads had different PID numbers(similar to how processes had different PIDs).
>
> To fix these issues in the thread implementation, Red Hat started something called NPTL(Native Posix Thread Library), which later on was included in the Linux kernel (starting from 2.6 version of the kernel). The library function to create threads was also included in the GNU C library. The library function is called as pthread_create.
>
> Although you can use clone system call to create a thread, it is recommended to use pthread_create. This is for portability reasons (It is not necessary that a variant of Unix will have clone() system call available. However, the pthread_create library can still be used, as it will take care of the underlying system call and other complexities).

<br/>

<span id="再聊-pid-pgid-tgid"></span>

 #### 再聊 PID PGID TGID PPID SID

对于每个进程而言，他都拥有着以下信息用于标识当前进程的所属单位，我们可以通过一些命令行工具，如 : **`pstree`**, **`ps`**, **`htop`** 去查看它

- **`PID`**
  -  一个进程在当前操作系统的唯一标识
- **`PGID`**
  - 进程组ID，一个进程组下有多个进程，并且仅有一个主进程 ( 父进程 )，它的 **`PID == PGID`**，除了主进程，在该进程组下的所有进程都属于主进程的子进程，它们的 **`PID != PGID`** **`PPID == PGID`** 

  - 进程组的存在与主进程是否存活无关，进程组中仅有一个 组员进程 存在则意味着进程组存在

- **`SID`**
  - 会话ID，一个会话下有多个进程组，并且仅有一个会长，它的 **`PID == SID`**，会长进程拥有一个进程组，并且也作为这个进程组内的主进程，即 **`PID == PGID`**，而由会长往下所派生的子进程也纳入至会长进程所在进程组中的子进程，它们的 **`PID == SID`** **`PID != PGID`** **`PPID == PGID`** 

  - 创建一个会话需要依赖于一个进程的存在，即让这个进程提升为一个新的会话的会长，但是需要注意的是，**所依赖的进程不能够作为某个进程组的主进程而存在**{style="color:red"}

  - 新创建的会话会丢弃原有的控制终端，会长不依赖于终端，这种特性也通常用于 [守护进程](#DaemonDaemon) 的创建

- **`TGID`**
  - 线程组ID，每个进程都能够以当前进程作为主线程并向下衍生出子线程，作为主线程而言，它的 **`PID == TGID`**，除了主线程，在该线程组下的所有线程都属于主线程的子线程，他们的 **`PID != TGID`**

- **`TID`**
  - 线程的ID，由于历史原因，linux 早期的线程实现并未遵循 **`POSIX`** 的标准，反观至今的 linux 内核版本所使用的线程实现均遵循了 **`POSIX`** ( **`NPTL`** ) 的标准，而旧内核的线程实现和至今的线程实现有一点更需要关注的区别则为线程的 **`"PID"`**，对于早期并未遵循 **`POSIX`** 线程实现标准的内核版本来说，每个线程都具有不同的 **`PID`** ( 这和进程的实现一致，至少从这一点来看没错 )，而对于现今遵循了 **`POSIX`** ( **`NPTL`** ) 标准所实现的线程，上面所述的 **`"PID"`** 更应被称之为 **`TID`**
  
  - **`TID`** : 仅能通过 [pthread_self()](#pthread_self) 获取，其仅能这个线程在 **当前进程内**{style="color:red"} 的唯一的标识；使用 **`NPTL`** 所提供的线程库来完成多线程模型的开发一律都是使用该 **`TID`** 作为基准

   - **`"PID"`** : 可以通过系统调用 [gettid()](#gettid_) 来获取，但是在标准的 glibc 库中并没有实现对它的封装，故最终还是要通过系统调用 **`syscall`** 来获取，其可作为整个这个线程在 **整个系统**{style="color:red"} 中的唯一标识

- **`PPID`**
  - 子进程的父进程 **`PID`**

```c
USER VIEW
 <-- PID 43 --> <----------------- PID 42 ----------------->
                     +---------+
                     | process |
                    _| pid=42  |_
                  _/ | tgid=42 | \_ (new thread) _
       _ (fork) _/   +---------+                  \
      /                                        +---------+
+---------+                                    | process |
| process |                                    | pid=44  |
| pid=43  |                                    | tgid=42 |
| tgid=43 |                                    +---------+
+---------+
 <-- PID 43 --> <--------- PID 42 --------> <--- PID 44 --->
                     KERNEL VIEW
```

<br/>

#### 线程与进程的开销
<span id="线程与进程的开销"></span>

*Creation*

不可否认的是，创建一个线程的时间开销的确会比创建一个进程要小，原因是因为线程共享了大部分地址空间的数据，而对于进程来说存在一个较大的问题既是 **` 地址空间的拷贝`**，在早期来看，两者之间的差别的确是呈几何倍增长，在 《现代操作系统》 中有一句话谈到

> 创建一个线程较创建一个进程要快10~100倍

针对于进程在创建时，对地址空间的拷贝所消耗的时间拥有 **`COW`** 的优化，并且还提供了一系列的池技术的支持，所以，就现在的眼光来看，其实二者之间的区别其实在内核开发者的努力之下已经缩短的非常之小了

在这个 [网站](https://computing.llnl.gov/tutorials/pthreads/#WhyPthreads) 中有详细的对比数据，如果除去测试结果中的 销毁时间, Context-switch 的时间，真实的二者创建的时间开销接近于 **`1 : 1`**

*Context switch*

进程的 **`Context switch`** 需要分为直接开销和间接开销 : 

对于直接开销来说，它需要经历以下几个过程 ( 其中，刷新 **`TLB`** 所导致的 **`Page Table`** 的重读，还有 **`CR3`** 寄存器的更换是非常消耗时间的过程 )

1. 切换页表全局目录
2. 切换内核态堆栈
3. 切换硬件上下文 ( 进程恢复前，必须装入寄存器的数据统称为硬件上下文 )
    - **``ip ( instruction pointer )``** : 指向当前执行指令的下一条指令
    - **``bp ( base pointer )``** : 用于存放执行中的函数对应的栈帧的栈底地址
    - **``sp ( stack poinger )``** : 用于存放执行中的函数对应的栈帧的栈顶地址
    - **``CR3``** : 页目录基址寄存器，保存页目录表的物理地址
    - ......
4. 刷新 **`TLB`**
5. 系统调度器的代码执行

而对于间接开销来说，主要指的是虽然切换到一个新进程后，由于各种缓存并不热，速度运行会慢一些；此外如果进程始跨CPU访问的话，之前已经热缓存起来的 **`TLB`** ,**`L1`**, **`L2`**, **`L3`** 也因为运行的进程已经变了，所以以局部性原理 cache 起来的代码和数据也都没有用了，导致新进程穿透到内存的 I/O 会变多

反观线程的 **`Context switch`**

虽然对于线程来说其已经和其父线程 ( 进程 ) 已经共享了较多的内核态上的数据，但是为了保证切换后的一致性，故其在进行 **`Context switch`** 时同样需要经历页表的切换, 刷新 **`TLB`** 还有 **`CR3`** 寄存器的更换的过程，所以实际上线程和进程的上下文切换所需的时间开销差别和 **`Creation`** 一样，是不大的 ( 线程还是会优于进程一点 ) ，在这片 [文章](https://zhuanlan.zhihu.com/p/79772089) 中详细的介绍了二者之间的测试结果和测试方式


<br/>

#### 选择进程还是线程？
<span id="选择进程还是线程"></span>

实际上，在 linux 中官方其实更推荐的是使用多进程开发模型，具体理由其实在上一节中已经分析过，在 linux 中的线程和进程之间的不管是执行效率而言还是创建效率，相差都是甚微，而相比，进程严格的隔离性也让程序的健壮性更强一点，而对比线程，事实上只在短线程的情况下比进程有显著的性能差异，但非短线程不可的应用场景其实非常有限

而在 windows 中，我们还是保有之前使用线程的习惯即可，因为 windows 并没有针对线程和进程之间做和 linux 相同的优化措施，对于 windows 中，进程不管是创建也好还是进行 **`Context switch`**，二者之间的时间开销是几何倍的差距所呈现的

在这里，我们不妨捎带的总结下线程和进程在使用时各自的优缺点

- 线程
  -  方便高效的内存共享
  -  占用内存少，切换简单，CPU利用率高
  -  创建销毁切换速度更快

- 进程
  - 多进程下的地址空间是不进行共享的，想让数据共享只能使用 IPC
  - 占用内存多，切换复杂，CPU利用率低
  - 不同进程之间的地址空间实现了良好的隔离，使程序的健壮性更高
  - 创建销毁切换速度稍慢
  - 更好的多核可伸缩性，进程的使用将许多内核资源（如地址空间，页表，打开的文件）隔离，在多核系统上的可伸缩性强于多线程程序
  

<br/>

#### 进程的使用
<span id="进程的使用"></span>

#### int fork()
##### <unistd.h>

创建一个子进程

当函数的成功调用，则创建出一个子进程，并且由于子进程是从父进程的基础上 **`clone`** 出来的，故这时候子进程和父进程各自执行对应地址空间视角的代码段下问
  - 在子进程的上下文中，该函数返回 **`0`**，然后继续当前代码的下文执行
  - 在父进程的上下文中，该函数返回 **`所创建出来的子进程的 PID`**，然后继续当前代码的下文执行

当子进程创建失败，则该函数返回 **`-1`**

![2020-06-28-00-23-03](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2020-06-28-00-23-03.png)

```c
#include <stdio>
#include <stdlib>
#include <unistd.h>

int main(void) {
  int pid = fork();
  if (pid < 0) {
    perror("E");
    exit(EXIT_FAILURE);
  } else if (pid > 0) {
    printf("parent process execute\n");
    printf("create child process, PID is %d\n", pid);
  } else if (pid == 0) {
    printf("child process execute\n");
  }

  return EXIT_SUCCESS;
}
```

<br/>

#### int getpid()
##### <unistd.h>

返回当前上下文所运行的进程的 **`PID`**

```c
#include <stdio>
#include <stdlib>
#include <unistd.h>

int main(void) {
  printf("PID is %d\n", getpid());
  return EXIT_SUCCESS;
}
```

<br/>

#### int getppid()
##### <unistd.h>

返回当前上下文所运行进程的父进程的 **`PID`**

```c
#include <stdio>
#include <stdlib>
#include <unistd.h>

int main(void) {
  printf("PPID is %d\n", getppid());
  return EXIT_SUCCESS;
}
```

<br/>

#### int execl / execlp(const char *path, const char *arg, ... )
##### <unistd.h>

将当前进程的二进制可执行文件替换为 **`path`** 所指定的文件，如果成功，则中断当前进程所依赖的旧二进制可执行文件的上下文调用，并依据所录入的命令行参数 **`arg`** 和 **`...`** 去执行所替换后的可执行文件的入口函数，即开始执行替换后的二进制可执行文件的上下文，如果调用失败，则该函数返回 **`-1`**

我们要保证 **`path`** 所指定的文件是一个可执行文件，即拥有入口函数的，否则该函数的调用失败

该函数在调用完成后，当前进程的用户态中的数据将完全的替换至新可执行文件的上下文，并分配新的地址空间，而内核态的大部分信息将得到保留，包括 **`PCB 进程控制模块`**, **`文件描述符表`** 还有 **`task_struct`** 等等

该函数的最后一个参数一般都设置为 **`NULL`**

**`execl`** 和 **`execlp`** 的功能性是一致的，只是对于 **`execlp`** 来说，他对于所指定的 **`path`** 会在环境变量所指定的路径中去寻找可执行文件，如果找不到则该函数调用失败，简而言之，**`execlp`** 函数会更适合去调用一些 linux 的系统命令

main.c
```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

void foo(void) {
  /* Keep file number and PCB process control */
  int fd = open("./test.log", O_RDONLY);
  if (fd < 0) {
    perror("E");
    exit(EXIT_FAILURE);
  }
  char buf[5] = { 0 };
  read(fd, buf, sizeof(buf));

  /* Executeable file arg */
  char str_fd[32] = { 0 };
  sprintf(str_fd, "%d", fd);
  int flag = execl("./test", "test", str_fd, NULL);

  perror("main");
  exit(EXIT_FAILURE);
}

int main(int argc, char *argv[]) {
  foo();

  return EXIT_SUCCESS;
}

```

test.c
```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  printf("%s\n", argv[0]);

  /* file number */
  int fd = atoi(argv[1]);
  if (fd < 0) {
    exit(EXIT_FAILURE);
  }

  char buf[5] = { 0 };
  read(fd, buf, sizeof(buf));
  printf("[%d] %s\n", fd, buf);

  return EXIT_SUCCESS;
}
```

<br/>

<span id="pid_t_wait"></span>

#### pid_t wait(int *state)
##### <wait.h>

阻塞父进程上下文的继续调用，等待当前父进程进程组下的任意子进程的调用结束并回收其所占用的资源，如果函数调用成功，则返回成功回收资源的子进程的 **`PID`**，并且通过所指定的参数 **`state`** 去标识当前子进程的结束状态，如果调用失败 ( 无子进程 ) ，则函数返回 **`-1`**

为什么要进行进程资源的回收？

当一个进程在进行了退出之后，这个进程就会成为一个 **`Zombie`**，即它虽然是一个已经死亡的状态，但是其所占用的部分系统资源 ( 如 : 内核空间的 **`PCB`** )，其生命周期仅当它的上级父进程的结束才会真正意义上的消亡，但是对于部分进程来说其运行时是不可能结束的 ( 如后台服务 )，这时候我们就需要显示的对已经成为 **`Zombie`** 执行资源回收的工作以避免造成系统资源的浪费

- **`state`**
  
    对于函数调用完毕后为 state 所赋的值在未经过任何处理时通常对开发者来说是无用的，标准库中为我们提供了以下宏定义以供 state 的使用

    - **`WIFEXITED(status)`** : 返回非 **`0`** 则认为进程是正常结束，否则则认为进程异常结束
    - **`WEXITSTATUS(status)`** : 获取程序的退出时所返回的结果，即退出状态，异常结束的进程则结果为 **`0`**
    - **`WIFSIGNALED(status)`** : 如果进程出现了运行级别的异常，则结果为 **`1`**，否则为 **`0`**
    - **`WTERMSIG(status)`** : 获取进程终止的 **`Signal number`**

```c
#include <stdio.h>
#include <stdlib.h>
#include <wait.h>

int main(void) {
  int pid = fork();
  if (pid < 0) {
    perror("E");
    exit(EXIT_FAILURE);
  } else if (pid == 0) { /*child process*/
    printf("[%d] child process\n", getpid());
    exit(EXIT_SUCCESS);
  } else if (pid > 0) {
    printf("[%d] parent process\n", getpid());

    int stat;
    wait(&stat);

    printf("%d\n", stat);
    printf("%d\n", WIFEXITED(stat));
    printf("%d\n", WEXITSTATUS(stat));
    printf("%d\n", WIFSIGNALED(stat));
    printf("%d\n", WTERMSIG(stat));
  }
  
  return EXIT_SUCCESS
}
```

<br/>

#### pid_t waitpid(pid_t pid, int *state, in options)
##### <wait.h>

该函数与 [wait](#pid_t_wait) 的功能性是一致的，其最终目的还是去释放 **`Zombie`** 所占用的资源，只是相较于该函数来说，其提供了更多的选项以供开发人员使用

- **`pid`**
  - **`pid == -1`** : 处理当前父进程进程组下的任意子进程
  - **`pid > 0`** : 处理 ID 为 **`pid`** 的子进程
  - **`pid == 0`** : 处理当前父进程进程组下的所有子进程
  - **`pid < -1`** : 处理进程组 ID 为 **`pid`** 绝对值中的任意子进程
- **`state`** : 和[wait](#pid_t_wait) 保持一致
- **`options`**
  -  **`0`** : 阻塞式回收子进程资源
  -  **`WNOHANG`** : 非阻塞式回收子进程资源
- **`return`**
  - **`pid > 0`** : 成功回收资源的子进程 **`PID`**
  - **`pid == 0`** : 当参数指定为 **`WNOHANG`**，返回值为 0 则代表子进程还未结束
  - **`pid == -1`** : 函数调用失败，即当前进程下无任何子进程资源

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <wait.h>

int main(void) {
  for (int i = 0; i < 2; ++i) {
    int pid_0 = fork();
    if (pid_0 < 0) {
      perror("E");
      exit(EXIT_FAILURE);
    } else if (pid_0 == 0) {
      if (i == 1) {
        printf("[%d] process test start\n", getpid());

        while (true) {
          sleep(1);
        }
      } else {
        int pid_1 = fork();
        if (pid_1 > 0) {
          printf("[%d] child process 1 start\n", getpid());

          int idx = 0;
          while (++idx < 15) {
            sleep(1);
          }

          printf("[%d] child process 1 exit\n", getpid());

          exit(EXIT_SUCCESS);
        } else if (pid_1 == 0) {
          printf("[%d] child process 2 start\n", getpid());

          int idx = 0;
          while ((++idx) < 5) {
            sleep(1);
          }

          printf("[%d] child process 2 exit\n", getpid());

          exit(EXIT_SUCCESS);
        } else {
          perror("E");
          exit(EXIT_FAILURE);
        }
      }
    }
  }

  printf("[%d] parent start\n", getpid());

  int state;
  int flag = waitpid(0, &state, 0);

  printf("[%d] parent exit: %d\n", getpid(), flag);

  return EXIT_SUCCESS;
}
```

<br/>

#### pid_t setsid()
##### <sys/types.h> <unistd.h>

创建一个新的会话，并将当前调用进程提升为所创建会话的会长，同时也能提升为一个进程组的组长，如果成功则返回新建会话的 SID，否则返回 -1

该函数仅作用与非进程组组长进程，通常用于守护进程的创建

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>

void foo(void) {
  int pid = fork();
  if (pid < 0) {
    perror("create child process error\n");
    exit(EXIT_FAILURE);
  } else if (pid == 0) {
    /* Improve child process to be session leader. */
    int sid = setsid();

    while (true) {
      sleep(1);
    }
  }
}

int main(int argc, char *argv[]) {
  foo();
  
  return EXIT_SUCCESS;
}

```

<br/>

#### 线程的使用
<span id="线程的使用"></span>

#### int pthread_create(pthread_t *thread,  const pthread_attr_t *attr, void *(*start_routine) (void *) ,void *arg)

##### <pthread.h>

创建一个新的线程，并开始执行函数指针 **`start_routine`** 的上下文，如果成功，则返回 **`0`** 并且返回所创建线程的 **`TID`** 至指针 **`thread`** 中，如果调用失败，则返回对应的 **`错误码`** ( 需要通过 **`strerror`** 把该错误码转换成有效的输出信息 )

- **`thread`** : 创建成功后所返回线程的 **`TID`**

- **`attr`** : 指定所创建线程的一些属性，如果为 **`NULL`**，则采用默认属性来对线程进行构造
  - **`pthread_attr_t`** : 用于描述线程属性的结构体，对于线程属性的设置都需要基于该结构体实例的基准上去进行
  
    -  **`int pthread_attr_init (pthread_attr_t* attr)`** : 用于初始化所构建出来的用于描述线程属性设置的 **`pthread_attr_t`** 的实例，一个新创建出来的 pthread_attr_t 的实例在开始应用于设置线程属性前，都需要先对其进行初始化，关于当前函数调用的更多信息请参考 [这里](https://linux.die.net/man/3/pthread_attr_init)

    - **`int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate)`** : 用于设置线程的分离状态的属性，关于当前函数调用的更多信息请参考 [这里](https://linux.die.net/man/3/pthread_attr_setdetachstate)

    - **`int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize)`** : 用于设置分配至线程的栈大小，关于当前函数调用的更多信息请参考 [这里](https://linux.die.net/man/3/pthread_attr_setstacksize)

    - **`int pthread_attr_destroy(pthread_attr_t *attr)`** : 释放用于描述线程属性结构体所占用的资源，通常一个 **`pthread_attr_t`** 结构体的实例在使用完毕后 ( 已经创建线程 ) 我们需要通过该函数调用对其进行资源的释放工作，关于当前函数调用的更多信息请参考 [这里](https://linux.die.net/man/3/pthread_attr_destroy)

- **`start_routine`** : 一个函数指针，用于指定线程所执行的上下文

  - 需要注意的是，该函数的返回值所指向的内存单元要不为 **`NULL`**，要不为 **`malloc`** 所分配亦或者全局变量，它不能指向任意一个属于当前函数上下文的栈中所分配的内存单元

- **`arg`** : 传递至 **`start_routine`** 的实参

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/syscall.h>

static int idx = 0;

void *thread_start(void *_arg) {
  printf("[%lu] child-thread executed\n", pthread_self());

  while (true) {
    printf("[%lu] %d\n", ++idx);
    sleep(1);
  }

  return NULL;
}

int main(int argc, char *argv[]) {
  pthread_t t_id;
  int s = pthread_create(&t_id, NULL, thread_start, NULL);
  if (s != 0) {
    char *msg = strerror(s);
    printf("%s\n", msg);
  }

  printf("[%lu] main-thread executed, create [%lu]\n", pthread_self(), t_id);
  while (true) {
    printf("[%lu] %d\n", ++idx);
    sleep(1);
  }

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "pthread_exit"></span>

#### int pthread_exit(void *retval)
##### <pthread.h>

退出当前调用者线程的执行，需要注意的是，在使用 **`NPTL`** 所提供的库去实现多线程开发模型时，任意一个线程调用了 **`exit`** ( 亦或者等同于父级进程在 **`main`** 函数中的 **`return`**，这也是属于 **`exit`** 的调用 ) 都会导致其同组 **`TGID`** 下的所有进程的退出 ( 其中也包括了构造出这些子级线程的父级进程，即 **`TGID == PID`**  ) 但是使用 **`pthread_exit`** 进行线程的退出是安全且可控的

如果父级线程其往下所派生的子级线程还处于正在运行的状态，则 **父级线程在调用 **`pthread_exit`** 退出后并不会阻断其子集线程的执行，但是由于子线程的运行需要依赖于父进程的地址空间，故这时候父级线程并不会也不能够真正的退出 ( 处于僵尸进程的状态 ) ，仅当当前父级进程下的所有子级线程执行完毕后，父级线程才真正被释放**{style="color:red"}

一个使用了默认构造参数 ( 非分离 ) 的线程即便是使用了 **`pthread_exit`** 完成了一次安全且正确的退出后，该线程所占用的系统资源其实还并未真正的完全释放，仅当某个线程对该线程进行了一次 **`pthread_join`** 才能保证其资源的全部释放；关于这一点的确适合进程有点相似，但不同的是，进程在这种状态之下我们是可以人为观测到的 ( **`ps`**、**`htop`** )，而对于线程来说，虽然开发人员无法直观的观测到这种状态之下的线程但并不意味着它就并不存在，相关的更多信息请点击 [这里](#pthread_join)

- **`retval`** : 表示当前线程所退出的状态，通常指定为 **`NULL`**

  需要注意的是，该参数所指向的内存单元要不为 **`NULL`**，要不为 **`malloc`** 所分配亦或者全局变量，它不能指向任意一个属于当前函数上下文的栈中所分配的内存单元

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <pthread.h>

void *thread_start(void *arg) {
  int idx = 0;
  while (true) {
    printf("[%lu] %d\n", pthread_self(), ++idx);
    sleep(1);

    if (idx == 5) {
      pthread_exit(EXIT_SUCCESS);
    }
  }

  return NULL;
}

int main(int argc, char *argv[]) {
  pthread_t ti_d;
  int s = pthread_create(&ti_d, NULL, thread_start, NULL);
  printf("[%lu] create %lu\n",pthread_self(),ti_d);

  while (true) {
    sleep(1);
  }
  return EXIT_SUCCESS;
}
```

<br/>

<span id = "pthread_self"></span>

#### pthread_t pthread_self()
##### <pthread.h>

获取当前线程的 **`TID`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <pthread.h>

void *thread_start(void *arg) {
  int idx = 0;
  while (true) {
    printf("[%lu] %d\n", pthread_self(), ++idx);
    sleep(1);

    if (idx == 5) {
      pthread_exit(EXIT_SUCCESS);
    }
  }

  return NULL;
}

int main(int argc, char *argv[]) {
  pthread_t ti_d;
  int s = pthread_create(&ti_d, NULL, thread_start, NULL);
  printf("[%lu] create %lu\n",pthread_self(),ti_d);

  while (true) {
    sleep(1);
  }
  return EXIT_SUCCESS;
}
```

<br/>

<span id = "gettid_"></span>

#### int gettid()
##### <sys/syscall.h> <sys/types.h>

获取当前线程的 ["PID"](#再聊-pid-pgid-tgid)，事实上，**`glibc`** 库中并没有实现对于 **`gettid`** 的封装，故其调用最终还需要通过 **`syscall`** 来执行

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <pthread.h>

#include <sys/syscall.h>
#include <sys/types.h>

void *thread_start(void *arg) {
  int idx = 0;
  while (true) {
    printf("[%lu] %d\n", syscall(SYS_getsid), ++idx);
    sleep(1);

    if (idx == 5) {
      pthread_exit(EXIT_SUCCESS);
    }
  }

  return NULL;
}

int main(int argc, char *argv[]) {
  pthread_t ti_d;
  int s = pthread_create(&ti_d, NULL, thread_start, NULL);
  printf("[%lu] create %lu\n",syscall(SYS_getsid),ti_d);

  while (true) {
    sleep(1);
  }
  return EXIT_SUCCESS;
}
```

<br/>

<span id = "pthread_join"></span>

#### int pthread_join(pthread_t thread, void **retval)

##### <pthread.h>

等待指定线程 **`thread`** 的退出并回收其所占用的系统资源，如果调用成功则返回 **`0`** 并将线程的退出状态写入至二级指针 **`retval`** 所指向的内存块中，如果调用失败，则返回对应的 **`错误码`** ( 需要通过 **`strerror`** 把该错误码转换成有效的输出信息 )

一个线程即便是通过了正常途径  ( **`return`** 或者 **`pthread_exit`** ) 退出后，其还是会保留一小部分资源在内核当中，它类似于僵尸进程，亦或者我们可以称之为 **"僵尸线程"**{style="color:red"} ( 事实上 "僵尸线程" 并未真正的在内核中定义，但是实际上其确实是存在的 )，**仅当其父级线程的 真正终止 亦或者 由 **`pthread_join`** 所回收，这个 "僵尸线程" 所占有的资源才真正的被完全回收**{style="color:red"}；**在多线程开发模型中，我们应当避免 "僵尸线程" 的产生，当一个应用程序积累了足够多的僵尸线程后，将可能不再保有创建新线程的权限**{style="color:red"}

- **`thread`** : 指定等待线程的 **`TID`**
- **`retval`** : 用于存储线程退出状态的二级指针，其赋值通常由所等待线程执行函数的返回值亦或者 [pthread_exit](#pthread_exit) 的形参来指定

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>

void *thread_start(void *_agr) {
  printf("child-thread executing\n");

  sleep(5);

  return NULL;
}
void foo(void) {
  pthread_t t_id;
  pthread_create(&t_id, NULL, thread_start, NULL);

  void *ret_val = NULL;
  pthread_join(t_id, &ret_val);

  printf("main-thread executing\n");
}

int main(int argc, char *argv[]) {
  foo_01();

  return EXIT_SUCCESS;
}

```

<br/>

#### int pthread_detach(pthread_t thread)
##### <pthread.h>

设定指定线程 **`thread`** 为分离状态，如果成功，则返回 **`0`**，如果调用失败，则返回对应的 **`错误码`** ( 需要通过 **`strerror`** 把该错误码转换成有效的输出信息 )

当一个线程被置为分离，那么当其在终止后其所占用的资源就会自动由内核所完全回收，即不再需要依赖于父级进程的终止亦或者 **`pthread_join`** 的调用

当一个线程被设置为分离状态后，任意线程针对于当前线程的 **`pthread_join`** 都会立即返回错误号为 **`EINVAL`** 的错误信息，我们可以理解为 **detach** 即已经不需要依赖于其他线程，但并不意味着该线程真正的不被其他线程所影响；事实上，**分离状态仅仅指定了该线程在终止时，操作系统所给予的控制行为 ( 自动回收其所占用的所有资源 )**{style="color:red"}，一个线程组内的任意线程的 **`exit`** ( 亦或者等同于主线程在 **`main`** 函数中的 **`return`** ) 任然会导致分离状态线程的终止

- **`thread`** : 分离线程的 **`TID`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>

void *thread_handler(void *_arg) {
  int idx = 0;
  while (true) {
    if (idx == 5) {
      pthread_exit(NULL);
    }

    printf("[%lu] %d\n", pthread_self(), ++idx);
    sleep(1);
  }

  return NULL;
}
void foo(void) {
  pthread_t t_id;
  pthread_create(&t_id, NULL, thread_handler, NULL);
  pthread_detach(t_id);

  sleep(5);

  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  foo();

  return EXIT_SUCCESS;
}

```

<br/>

#### int pthread_cancel(pthread_t thread)
##### <pthread.h>

杀死、取消线程 **`thread`** 的继续运行，如果成功，则返回 **`0`**，如果调用失败，则返回对应的 **`错误码`** ( 需要通过 **`strerror`** 把该错误码转换成有效的输出信息 )

需要注意的是，线程的取消工作并不是立即执行的，而是要保证线程在运行至某个状态下才能够完成取消工作，关于这个状态，其通常由一些系统调用来进行检查，诸如 **`create`**、**`open`**、**`write`**、**`……`**，关于详情可以点击 [这里](http://man.he.net/?topic=pthreads&section=7)，但是我们可以初略地认为，这个状态则为从用户态切换到内核态的时刻

- **`thread`** : 指定取消线程的 **`TID`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>

void *thread_start(void *_arg) {
  printf("child thread executed\n");

  int idx = 0;
  while (true) {
    printf("[%lu] %d\n", pthread_self(), ++idx);
    sleep(1);
  }

  return NULL;
}
void foo_06(void) {
  pthread_t t_id;
  pthread_create(&t_id, NULL, thread_start, NULL);

  /* Sleep 3 sec. and kill child thread */
  sleep(3);

  pthread_cancel(t_id);

  printf("main thread executed\n");
  exit(EXIT_SUCCESS);
}

int main(int argc, char *argv[]) {
  foo();

  return EXIT_SUCCESS;
}
```

<br/>

#### int pthread_equal(pthread_t t1, pthread_t t2)
##### <pthread.h>

比较两个线程的 TID **`t1`**  **`t2`** 是否相等，如果相等则返回 **`1`** 否则返回 **`0`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  pthread_t t_id;
  pthread_create(&t_id, NULL, thread_start, NULL);

  printf("%d\n", pthread_equals(t_id, pthread_self()));

  return EXIT_SUCCESS;
}
```


<br/>

### 线程同步
<span id="线程同步"></span>

---

关于线程同步的意义这里不再做详细的概述；区别于 [进程](#什么是进程) ，由于线程和其父线程相互间共享了大部分地址空间的数据，故在多线程开发模型的情境下，我们需要拥有一种途径来提供原子性和一致性的操作规范，在 linux 中，为开发人员提供了以下几种途径来保证线程的同步

1. [互斥锁](#互斥锁)
2. [自旋锁](#自旋锁)
3. [读写锁](#读写锁)
4. [条件变量](#条件变量)
5. [信号量](#信号量)

<br/>

<span id = "互斥锁"></span>
#### 互斥锁

依赖于一个 **`互斥对象`**，当某个线程在获取互斥对象临界区的锁的时候，如果该锁以被其他线程锁持有，则当前线程则由内核负责通知并进入到阻塞休眠的状态，仅当该锁已被目标线程所释放且当前线程已获取到执行时间片的条件下，内核才会重新唤起当前线程并继续执行其上下文

为了实现 **`锁的状态发生变化后唤醒执行线程`**，就需要把互斥量的锁交由内核所管理，由内核统一负责执行线程的唤醒和休眠的操作，故对于互斥量的加锁和解锁操作往往都需要从用户态中切换至内核态执行，这里就会涉及到一定的上下文切换上的时间开销，但值得一提的是，自 **`linux 2.6`** 以后，互斥量完全通过 **`futex`** 的 API 实现了，大大减小了内部系统调用的开销

针对于互斥锁操作的 API 都内置在 **`pthread.h`** 头文件当中

- **`互斥量`**

  互斥量通过结构体 **`pthread_mutex_t`** 来表示

- **`互斥量的初始化`**

  在尝试获取一个新创建的亦或者是已被销毁的互斥量的临界锁之前，我们必须要对互斥量进行一次初始化的操作，否则当前互斥量所保有的锁则一直保持着被持有着的状态，即尝试获取该锁的时候都会线程的阻塞亦或者失败返回

  对于互斥量的初始化操作来说，其分为了以下两种途径

   - **`int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr)`**

        动态初始化一个互斥量 **`mutex`**，并指定其类型为 **`attr`**，当 **`attr`** 指定为 **`NULL`** 时，则指定互斥量的类型为默认类型；当函数成功调用时，返回 **`0`**，如果调用失败，则返回对应的 **`错误码`**；关于互斥量类型的更多信息请参考 [这里](https://linux.die.net/man/3/pthread_mutex_lock)

   -  **`PTHREAD_MUTEX_INITIALIZER`** 

         使用宏函数 **`PTHREAD_MUTEX_INITIALIZER`** 静态初始化一个互斥量 **`mutex`**，其效果等同于将形参 **`attr`** 指定为 **`NULL`** 的 **`pthread_mutex_init()`** 的调用

- **`获取互斥量的临界锁`**

    - **`int pthread_mutex_lock(pthread_mutex_t *mutex)`**

      获取互斥量 **`mutex`** 的临界锁，如该锁已被其他线程所持有亦或者临界锁未正确进行过初始化，则当前线程进入至阻塞休眠的状态，仅当该锁已被目标线程所释放且当前线程已获取到执行时间片的条件下，内核才会重新唤起当前线程并继续执行其上下文

    - **`int pthread_mutex_trylock(pthread_mutex_t *mutex)`**

      尝试获取互斥量 **`mutex`** 的临界锁，如该锁已被其他线程所持有亦或者临界锁未正确进行过初始化，则函数的调用立即结束并返回对应的 **`错误码`*

- **`释放当前线程所持有的互斥量的临界锁`**

    - **`int pthread_mutex_unlock(pthread_mutex_t *mutex)`**

      释放掉当前线程所持有的互斥量 **`mutex`** 的锁，如成功则返回 0，否则返回对应的 **`错误码`**

- **`释放互斥量对象`**
    - **`int pthread_mutex_destroy(pthread_mutex_t *mutex)`**

      释放掉互斥量对象 **`mutex`**，当一个互斥量不再被任何一个线程所使用的时候，我们应该手动的对其进行释放，如成功则返回 0，否则返回对应的 **`错误码`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>
#include <wait.h>

void *thread_start(void *arg) {
  pthread_mutex_t *mutex = (pthread_mutex_t *)arg;
  
  /* start lock */
  /* pthread_mutex_lock(mutex); */
  int errno;
  if ((errno = pthread_mutex_trylock(mutex)) != 0) {
    printf("[%lu] %s\n", pthread_self(), strerror(errno));
    pthread_exit(NULL);
  }

  sleep(2);
  printf("[%lu] child-thread executed\n", pthread_self());

  /* end lock */
  pthread_mutex_unlock(mutex);
  return NULL;
}

void foo(void) {
  pthread_mutex_t mutex;
  pthread_mutex_init(&mutex, NULL);

  pthread_t threads[2] = { 0 };
  for (size_t i = 0; i < 2; ++i) {
    pthread_t t_id;
    pthread_create(&t_id, NULL, thread_start, (void *)&mutex);

    printf("[%lu] create child thread (%lu)\n", pthread_self(), t_id);
    threads[i] = t_id;
  }

  for (int i = 1; i >= 0; --i) {
    pthread_join(threads[i], NULL);
    printf("[%lu] Recyle (%lu)\n", pthread_self(), threads[i]);
  }

  pthread_mutex_destroy(&mutex);
  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  foo();
  return EXIT_SUCCESS;
}
```

<br/>

<span id = "自旋锁"></span>
#### 自旋锁

自旋锁和互斥锁所实现出来的效果和使用方式都是非常的类似的，仅当某个线程在请求自旋对象所保有的临界锁的时候，如果该锁已被其它线程所占用，则当前线程则处于一个阻塞的状态，需要注意的是，这种阻塞并不是线程的休眠，它区别于互斥锁，实际上该线程还正在占用着 CPU 时间片运行着，它类似于一个 **`while`** 的循环以判断自旋对象所保有的锁是否已被释放，当锁以被释放且以由当前线程获取到 CPU 执行时间片的前提条件下，当前线程则能够进入到自旋锁的临界区中执行上下文

由于自旋锁其阻塞的过程由于是通过一个循环来不断地判断自旋对象所保有的锁是否被释放，故对于自旋锁所造成的阻塞其实线程是一只保留在用户态空间下的，虽然其一定程度上能够解决掉互斥锁由于线程休眠和唤醒时所造成的从用户态切换到内核态的时间开销，但是，自旋锁由于是在循环中不断的进行着判断 ( 判断自旋对象锁保有的锁已被某个线程所释放 )，故，当自旋锁的 **`锁粒度`** 较大的时候，会浪费较多的 CPU 执行时间片

针对于自旋锁操作的 API 都内置在 **`pthread.h`** 头文件当中

- **`自旋对象`**

  自旋对象通过结构体 **`pthread_spinlock_t`** 来表示

- **`自旋对象的初始化`**

  在尝试获取一个新创建的亦或者是已被销毁的自旋对象的临界锁之前，我们必须要对自旋对象进行一次初始化的操作，否则当前自旋对象所保有的锁则一直保持着被持有着的状态，即尝试获取该锁的时候都会线程的阻塞亦或者失败返回
   - **`int pthread_spin_init(pthread_spinlock_t *lock, int pshared)`**

        动态初始化一个对象 **`mutex`**，并指定其类型为 **`attr`**，它可以为以下两种宏定义之一
        
        - **`PTHREAD_PROCESS_SHARED`** : 自旋对象允许在不同进程下的子线程进行共享使用
        - **`PTHREAD_PROCESS_PRIVATE`** : 自旋对象仅允许在当前进程组下所派生出来的子线程进行共享使用

- **`获取自旋对象的临界锁`**

    - **`int pthread_spin_lock(pthread_spinlock_t *lock)`**

      获取自旋对象 **`lock`** 的临界锁，如该锁已被其他线程所持有亦或者临界锁未正确进行过初始化，则当前线程进入一种循环方式的阻塞状态，仅当该锁已被目标线程所释放且当前线程已获取到执行时间片的条件下，阻塞循环才会退出

    - **`int pthread_spin_trylock(pthread_spinlock_t *lock)`**

      尝试获取自旋对象 **`lock`** 的临界锁，如该锁已被其他线程所持有亦或者临界锁未正确进行过初始化，则函数的调用立即结束并返回对应的 **`错误码`*

- **`释放当前线程所持有的自旋对象的锁`**

    - **`int pthread_spin_unlock(pthread_spinlock_t *lock)`**

      释放掉当前线程所持有的自旋对象 **`lock`** 的锁，如成功则返回 0，否则返回对应的 **`错误码`**

- **`释放互斥量对象`**
    - **`int pthread_spin_destroy(pthread_spinlock_t *lock)`**

      释放掉自旋对象 **`mutex`**，当一个自旋对象不再被任何一个线程所使用的时候，我们应该手动的对其进行释放，如成功则返回 0，否则返回对应的 **`错误码`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>
#include <wait.h>

void *thread_start(void *arg) {
  pthread_spinlock_t *locker = (pthread_spinlock_t *)arg;
  
  /* start lock */
  pthread_spin_lock(locker);
  /* int errno;                                               */
  /* if ((errno = pthread_spin_trylock(locker)) != 0) {       */
  /*   printf("[%lu] %s\n", pthread_self(), strerror(errno)); */
  /*   pthread_exit(NULL);                                    */
  /* }                                                        */

  usleep(500 * 1000);
  
  /* end lock */
  pthread_spin_unlock(locker);

  printf("[%lu] child-thread executed\n", pthread_self());
  return NULL;
}
void foo(void) {
  pthread_spinlock_t locker;
  pthread_spin_init(&locker, PTHREAD_PROCESS_PRIVATE);

  pthread_t threads[20] = { 0 };
  for (size_t i = 0; i < 20; ++i) {
    pthread_t t_id;
    pthread_create(&t_id, NULL, thread_start, (void *)&locker);

    printf("[%lu] create child thread (%lu)\n", pthread_self(), t_id);
    threads[i] = t_id;
  }

  for (int i = 0; i < 20; ++i) {
    pthread_join(threads[i], NULL);
    printf("[%lu] Recyle (%lu)\n", pthread_self(), threads[i]);
  }

  pthread_spin_destroy(&locker);
  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  foo();
  return EXIT_SUCCESS;
}
```

<br/>


<span id = "读写锁"></span>
#### 读写锁

读写锁也称为 **`共享-独占锁`**，它非常适合于对 **数据结构读的次数远大于写**{style="color:red"} 的情景，其提供了两种模式的锁定机制
- 当线程以 **`读模式`** 获取了读写锁对象的临界区锁的时候，仅当同样使用读模式去获取读写锁对象临界区锁的时候才能成功，反之，当其他线程使用 **`写模式`** 去请求一个已经被某个线程持有读模式锁的读写锁对象的临界区锁的时候，则会造成当前线程的阻塞等待直至读写锁对象的读模式的锁被释放，即，针对于 **`读模式`** 的锁定呈现了一种共享的状态
- 当线程以 **`写模式`** 获取了读写锁对象的临界区锁的时候，其它线程针对该读写锁对象所使用的任何模式的锁请求都会造成当前线程的阻塞，即，针对于 **`写模式`** 的锁定呈现了一种独占的状态

在读模式的请求与写模式的请求并行请求读写锁对象的情境之下，**写模式请求的优先级会高于读模式的请求**{style="color:red"}，即永远都是写模式的请求优先抵达至读写锁对象中，后来的读模式请求则会因为写模式请求所持有的独占特性而造成阻塞运行

需要注意的是，读写锁并不持有两把锁，所持有的仅仅只是对于请求读写锁对象的临界区锁的模式，即 **`读模式请求`** 和 **`写模式请求`**

针对于读写锁操作的 API 都内置在 **`pthread.h`** 头文件当中

- **`读写锁对象`**

  读写锁对象通过结构体 **`pthread_rwlock_t`** 来表示

- **`读写锁对象的初始化`**

  在尝试获取一个新创建的亦或者是已被销毁的读写锁对象的临界锁之前，我们必须要对读写锁对象进行一次初始化的操作，否则当前读写锁对象所保有的锁则一直保持着被持有着的状态，即尝试获取该锁的时候都会线程的阻塞亦或者失败返回
   - **`int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr)`**

      动态初始化一个读写锁对象 **`rwlock`**，并指定其类型为 **`attr`**，当 **`attr`** 指定为 **`NULL`** 时，则指定互斥量的类型为默认类型；当函数成功调用时，返回 **`0`**，如果调用失败，则返回对应的 **`错误码`**

- **`以读模式获取读写锁对象的临界锁`**

    - **`int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)`**

      以读模式获取读写锁对象 **`rwlock`** 的临界锁，如该锁已被其他线程以 **`写模式`** 所持有亦或者临界锁未正确进行过初始化，则阻塞当前线程的执行直至读写锁对象所已被其它线程所持有的临界区锁已被释放

    - **`int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)`**

      尝试以读模式获取读写锁对象 **`rwlock`** 的临界锁，如该锁已被其他线程以 **`写模式`** 所持有亦或者临界锁未正确进行过初始化，则函数的调用立即结束并返回对应的 **`错误码`*

- **`以写模式获取读写锁对象的临界锁`**

    - **`int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)`**

      以写模式获取读写锁对象 **`rwlock`** 的临界锁，如该锁已被其他线程以 **`任意模式`** 所持有亦或者临界锁未正确进行过初始化，则阻塞当前线程的执行直至读写锁对象所已被其它线程所持有的临界区锁已被释放

    - **`int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock)`**

      尝试写模式获取读写锁对象 **`rwlock`** 的临界锁，如该锁已被其他线程以 **`任意模式`** 所持有亦或者临界锁未正确进行过初始化，则函数的调用立即结束并返回对应的 **`错误码`*


- **`释放当前线程所持有的读写锁对象的锁`**

    - **`int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)`**

      释放掉当前线程所持有的自旋对象 **`lock`** 的锁，如成功则返回 0，否则返回对应的 **`错误码`**

- **`释放读写锁对象`**
    - **`int pthread_spin_destroy(pthread_spinlock_t *lock)`**

      释放掉自旋对象 **`mutex`**，当一个自旋对象不再被任何一个线程所使用的时候，我们应该手动的对其进行释放，如成功则返回 0，否则返回对应的 **`错误码`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>
#include <wait.h>

void *thread_start_1(void *arg) {
  pthread_rwlock_t *rwlocker = (pthread_rwlock_t *)arg;
  
  /* wait for read locker executed */
  sleep(1);

  /* start lock */
  pthread_rwlock_wrlock(rwlocker);
  printf("[%lu] Write lock\n", pthread_self());

  sleep(2);
  
  /* end lock */
  pthread_rwlock_unlock(rwlocker);

  printf("[%lu] Write locker executed\n", pthread_self());
  return NULL;
}

void *thread_start_2(void *arg) {
  pthread_rwlock_t *rwlocker = (pthread_rwlock_t *)arg;

  /* start lock */
  pthread_rwlock_rdlock(rwlocker);
  printf("[%lu] Read lock\n", pthread_self());
  
  sleep(2);
  
  /* end lock */
  pthread_rwlock_unlock(rwlocker);

  printf("[%lu] Read locker executed\n", pthread_self());
  return NULL;
}


void foo(void) {
  pthread_spinlock_t locker;
  pthread_spin_init(&locker, PTHREAD_PROCESS_PRIVATE);

  pthread_t t_id_1;
  pthread_create(&t_id_1, NULL, thread_start_1, (void *)&locker);

  pthread_t t_id_2;
  pthread_create(&t_id_2, NULL, thread_start_1, (void *)&locker);

  pthread_join(t_id_1, NULL);
  pthread_join(t_id_2, NULL);

  pthread_spin_destroy(&locker);
  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  foo();
  return EXIT_SUCCESS;
}
```

<br/>

<span id = "条件变量"></span>
#### 条件变量

条件变量的使用依赖于 **`条件变量对象`** 和 **`互斥对象`**，也就是说，条件变量的使用玩玩需要配合互斥量来进行的；需要注意的是，条件变量虽然也提供了一种阻塞等待的机制，但是条件变量本身不是锁，是属于一种 **`线程间的通讯机制`**，它所解决的问题并不是 **`互斥`**，而是 **`等待`**

条件变量整体而言可以拆分出两种动作 : 

- **`等待`** : 当 **`等待线程`** 使用了条件变量的等待动作后，条件变量会阻塞当前阻塞线程的执行，使之置于休眠状态，并恢复由于正在请求所依赖 **`互斥量`** 保有的临界锁而处于阻塞休眠状态的线程的执行 ( **`通知线程`** )，仅当 **`通知线程`** 成功的发送了一个 **`唤醒通知`**，等待线程才会被 **`唤醒`** 并执行检测，如果所依赖的 **`互斥量`** 其本身所保有的临界锁正在被持有，则等待线程 **`回到`** 休眠状态 ( 通知线程继续执行互斥临界区的上下文，不受影响 ) ，仅当持有 **`互斥量`** 锁保有的锁的线程其临界区执行完毕，等待线程才恢复所保留的上下文继续执行 ( 由于等待线程继续执行的上下文处在互斥量的临界区内，故这时候其它线程在请求互斥量锁保有的锁的时候同样会造成阻塞休眠 ) ( 这一机制也是为了保证互斥量的临界区执行是唯一的 )，反之，等待线程会立即恢复所保留上下文并继续执行

- **`通知`** : 通知的任务就较为简单，**`通知线程`** 所保有的任务就是负责发送通知，当通知成功送达至 **`等待线程`** 中，则执行等待线程初次被唤醒后的逻辑判断；通知线程并不关心所发送的通知是否成功送达，其所关心的仅仅只是发送一个通知，在一个通知被发送出去后，通知线程还是会继续执行其上下文逻辑

在这里需要再强调一点的是，对于 **`等待`** 任务其在被初次唤醒后会执行一次逻辑判断，即判断所依赖的 **`互斥量`** 其本身所保有的临界锁是否已被持有，所以我们在实际使用的时候需要注意 **`通知线程`** 在执行通知时所在的上下文段，当所执行的通知动作是处于 **`互斥量`** 的锁定临界区内的时候，这时候的通知动作就会导致 **`等待线程`** 会执行多余的 **`被唤醒`** 的动作，即执行了不必要的上下文切换，因为当通知动作储在互斥量锁定临界区内的时候，即便等待线程被唤醒，其同样还是会回到休眠的状态，因为当前互斥量所保有的临界区的锁还在被通知线程所占用着

针对于条件变量操作的 API 都内置在 **`pthread.h`** 头文件当中

- **`条件变量对象`**

  读写锁对象通过结构体 **`pthread_cond_t`** 来表示

- **`条件变量对象的初始化`**

  在使用一个新创建的亦或者是已被销毁的条件变量对象前，我们必须要对条件变量对象进行一次初始化的操作，否则会造成未定义的行为
   - **`int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict cond_attr)`**

      动态初始化一个条件变量对象 **`cond`**，并指定其类型为 **`cond_attr`**，当 **`cond_attr`** 指定为 **`NULL`** 时，则指定条件变量对象的类型为默认类型；当函数成功调用时，返回 **`0`**，如果调用失败，则返回对应的 **`错误码`**

- **`等待`**

    - **`int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex)`**

      使当前线程 ( **`等待线程`** ) 处于阻塞休眠的状态，并唤醒由于正在请求 **mutex** 临界锁而导致休眠阻塞状态线程的执行，仅当 **`通知线程`** 成功的发送了一个 **`唤醒通知`**，等待线程才会被 **`唤醒`** 并执行检测，如果所依赖的 **`互斥量`** 其本身所保有的临界锁正在被持有，则等待线程 **`回到`** 休眠状态 ( 通知线程继续执行互斥临界区的上下文，不受影响 ) ，仅当持有 **`互斥量`** 锁保有的锁的线程其临界区执行完毕，等待线程才恢复所保留的上下文继续执行 ( 由于等待线程继续执行的上下文处在互斥量的临界区内，故这时候其它线程在请求互斥量锁保有的锁的时候同样会造成阻塞休眠 ) ( 这一机制也是为了保证互斥量的临界区执行是唯一的 )，反之，等待线程会立即恢复所保留上下文并继续执行

- **`唤醒`**

    - **`int pthread_cond_signal(pthread_cond_t *cond)`**

      给使用了条件变量对象 **`cond`** 的线程发送一个唤醒通知，当函数成功调用时，返回 **`0`**，如果调用失败，则返回对应的 **`错误码`**
      
    - **`int pthread_cond_broadcast (pthread_cond_t *cond)`**

      给所有使用了条件变量 **`cond`** 的线程广播发送唤醒通知，注意，这相当于是找到了使用了条件变量 **`cond`** 的线程数，并发送指定数量的唤醒通知，也就是说，<font color = "red">哪怕是广播唤醒，线程之间任然需要进入争夺 **mutex** 临界锁的局面，并且争夺失败的线程则会进入休眠的局面，并在每次获取到 CPU 时间片的时候判断临街锁是否被持有，如果没有则再次进入争夺临界锁的局面</font>

- **`释放条件变量对象`**
    - **`int pthread_cond_destroy(pthread_cond_t *cond)`**

      释放掉条件变量对象 **`cond`**，当一个条件变量对象不再被任何一个线程所使用的时候，我们应该手动的对其进行释放，如成功则返回 0，否则返回对应的 **`错误码`**

下面代码展示一个生产者消费者的模型应用

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>

static pthread_mutex_t mutex;
static pthread_cond_t cond;
static char data[64] = { 0 };

static void _init(void) {
  pthread_mutex_init(&mutex, NULL);
  pthread_cond_init(&cond, NULL);
}

static void _free(void) {
  pthread_mutex_destroy(&mutex);
  pthread_cond_destroy(&cond);
}

void *producer_thread_start(void *_arg) {
  int idx = 0;

  while (true) {
    pthread_mutex_lock(&mutex);   /* Start lock */

    memset(data, 0x0, sizeof(data));
    sprintf(data, "%d\n\0", ++idx);

    pthread_mutex_unlock(&mutex); /* End lock */
    
    sleep(1);
    /* Notify consumer-thread to resume the context */
    pthread_cond_signal(&cond);
  }

  return NULL;
}
void *consumer_thread_start(void *_arg) {
  while (true) {
    pthread_mutex_lock(&mutex);   /* Start lock */

    if (strlen(data) == 0) {
      /* Suspend current thread executed and resume producter thread executed */
      pthread_cond_wait(&cond, &mutex);
    }
    printf("%s", data);

    /** 
     * It needs to be cleared to 0 after each read is completed, 
     * in order to prevent the current thread from preempting the CPU time slice in the next loop
     */
    memset(data, 0x0, sizeof(data));

    pthread_mutex_unlock(&mutex); /* End lock */
  }

  return NULL;
}
void foo(void) {
  int t_ret;

  _init();

  /* Create producter process */
  pthread_t t_id_producer;
  if ((t_ret = pthread_create(&t_id_producer, NULL, producer_thread_start, NULL))) {
    printf("%s\n", strerror(t_ret));
    exit(EXIT_FAILURE);
  }
  /* Create consumer process */
  pthread_t t_id_consumer;
  if ((t_ret = pthread_create(&t_id_consumer, NULL, consumer_thread_start, NULL))) {
    printf("%s\n", strerror(t_ret));
    exit(EXIT_FAILURE);
  }

  /* Wait for all thread executed */
  pthread_join(t_id_producer, NULL);
  pthread_join(t_id_consumer, NULL);

  _free();
  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  foo();

  return EXIT_SUCCESS;
}
```

下面代码展示了广播唤醒下，各线程争夺临街锁的局面

```c

#include <math.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

static pthread_mutex_t mutex;
static pthread_cond_t cond;
static char data[64] = {0};

static void _init(void) {
  pthread_mutex_init(&mutex, NULL);
  pthread_cond_init(&cond, NULL);
}

static void _free(void) {
  pthread_mutex_destroy(&mutex);
  pthread_cond_destroy(&cond);
}

void *thread_start_main(void *_arg) {
  sleep(4);

  printf("main thread start lock\n");
  pthread_mutex_lock(&mutex); /* Start lock */
  
  sleep(1);

  pthread_mutex_unlock(&mutex); /* End lock */
  printf("main thread end lock\n");

  sleep(1);

  printf("main thread send wakeup signal\n");
  pthread_cond_broadcast(&cond);

  return NULL;
}

void *thread_start_child(void *_arg) {
  printf("child thread %d start lock\n", (int)pthread_self());
  pthread_mutex_lock(&mutex); /* Start lock */

  printf("child thread %d sleep and wait for wakeup signal arrived\n", (int)pthread_self());
  pthread_cond_wait(&cond, &mutex);
  
  int idx = 0;
  for (size_t i = 0; i < 5; ++i) {
    printf("child thread %d say hello [%d]\n", (int)pthread_self(), idx++);
    fflush(stdout);
    sleep(1);
  }

  printf("child thread %d end lock\n", (int)pthread_self());
  pthread_mutex_unlock(&mutex); /* End lock */

  return NULL;
}

void foo(void) {
  int t_ret;

  _init();

  pthread_t t_id_child_1;
  if ((t_ret = pthread_create(&t_id_child_1, NULL, thread_start_child, NULL))) {
    printf("%s\n", strerror(t_ret));
    exit(EXIT_FAILURE);
  }

  pthread_t t_id_child_2;
  if ((t_ret = pthread_create(&t_id_child_2, NULL, thread_start_child, NULL))) {
    printf("%s\n", strerror(t_ret));
    exit(EXIT_FAILURE);
  }

  pthread_t t_id_main;
  if ((t_ret = pthread_create(&t_id_main, NULL, thread_start_main, NULL))) {
    printf("%s\n", strerror(t_ret));
    exit(EXIT_FAILURE);
  }

  /* Wait for all thread executed */
  pthread_join(t_id_main, NULL);
  pthread_join(t_id_child_1, NULL);
  pthread_join(t_id_child_2, NULL);

  _free();
  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  foo();

  return EXIT_SUCCESS;
}

```


<br/>

<span id = "信号量"></span>
#### 信号量

信号量是一种加强型的互斥锁，其本身实现很简单，其本身内置了一个计数 **`Count`**，当尝试去锁定信号量 ( 执行信号量的临界区 ) 的时候，这个计数就会 **`-1`** ( 当计数本身为 **`0`** 时，则不会做 **`-1`** 操作 )，并且会判断做完算术运算后的计数是否等于 **`0`**，如果等于 **`0`**，则使当前 进程 / 线程 进入阻塞休眠的状态，直至计数不再为 **`0`** ( 需要其他引用了这个信号量的 进程 / 线程 手动对这个计数做 **`+1`** 的操作 ) 则恢复上下文并继续执行

针对信号量操作的 API 都内置在 **`semaphore.h`** 头文件当中

- **`信号量对象`**

  信号量对象通过结构体 **`sem_t`** 来表示

- **`信号量对象的初始化`**

  在使用一个新创建的亦或者是已被销毁的条件变量对象前，我们必须要对条件变量对象进行一次初始化的操作，否则会造成未定义的行为
   - **`int sem_init (sem_t *sem, int pshared, unsigned int value)`**

      动态初始化一个信号量对象 **`sem`**，依据 **`pshared`** 指定该信号量作用于 **`进程 (1)`** 还是 **`线程 (0)`**，并依据 **`value`** 指定该信号量 **`计数 ( Count )`** 的默认值；当函数成功调用时，返回 **`0`**，如果调用失败，则返回对应的 **`错误码`**

- **`信号量计数 -1 ( 锁定 )`**

    - **`int sem_wait (sem_t *sem)`**

      使信号量 **`sem`** 的计数 **`-1`** ( 计数本身为 **`0`** 时，则不会做 **`-1`** 操作 )，当算数运算后的结果为 **`0`** 时，则会使当前 线程 / 进程 置于阻塞休眠的状态，直至计数不再为 **`0`** 时，则恢复上下文并继续执行

    - **`int sem_trywait (sem_t *sem)`**

      使信号量 **`sem`** 的计数 **`-1`** ( 计数本身为 **`0`** 时，则不会做 **`-1`** 操作 )，当算数运算后的结果为 **`0`** 时，则会函数调用立即返回 **`-1`**，否则返回 **`0`**

- **`信号量计数 +1 ( 解锁 )`**

    - **`int sem_post (sem_t *sem)`**

      使信号量 **`sem`** 的计数 **`+1`**

- **`释放信号量对象`**
    - **`int sem_destroy (sem_t *sem)`**

      释放掉信号量对象 **`sem`**，当一个信号量对象不再被任何一个 线程 / 进程 所使用的时候，我们应该手动的对其进行释放，如成功则返回 **`0`**，否则返回对应的 **`错误码`**


```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>

static sem_t sem_producer;
static sem_t sem_consumer;
static char data[64] = { 0 };

static void _init(void) {
  sem_init(&sem_producer, 0, 1);  /* producter_sem default value = 1 */
  sem_init(&sem_consumer, 0, 0);  /* consumer_sem default value = 0 */
}

static void _free(void) {
  sem_destroy(&sem_producer);
  sem_destroy(&sem_consumer);
}

void *producer_thread_start(void *_arg) {
  int idx = 0;

  while (true) {
    sem_wait(&sem_producer); /* producer_sem-- */

    memset(data, 0x0, sizeof(data));
    sprintf(data, "%d\n", ++idx);

    sem_post(&sem_consumer); /* consumer_sem++ */
  }

  return NULL;
}
void *consumer_thread_start(void *_arg) {
  while (true) {
    sem_wait(&sem_consumer); /* consumer_sem-- */

    printf("%s", data);
    memset(data, 0x0, sizeof(data));

    sem_post(&sem_producer); /* producer_sem++ */

    usleep(500 * 1000);
  }

  return NULL;
}
void foo(void) {
  int t_ret;

  _init();

  /* Create producter process */
  pthread_t t_id_producer;
  if ((t_ret = pthread_create(&t_id_producer, NULL, producer_thread_start, NULL))) {
    printf("%s\n", strerror(t_ret));
    exit(EXIT_FAILURE);
  }
  /* Create consumer process */
  pthread_t t_id_consumer;
  if ((t_ret = pthread_create(&t_id_consumer, NULL, consumer_thread_start, NULL))) {
    printf("%s\n", strerror(t_ret));
    exit(EXIT_FAILURE);
  }

  /* Wait for all thread executed */
  pthread_join(t_id_producer, NULL);
  pthread_join(t_id_consumer, NULL);

  _free();
  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  foo();

  return EXIT_SUCCESS;
}

```

<br/>

### IPC ( InterProcess Communication )
<span id="IPC"></span>

---

linux 中的进程其地址空间都是相互独立的，每个进程各自有不同的用户地址空间，虽然子进程的创建 clone 于父进程，但他们之间的地址空也仅仅只是一个相同却不共享的关系，所以，进程于进程之间则需要拥有一个可靠的方式去进行数据的传输，而这种进程与进程之间的数据传输的可靠方案我们称之为 **`IPC`** ( InterProcess Communication )，即进程间通信

进程间通信并不是指一种单一的方案，而是多种不同方案的组成，它们都统称为进程间通信技术，但不可否认的是，任何一种方案都需要依赖于内核去完成进程与进程之间的数据传输，即在内核中开辟出一块缓冲区，需要传输数据的进程则往这块缓冲区中写入数据，而需要读取数据的进程则往这块缓冲区中取出数据，二者需要保证一方读一方写的单一职责性去完成本次进程间的数据传输

![2020-07-03-14-59-37](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2020-07-03-14-59-37.png)


<br/>

 #### 进程间通信的种类
<span id="进程间通信的种类"></span>

进程间通信需要依赖于操作系统所提供特殊的方法，如 : 普通文件, 管道, 信号, 共享内存, 消息队列, 套接字, 命名管道等等，但随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用，现今常用的进程间通信方式有

- [管道](#pipe管道) ( 使用最简单 )
- [信号](#信号_signal) ( 开销最小 )
- [共享映射区](#共享映射区) ( 无血缘关系 )
- 本地套接字 ( 最稳定 )


<br/>

 ### pipe ( 管道 )
<span id="pipe管道"></span>

---

**`pipe`** 是最基本的 **`IPC`** 机制，有时候也称之位 **`匿名管道`**，其应用于有 **血缘关系**{style="color:red"} 的进程之间去完成数据的传输

管道的本质是一块内核的缓冲区，使用环形队列所实现而成，其默认大小为 **`4 KB`** ( 通过 **`ulimit -a`** 命令查看 )，一个管道都拥有两个端口分别标识这个管道的读端和写端，它被 文件描述符 所引用；我们在创建一个管道的时候我们都可以拿到两个引用自管道读端和写端的文件描述符，依赖于父级进程所创建的子级进程是属于 clone 的关系，即同时 clone 了父级进程上在创建管道时所返回的分别表示着管道读端和写端的文件描述符，依赖于这两个文件描述符并通过 **`read`** / **`write`**  的这两个系统调用以完成 **血缘关系**{style="color:red"} 进程间的数据通信操作

<br/>

#### 管道的特性
<span id="管道的特性"></span>

**一个管道的数据流向是呈单向流动的，也就是说一个管道的创建我们就需要规定好两个进程间谁去使用读端的文件描述符谁去使用写端的文件描述符**{style="color:red"}，但并不意味着单个进程下就不能同时使用读端和写端所分别引用的文件描述符；虽然管道对于读写的使用并没有进行过单一访问性的校验，但我们不妨设想一种情况，两个进程间使用管道进行通信，假设某个进程同时支持对管道的读和写，但是另一个进程的职责只是负责对管道进行读，那么当着两个进程同时运行的时候 ，我们就无法保证仅持有读权限的进程所读取到的数据是一种合法的数据了，再者如果需要完成两个进程间的同步操作又显得过于麻烦，所以规定一个管道的使用我们必须保证其数据流向是单向的，如有特殊要求，则开启一个数据反向流向的管道即可

由于管道其实质属于一块缓冲区，故管道中的数据一旦被读取 ( **`read`** ) 则不复存在

管道的读写两端默认情况下都是属于阻塞式的操作
  - **`read`** : 针对于读端进行操作时，如管道没有数据，则读取操作则会发生阻塞(**_Interruptible Sleep(S)_**)

  -  **`write`** : 针对于写端进行操作时，如管道数据已满，则写入操作则会发生阻塞(**_Interruptible Sleep(S)_**)

<br/>

#### 管道的使用

<span id="管道的使用"></span>

#### int pipe(int fd_pipe[2])
##### <unistd.h>

创建一个管道，如果创建成功，则该函数返回 **`0`**，并将分别标识管道读端和写端的文件描述符写入至数组参数 **`fd_pipe`** 指定下标之中  ( **`fd_pipe[0]`** : 读端 , **`fd_pipe[0]`** : 写端  )，如果创建失败，则该函数返回 **`-1`**

```c
#include <stdio.h>
#include <unistd.h>

int main(void) {
  int fd[2] = { 0 };
  if (pipe(fd) == -1) {
    perror("e");
    exit(EXIT_FAILURE);
  }

  int pid = fork();
  if (pid < 0) {
    perror("e");
    exit(EXIT_FAILURE);
  } else if (pid == 0) { /* child process context */
    close(fd[1]);

    /* read */
    char buf[0x8] = { 0 };
    int ln = read(fd[0], buf, sizeof(buf));
    printf("[%d] %s\n", getpid(), buf);

    exit(EXIT_SUCCESS);
  }

  /* parent process context */
  close(fd[0]);

  /* write */
  char *data = "hello,world!";
  int sz = write(fd[1], data, strlen(data) + 1);
  printf("[%d] parent end write, size = (%d)\n", getpid(), sz);

  /* wait for child process executed */
  int stat;
  wait(&stat);

  /* close all pipe */
  for (size_t i = 0; i < 2; ++i) {
    close(fd[i]);
  }

  /* end */
  exit(EXIT_SUCCESS);
}
```

<br/>

#### 改变管道的默认阻塞行为

<span id="改变管道的默认阻塞行为"></span>

管道的读写两端由文件描述符所引用，既然是文件描述符，那么就可以通过 **`fcntl`** 的系统调用来获取这两个文件描述符在创建时所指定的 **`flag`** 并对其进行修改

```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main(void) {
  int fd_pipe[2];
  if (pipe(fd_pipe) == -1) {
    perror("e");
    exit(EXIT_FAILURE);
  }
  
  /* set pipe line read postion nonblock */
  int fl = fcntl(fd_pipe[0], F_GETFL);
  fcntl(fd_pipe[0], F_SETFL, fl | O_NONBLOCK);

  return EXIT_SUCCESS;
}
```

<br/>

#### 管道的读写行为

<span id="管道的读写行为"></span>

管道的读写行为在不同情境之下都会有不同的体现，总结如下

- read
  - 写端全部关闭
    - 有数据
      - 正常读取
    - 无数据
      - 解除读端的默认阻塞，并返回实际读取到的字节数为 **`0`**
  - 写端未全部关闭
    - 有数据
      - 正常读取
    - 无数据
      - 阻塞当前读取操作，直至缓冲区中被写入了新的数据
- write
    - 读端全部关闭
      - 管道破裂，进程强制终止，并且内核给当前进程发出 **`SIGPIPE`** 信号
    - 读端未全部关闭
      - 管道填满
        - 阻塞当前写入操作，直至缓冲区中有多余的空间被空出来
      - 管道未满
        - 正常写入

<br/>

 ### FIFO
<span id="fifo111"></span>

---

**`FIFO`** 同样也是作为管道的一类，通常称之为 **`有名管道`**，区别于上面的 [pipe](#pipe管道)，FIFO 除了能应用于用于有 **血缘关系**{style="color:red"} 的进程之间去完成数据的传输，还能应用于 **没有血缘关系**{style="color:red"} 的进程间去完成数据的传输

为什么 FIFO 通信的机制需要被称为 **`有名管道`**，这同样也是其传输特性所导致的；FIFO 需要依赖于 linux 中的基础文件 **`管道文件 (p)`** 去完成两个进程间的通信，但是需要注意的是，进程间的数据传输并不会写入到管道文件之中，而是依赖于管道文件建立两个进程之间读和写的链接关系，并且管道文件最终又会指向内核的缓冲区当中，所以，通过 FIFO 进行通信实际上数据的流动还是在内核缓冲区中进行

由于 FIFO 本身也是属于管道一类的 IPC 通信机制，故其所保有的特性大部分都可沿用至 [pipe](#pipe管道)

<br/>

#### FIFO的特性

<span id="FIFO的特性"></span>

FIFO 严格遵循 $first$ $in$ $first$ $out$ 的特性，即数据的写入总是追加到缓冲区的末尾，而数据的读取则总是会从缓冲区的开始处取出，并且不支持使用 **`lseek()`** 等函数去修改文件读写指针的定位

由于 FIFO 实际上还是依赖于内核缓冲区来进行通信，故缓冲区中的数据一旦被读取 ( read ) 则不复存在

FIFO 需要严格规定两个进程之间的读写两端，这一特性还延续到管道文件的打开身上，**在默认情境之下 ( 未设置 **`O_NONBLOCK`** )，一方进程以 **`读 / 写`** 打开的管道文件始终都会阻塞当前进程的上下文执行直至当前文件接收到存在另一个进程以 **`写 / 读`** 的方式打开**{style="color:red"}

<br/>

#### FIFO的使用

<span id="FIFO的使用"></span>

FIFO 的使用并无太多特性，需要注意仅只是创建一个管道文件并且使用完最好使用 **`unlink()`** 删除即可

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <unistd.h>

#define FIFO_NAME "myfifo"

void foo(void) {
  if (mkfifo(FIFO_NAME, 0666) < 0)
    perror("mkfifo");

  int pid = fork();
  if (pid < 0) {
    printf("Create child process error\n");
    exit(EXIT_FAILURE);
  } else if (pid == 0) {
    int fd_r = open(FIFO_NAME, O_RDONLY);
    if (fd_r < 0) {
      printf("Open reading-only fifo file error\n");
      exit(EXIT_FAILURE);
    }

    printf("[%d] Child process start read\n", getpid());

    char buf[14] = { 0 };
    int size;
    while ((size = read(fd_r, buf, sizeof(buf))) != 0) {
      printf("[%d] child process read %d bytes, value = %s", getpid(), size, buf);
    }

    printf("[%d] Child process ending\n", getpid());
    close(fd_r);
    return;
  } else {
    int fd_w = open(FIFO_NAME, O_WRONLY);
    if (fd_w < 0) {
      printf("Open writing-only fifo file error\n");
      exit(EXIT_FAILURE);
    }

    printf("[%d] Parent process start read\n", getpid());

    char buf[0x100] = { 0 };
    int idx = 0;
    int size;
    while (++idx < 10) {
      sprintf(buf, "%d\n", idx);
      int size = write(fd_w, buf, strlen(buf) + 1);

      printf("[%d] Parnet process write %d bytes, value = %s", getpid(), size, buf);

      memset(buf, 0, sizeof(buf));
    }

    printf("[%d] Parent process ending\n", getpid());
    close(fd_w);
    return;
  }

  unlink(FIFO_NAME);
}

int main(int argc, char *argv[]) {
  foo();
  return EXIT_SUCCESS;
}
```

<br/>

#### FIFO的阻塞和读写行为

<span id="FIFO的阻塞和读写行为"></span>

默认情况之下，FIFO 的阻塞行为除了 **`read()`** **`write()`**，还会延续到文件的打开 **`open()`**，当一方进程以 **`读 / 写`** 打开的管道文件始终都会阻塞当前进程的上下文执行直至当前文件接收到存在另一个进程以 **`写 / 读`** 的方式打开，当然这是默认行为，我们也可以在打开文件 ( **`open()`** ) 的时候通过指定 **`O_NONBLOCK`** 去取消打开时的阻塞行为

- 写端取消阻塞 : 立即返回结果；除了会判断管道文件路径的有效性外，还会判断当前管道文件的读端是否打开，如未打开，则 **`open()`** 函数调用失败
- 读端取消阻塞 : 立即返回结果；并不会判断所指定的管道文件是否打开写端，仅判断文件路径的有效性去决定  **`open()`** 函数调用结果

对于 FIFO 的读写行为则延续至 [pipe](#pipe管道) 之中，这里不再阐述

<br/>

 ### 共享映射区
<span id="共享映射区"></span>

---

共享映射区能够将一个磁盘中的文件作为共享的内容并将之加载至内核的缓冲区内，我们可以简单地理解为该机制可以让一个磁盘文件和内核的缓冲区建立一个映射的关系，就这点和 [FIFO](#fifo111) 有一点相似，但是实际上，共享映射区虽然在使用的时候都是以内核缓冲区为基准，但是要想实现进程二者间的数据共话，数据的写入实际上还是会重新映射到磁盘的文件当中去的

虽然共享区的创建出去需要依赖于一个已经被打开 ( **`open()`** ) 文件的文件标识符来完成，但是实际上，共享区的创建完成后即已经把当前文件的数据都读取到共享映射区当中，即一个共享区的成功创建后就不需要再依赖于所打开的文件，这时候我们可以手动的去关闭它

当我们在对共享区进行读写操作的时候，共享区并不会提供读写的阻塞机制，故使用这一方式去完成 IPC 时我们要保证读端和写端的同步

![2020-07-05-02-26-06](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2020-07-05-02-26-06.png)

<br/>

#### 共享映射区的使用

<span id="共享映射区的使用"></span>

#### void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)
##### <sys/mman.h>

依据所打开文件 ( **`open()`** ) 的文件标识符 **`fd`** 在内核中构建一块共享映射区，如果成功，则返回这块内存区域的首地址，如创建失败，则返回为宏 **`MAP_FAILED`** 的结果

- **`addr`** : 指定所创建的共享映射区的内存首地址，通常它由内核本身来指定，故该参数通常设置为 **`NULL`**

- **`length`** : 映射到共享映射区的文件大小，通常它为文件描述符 **`fd`** 所指向的文件的本身大小

- **`prot`** : 构建的共享映射区的保护方式
  - **`PROT_READ`** : 只读
  - **`PROT_WRITE`** : 只写
  - 需要指定多种不同方式时，通过位或操作符来添加

- **`flags`** : 所构建的构想映射区的特性
  - **`MAP_SHARED`** : 共享映射区的数据可用于不同进程间共享，指定了该参数后往共享映射区所写入的数据会映射回文件本身
    - 当指定了该特性后，我们要保证共享映射区的保护方式 **`prot`** 所指定的权限要 **`<=`** 打开的文件所指定的权限

  - **`MAP_PRIVATE`** : 共享映射区的数据仅用于单独进程本身，制定了该参数后往共享映射区写入数据时会触发 $COW$ ( copy-on-write ) 的特性，即会对原有共享区的数据拷贝一份新的出来，而写入的数据仅针对于拷贝出来的区域，起到保护原始共享映射区不会被污染的作用
    - 当指定了该特性后，无需考虑 **`fd`** 所指向的文件权限

  - **`MAP_ANONYMOUS`** : 构建匿名共享映射区，即不需要依赖于一个实际存在的文件
  - 需要指定多种不同方式时，通过位或操作符来添加

- **`fd`** : 共享映射区在构建时所依赖的文件描述符，需要注意的是，由于共享映射区的构建之初需要依赖于一个实际存在于磁盘中的文件，故 fd 所指向的文件大小必须大于 0，否则在构建共享映射区时会出现总线错误
  - 当该参数指定为 -1 时，则意为创建一个匿名共享映射区，即不需要依赖于一个实际存在的文件

- **`offset`** : 需要将文件拷贝到共享映射区的字节数，该参数的指定必须为 **0或者4KB的整数倍**{style="color:red"}

#### int munmap(void *addr, size_t length)
##### <sys/mman.h>

释放共享映射区，共享映射区在使用完毕后我们需要现实的对其进行关闭以供内存的重用

- **`addr`** : 所需释放的共享映射区的首地址，即 **`mmap`** 系统调用的返回值
- **`length`** : 创建共享映射区时所指定的 **`length`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/wait.h>

void foo(void) {

  int fd = open("./test", O_RDWR);
  if (fd < 0) {
    perror("open file error");
    return;
  }

  int len = lseek(fd, 0, SEEK_END);
  void *addr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  if (addr == MAP_FAILED) {
    perror("memory map error");
    return;
  }
  close(fd);

  int pid = fork();
  if (pid < 0) {
    perror("fork error");
    return;
  } else if (pid == 0) { /* child context */
    sleep(1);

    /* read */
    printf("[%d] child process start read data\n",getpid());

    printf("%s\n", (char *)addr);

    printf("[%d] child process end\n",getpid());
    
    return;
  } else {               /* parent context */
    /* write */
    printf("[%d] parent process start write data\n",getpid());

    char *str = "hello,world!";
    int size = strlen(str) + 1;
    memcpy(addr, str, size);

    printf("[%d] parent process write %d bytes, value = %s\n", getpid(), size, str);
    
    /* close */
    wait(NULL);
    munmap(addr,len);
  }
}

int main(int argc, char *argv[]) {
  foo();

  return EXIT_SUCCESS;
}
```


<br/>

### 信号 ( Signals )
<span id="信号_signal"></span>

---

#### 信号的一些基本概念和特性
<span id="信号的一些基本概念和特性"></span>

信号是一种信息的载体，是 linux / unix 环境下的古老且经典的通信方式，反观至今天，它任然能够作为一种有效可靠的进程间的通信手段之一

操作系统是拥有多种不同信号定义的，而对于这个定义来说，也仅仅只是代表着具体某个信号所对应的 ID，不管是接收一个信号也好还是发送一个信号，我都需要指定这个信号的定义 ( ID ) 以通知内核当前所需处理的信号，当然，我们无需记忆如此之多的信号所对应的 ID 值，仅在需要时就可以到 [man page session 7 - signal](http://man.he.net/?topic=signal&section=7) 找到不同标准规范的信号定义

信号被存储在内核区的 PCB 模块之中，简而言之就是作为一个结构体中的成员而存在，而作为 PCB 进程控制模块而言，由它来负责控制当前进程中的信号收发

**如不考虑阻塞，当一个进程以任何方式收到一个信号时会立刻 **`中断`** 当前用户态中的运行，并进入到内核态中执行当前所收到信号的相关 **`Action`**<span></span>**{style="color:red"}； 由于 **`Action`** 的执行需要设计到用户态到内核态的切换，所以，就信号的实现手段来说是存在一定的延时性的，但是这种延时性对于用户来说是非常之短，可忽略不计

信号的实现拥有以最大的特性就是 **`异步执行`** ( 这里的异步并不指的是在当前代码上下文中的异步状态，因为信号执行 **`Action`** 时往往会中断当前用户态的运行 )，当进程收到一个信号且正在执行这个信号所对应的动作时，另一个信号的到达并不会阻塞当前所执行的信号动作，即异步处理另一个信号所对应的动作；但是对于相同的信号来说，重复信号的送达必须得等待上一个信号的动作执行完毕才能够执行，我们可以抽象的理解为这是一个队列的概念，但是这个队列仅能存储 **`1`** 个等待的信号 ( 这 **`1`** 个等待的信号通常也称之为 **`未决信号`** )，剩余信号的送达将都会被内核所丢弃，即 **linux 中的信号并不是可靠的**{style="color:red"}

关于相同信号的队列状态，会在 [未决信号集和阻塞信号集](#未决信号集和阻塞信号集) 中进行细说

<br/>

#### 信号的状态和处理方式 ( Action )
<span id="信号的状态和处理方式"></span>

一个信号从它的产生到抵达一个进程的过程我们可以总结为以下三种状态
- 产生 : 即产生了一个信号，这个过程可能是键盘中断亦或者系统调用来实现
- 未决 : 未决状态为产生和抵达之间的一种状态，通常是由于阻塞 ( mask ) 所导致的当前状态，一旦某个信号的阻塞解除，则立即进入 **`抵达`** 状态
- 抵达 : 即进程已经成功接收到了某个信号，当一个进程接收到了一个信号后，如不考虑阻塞 ( mask ) 的情况，则会立即切换到内核态并执行当前信号的 [Action](#signal_action_111)

<br/>

<span id = "signal_action_111"></span>

信号的 **`Action`** 特就是某个进程在成功接收到某个信号后所需立即执行的动作，这种动作分为了以下三种类型

- Perform the default action
- Ignore the signal
- Catch the signal with a signal handler ( by **`signal()`** or **`sigaction()`** system call ) , a programmer-defined function that is automatically invoked

这里需要补充一下 **`Perform the default action`**，在 linux / unix 系统中的所有信号都有一个对应的默认执行动作，具体来说，它归纳为以下几种 ( 对于大多数信号而言其行为都是终止当前进程 )

- Term : Default action is to terminate the process
- Ign : Default action is to ignore the signal
- Core : Default action is to terminate the process and  dump  core
- Stop : Default action is to stop the process
- Cont  - Default  action  is  to  continue the process if it is currently stopped

[说明文档](http://man.he.net/?topic=signal&section=7) ( man page session 7 - signal ) 中查阅到所有信号所对应的默认执行动作


```text
 First the signals described in the original POSIX.1-1990 standard.

 Signal     Value     Action   Comment
 ----------------------------------------------------------------------
 SIGHUP       1        Term    Hangup detected on controlling terminal 
                               or death of controlling process
 SIGINT       2        Term    Interrupt from keyboard
 SIGQUIT      3        Core    Quit from keyboard
 SIGILL       4        Core    Illegal Instruction
 SIGABRT      6        Core    Abort signal from abort(3)
 SIGFPE       8        Core    Floating point exception
 SIGKILL      9        Term    Kill signal
 SIGSEGV      11       Core    Invalid memory reference
 SIGPIPE      13       Term    Broken pipe: write to pipe with no readers
 SIGALRM      14       Term    Timer signal from alarm(2)
 SIGTERM      15       Term    Termination signal
 SIGUSR1   30,10,16    Term    User-defined signal 1
 SIGUSR2   31,12,17    Term    User-defined signal 2
 SIGCHLD   20,17,18    Ign     Child stopped or terminated
 SIGCONT   19,18,25    Cont    Continue if stopped
 SIGSTOP   17,19,23    Stop    Stop process
 SIGTSTP   18,20,24    Stop    Stop typed at terminal
 SIGTTIN   21,21,26    Stop    Terminal input for background process
 SIGTTOU   22,22,27    Stop    Terminal output for background process

 The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.

 Next  the  signals  not  in  the POSIX.1-1990 standard but described in
 SUSv2 and POSIX.1-2001.

 Signal       Value     Action   Comment
 --------------------------------------------------------------------
 SIGBUS      10,7,10     Core    Bus error (bad memory access)
 SIGPOLL                 Term    Pollable event (Sys V).
                                 Synonym for SIGIO
 SIGPROF     27,27,29    Term    Profiling timer expired
 SIGSYS      12,31,12    Core    Bad argument to routine (SVr4)
 SIGTRAP        5        Core    Trace/breakpoint trap
 SIGURG      16,23,21    Ign     Urgent condition on socket (4.2BSD)
 SIGVTALRM   26,26,28    Term    Virtual alarm clock (4.2BSD)
 SIGXCPU     24,24,30    Core    CPU time limit exceeded (4.2BSD)
 SIGXFSZ     25,25,31    Core    File size limit exceeded (4.2BSD)

 Up to and including Linux 2.2, the default behavior for  SIGSYS,  SIGX-
 CPU,  SIGXFSZ,  and (on architectures other than SPARC and MIPS) SIGBUS
 was to terminate the process (without a core  dump).   (On  some  other
 UNIX systems the default action for SIGXCPU and SIGXFSZ is to terminate
 the  process  without  a  core  dump.)   Linux  2.4  conforms  to   the
 POSIX.1-2001  requirements  for  these signals, terminating the process
 SIGINFO      29,-,-             A synonym for SIGPWR
 SIGLOST      -,-,-      Term    File lock lost (unused)
 SIGWINCH     28,28,20   Ign     Window resize signal (4.3BSD, Sun)
 SIGUNUSED    -,31,-     Core    Synonymous with SIGSYS

 (Signal 29 is SIGINFO / SIGPWR on an alpha but SIGLOST on a sparc.)


 SIGEMT is not specified in POSIX.1-2001, but  nevertheless  appears  on
 most  other UNIX systems, where its default action is typically to ter-
 minate the process with a core dump.

 SIGPWR (which is not specified in POSIX.1-2001) is typically ignored by
 default on those other UNIX systems where it appears.

 SIGIO (which is not specified in POSIX.1-2001) is ignored by default on
 several other UNIX systems.

 Where defined, SIGUNUSED is synonymous with SIGSYS  on  most  architec-
 tures.
```

最后要说明的是 **`Catch the signal with a signal handler`**，它能够由开发人员去人为的指定捕获信号后所执行的具体 Action，在这里可能会涉及到多次的内核态到用户态的切换过程，其具体的调用流程如下

![2020-07-09-01-56-26](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2020-07-09-01-56-26.png)

<br/>

#### 信号的基本使用
<span id="信号的基本使用"></span>

#### sighandler_t signal(int signum, sighandler_t handler)
##### <signal.h>

捕获指定信号 **`signum`** 在执行时所触发的动作为 **`handler`**

- **`sighandler_t`** : typedef void (*sighandler_t)(int)

- **`signum`** : 指定的信号，signal.h 头文件中提供了所有信号的宏定义，由于信号所对应的 ID 在不同的操作系统中可能会有不同的实现，故该参数建议统一采用库中所提供的宏定义去指定

- **`handler`** : 捕获信号的处理函数

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>
#include <unistd.h>

void SIGINT_handler(int _sig) {
  printf("Catch SIGINT signal, and disable terminate action by default\n");
}
void foo(void) {
  signal(SIGINT, &SIGINT_handler);

  /* Blocked 3 senconds and then send a SIGINT signal to current process */
  sleep(3);
  kill(getpid(), SIGINT);
}

int main(int argc, char *argv[]) {
  foo();
  return EXIT_SUCCESS;
}
```

!!! warning
      由于子进程的创建仅仅只是拷贝父进程地址空间中的数据，即并不共享，故在 **多进程**{style="color:red"} 开发模型下。使用该函数去针对不同的父子级进程去完成相同信号不同处理行为的设置这是安全的，但在 **多线程**{style="color:red"} 开发模型下由于父子级线程之间共享了大部分的地址空间的数据，其中也包括了针对不同信号间的处理行为 ( **`Action`** ) 的设置，故这时候不同线程间使用该函数去完成相同信号不同处理行为的设置时是不安全的，因为某一个线程针对某一个信号的处理行为的设置会覆盖至所有线程之中，故在多线程开发模型下为了保证不被污染，更鼓励使用 [sigwait()](#sigwaitinfo) / [sigwaitinfo()](#sigwaitinfo) 去完成信号的处理行为的绑定设置

<br/>



#### int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)
##### <signal.h>

捕获指定信号 **`signum`** 在执行时所触发的动作为 **`act`**


- **`signum`** : 指定的信号，signal.h 头文件中提供了所有信号的宏定义，由于信号所对应的 ID 在不同的操作系统中可能会有不同的实现，故该参数建议统一采用库中所提供的宏定义去指定

- **`act`** :  用于指定 **`Action`** 执行的一些相关信息，它是一种结构体类型，其结构如下
  
  ```c
  struct sigaction {
    void      (*sa_handler)(int);
    void      (*sa_sigaction)(int, siginfo_t *, void *); 
    sigset_t  sa_mask;
    int       sa_flags;
    void      (*sa_restorer)(void);
  };
  ```
  - **`sa_handler`** : 捕获 **`Action`** 在执行时所使用的自定义 **`handler`**

    - 作为 **`handler`** 的成员可以指定自定义的函数，当指定了任意一个函数指针后，则意味当前 Action 的动作采取的是捕获的方式，当然，我们也可以通过以下两种宏定义来指定这个 Action 的一些具体的行为动作

      - **`SIG_IGN`** : 采取忽略 Action

      - **`SIG_DF`** : 执行默认的 Action

  - **`sa_sigaction`** : 另一种形态的 **`handler`**，通常我们仅需指定 **`sa_handler`** 即可

  - **`sa_mask`** : 阻塞信号集，我们可以通过它来指定在当前信号 **`signum`** 在执行捕获 Action 的 **handler** 时所需屏蔽的信号，需要注意的是，这个屏蔽 ( mask ) 的限制是仅限于执行 **`handler`** 期间才会生效的，并不是一个全局屏蔽的作用

  - **`sa_flags`** : 该成员通常设置为 0

  - **`sa_restorer`** : 已弃用的成员

- **`oldact`** : 旧值，如无特殊要求设置为 NULL 即可

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>

void handler(int _sig) {
  printf("handler executed!\n");
}

int main(void) {
  struct sigaction act;
  act.sa_handler = handler;
  sigemptyset(&sa_mask);
  act.sa_flags = 0;

  sigaction(SIGINT, &act, NULL);

  return EXIT_SUCCESS;
}
```

!!! warning
      由于子进程的创建仅仅只是拷贝父进程地址空间中的数据，即并不共享，故在 **多进程**{style="color:red"} 开发模型下。使用该函数去针对不同的父子级进程去完成相同信号不同处理行为的设置这是安全的，但在 **多线程**{style="color:red"} 开发模型下由于父子级线程之间共享了大部分的地址空间的数据，其中也包括了针对不同信号间的处理行为 ( **`Action`** ) 的设置，故这时候不同线程间使用该函数去完成相同信号不同处理行为的设置时是不安全的，因为某一个线程针对某一个信号的处理行为的设置会覆盖至所有线程之中，故在多线程开发模型下为了保证不被污染，更鼓励使用 [sigwait()](#sigwaitinfo) / [sigwaitinfo()](#sigwaitinfo) 去完成信号的处理行为的绑定设置

<br/>

<span id = "kill_fun"></span>

#### int kill(pid_t pid, int signum)
##### <signal.h>

给指定进程 **`pid`** 发送一个信号 **`signum`**，如果成功则返回 **`0`**，否则返回 **`-1`**

- **`pid`** : 进程的 pid

- **`signum`** : 指定的信号，signal.h 头文件中提供了所有信号的宏定义，由于信号所对应的 ID 在不同的操作系统中可能会有不同的实现，故该参数建议统一采用库中所提供的宏定义去指定

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>
#include <unistd.h>

void foo(void) {
  /* Blocked 3 senconds and then send a SIGINT signal to current process */
  sleep(3);
  kill(getpid(), SIGINT);
}

int main(int argc, char *argv[]) {
  foo();
  return EXIT_SUCCESS;
}
```

!!! warning
    当前函数遵循多进程 ( 旧 linux 内核版本的线程和进程的 **`PID`** 实现一致，更多信心可以查看 [这里](#再聊-pid-pgid-tgid) ) 开发的实现，故在对于实现了 **`POSIX`** 标准的 **`NPTL`** 库所构造线程的 **`TID`** 发送信号时，如果当前所发送的信号在所指定线程内存在阻塞 ( **`mask`** )，则会把信号发送至其父级线程 ( 构造当前线程的进程 ) 当中去，故对于使用 **`pthread_create`** 所构建出来的线程去发送信号时，正确的做法应该使用 [pthread_kill](#pthread_kill) 去完成

<br/>

<span id = "pthread_kill"></span>

#### int pthread_kill(pthread_t thread, int sig)
##### <signal.h>

向指定线程 **`thread`** 发送一个信号 **`sig`**

[kill()](#kill_fun) 由于历史原因，其并未遵循 **`POSIX`** 的 标准规范去完成信号发送，但是为了保证内核的升级能够向下兼容，所以它被保留了下来；由于未遵循 **`POSIX`** 标准规范，故在使用遵循 **`POSIX`** ( **`NPTL`** ) 标准规范的多线程开发模型下，如果 [kill()](#kill_fun) 所发送信号的线程发生了阻塞，则这个信号会发送至其父级线程身上，为了避免这一误导性的错误，在使用 **`NPTL`** 完成多线程的开发情景下，信号的发送更推荐使用当前函数

- **`thread`** : 线程的 tid

- **`sig`** : 指定的信号，signal.h 头文件中提供了所有信号的宏定义，由于信号所对应的 ID 在不同的操作系统中可能会有不同的实现，故该参数建议统一采用库中所提供的宏定义去指定

  当该参数指定为 **`0`** 时，则可以运行错误检查，用于检测指定的线程 **`thread`** 是否还在运行

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/types.h>

void *thread_start(void *_arg) {
  sigset_t mask;
  sigemptyset(&mask);
  sigaddset(&mask, SIGINT);
  pthread_sigmask(SIG_BLOCK, &mask, NULL);

  printf("[%lu] child-thread executed\n", pthread_self());

  while (true) {
    sleep(1);
  }

  return NULL;
}

void sig_handler(int _sig) {
  printf("executed, tid = %lu\n", pthread_self());
  fflush(stdout);

  exit(EXIT_SUCCESS);
}

int main(int argc, char *argv[]) {
  pthread_t t_id;
  int s = pthread_create(&t_id, NULL, thread_start, NULL);
  if (s != 0) {
    char *msg = strerror(s);
    printf("%s\n", msg);
  }

  /* Wait for child thread executed and set the set of signal mask */
  sleep(1);

  struct sigaction act;
  sigemptyset(&act.sa_mask);
  act.sa_handler = sig_handler;
  act.sa_flags = 0;
  sigaction(SIGINT, &act, NULL);

  /* Send a SIGINT signal to child thread */
  printf("[%lu] main-thread executed, create [%lu]\n", pthread_self(), t_id);

  pthread_kill(t_id, SIGINT);

  while (true) {
    sleep(1);
  }

  return EXIT_SUCCESS;
}
```

<br/>

#### int raise( int signum)
##### <signal.h>

给当前进程发送一个信号 **`signum`**，如果成功则返回 **`0`**，否则返回 **`-1`**

- **`signum`** : 指定的信号，signal.h 头文件中提供了所有信号的宏定义，由于信号所对应的 ID 在不同的操作系统中可能会有不同的实现，故该参数建议统一采用库中所提供的宏定义去指定

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>
#include <unistd.h>

void foo(void) {
  /* Blocked 3 senconds and then send a SIGINT signal to current process */
  sleep(3);
  raise(SIGINT);
}

int main(int argc, char *argv[]) {
  foo();
  return EXIT_SUCCESS;
}
```

<br/>

#### int abort()
##### <signal.h>

给当前进程发送一个 **`SIGABRT (6)`** 的信号，并设置 **`core`** 文件 ，如果成功则返回 **`0`**，否则返回 **`-1`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>
#include <unistd.h>

void foo(void) {
  /* Blocked 3 senconds and then send a SIGABRT signal to current process */
  sleep(3);
  abort();
}

int main(int argc, char *argv[]) {
  foo();
  return EXIT_SUCCESS;
}
```

<br/>

#### unsigned int alarm(unsigned int seconds)
##### <signal.h>

设定一个定时器，在 **`seconds`** 秒后由内核发送一个 **`SIGALRM (14)`** 信号给当前进程

**每一个进程有且仅能拥有一个定时器，后面所声明的定时器则覆盖掉前一个所声明的定时器**{style="color:red"}

该函数所指定的定时器使用的是自然定时法，即与进程状态无关，无论是 就绪, 运行, 挂起(阻塞 / 暂停), 终止, 僵尸, ... 都不影响 alarm 的计数

该函数不存在调用失败的返回结果，其返回值依据 **`seconds`** 来决定是返回 **`0`** 还是返回 **`剩余的秒数`**

- **`seconds`** : 指定定时器的计时秒数

  - **`seconds > 0`** : 指定定时器开启，并函数调用返回 **`0`**
  - **`seconds = 0`** : 指定定时器关闭，并函数调用返回 **`剩余的秒数`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>
#include <unistd.h>

void foo_SIGALRM_handler(int _sig) {
  printf("Time out\n");
  exit(EXIT_SUCCESS);
}
void foo(void) {
  /* Registered the SIGALRM signal handler */
  signal(SIGALRM, foo_02_SIGALRM_handler);

  /* Count down two seconds, then send a SIGALRM signal to the current process */
  alarm(2);

  sleep(1024);
}

int main(int argc, char *argv[]) {
  foo();
  return EXIT_SUCCESS;
}
```

<br/>

#### int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value)
##### <signal.h>

开启一个定时器，如果成功则返回 **`0`**，失败则返回 **`-1`**

**每一个进程有且仅能拥有一个定时器，后面所声明的定时器则覆盖掉前一个所声明的定时器**{style="color:red"}

- **`which`** : 指定定时器的计数方式同时也决定了 timeout 后由内核所发送给当前进程的信号类型
  
  - **`ITIMER_REAL`** : 使用自然计数法，timeout 后内核发送一个 **`SIGALRM (14)`** 给当前进程
  - **`ITIMER_VIRTUAL`** : 虚拟空间计时法，仅计算用户空间的运行时间，timeout 后内核发送一个 **`SIGVTALRM (26)`** 给当前进程
  - **`ITIMER_PROF`** : 运行时计时法，计算用户空间的运行时间加上内核空间的运行时间，timeout 后内核发送一个 **`SIGPROF (27)`** 给当前进程

- **`new_value`** : 指定定时器的 timeout 时间，其由一个嵌套结构体所构成
  ```c
  /* itimerval */
  struct itimerval { 
    struct timerval it_interval;  /* Interval time for each timer trigger */
    struct timerval it_value;     /* Delay time when the timer is first executed */
  }; 

  /* timeval */
  struct timeval { 
    long tv_sec; 		 /* second */
    long tv_usec; 	 /* microsecond */
  }      
  ```
  - **`itimerval`** 中的每一种时间类型都属于 **`timeval`** 结构体类型；在 **`timeval`** 结构体类型中，我们可以设定当前时间类型所延迟的 秒 / 微妙，注意，仅保证一种成员是有效的，无效的成员设定为 **`0`**
  
  - **`it_value`** : 指定定时器在第一次触发时所延迟的时间
  
    - 如果当前成员都设定为 **`0`**，则意为取消定时器，无论 **`it_interval`** 设置为何值
  
  - **`it_interval`** : 指定定时器每次轮询所间隔的时间
    - 如果当前成员都设定为 **`0`**，则意为定时器仅依据 **`it_value`** 的延迟时间仅运行一次 ( 假定 **`it_value`** 并未设置为 **`0`**)
  
- **`old_value`** : 存放旧的 timeout 时间，如无特殊要求设置为 **`NULL`** 即可

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>
#include <unistd.h>
#include <sys/time.h>
#include <pthread.h>

int idx = 0;
void IGALRM_handler(int _sig) {
  printf("KEN_MODE [%lu] %d\n", pthread_self(), ++idx);
}
void foo(void) {
  signal(SIGALRM, SIGALRM_handler);

  struct itimerval time_value;
  time_value.it_value.tv_sec = 0;
  time_value.it_value.tv_usec = 1 * 1000;
  time_value.it_interval.tv_sec = 1;
  time_value.it_interval.tv_usec = 0;
  setitimer(ITIMER_REAL, &time_value, NULL);

  while (true) {
    printf("USR_MODE [%lu] %d\n", pthread_self(), ++idx);
    sleep(1);
  }
}


int main(int argc, char *argv[]) {
  foo();
  return EXIT_SUCCESS;
}

```

<br/>

#### 未决信号集和阻塞信号集
<span id="未决信号集和阻塞信号集"></span>

任何一个信号 ( 除了 **`SIGKILL`** 和 **`SIGSTOP`**，它们无法被捕获、忽略和阻塞 ) 在真正到达一个进程前都会经历一次 **`未决 (pending)`** 的过程，在内核态的 PCB 模块中，拥有一个成员用于维护和表示发生在当前进程中每种信号的未决状态，它称之为 **`未决信号集`**，未决信号集是一个线性集合，其中，集合的每个下标都能够映射至对应 ID 的信号，当一个信号在即将抵达至当前进程前，都会把当前信号维护至未决信号集对应信号 ID 的下标处以表示当前信号的未决状态，**当未决信号集指定下标的空间已经维护了某个信号，那么后来发送至当前进程的这个信号则会被丢弃**{style="color:red"}

当某个信号已处于未决信号集后，两个条件会决定这个信号是否能够真正意义上的抵达至当前进程

1. 当前信号是否正在执行 **`Action`**，如果是的话，那么这个信号则保持不变，任然维持着 **`未决`** 的状态；如果没有，则会进入第二个条件
   
2. 当前信号是否被阻塞，如果是的话，那么这个信号则保持不变，任然维持着 **`未决`** 的状态，亦或者我们也可以认为这个信号处于一种等待着阻塞结束的状态；如果没有，则这个信号便会成功抵达当前进程并执行其所对应的 **`Action`**

对于 **`阻塞 ( mask )`** 的信号来说，PCB 模块同样是使用一个结构性和 **`未决信号集`** 保持一致的集合用于维护和表示，我们称这个用于表示信号阻塞信息的集合为 **`阻塞信号集`**；阻塞信号集的数据结构和未决信号集是保持一致性的，即数组中的每个下标都用于存放不同信号的阻塞信息，每个处于未决信号集的信号在执行前都会检查阻塞信号集中对应下标的元素是否已被占用，如果是的话则认为这个信号正在置于一个阻塞的状态，并等待着阻塞的结束 ( 阻塞信号集对应信号 ID 下标的数据重置 ) 以抵达当前进程并执行其所对应的 **`Action`**，它的产生可能是一些其它因素但更多的情况，则交由开发人员通过对应的系统调用来人为的设置

在这里需要强调的是，不管是阻塞信号集也好还是未决信号集，上面所说到的都是 "把当前信号维护至集合的对应下标的存储空间中"，但是这并不是真正意义上的把一个信号存储在这个集合中，真实情况则为把对应集合中对应信号 ID 的下标所存储的数据置为 **`1`** 则能够表示某个信号已经被维护在了某个集合当中，反之置为 **`0`** 则表示某个信号并没有在具体某个集合下面，即还未产生对应集合所表示的状态

对于信号集而言虽然其存储结构简单，但并不意味着我们可以手动的依据下标来修改信号集中具体某个下标 ( 信号 ID ) 的状态，对于一切信号集的操作标准库中提供了一些 API 以供我们执行，而我们对于信号集的修改也要围绕着这些 API 去进行才能够符合标准的规范

```text
    pending              mask
  +--------+          +--------+
 0|        |         0|        |
 1|SIGINT 1| +-----> 1|SIGINT 1|
 2|        |         2|        |
 3|        |         3|        |
 4|        |         4|        |
 5|        |         5|        |
 6|        |         6|        |
..|        |        ..|        |
  |        |          |        |
  |        |          |        |
  |        |          |        |
  +--------+          +--------+
```

<br/>

#### 信号集的使用
<span id="信号集的使用"></span>

#### sigset_t
##### <signal.h>

不管是阻塞信号集也好还是未决信号集，二者之间的存储结构都是一致的，都是一块线性的数组空间，它由以下结构体来进行表示 ()  ，我们对于任何信号集的任何操作都需要以这个结构体的实例为基准去进行

```c
typedef struct
{
  unsigned long int __val[_SIGSET_NWORDS];
} sigset_t;
```

<br/>

#### int sigfillset(sigset_t *set)
##### <signal.h>

将信号集 **`set`** 中的所有数据置为 **`1`**，成功则返回 **`0`**，否则返回 **`-1`**


```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>

int main(void) {
  sigset_t mask;
  sigfillset(&mask);

  return EXIT_SUCCESS;
}
```

<br/>

#### int sigemptyset(sigset_t *set)
##### <signal.h>

将信号集 **`set`** 中的所有数据置为 **`0`**，成功则返回 **`0`**，否则返回 **`-1`**


```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>

int main(void) {
  sigset_t mask;
  sigemptyset(&mask);

  return EXIT_SUCCESS;
}
```


<br/>

#### int sigaddset(sigset_t *set, int sig)
##### <signal.h>

将信号集 **`set`** 中的信号 ID **`sig`** 所对应的下标的数据置为 **`1`**，成功则返回 **`0`**，否则返回 **`-1`**


```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>

int main(void) {
  sigset_t mask;
  sigaddset(&mask, SIGINT);

  return EXIT_SUCCESS;
}
```

<br/>

#### int sigdelset(sigset_t *set, int sig)
##### <signal.h>

将信号集 **`set`** 中的信号 ID **`sig`** 所对应的下标的数据置为 **`0`**，成功则返回 **`0`**，否则返回 **`-1`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>

int main(void) {
  sigset_t mask;
  sigdelset(&mask, SIGINT);

  return EXIT_SUCCESS;
}
```

<br/>

#### int sigismember(const sigset_t *set, int signum)
##### <signal.h>

判断指定信号 ID **`signum`** 在当前信号集 **`set`** 所对应的下标的数据是否置为 **`1`**，如果是则返回 **`1`**，不是则返回 **`0`**，函数调用失败时则返回 **`-1`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>

int main(void) {
  sigset_t mask;
  sigemptyset(&mask);

  sigaddset(&mask, SIGINT);

  printf("%d\n",sigismember(&mask,SIGINT));

  return EXIT_SUCCESS;
}
```

<br/>

#### int sigpending(sigset_t *set)
##### <signal.h>

获取当前进程的未决信号集，并将之拷贝到所指定的 **`set`** 当中，成功则返回 **`0`**，否则返回 **`-1`**

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>

int main(void) {
  sigset_t pending;
  sigpending(&pending);

  return EXIT_SUCCESS;
}
```

<br/>

<span id  = "sigprocmask"></span>

#### int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
##### <signal.h>

根据所指定的信号集 **`set`** 和所指定的修改方式 **`how`** 去修改当前进程中的阻塞信号集，成功则返回 **`0`**，否则返回 

- **`how`** : 所指定的修改方式，以宏定义来指定
  
  - **`SIG_BLOCK`** : 当前信号集 **`set`** 中值位 **`1`** 的下标则作为屏蔽项
  - **`SIG_UNBLOCK`** : 当前信号集 **`set`** 中值位 **`1`** 的下标则作为解除屏蔽项
  
- **`set`** : 内核中的阻塞信号集的修改依据则以这个参数为基准

- **`oldset`** : 旧值，可忽略

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <signal.h>

int main(void) {
  sigset_t mask;
  sigemptyset(&mask);

  sigaddset(&mask, SIGINT);

  sigprocmask(SIG_BLOCK, &mask, NULL);

  return EXIT_SUCCESS;
}
```

!!! warning
    该函数并未遵循 **`POSIX`** 的规范完成进程的屏蔽信号集的设置，故在使用遵循 **`POSIX`** 规范的 **`NPTL`** 库所完成多线程模型的情境之下，更推荐的方式则为使用 [pthread_sigmask](#pthread_sigmask) 来完成


<br/>

<span id = "pthread_sigmask"></span>

#### int pthread_sigmask()
##### <sys/syscall.h> <sys/types.h>

设定当前线程的阻塞信号集

每个线程的阻塞信号集虽然会从其父级进程中继承下来，但是这份继承也仅仅只是拷贝，并不属于共享，故任意一个子集线程都可以以这份从父级线程中所拷贝的阻塞信号集向下继续做独立的延伸工作

虽然该函数其功能和形参的实现都和 [sigprocmask](#sigprocmask) 保持一致 ( 故这里不再对该函数的形参做阐述 )，唯一的区别仅是当前函数的内部实现严格遵循着 **`POSIX`** 所指定的规范，故在使用 **`NPTL`** 库所完成的多线程开发模型中，更为推荐使用该函数来完成线程的阻塞信号集的设置

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/types.h>

void *thread_start(void *_arg) {
  sigset_t mask;
  sigemptyset(&mask);
  sigaddset(&mask, SIGINT);
  pthread_sigmask(SIG_BLOCK, &mask, NULL);

  printf("[%lu] child-thread executed\n", pthread_self());

  while (true) {
    sleep(1);
  }

  return NULL;
}

void sig_handler(int _sig) {
  printf("executed, tid = %lu\n", pthread_self());
  fflush(stdout);

  exit(EXIT_SUCCESS);
}

int main(int argc, char *argv[]) {
  pthread_t t_id;
  int s = pthread_create(&t_id, NULL, thread_start, NULL);
  if (s != 0) {
    char *msg = strerror(s);
    printf("%s\n", msg);
  }

  struct sigaction act;
  sigemptyset(&act.sa_mask);
  act.sa_handler = sig_handler;
  act.sa_flags = 0;
  sigaction(SIGINT, &act, NULL);

  printf("[%lu] main-thread executed, create [%lu]\n", pthread_self(), t_id);

  while (true) {
    sleep(1);
  }

  return EXIT_SUCCESS;
}
```

<br/>

<span id = "sigwaitinfo"></span>

#### int sigwaitinfo(const sigset_t *set, siginfo_t *info)
##### <signal.h>

阻塞当前线程的执行并等待信号集 **`set`** 中所设定的信号的到达，如果当前线程某一个符合要求 ( 设置在信号集 **`set`** 中且已被指定到内核的屏蔽信号集 **`mask`** 中 ) 的信号，则函数调用立即返回 **`指定信号的 ID`**，且将所抵达信号的详细信息写入至 **`info`** 所指向的内存块中，如调用失败，则函数立即返回 **`-1`**

需要注意的是，我们要保证 **`set`** 信号集中所指定的信号已用于当前线程的阻塞信号集 ( **`mask`** ) 的指定

当前函数还存在另一派生，即 [sigwait()](https://linux.die.net/man/3/sigwait)，其用法和当前函数大致相同，这里不再阐述

- **`set`** : 指定需要等待信号的信号集，通常它需要选用于阻塞信号集的设置 [pthread_sigmask()](#pthread_sigmask) 

- **`info`** : 用于存储所接受到的信号的详细信息，其成员在这里不再阐述，详情请看 [这里](https://linux.die.net/man/2/sigwaitinfo)

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/syscall.h>

void *wait_sig_handler(void *_arg) {
  printf("[%lu](%lu) child-thread-signal executing\n", pthread_self(), syscall(SYS_gettid));

  sigset_t mask;
  sigemptyset(&mask);
  sigaddset(&mask, SIGUSR2);
  pthread_sigmask(SIG_BLOCK, &mask, NULL);

  siginfo_t sig_info;
  memset(&sig_info, 0, sizeof(siginfo_t));

  /* Block the execution of the current thread and wait for the arrival of the specified signal */
  int signum = sigwaitinfo(&mask, &sig_info);
  printf("[%lu] {%d} deliverd\n", pthread_self(), signum);

  /* When this thread received SIGUSR2 siganl, exied immediately */
  return NULL;
}

void *thread_start(void *arg) {
  /* Create a new thread for signal processing */
  pthread_t wait_sig_tid;
  pthread_create(&wait_sig_tid, NULL, foo_08_wait_sig_handler, NULL);

  printf("[%lu](%lu) child-thread executing, create (%lu)\n", pthread_self(), syscall(SYS_gettid), wait_sig_tid);
  
  /** 
   * Waiting for the exit of the signal sub-thread, 
   * BTW, this does not necessarily need to block waiting, 
   * it can process anything asynchronously
  */
  pthread_join(wait_sig_tid, NULL);

  printf("[%lu](%lu) child-thread exited\n", pthread_self(), syscall(SYS_gettid));
  return NULL;
}

void foo(void) {
  pthread_t t_id;
  pthread_create(&t_id, NULL, foo_08_thread_start, NULL);

  printf("[%lu](%lu) main-thread executing, create (%lu)\n", pthread_self(), syscall(SYS_gettid), t_id);
  
  /* Wait for child-thread exited */
  pthread_join(t_id, NULL);
  printf("[%lu](%lu) man-thread exited\n", pthread_self(), syscall(SYS_gettid));

  exit(EXIT_SUCCESS);
}

int main(int argc, char *argv[]) {
  foo();
  return EXIT_SUCCESS;
}
```

<br/>

## Socket 编程
<span id="Socket-编程"></span>

### 关于 Socket 的一些基本概念
<span id="关于-Socket-的一些基本概念"></span>

---

TCP/IP 协议最早在 **_BSD UNIX_** 上实现，为 TCP/IP 协议设计的应用层编程接口称为 **_socket API(简称为 socket)_**

**_Socket_** 本身有 **_'插座'_** 的意思，在 linux 环境下，用于<font color = "red">表示进程间网络通信的特殊文件类型，其本质为内核借助 **_缓冲区_** 形成的 **_伪文件_**</font>

既然是文件，那么理所当然的，我们通过使用 **_文件描述符_** 来引用 socket，<font color = "red">linux 内核将 socket 封装成文件的目的是为了统一接口，使得读写 socket 和 **_读写文件(read(), write())的操作一致_**</font>

在 TCP/IP 协议中，<font color = "red">**_'IP 地址 + TCP/UDP 端口号'_** 唯一标识网络通讯中的一个进程</font>，也就是说，<font color = "red">**_'IP 地址 + 端口号'_** 就对应一个 socket</font>，事实上，<font color = "red">两个主机间欲通过 socket 建立起连接，**_通信双方必定都会各持有一份 'socket'_**，这样的连接关系我们称之为 $Socket \:\: pair$，通过这一对 $Socket \:\: pair$，确立了通信双方网络连接上的一对一的关系</font>

<font color = "red">每当一端的 socket 建立，内核都会为其在内核态中初始化两块缓冲区(读缓冲和写缓冲)</font>，这和 **_管道_** 类似，但是需要注意的是 : 

- 管道主要应用于本地进程间通信，而套接字应用于网络进程间数据的传递 
  
- <font color = "red">socket 仅使用一个文件描述符就映射读写两端的缓冲区的操作，而管道的则为读写缓冲区两端各自映射了不同的文件描述符</font>

- 针对 socket 伪文件的默认读写行为和管道保持一致，即 : 

  - `read` : 针对于读端进行操作时，如管道没有数据，则读取操作则会发生阻塞(**_Interruptible Sleep(S)_**)

  - `write` : 针对于写端进行操作时，如管道数据已满，则写入操作则会发生阻塞(**_Interruptible Sleep(S)_**)

<br/>

![2020-11-25-13-01-36](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2020-11-25-13-01-36.png)

<br/>

### 大小端字节序转换 API

<span id="大小端字节序转换-API"></span>

---

<font color = "red">TCP/IP协议规定，网络数据流应采用 **_大端字节序_**</font>，一对建立连接的主机，发送方将写入缓冲区中的数据依内存地址从低到高的顺序发出，而接收方则将读取缓冲区中的数据依内存地址从低到高的顺序读入 ; <font color = "red">我们在使用 socket 进行通信的过程中，就要保证缓冲区中的数据是依照大端字节序进行排列的</font>

> 事实上，大端字节序的应用仅仅在网络接口层校验 **_以太网帧_** 中的一些关键信息(目的地址, 原地址, 端口等)才需要依照这个顺序(大端字节序)进行排列，而<font color = "red">对于帧中所包含的需要被发出或接受的有效数据，网络接口层对其可能仅仅只是做数据长度的一个校验，而究竟所发出或接受的数据到底是大端字节序还是小端字节序，这个并无强制的要求</font>

<br/>

#### 校验本机字节序的类别

<span id="校验本机字节序的类别"></span>

```c
#include <math.h>                       
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

union entity {
  short s;
  char c[sizeof(short)];
};

int main(int argc, char *argv[]) {
  union entity obj;
  obj.s = 0x0102;

  if (obj.c[0] == 0x02) {
    printf("least significant digit\n");
  } else {
    printf("most significant digit\n");
  }

  return EXIT_SUCCESS;
}
```


<br/>

#### 整形数据的字节序转换

<span id="整形数据的字节序转换"></span>

##### #include <arpa/inet.h>

以下函数提供了32位长整型(**_int_**)和16位短整型(**_short_**)的转换工作

如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回

- uint32_t htonl(uint32_t hostlong) : 将小端字节序 hostlong 转换为大端字节序并返回

- uint16_t htons(uint16_t hostshort) : 将小端字节序 hostshort 转换为大端字节序并返回

- uint32_t ntohl(uint32_t netlong) : 将大端字节序 netlong 转换为小端字节序并返回

- uint32_t ntohs(uint32_t netshort) : 将大端字节序 netshort 转换为小端字节序并返回

值得一提的是，关于这些函数的记忆方式 : **_h 表示 host(小端字节序), n 表示 network(大端字节序), l 表示 32 位长整数，s 表示 16 位短整数_**

```cpp
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <arpa/inet.h>

int main(int argc, char *argv[]) {
  int i_most = htonl(0x12345678);
  printf("0x%x\n", i_most);
  int i_least = ntohl(i_most);
  printf("0x%x\n", i_least);

  short s_most = htons(0x1234);
  printf("0x%x\n", s_most);
  short s_least = ntohs(s_most);
  printf("0x%x\n", s_least);

  return EXIT_SUCCESS;
}
```

<br/>

#### IP地址的转换

<span id="IP地址的转换"></span>

##### <arpa/inet.h>

- int inet_pton(int af, const char *src, void *dst) : 将字符串 `src` 转换为大端字节序的数据并写入至 `dst` 所指向的内存中

  - `af` : IP协议类型
  
    - AF_INET : IPV4

    - AF_INET6 : IPV6

  - `src` : 点分十进制的 IP 地址字符串

  - `dst` : 转换结果所需写入的缓冲区，通常提供一个 32 位长整型大小的缓冲区即可

  - `return` : 

    - 1 : 转化成功

    - 0 / -1 : 转换失败

- const char *inet_ntop(int af, const void *src, char *dst, socklen_t size) : 将大端字节序的数据 `src` 转换为点分十进制的 IP 字符串并写入至 `dst` 所指向的内存中

  - `af` : IP协议类型
  
    - AF_INET : IPV4

    - AF_INET6 : IPV6

  - `src` : 指向大端字节序数据的指针

  - `dst` : 转换结果需要写入的缓冲区，通常提供一个 `3*4 + 3 + 1` 长度的空间即可

  - `size` : 指定 `dst` 缓冲区的长度，防止缓冲区溢出的问题

  - `return` : 

    - 指向 `dst` 的指针 : 转化成功

    - `NULL` : 转换失败

```c
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <arpa/inet.h>

int main(int argc, char *argv[]) {
  struct sockaddr_in serv;
  bzero(&serv, sizeof(serv));                            
  serv.sin_family = AF_INET;
  serv.sin_port = htons(8886);
  inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);

  struct sockaddr_in client;                                                                                      
  bzero(&client, sizeof(struct sockaddr_in));
  socklen_t len = sizeof(struct sockaddr);
  int cfd = accept(sfd, (struct sockaddr *)&client, &len);
  char dest[16] = {0};
  inet_ntop(AF_INET, &client.sin_addr.s_addr, dest, sizeof(dest));
}
```

<br/>

### Socket API
<span id="Socket-API"></span>

---

#### 几个重要的结构体

##### <arpa/inet.h>

Socket API 中许多函数都离不开这几个结构体，它们通常用来表示两端连接上的一些头部信息

![2020-11-25-19-15-06](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2020-11-25-19-15-06.png)

- sockaddr

  ```c
  struct sockaddr {
	  sa_family_t sa_family; 		/* address family, AF_xxx */
	  char sa_data[14];			/* 14 bytes of protocol address */
  };
  ```

- sockaddr_in

  ```c
  struct sockaddr_in {
	  __kernel_sa_family_t sin_family; /* Address family */
	  __be16 sin_port;                 /* Port number */
	  struct in_addr sin_addr;         /* Internet address */

	  /* Pad to size of `struct sockaddr'. */
	  unsigned char sin_zero[sizeof (struct sockaddr)
                                     - __SOCKADDR_COMMON_SIZE
                                     - sizeof (in_port_t)
                                     - sizeof (struct in_addr)];
  };

  struct in_addr {  /* Internet address. */
  	__be32 s_addr;
  };
  ```

- sockaddr_in6

  ```c
  struct sockaddr_in6 {
	  unsigned short int sin6_family;     /* AF_INET6 */
	  __be16 sin6_port; 					/* Transport layer port # */
	  __be32 sin6_flowinfo; 				/* IPv6 flow information */
	  struct in6_addr sin6_addr;			/* IPv6 address */
	  __u32 sin6_scope_id; 				/* scope id (new in RFC2553) */
  };

  struct in6_addr {
  	union {
  		__u8 u6_addr8[16];
  		__be16 u6_addr16[8];
  		__be32 u6_addr32[4];
  	} in6_u;
  	#define s6_addr 		in6_u.u6_addr8
  	#define s6_addr16 		in6_u.u6_addr16
  	#define s6_addr32	 	in6_u.u6_addr32
  };
  ```

- sockaddr_un

  ```c
  #define UNIX_PATH_MAX 108
	struct sockaddr_un {
	  __kernel_sa_family_t sun_family; 	/* AF_UNIX */
	  char sun_path[UNIX_PATH_MAX]; 	/* pathname */
  };
  ```

`strcut sockaddr` 很多网络编程函数诞生早于 `IPv4` 协议，那时候都使用的是 `sockaddr` 结构体,为了向前兼容，现在 `sockaddr` 退化成了(void *)的作用，简而言之就是，后面的结构体都是依据 `sockaddr` 来进行扩充的

`IPv4` 和 `IPv6` 的地址格式定义在 `netinet/in.h` 中，`IPv4` 地址用 `sockaddr_in` 结构体表示，包括 16 位端口号和 32 位 IP 地址 ; `IPv6` 地址用 `sockaddr_in6` 结构体表示，包括 16 位端口号和 `128` 位 `IP` 地址和一些控制字段 ; `UNIX Domain Socket` 的地址格式定义在 `sys/un.h` 中，用 `sockaddr_un` 结构体表示

各种socket地址结构体的开头都是相同的，前16位表示整个结构体的长度(并不是所有UNIX的实现都有长度字段，如Linux就没有)，后16位表示地址类型

通常，Socket API 中都会提供一个参数来确定当前所连接的协议类型，通过该参数，只要取得某种 `sockaddr` 结构体的首地址，不需要知道具体是哪种类型的 `sockaddr` 结构体，就可以根据地址类型字段确定结构体中的内容，因此，Socket API 可以接受各种类型的 `sockaddr` 结构体指针做参数，但是，Socket API 的实现早于 ANSI C 标准化，那时还没有 `void *` 类型，因此 API 中的地址参数都用 `struct sockaddr *` 类型表示，在传递参数之前要强制类型转换一下

<br/>

#### int socket(int domain, int type, int protocol)

##### <arpa/inet.h>

打开一个 socket 网路通信端口，并返回其所对应的 **_文件描述符_** ; 在该函数调用完毕后，内核会在当前内核态中分别创建 **_读、写缓冲区_**，并将刚刚返回的文件描述符映射到这两个缓冲区身上

对于需要作为被动态(listen)的 socket，需要注意的是，该函数调用完毕后所返回的文件描述符虽然能够映射到内核态中的读、写缓冲区，但是我们<font color = "red">在往 client 写入或读取数据时并不使用该文件描述符，**_该文件描述符针对声明为被动态 socket 的作用主要是用来监听客户端的连接和绑定工作_**</font>

- `domain` : 指定 IP 协议类型

  - `AF_INET` : IPv4

  - `AF_INET6` : IPv6

  - `AF_UNIX` : UNIX Domain Socket

- `type` : 指定 socket 协议类型

  - `SOCK_STREAM` : TCP 连接，面向顺序的、可靠的、数据完整的基于字节流的连接

  - `SOCK_DGRAM` : UDP 连接，面向不可靠的、无连接的、固定长度的传输调用

  - `SOCK_SEQPACKET` : 该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输，必须把这个包完整的接受才能进行读取。

  - `SOCK_RAW` : 使用 ICMP 公共协议

  - `SOCK_RDM` : 较少使用，该协议主要提供给数据链路层接口访问

- `protocol` : 0，即默认协议

- `return` : socket 文件描述符

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <netinet/in.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  int sfd = socket(AF_INET, SOCK_STREAM, 0x0);
  if (sfd < 0) {
    perror("create socket pair error");
    exit(EXIT_FAILURE);
  }

  close(sfd);
  return EXIT_SUCCESS;
}
```

<br/>

#### int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)

##### <arpa/inet.h>

绑定 `socket()` 函数所返回的 socket 文件描述符中的一些通信连接所监听的头部信息

- `sockfd` : `socket()` 函数所返回的 socket 文件描述符

- `addr` : 绑定所指定 socket 文件描述符 `sockfd` 中的一些监听的连接通信头部信息，如 : IP 地址，端口号等

- `addrlen` : 指定 `addr` 的长度，防止缓冲区溢出的问题

- `return` : 

  - 0 : 绑定成功

  - -1 : 绑定失败

```c
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  int sfd = socket(AF_INET, SOCK_STREAM, 0x0);
  if (sfd < 0) {
    perror("create socket pair error");
    exit(EXIT_FAILURE);
  }

  struct sockaddr_in serv;
  bzero(&serv, sizeof(serv));
  serv.sin_family = AF_INET;
  serv.sin_port = htons(8886);
  /* servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  INADDR_ANY: 任意地址IP，针对于主机存在多网卡的情况 */
  inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
  int bflg = bind(sfd, (const struct sockaddr *)&serv, sizeof(serv));
  if (bflg < 0) {
    perror("socket bind error");
    exit(EXIT_FAILURE);
  }

  close(sfd);
  return EXIT_SUCCESS;
}
```

<br/>

#### int listen(int sockfd, int backlog)

##### <arpa/inet.h>

使 **_sockfd_** 所对应的 socket 由 **_主动态_** 转换为 **_被动态_**，与此同时，内核还会创建两个队列，其分别为 **_请求连接队列_** 和 **_已连接队列_**，当该函数调用完毕后，当前主机允许被发现且连接，任何连接到该主机的 client 将被列入 **_已连接队列_** 并等待被取出

绑定 `socket()` 函数所返回的 socket 文件描述符中的一些通信连接所监听的头部信息

- `sockfd` : `socket()` 函数所返回的 socket 文件描述符

- `backlog` : 同时请求连接的最大个数(还未真正建立连接，仅请求)

- `return` : 

  - 0 : 监听成功

  - -1 : 监听失败

```c
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  int sfd = socket(AF_INET, SOCK_STREAM, 0x0);
  if (sfd < 0) {
    perror("create socket pair error");
    exit(EXIT_FAILURE);
  }

  struct sockaddr_in serv;
  bzero(&serv, sizeof(serv));
  serv.sin_family = AF_INET;
  serv.sin_port = htons(8886);
  inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
  int bflg = bind(sfd, (const struct sockaddr *)&serv, sizeof(serv));
  if (bflg < 0) {
    perror("socket bind error");
    exit(EXIT_FAILURE);
  }

  listen(sfd, 0x400);

  return EXIT_SUCCESS;
}
```

<br/>

#### int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)

##### <arpa/inet.h>

从 **_已连接队列_** 中获取一个新的连接，并为之<font color = "red">创建一个新的 socket 文件描述符并返回，该 socket 文件描述符是真正意义上用来和 client 进行读写通信的文件描述符</font>

如果已连接队列中没有任何连接，则阻塞当前函数的调用，需要注意的是，该阻塞所引起的进程状态为 **_Interruptible Sleep(S)_** 形式的阻塞，也就意味着，<font color = "red">一个信号的到达将中断该阻塞状态，此时该函数会返回 -1</font>

- `sockfd` : `socket()` 函数所返回的 socket 文件描述符

- `addr` : 当成功获取新的连接，则将连接的头部信息写入到该参数所指向的内存中

- `addrlen` : 指定 `addr` 的长度，防止缓冲区溢出的问题

- `return` : 

  - 大于0的任意数 : 获取新连接成功

  - -1 : 获取失败

```c
#include <arpa/inet.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  int sfd = socket(AF_INET, SOCK_STREAM, 0x0);
  if (sfd < 0) {
    perror("create socket pair error");
    exit(EXIT_FAILURE);
  }

  struct sockaddr_in serv;
  bzero(&serv, sizeof(serv));
  serv.sin_family = AF_INET;
  serv.sin_port = htons(8886);
  inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
  int bflg = bind(sfd, (const struct sockaddr *)&serv, sizeof(serv));
  if (bflg < 0) {
    perror("socket bind error");
    exit(EXIT_FAILURE);
  }

  listen(sfd, 0x400);

  struct sockaddr_in client;
  bzero(&client, sizeof(struct sockaddr_in));
  socklen_t len = sizeof(struct sockaddr);
  int cfd = accept(sfd, (struct sockaddr *)&client, &len);
  if (cfd < 0) {
    perror("accept connect error");
    exit(EXIT_FAILURE);
  }
  char dest[16] = {0}; /* 4*3 + 3 + 1 */
  printf("accept client [%s:%d]\n",
         inet_ntop(AF_INET, &client.sin_addr.s_addr, dest, sizeof(dest)),
         ntohs(client.sin_port));
  
  close(sfd);
  return EXIT_SUCCESS;
}
```

<br/>

#### int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)

依据 **_addr_** 中所指定的连接参数于一个主机建立起连接并为之<font color = "red">创建一个新的 socket 文件描述符并返回</font>，当一个成功建立连接后，双方才可以开始正式的通信，这通常是作为 `client` 的行为

- `sockfd` : `socket()` 函数所返回的 socket 文件描述符

- `addr` : 用于写入所需要连接主机的一些头部信息

- `addrlen` : 指定 `addr` 的长度，防止缓冲区溢出的问题

- `return` : 

  - 0 : 成功建立连接

  - -1 : 获取失败

```c
#include <arpa/inet.h>
#include <ctype.h>
#include <math.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  int cfd = socket(AF_INET, SOCK_STREAM, 0x0);
  if (cfd < 0) {
    perror("create socket pair error");
    exit(EXIT_FAILURE);
  }

  struct sockaddr_in serv;
  serv.sin_family = AF_INET;
  serv.sin_port = htons(8886);
  inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
  int cflg = connect(cfd, (struct sockaddr *)&serv, sizeof(serv));
  if (cflg < 0) {
    perror("connect to server error");
    exit(EXIT_FAILURE);
  }
  printf("success connect to server [%s:%d]\n", "127.0.0.1",
         ntohs(serv.sin_port));
  fflush(stdout);

  close(cfd);
  return EXIT_SUCCESS;
}
```

<br/>

#### 基本的读写行为


linux 内核将 socket 封装成文件的目的是为了统一接口，使得读写 socket 和 **_读写文件(read(), write())的操作一致_**，也就是说，我们针对成功建立连接的一端，只需要对需要通信的目标所映射的文件描述符进行常规文件的读写操作即可，下面的代码仅展示作为 client 端在成功与 server 端建立通信后其基本的读写行为

关于基本的读写操作，还可以使用 **_recv()_**(`man recv`) 和 **_send()_**(`man send`)

```c
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <arpa/inet.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  int cfd = socket(AF_INET, SOCK_STREAM, 0x0);
  if (cfd < 0) {
    perror("create socket pair error");
    exit(EXIT_FAILURE);
  }

  struct sockaddr_in serv;
  serv.sin_family = AF_INET;
  serv.sin_port = htons(8886);
  inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
  int cflg = connect(cfd, (struct sockaddr *)&serv, sizeof(serv));
  if (cflg < 0) {
    perror("connect to server error");
    exit(EXIT_FAILURE);
  }
  printf("success connect to server [%s:%d]\n", "127.0.0.1",
         ntohs(serv.sin_port));
  fflush(stdout);

  char buf[256] = {0};
  while (true) {
    bzero(buf, sizeof(buf));
    int n = read(STDIN_FILENO, buf, sizeof(buf));

    write(cfd, buf, n);

    bzero(buf, sizeof(buf));
    if (read(cfd, buf, sizeof(buf)) <= 0) {
      printf("read error or server closed");
      break;
    }
    printf("receive %s\n", buf);
  }

  close(cfd);
  return EXIT_SUCCESS;
}
```

<br/>

#### int shutdown(int sockfd, int how)

<font color = "red">关闭当前通信端的读或写缓冲区</font>，可以实现 **_半关闭_**(即只保持读或写的操作与远程端进行通信) 状态的 socket 连接

该函数可同时关闭读缓冲器和写缓冲区，当指定了该操作后，也就意味着当前端主动发起了连接关闭请求(**_FIN_**)(呈现 `FIN_WAIT_2` 的状态)，针对这点功能而言，似乎和 `close()` 保持一致，但是<font color = "red">需要注意的是，`close()` 始终都是针对文件描述符进行操作的，也就是说仅当该文件描述符的引用计数为 0 时，当前端才能够发起连接关闭的请求，而该函数可以无视这一约束</font>

- `sockfd` : `socket()` 函数所返回的 socket 文件描述符

- `how` : 
  
  - `SHUT_RD` : 关闭读缓冲区

  - `SHUT_WR` : 关闭写缓冲区

  - `SHUT_RDWR` : 关闭读写缓冲区，意味着当前端主动发起了连接关闭的操作

- `return` : 

  - 0 : 调用成功

  - -1 : 调用失败

```c
#include <arpa/inet.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  int cfd = socket(AF_INET, SOCK_STREAM, 0x0);

  struct sockaddr_in serv;
  serv.sin_family = AF_INET;
  serv.sin_port = htons(8886);
  inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
  int cflg = connect(cfd, (struct sockaddr *)&serv, sizeof(serv));
  printf("success connect to server [%s:%d]\n", "127.0.0.1",
         ntohs(serv.sin_port));

  char buf[256] = {0};
  while (true) {
    bzero(buf, sizeof(buf));
    int n = read(STDIN_FILENO, buf, sizeof(buf));
    
    write(cfd, buf, n);

    bzero(buf, sizeof(buf));
    if (read(cfd, buf, sizeof(buf)) <= 0) {
      printf("read error or server closed");
      break;
    }
    printf("%s", buf);
  }
  
  /* close(cfd); */
  shutdown(cfd, SHUT_RDWR); 
  return EXIT_SUCCESS;
}
```

<br/>

### IO 多路复用
<span id="IO-多路复用"></span>

---

#### linux 中的 IO 模型

<span id="linux中的IO模型"></span>

- **阻塞 IO**

这是最常用的简单的IO模型，阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情，阻塞IO操作只能对单个文件描述符进行操作，如默认属性的 [read()](#https://man7.org/linux/man-pages/man2/read.2.html) 或 [write()](#https://man7.org/linux/man-pages/man2/write.2.html)

![2020-11-30-12-07-15](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2020-11-30-12-07-15.png)


- **非阻塞式 IO**

我们在发起IO时，通过对文件描述符设置 `O_NONBLOCK` 属性来指定该文件描述符的 IO 操作为非阻塞，非阻塞 IO 通常发生在一个 for 循环当中，因为每次进行 IO 操作时要么 IO 操作成功，要么当 IO 操作会阻塞时返回错误`EWOULDBLOCK / EAGAIN`，然后再根据需要进行下一次的 for 循环操作，这种类似轮询的方式会浪费很多不必要的CPU资源，是一种糟糕的设计，和阻塞IO一样，非阻塞IO也是通过调用[read()](#https://man7.org/linux/man-pages/man2/read.2.html) 或 [write()](#https://man7.org/linux/man-pages/man2/write.2.html)来进行操作的，也只能对单个描述符进行操作
![2020-11-30-12-07-57](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2020-11-30-12-07-57.png)


- **信号驱动 IO**

信号驱动 IO 是利用 [信号](#https://man7.org/linux/man-pages/man7/signal.7.html) 机制，让内核告知应用程序文件描述符的相关事件

信号驱动 IO 在网络编程的时候通常很少用到，因为在网络环境中，和 socket 相关的读写事件太多了，比如下面的事件都会导致 `SIGIO` 信号的产生 : 

1. TCP连接建立
2. 一方断开TCP连接请求
3. 断开TCP连接请求完成
4. TCP连接半关闭
5. 数据到达TCP socket
6. 数据已经发送出去(写 buffer 有空余空间)

上面所有的这些都会产生 `SIGIO` 信号，但我们没办法在 `SIGIO` 对应的信号处理函数中区分上述不同的事件， `SIGIO` 只应该在 IO 事件单一情况下使用，比如说用来监听端口的 socket，因为只有客户端发起新连接的时候才会产生 `SIGIO` 信号

![2020-11-30-12-06-09](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2020-11-30-12-06-09.png)

- **异步 IO**

异步 IO 和信号驱动 IO 差不多，但它比信号驱动 IO 可以多做一步 : 相比信号驱动 IO 需要在程序中完成数据从用户态到内核态(或反方向)的拷贝，异步 IO 可以把拷贝这一步也帮我们完成之后才通知应用程序，参见 : 

1. [aio_read](#http://man7.org/linux/man-pages/man3/aio_read.3.html)
2. [aio_write](#http://man7.org/linux/man-pages/man3/aio_write.3.html) 
3. [linux 异步IO 那点事儿](#https://www.cnblogs.com/feisky/archive/2012/03/02/2377530.html)

![2020-11-30-12-08-21](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2020-11-30-12-08-21.png)

<br/>

#### 什么是 IO 多路复用

<span id="什么是IO多路复用"></span>

应用程序通常需要处理来自多条事件流中的事件，比如现在用的电脑，需要同时处理键盘鼠标的输入、中断信号等等事件，再比如web服务器如nginx，需要同时处理来来自N个客户端的事件

> 逻辑控制流在时间上的重叠叫做 <font color = "red">**并发**</font>

CPU 的单核在某一时刻下仅能做一件事情，应对存在多条事件流的情景，一种解决方法就是对 CPU 进行 **_时分复用_**，也就是多个事件流将 CPU 切分为多个时间片，不同事件流的时间片交替执行，这就是所谓的 多线程/进程 的做法

事实上，这种做法是存在成本的，其一就是 线程和进程 的创建是需要时间开销的，其次，在多个时间片轮流执行的情况下，会引发多次 $context \:\: switch$，那么，这种做法其实就大相径庭了

而IO多路复用，<font color = "red">其本质就是使用一个 进程/线程 来处理多种事件流的方案(**_是一种同步 IO 模型_**)，即一个 进程/线程 可以监听多个文件描述符，一旦某个文件描述符就绪(事件的发生)，能够通知程序进行相应的操作</font>，它所解决的本质问题就是用更少的资源去做更多的事情

![2020-11-30-12-07-38](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2020-11-30-12-07-38.png)

<br/>


#### select

<span id="selectapi"></span>

**_int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)_**

**_<select.h>_**

该函数指定文件描述符位图(集合)以让内核去监听多个文件描述符所指向文件的可读(`readfds`)、可写(`writefds`)、异常(`exceptfds`)事件的发生，其判断标准依赖于文件描述符其所指向的缓冲区的变化情况来决定，一旦某个 IO 模型事件的发生(缓冲区产生变化)，则该函数立即返回，并设置在当前时间下，存在变化的(缓冲区)文件描述符回填至输出参数(`readfds`, `writefds`, `exceptfds`)中

- `nfds` : 需要监控的文件描述符位图(`readfds`, `writefds`, `exceptfds`)的范围，<font color = "red">它的值我们通常指定为当前所指定的文件描述符位图中，最大文件描述符值 +1</font>

- `readfds` : 

  - 输入 : 需要监听读行为的文件描述符所构造的位图，如不需要监听这一行为，则设置为 `NULL`

  - 输出 : 当前时间下存在读行为的文件描述符重新构造出一个新的文件描述符位图并输出

- `writefds` : 

  - 输入 : 需要监听写行为的文件描述符所构造的位图，如不需要监听这一行为，则设置为 `NULL`

  - 输出 : 当前时间下写缓冲区未满可写的文件描述符重新构造出一个新的文件描述符位图并输出

- `exceptfds` : 

  - 输入 : 需要监听异常行为的文件描述符所构造的位图，如不需要监听这一行为，则设置为 `NULL`

  - 输出 : 当前时间下存在异常行为的文件描述符重新构造出一个新的文件描述符位图并输出

- `timeout` : 

  - `NULL` : 永久阻塞函数的调用，直到一个事件的发生

  - `0` : 不阻塞，无论此刻是否发生新的事件，函数都立即返回

  - `> 0` : 指定阻塞的时间 ; 若没有超过该事件则函数调用阻塞 ; 若在时间之内存在事件的发生，函数调用立即返回 ; 若阻塞时间大于该参数所指定的值，函数调用立即返回

**_fd_set_**

`fd_set` 是用于指定 select 具体需要监听的文件描述符的位图，它是一个结构体，其结构如下 : 

```c
typedef struct{
/**
 * XPG4.2 requires this member name.  
 * Otherwise avoid the name from the global namespace.
*/
#ifdef __USE_XOPEN
  __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)->fds_bits)
#else
  __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)->__fds_bits)
#endif
} fd_set;
```

事实上，它仅仅只是一个一维数组的存在，我们需要关注的是这个数组的长度，通过继续往下刨析源码，该数组长度最终在宏定义展开后其值为 : `1024`

由宏 `__FD_SETSIZE` 决定了该文件描述符位图的长度为 `1024`，也就意味着，我们无法通过一些 linux 内核的参数调整来改变这个值，即被固定为 `1024`，除非我们手动改写源码，再编译内核以使用

<font color = "red">正因为该数组的长度为 `1024`，也就意味着，select 函数最多仅支持对一种监听行为的文件描述符的监听个数仅被固定在了 `1024`，这也属于 select 函数的缺陷之一</font>

**_操作 fd_set_**

在头文件 `select.h` 中提供了以下四种 **_宏函数_** 来完成对文件描述符位图 `fd_set` 的操作

- void FD_CLR(int fd, fd_set *set) : 将 fd 从 文件描述符位图 set 中移除

- int FD_ISSET(int fd, fd_set *set) : 判断 fd 是否在文件描述符位图 set 中，如果存在则返回1，否则返回0 ; 该宏函数用来判断 `select` 函数返回后，用于检测 `select` 函数的本次返回是否因为指定文件描述符 fd 所产生的行为事件所导致的

- void FD_SET(int fd, fd_set *set) : 将fd设置到文件描述符位图 set 中

- void FD_ZERO(fd_set *set) : 初始化文件描述符位图 set

**_select 的使用_**

下面的代码展示了 select 用于监听 socket 伪文件所指向的缓冲区中是否存在事件(变化)的发生，主要针对于是否有新连接的加入导致产生了监听描述符产生了读事件，是否有连接的新数据的写入导致了通信描述符产生了读事件

<font color = "red">事实上，`select` 函数是针对文件描述符所指向的缓冲区来完成监听工作，也就意味着，只要存在该特性(例如管道，stdin，stdout等等)，都可以使用 `select` 函数来完成某一项工作事件的监听</font>

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <errno.h>
#include <select.h>

int main(int argc, char *argv[]) {
  int sfd = socket(AF_INET, SOCK_STREAM, 0x0);

  struct sockaddr_in serv;
  bzero(&serv, sizeof(serv));
  serv.sin_family = AF_INET;
  serv.sin_port = htons(8886);
  inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
  int bflg = bind(sfd, (const struct sockaddr *)&serv, sizeof(serv));
  
  listen(sfd, 0x400);
  printf("[INFO] server start listen\n");

  fd_set tmp_fds, read_fds;
  FD_ZERO(&tmp_fds);
  FD_ZERO(&read_fds);

  FD_SET(sfd, &read_fds);

  char buf[0x400] = { 0 };
  int conn_count = 0;
  /**
   * 初始以监听文件描述符作为最大描述符，
   * 并在这个描述符的基础上，添加客户端
   * 读写的描述符
  */
  int max_fd = sfd;
  while (true) {
    /**
     * 为什么需要一个 temp 来暂存？
     *
     * 因为 select 函数返回后，都会改变 fd_set 原本所设置
     * 的文件描述符的状态
    */
    tmp_fds = read_fds;

    int nready = select(max_fd + 1, &tmp_fds, NULL, NULL, NULL);
    if(nready < 0) continue;
    printf("%d\n", nready);
    
    if (FD_ISSET(sfd, &tmp_fds)) {
      struct sockaddr_in client;
      bzero(&client, sizeof(struct sockaddr_in));
      socklen_t len = sizeof(struct sockaddr);

      int cfd = accept(sfd, (struct sockaddr *)&client, &len);
      if (cfd < 0) {
        if (errno == ECONNABORTED || errno == EINTR) {
          continue;
        }
        break;
      }
      char dest[16] = {0};
      printf("accept client [%s:%d]\n",inet_ntop(AF_INET, &client.sin_addr.s_addr, dest, sizeof(dest)), ntohs(client.sin_port));
      
      /* 这里这样写是有风险的，会造成服务器 TIME_WAIT 过多，一个 ddos 就完了 */
      if (++conn_count == FD_SETSIZE) {
        close(cfd);
        continue;
      }
      
      /* 新创建的用于与 client 进行沟通的文件描述符转交由 select 进行监控 */
      FD_SET(cfd, &read_fds);
      if(max_fd < cfd) max_fd = cfd;

      /* 表示此刻仅仅只是监听到了连接请求，并无数据写入请求 */
      if (nready == 1) continue;
    }

    /**
     * 处理用于 client 通信文件描述符产生变化的情景
     *
     * 这里只需要操作用于跟 client 进行读写通信的文
     * 件描述符即可，更因为通信文件描述符的创建必定
     * 会在文件描述符之后，故初始下标仅需设置为监听
     * 描述符后面一位即可
    */
    for (size_t i = sfd + 1; i <= max_fd; ++i) {
      int cfd = i;
      if (!FD_ISSET(cfd, &tmp_fds)) continue;
      
      bzero(buf, sizeof(buf));
      int n = read(cfd, buf, sizeof(buf));
      if (n <= 0) {
        printf("read over or client is closed\n");
        FD_CLR(cfd, &read_fds);
        close(cfd);
      }

      printf("receive %s", buf);
      write(cfd, buf, n);

      /* 本次仅有一个读写请求，故无需遍历后面的元素 */
      if (nready == 0) break;
    }
  }

  return EXIT_SUCCESS;
}
```

<br/>

#### poll

<span id="pollapi"></span>

**_int poll(struct pollfd *fds, nfds_t nfds, int timeout)_**

**_<poll.h>_**

该函数和 select 的功能一致(包括其底层实现)，依赖于一个包含事件信息的集合 `fds`，其中每个元素包含了需要监听的文件描述符和需要监听的多种 IO事件(**_读、写、异常等等_**)，当该集合中某一个元素(**_文件描述符_**)其缓冲区发生了变化(**_产生事件_**)，则该函数立刻返回，并设置存此刻下缓冲区存在变化的文件描述符至输出参数 `fds` 当中(设置对应元素的 **_revents_** 成员)

- `fds` : 监听事件信息的集合，其元素类型为 `struct pollfd`，该结构体中包含了需要监听的文件描述符和需要具体监听的 IO事件
  
- `nfds` : 需要监听的文件描述符的个数，<font color = "red">它映射至 fds 集合中，已经成功初始化的元素(设置了监听行为的)的个数 +1</font>

- `timeout` : 

  - `-1` : 永久阻塞函数的调用，直到一个事件的发生

  - `0` : 不阻塞，无论此刻是否发生新的事件，函数都立即返回

  - `> 0` : 指定阻塞的时间 ; 若没有超过该事件则函数调用阻塞 ; 若在时间之内存在事件的发生，函数调用立即返回 ; 若阻塞时间大于该参数所指定的值，函数调用立即返回

值得一提的是，虽然 poll 和 select 的底层实现是类似的，<font color = "red">但是 poll 无法实现跨平台，反观 select 是支持跨平台编码的</font> ; 其次，<font color = "red">poll 对于需要监听的文件描述符是允许突破 1024 个的限制的，具体多少取决于当前操作系统中对于一个进程最大允许打开的文件描述符的限制(可通过参数配置)</font>

**_struct pollfd_**

```c
/* Data structure describing a polling request.  */
struct pollfd {
  int fd;             /* File descriptor to poll.  */
  short int events;   /* Types of events poller cares about.  */
  short int revents;  /* Types of events that actually occurred.  */
};
```

- `fd` : 需要通知内核进行监听的文件描述符，当它初始化为 `-1` 时，则代表着通知内核取消对当前下标元素的监听工作

- `events` : 指定需要监听的 IO事件类型，当需要指定内核对该描述符的多种 IO事件 进行监听时，可以通过 **_异或操作符_** 对需要监听的事件类型进行分割

- `revents` : 属于 `poll` 函数调用的返回参数，当 poll 函数返回后，如果是由于当前文件描述符 `fd` 的缓冲区存在变化所导致的，则会回填具体所触发的 IO 事件到该成员中，否则该成员会被置为 `0`(不是因为此描述符的 IO事件 触发所导致 poll 函数的返回)

- `IO-EVENTS`

  - `POLLIN` : 有数据可读(常用)

  - `POLLRDNORM` : 有普通数据可读

  - `POLLRDBAND` : 有优先数据可读

  - `POLLPRI` : 有紧迫数据可读

  - `POLLOUT` : 写数据不会导致阻塞(缓冲区空余)(常用)

  - `POLLWRNORM` : 写普通数据不会导致阻塞

  - `POLLWRBAND` : 写优先数据不会导致阻塞

  - `POLLMSGSIGPOLL` : 消息可用

  - `POLLER` : 指定的文件描述符发生错误
  
  - `POLLHUP` : 指定的文件描述符挂起事件

  - `POLLNVAL` : 指定的文件描述符非法

**_poll 的使用_**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <errno.h>
#include <poll.h>

int main(int argc, char *argv[]) {
  int sfd = socket(AF_INET, SOCK_STREAM, 0x0);

  struct sockaddr_in serv;
  bzero(&serv, sizeof(serv));
  serv.sin_family = AF_INET;
  serv.sin_port = htons(8886);
  inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
  int bflg = bind(sfd, (const struct sockaddr *)&serv, sizeof(serv));
  
  listen(sfd, 0x400);
  printf("[INFO] Server start listen in [127.0.0.1:8888]\n");

  struct pollfd fds[0x400];
  for (size_t i = 0; i < 0x400; ++i) fds[i].fd = -1;
  
  /* monitor connection file descriptor */
  fds[0].fd = sfd;
  fds[0].events = POLLIN;
  int max_fd = 0;

  char buffer[0x400] = { 0 };
  while (true) {
    int nready = poll(fds, max_fd + 1, -1);
    if (nready < 0) continue;

    /* new connection arrived */
    if (fds[0].revents == POLLIN) {
      struct sockaddr_in client;
      bzero(&client, sizeof(struct sockaddr_in));
      socklen_t len = sizeof(struct sockaddr);

      int cfd = accept(sfd, (struct sockaddr *)&client, &len);
      if (cfd < 0) {
        if (errno == ECONNABORTED || errno == EINTR) {
          continue;
        }
        break;
      }
      char dest[16] = {0};
      printf("accept client [%s:%d]\n",inet_ntop(AF_INET, &client.sin_addr.s_addr, dest, sizeof(dest)), ntohs(client.sin_port));
      
      int i = 0;
      for (i = 0; i < 0x400; ++i) {
        if (fds[i].fd == -1) {
          fds[i].fd = cfd;
          fds[i].events = POLLIN;
          break;
        }
      }

      if (i == 0x400) {
        printf("Arrived the max limit connection, please wait a monents\n");
        close(cfd); /* This code has security risks. */
        continue;
      }
      if (max_fd < i) {
        max_fd = i;
      }
      /**
       * It's means that only one connection event occurs at the moment,
       * so we dont't need to executed flowing code at all
      */
      if (nready == 1) {
        continue;
      }
    }

    /* Process the read data event */
    for (size_t i = 1; i <= max_fd; ++i) {
      if (fds[i].fd == -1) continue;
      if (fds[i].revents != POLLIN) continue;

      int cfd = fds[i].fd;
      bzero(buffer, sizeof(buffer));

      int n = read(cfd, buffer, sizeof(buffer));
      if (n <= 0) {
        shutdown(cfd, SHUT_RDWR);
        fds[i].fd = -1;
        printf("[INFO] Read error or client closed\n");
        continue;
      } else {
        printf("receive %s", buffer);
        write(cfd, buffer, n);
      }

      if (nready == 1) break;
    }
  }

  shutdown(sfd, SHUT_RDWR);
  return EXIT_SUCCESS;
}
```

<br/>

#### epoll

<span id="epollapi"></span>

epoll 是 linux 下IO多路复用接口 select,poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，就使用方式而言，它和 select,poll 并无较大的区别，其本质还是让一个文件描述符绑定一个 IO 事件以交由内核去进行监听工作，仅当所监听的文件描述符的某一个事件发生时，内核才会将发生事件的文件描述符连同一些附带的信息返回至内核态的用户程序

目前 epoll 是 linux 大规模并发网络程序中的热门首选模型

epoll 和 select 一致，<font color = "red">对于需要监听的文件描述符是允许突破 1024 个的限制的</font>，具体多少取决于当前操作系统中对于一个进程最大允许打开的文件描述符的限制(可通过参数配置)

**_int epoll_create(int size)_**

**_<epoll.h>_**

创建 epoll 其内部所维护的红黑树的树根，并返还指向这个树根的文件描述符

<font color = "red">epoll 内部使用红黑树来维护添加进来需要交由内核进行对应 IO事件 监控的文件描述符</font>

- `size` : 最大节点数, 此参数在linux 2.6.8已被忽略, 但必须传递一个大于0的数

- `return` : 

  - `0` : 调用成功

  - `-1` : 调用失败，并设置 `errno`

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/epoll.h>

#define LISTEN_MAX_LIMIT 0x400

int main(int argc, char *argv[]) {
  int epfd = epoll_create(LISTEN_MAX_LIMIT);
  
  return EXIT_SUCCESS;
}
```

**_int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)_**

**_<epoll.h>_**

提供对 epoll 内部所维护的红黑树进行节点的 添加,修改,删除 操作，简而言之就是操作内核针对文件描述符的监控操作

- `epfd` : epoll 内部所维护的红黑树其树根所指向的文件描述符

- `op` : 执行的操作，使用以下宏定义来表示

  - EPOLL_CTL_ADD : 将文件描述符 `fd` 和其需要被监听的IO事件(由 `event` 参数所指定)添加进 epoll 内部所维护的红黑树当中
	
  - EPOLL_CTL_MOD : 在 epoll 内部所维护的红黑树当中修改文件描述符 `fd` 和其需要被监听的IO事件(由 `event` 参数所指定)

  - EPOLL_CTL_DEL : 从 epoll 内部所维护的红黑树当中删除文件描述符 `fd` 所映射的节点，也意味着让内核取消对该文件描述符 IO 事件的监听工作(对于删除而言，无需另外指定 `event` 参数)

- `fd` : 设置需要交由内核进行 IO事件 监听的文件描述符

- `event` : 一个结构体，用于存储指定描述符 `fd` 需要被监听的具体的 IO事件 和一些需要被存储的附加信息(<font color = "red">具体所指定的形参仅只是在函数内部做了一个数据的拷贝</font>)

  - `struct epoll_event`

    - `events` : 设置需要具体被监听的 IO 事件，如需指定多种行为可用 异或操作符 进行分割

      - `EPOLLIN` : 表示对应的文件描述符所指向的缓冲区存在可读

      - `EPOLLOUT` : 表示对应的文件描述符所指向的缓冲区存在空间可写

      - `EPOLLPRI` : 表示对应的文件描述符有紧急的数据可读(这里应该表示有带外数据到来)

      - `EPOLLERR` : 表示对应的文件描述符发生错误

      - `EPOLLHUP` : 表示对应的文件描述符被挂断

      - `EPOLLET` :	将EPOLL设为边缘触发$(Edge \:\: Triggered)$模式，这是相对于水平触发$(Level \:\: Triggered)$而言的

      - `EPOLLONESHOT` : 只监听一次事件，当监听完这次事件之后，如果还需要继续监听某个文件描述符的话，需要再次把这个文件描述符添加进 epoll 内部所维护的红黑树当中

    - `data` : 指定当前文件描述符 `fd` 在 epoll 内部所维护的红黑树中所对应节点的一些附加信息，它是一个共用体，其结构如下

    ```c
    typedef union epoll_data {
      void *ptr;
      int fd;
      uint32_t u32;
      uint64_t u64;
    } epoll_data_t;
    ```

    ```c
    struct epoll_event {
      uint32_t events;    /* Epoll events */
     epoll_data_t data;  /* User data variable */
    }
    ```

- `return` : 

  - `0` : 调用成功

  - `-1` : 调用失败，并设置 `errno`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <sys/epoll.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  int sfd = socket(AF_INET, SOCK_STREAM, 0x0);

  struct sockaddr_in serv;
  bzero(&serv, sizeof(serv));
  serv.sin_family = AF_INET;
  serv.sin_port = htons(8886);
  inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
  int bflg = bind(sfd, (const struct sockaddr *)&serv, sizeof(serv));
  
  listen(sfd, 0x400);
  printf("[INFO] server start listen\n");

  int ep_fd = epoll_create(1024);

  struct epoll_event ev;
  ev.data.fd = sfd;
  ev.events = EPOLLIN;
  epoll_ctl(ep_fd, EPOLL_CTL_ADD, sfd, &ev);

  close(ep_fd);
  close(sfd);
  return EXIT_SUCCESS;
}
```

**_int epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout);_**

**_<epoll.h>_**

依照 epoll 内部所维护的红黑树其内部的节点(需要被监听的文件描述符)，等待某一个节点的 IO 事件的发生，并将此刻发生 IO事件 的节点信息回填至 `events` 数组中(会预先对该形参做一次初始化)，并返回此刻具体引发 IO 事件的节点数

- `epfd` : epoll 内部所维护的红黑树其树根所指向的文件描述符

- `events` : 输出参数，当函数调用返回时，会将此刻引发 IO 事件的节点回填至该参数中(函数内部会预先对该形参做一次初始化)，该数组的长度则设置为我们需要 epoll 对文件描述符进行 IO事件 监听的最大数量即可

- `maxevents` : 设置为我们需要 epoll 对文件描述符进行 IO事件 监听的最大数量

- `timeout` : 

  - `-1` : 永久阻塞函数的调用，直到一个事件的发生

  - `0` : 不阻塞，无论此刻是否发生新的事件，函数都立即返回

  - `> 0` : 指定阻塞的时间 ; 若没有超过该事件则函数调用阻塞 ; 若在时间之内存在事件的发生，函数调用立即返回 ; 若阻塞时间大于该参数所指定的值，函数调用立即返回

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <sys/epoll.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>


int main(int argc, char *argv[]) {
  int sfd = socket(AF_INET, SOCK_STREAM, 0x0);

  struct sockaddr_in serv;
  bzero(&serv, sizeof(serv));
  serv.sin_family = AF_INET;
  serv.sin_port = htons(8886);
  inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
  int bflg = bind(sfd, (const struct sockaddr *)&serv, sizeof(serv));
  
  listen(sfd, 0x400);
  printf("[INFO] server start listen\n");

  int ep_fd = epoll_create(1024);

  struct epoll_event ev;
  ev.data.fd = sfd;
  ev.events = EPOLLIN;
  epoll_ctl(ep_fd, EPOLL_CTL_ADD, sfd, &ev);

  struct epoll_event events[1024] = { 0 };
  char buffer[1024] = { 0 };
  while (true) {
    int nready = epoll_wait(ep_fd, events, 1024, -1);
    if(nready < 0) continue;

    for (size_t i = 0; i < nready; ++i) {
      /* new client connection */
      if (events[i].data.fd == sfd) {
        struct sockaddr_in client;
        bzero(&client, sizeof(struct sockaddr_in));
        socklen_t len = sizeof(struct sockaddr);

        int cfd = accept(sfd, (struct sockaddr *)&client, &len);
        if (cfd < 0) {
          if (errno == ECONNABORTED || errno == EINTR) {
            continue;
          }
          break;
        }
        char dest[16] = {0};
        printf("accept client [%s:%d]\n", inet_ntop(AF_INET, &client.sin_addr.s_addr, dest, sizeof(dest)), ntohs(client.sin_port));
        
        ev.data.fd = cfd;
        ev.events = EPOLLIN;
        epoll_ctl(ep_fd, EPOLL_CTL_ADD, cfd, &ev);

        continue;
      }

      /* Process the read data event */
      int cfd = events[i].data.fd;
      bzero(buffer, sizeof(buffer));

      int n = read(cfd, buffer, sizeof(buffer));
      if (n <= 0) {
        printf("Read error or connection closed\n");
        close(cfd);
        epoll_ctl(ep_fd, EPOLL_CTL_DEL, cfd, NULL);
        continue;
      }
      
      printf("receive %s", buffer);
      write(cfd, buffer, n);
    }
  }
  
  close(ep_fd);
  close(sfd);
  return EXIT_SUCCESS;
}
```

**_epoll 的两种工作模式_**

epoll 对其内部所维护的红黑树节点进行监听的方式拥有两种模式 : $LT(level \:\: trigger)$ 和 $ET(edge \:\: trigger)$，而其中，LT模式模式为 epoll 的默认行为

- LT : 是一种缺省的工作方式，<font color = "red">可支持 blocked 和 non-blocked 文件描述符的操作</font>，在这种做法中，内核会告知某个文件描述符是否就绪了(事件发生)，如果本次(`epoll_wait` 返回)不作任何操作，在下一次执行 `epoll_wait()` 时内核还是会继续重复上一次的通知

- ET : 是一种高速工作的方式，<font color = "red">仅支持 non-blocked 文件描述的操作</font>，在这种模式下，epoll 对于被监听的文件描述符其 IO事件 的发生仅做一个状态的通知，并不保证引起该 IO事件 的源头是否已经被处理，也就是说，即便该文件描述符因为某些原因而引发 IO事件 的原因即便还未处理完毕，epoll 也不会再在做任何通知，除非针对该文件描述符新事件的到来才会让内核重新返回该文件描述符的通知

  - ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高

  - epoll 工作在 ET 模式的时候，相关描述符必须使用非阻塞式调用，以避免由于一个文件描述符的阻塞导致多个文件描述符的任务饿死

  - 设置 ET 模式很简单，只需要在对相关文件描述符进行事件属性设置(`epoll_ctl()`)时，使用异或操作符添加 `EPOLLET` 宏定义即可


**_epoll 反应堆_**

epoll 反应堆是一种开发模式，其借鉴封装的思想，简单的说就是当某个事情发生了，自动的去处理这个事情 ; 这样的思想对我们的编码来说就是 **_设置回调_**，将文件描述符对应的事件和事件产生时的处理函数捆绑在一起，这样当某个文件描述符的事件发生了，回调函数会自动被触发，这就是所谓的反应堆思想

反应堆的核心是 **_回调函数_**，在调用 `epoll_ctrl()` 时，参数 `struct epoll_event` 中的成员 `union epoll_data` 就可以用来指定该文件描述符所绑定的一些信息，借此我们就可以封装一个属于自己的结构体，然后在结构体内部再声明回调函数的成员，以此完成文件描述符和回调函数的封装捆绑操作

下面的代码展示了一个简易版本的 epoll 反应堆

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <sys/epoll.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>

#define LISTEN_MAX_LIMIT 0x400

typedef struct ev_handler {
  void (*invoker)(int, void *);
  int fd;
  char buffer[128];
} ev_handler;

static ev_handler handlers[LISTEN_MAX_LIMIT] = { 0 };
static int sfd = 0;
static int epfd = 0;

void write_data(int cfd, void *arg);
void read_data(int cfd, void *arg);
void accept_new_client(int sf, void *arg);

void write_data(int cfd, void *arg) {
  ev_handler *handler = (ev_handler *)arg;

  if (strlen(handler->buffer) > 0) {
    write(cfd, handler->buffer, 128);
  }

  struct epoll_event ev;
  ev.events = EPOLLIN;
  handler->invoker = read_data;
  ev.data.ptr = handler;
  
  /* 当写入完毕后，改变当前 cfd 未监听缓冲区是否可读行为 */
  epoll_ctl(epfd, EPOLL_CTL_MOD, cfd, &ev);
}

void read_data(int cfd, void *arg) {
  ev_handler *handler = (ev_handler *)arg;

  bzero(handler->buffer, 128);
  int n = read(cfd, handler->buffer, 128);
  if (n <= 0) {
    printf("Read error or connection closed\n");

    handler->fd = -1;
    close(cfd);
    epoll_ctl(epfd, EPOLL_CTL_DEL, cfd, NULL);
  }
  
  struct epoll_event ev;
  ev.events = EPOLLOUT;
  handler->invoker = write_data;
  ev.data.ptr = handler;
  
  /* 当读取完毕后，改变当前 cfd 为监听缓冲区是否可写的行为 */
  epoll_ctl(epfd, EPOLL_CTL_MOD, cfd, &ev);
}

void accept_new_client(int sf, void *arg) {
  struct sockaddr_in client;
  bzero(&client, sizeof(struct sockaddr_in));
  socklen_t len = sizeof(struct sockaddr);

  int cfd = accept(sfd, (struct sockaddr *)&client, &len);
  if (cfd < 0) exit(EXIT_FAILURE);

  char dest[16] = {0};
  printf("accept client [%s:%d]\n", inet_ntop(AF_INET, &client.sin_addr.s_addr, dest, sizeof(dest)), ntohs(client.sin_port));

  int idx = 0;
  for (;idx < LISTEN_MAX_LIMIT; ++idx) if (handlers[idx].fd == -1) break;
    
  handlers[idx].fd = cfd;
  handlers[idx].invoker = read_data;

  struct epoll_event ev;
  ev.events = EPOLLIN;
  ev.data.ptr = &handlers[idx];

  epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);
}

void init_socket() {
  sfd = socket(AF_INET, SOCK_STREAM, 0x0);
  if (sfd < 0) exit(EXIT_FAILURE);

  struct sockaddr_in serv;
  bzero(&serv, sizeof(serv));
  serv.sin_family = AF_INET;
  serv.sin_port = htons(8886);
  inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
  int bflg = bind(sfd, (const struct sockaddr *)&serv, sizeof(serv));
  
  listen(sfd, LISTEN_MAX_LIMIT);
  printf("[INFO] Server start listen at [127.0.0.1:8886]\n");
}

void init_epoll() {
  for (size_t i = 0; i < LISTEN_MAX_LIMIT; ++i) handlers[i].fd = -1;

  epfd = epoll_create(LISTEN_MAX_LIMIT);

  ev_handler *handler = &handlers[LISTEN_MAX_LIMIT - 1];
  handler->fd = sfd;
  handler->invoker = accept_new_client;

  struct epoll_event ev;
  ev.events = EPOLLIN;
  ev.data.ptr = (void *)handler;

  epoll_ctl(epfd, EPOLL_CTL_ADD, sfd, &ev);
}

int main(int argc, char *argv[]) {
  init_socket();
  init_epoll();

  struct epoll_event events[LISTEN_MAX_LIMIT];
  while (true) {
    int nready = epoll_wait(epfd, events, LISTEN_MAX_LIMIT, -1);

    for (size_t i = 0; i < nready; ++i) {
      ev_handler *handler = (ev_handler *)events[i].data.ptr;
      handler->invoker(handler->fd, handler);
    }
  }

  close(epfd);
  close(sfd);
  
  return EXIT_SUCCESS;
}
```


<br/>

#### 再谈 select poll epoll

<span id="再谈selectpollepoll"></span>

**_select_**

- <font color = "red">内核中实现 select 是用轮询方法，即每次检测都会遍历所有 FD_SET中 中所保有的文件描述符的状态(检测是否有事件发生)</font>，显然，select 函数执行时间与 FD_SET 中的文件描述符的个数呈线性上升的关系，即交由 select 所监控的文件描述符的个数越多，那么效率就越低，其<font color = "red">时间复杂度为 $O(n)$</font>

- <font color = "red">其次，select 的每次调用都需要把 FD_SET 集合从用户态拷贝到内核态</font>，这个开销在同样在 FD_SET 的元素较多时开销很大

- 虽然 select 能够支持跨平台的编码，但是其 FD_SET 集合的长度取决于一个内置的宏定义来完成，即其长度固定为 1024

- select 提供精度更高(微妙)的超时时间

**_poll_**

poll 和 select 的实现其实是非常类似的，存在不同的是 :

- poll 不支持跨平台编码，仅支持 linux 平台

- poll 解锁了最大监听文件描述符的个数
  
- select 比 poll 提供了更高精度的超时时间

**_epoll_**

epoll 作为 select 和 poll 的一个进阶引用，它改进了作为前者而言所存在的诸多弊端，而改进这些弊端都绕不开和 epoll 的底层实现息息相关的三种关键要素 : **_红黑树、mmap、双向链表_**

- 对于产生用户态到内核态亦或者反之的数据拷贝情景(需要交由内核监听的文件描述符和其事件拷贝至内核态，亦或者当某一个事件发生时，从内核态拷贝发生相应事件的文件描述符和一些附带信息到用户空间)，epoll 使用了 [mmap](#共享映射区的使用) 来减少了在这上面开销

- 注册到 epoll 的文件描述符和其需要被监听的事件信息将封装成一个树上的节点并插入到 epoll 内部所实现的 **_红黑树_** 中进行维护，当添加或者删除一个节点时(`epoll_ctl`)性能较好，时间复杂度 $O(log_n)$，也正因为红黑树属于一颗平衡二叉树，所以重复添加的节点没有用的

- 每当我们需要将一个文件描述符和其需要被监听的 IO 事件注册进 epoll 时，都会遍历一遍目前已注册在 epoll 进行监听的文件描述符，挨个找到每个文件描述符所对应设备的 **_等待队列_** 并将当前进程挂在进这个队列当中，并为止还注册了一个 **_回调函数_**(该回调函数在内核中称为 : `ep_poll_callback`，其主要功能就是把当前因为事件发生被唤醒的文件描述符添加到一个双向队列 `rdllist` 当中)，每当一个设备的就绪则唤起等待设备队列中的进程，并在这期间就会完成这个回调函数的调用。<font color = "red">那么每当我们使用 `epoll_wait()` 所造成的阻塞操作其内部其实就是对这个双向队列做检查，一旦这个队列中存在被添加进来的文件描述符和其所绑定的事件(当队列为空的话，则调用 `schedule_timeout()` 让当前进程休眠一会)，则函数立即返回，并将双向队列中的数据通过 [mmap](#共享映射区的使用) 拷贝至用户空间以供应用程序进行操作</font>，这里对比 select 和 poll 省去了遍历所有被注册到内核进行监听的文件描述符的工作，在这里的时间复杂度可以理解为 $O(1)$，简而言之，epoll 这一特性可以总结为 : <font color = "red">它只管你 **_'活跃'_** 的设备，而跟 **_设备总数_** 无关</font>

- epoll 除了默认使用传统的 $LT(level \:\: trigger)$ 模型以外，还提供了 $ET(edge \:\: trigger)$ 模式，很大程度上减少了 epoll 事件被重复触发的次数

- epoll 和 poll 同样解锁了最大监听文件描述符的个数，并且两者间被影响的参数都指向同一个

- epoll 并不支持跨平台编码

**_三者的 benchmark_**

![2020-11-30-11-59-40](https://raw.githubusercontent.com/NGPONG/Blog/master/img/2020-11-30-11-59-40.jpg)

