# *C Programming language*

<br/>

## 目录

- [变量](#变量)
    - [变量的定义和变量的声明](#变量的定义和变量的声明)
    - [全局变量和局部变量](#全局变量和局部变量)
    - [extern 关键字](#extern)
    - [变量](#变量)
- [常量](#常量)
- [静态成员](#静态成员)
- [基础数据类型](#基础数据类型)
    - [原码 反码 补码](#原反补)
    - [整型](#整型)
    - [Boolen](#Boolen)
    - [实型](#实型)
    - [Char](#Char)
    - [sizeof](#sizeof)
- [指针](#指针)
    - [内存单元](#内存单元)
    - [变量在内存中的存储模型](#变量在内存中的存储模型)
    - [获取一个变量其所在内存空间的首地址](#获取一个变量其所在内存空间的首地址)
    - [指针变量的定义](#指针变量的定义)
    - [指针和地址](#指针和地址)
    - [寻址操作](#寻址操作)
    - [指针的类型](#指针的类型)
    - [指针的大小](#指针的大小)
    - [地址的算数运算](#地址的算数运算)
    - [泛型指针](#泛型指针)
    - [野指针](#野指针)
    - [空指针](#空指针)
    - [const 修饰指针变量](#const修饰指针变量)
    - [多级指针](#多级指针)
- [内存4区模型](#内存4区模型)
- [数组](#数组)
    - [数组的定义](#数组的定义)
    - [数组和指针](#数组和指针)
    - [数组的初始化](#数组的初始化)
    - [多维数组](#多维数组)
    - [指针数组](#指针数组)
    - [数组指针](#数组指针)
    - [数组作为函数的形参](#数组作为函数的形参)
- [字符串](#字符串)
    - [字符串在 c 中的定义](#字符串在c中的定义)
    - [c 标准库所提供的针对于字符串操作的 API](#c标准库所提供的针对于字符串操作的API)
- [heap](#heap)
- [函数](#函数)
    - [函数的声明和定义](#函数的声明和定义)
    - [栈与栈帧](#栈与栈帧)
    - [关于函数的返回值问题](#关于函数的返回值问题)
    - [函数指针](#函数指针)
- [结构体](#结构体)
    - [结构体的声明和定义](#结构体的声明和定义)
    - [结构体的内存地址](#结构体的内存地址)
    - [关于结构体的内存对齐的问题](#关于结构体的内存对齐的问题)
    - [关于结构体的深浅拷贝的问题](#关于结构体的深浅拷贝的问题)
    - [关于结构体中包含自身结构体类型的成员的问题](#关于结构体中包含自身结构体类型的成员的问题)
- [共用体](#共用体)
- [文件](#文件)
    - [在 c 语言中三种特殊的系统文件](#在c语言中三种特殊的系统文件)
    - [文件缓冲区](#文件缓冲区)
    - [文件指针](#文件指针)
    - [文件指针的具体使用](#文件指针的具体使用)
- [特殊的关键字](#特殊的关键字)
    - [typedef](#typedef)
    - [register](#register)
    - [volatile](#volatile)
- [编译](#编译)
    - [编译时所经历的 4 个步骤](#编译时所经历的4个步骤)
    - [GCC](#GCC)
    - [头文件](#头文件)
- [预处理指令](#预处理指令)
    - [头文件引入](#头文件引入)
    - [宏](#宏)
    - [条件编译](#条件编译)
- [位运算](#位运算)
    - [位逻辑运算符](#位逻辑运算符)
    - [移位运算符](#移位运算符)
- [关于系统提供给我们的API中，形参为 format 时需要注意的问题](#形参format)
- [控制台](#控制台)
- [Windows.h](#Windows.h)
- [stdlib.h](#stdlib.h)

<br/>

### 变量
<span id="变量"></span>

---
#### 变量的定义和变量的声明
<span id="变量的定义和变量的声明"></span>

在 C 语言中，是需要严格区分 <kbd>变量的定义</kbd> 和 <kbd>变量的声明</kbd> 的，我们先来看下如何对一个变量进行定义或者声明

```c
int main(void){

    // Variable definitions
    int varriable_def = 10;

    // Variable declaration
    int varriable_decl;
}
```

可以看到，我们对于一个变量如果在声明的过程中指定了其具体的值，那么这个变量就会提升为 [[变量的定义]]，反之，我们只是单纯的声明了一个变量的类型和其变量名，那么这种方式就称为 [[变量的声明]]

变量的定义 和 变量的声明 的区别最关键的部分还是对于两者的定义编译器是否为之开辟内存空间的问题，但这只是一个理论上的结论，<font color = "red">在 c 语言中，一个变量成员的使用必须要存在其定义，如果不存在的话，则编译器在编译源程序的时候，编译器则会找到这个变量的声明所对应的定义，并将当前变量的声明隐式提升为变量的定义</font>，这一机制我们也可以理解为编译器为变量的声明提供的一种 <font color = "red">隐式提升变量作用域 </font>的作用，归根结底，变量的声明在最终编译完成后，编译器还是会为当前变量分配相应的内存空间，只是对比 变量的定义 来说，开辟内存空间途径可能形式不同，但是需要注意的是，编译器为变量的声明隐式提升作用域的机制会根据变量声明在局部还是声明在全局的不同而不同

#### 全局变量和局部变量
<span id="全局变量和局部变量"></span>

局部变量: 
- 局部变量声明在函数体内，其作用域由此变量的声明开始，直至该函数体的结束，对于普通的局部变量而言 ( 未使用 [[extern]] 关键字的局部变量 )，如果我们只是声明了一个局部变量，那编译器在编译的过程中仅会在 <font color = "red">当前文件的开始直至当前函数体的结束符 [[}]] 之间</font> 寻找该变量的定义，如果不存在，则赋予一个随机数
- 对于一般的局部变量而言，其一般存储在内存的 [[栈]] 上，也就意味着其生命周期在出了该函数体外就会结束掉

全局变量: 
- 全局变量声明在函数体外，其作用域默认情况下由此成员的定义开始直至当前文件的结束，对于全局变量而言，如果我们只是声明了一个全局变量，那编译器在编译的过程中会先从当前全局变量的定义位置开始直至当前文件的结束中寻找该变量的定义，如果不存在，则会从 <font color = "red">其它需要链接的文件中尝试寻找该变量的定义</font> ( 这种情况也是间接的提升了全局变量的作用域 )，如果都不存在，则编译器会赋予它一个默认值，简而言之，<font color = "red">全局变量在 c 语言下默认情况是一个外部链接属性</font>

- 对于一般的全局变量而言，其存储在内存的 [[.bss]] 或 [[.rodata]] 段上，也就意味着其生命周期会延续到当前程序的结束

!!! danger 注意
    对于不同的编译器来说，这方面的实现可能会有所不同，就 [[GCC]] 而言，其符合着以上所说的这一规范，而对于 [[MSVC]] 而言，这个规范仅仅适用于全局变量，对于局部变量来说，其在使用前必须要有其定义，否则会编译错误

<br/>

#### extern 关键字
<span id="extern"></span>

该关键字能够用于扩展 [[函数/变量]] 的可见性，具体的作用就是在编译器编译步骤至链接的过程中，会在其他文件 ( 也有可能是当前文件 ) 中寻找符合使用了当前该关键字的成员声明的定义，以至使用了该关键字的声明能够映射到找到的相应文件的成员定义当中，从而间接实现了声明的可见性

前面说到，变量在使用前必须要存在定义，如果在使用的时候并没有对该变量的定义的话，编译器则会找到其声明，并将其隐式提升为定义，并赋予其相应的默认值，而使用了该关键字的第一大特性就是，[[它会阻住编译器对于变量进行定义的隐式提升效果]]，也就是说，如果我们对某一个变量使用了该关键字进行了声明后，如果该变量在某处进行了使用，则源程序会在编译的过程中报错，因为编译器不会将其声明隐式提升为定义

该关键字如果给变量使用的话，其可以作用于局部变量和全局变量
- 局部变量
    - 局部变量使用该关键字的时候，该变量不可以用作于定义
    - 对于局部变量来说，当我们在局部变量使用了该关键字后，该局部变量的具体定义能够映射至当前函数外的任意位置，乃至其它文件中，也就是间接的提升了其作用域
- 全局变量
    - 全局变量使用该关键字的时候，该变量可以用作于定义'
    - 对于全局变量来说，使用了该关键字的成员的定义和局部变量一样，其作用域同样也会有一种隐式提升的作用，其实这点就使用了 [[extern]] 关键字的全局变量和 普通的全局变量 来说是非常类似的，但是我们需要注意的是，它们两种声明方式所带来的后果其实是不同的，就 普通的全局变量 来说，其还是一种变量成员，即遵循 [[如果仅存在声明而没有定义的情况下，该声明会隐式提升成定义]] ，而对于使用了 [[extern]] 关键字的全局变量来说，[[它会阻住编译器对于变量进行定义的隐式提升效果]]，也就是说，如果一个声明为 [[extern]] 关键字的全局变量，如果再找不到其定义令他的声明隐式提升为定义的情况下，编译器编译的时候i会报错

而该关键字给函数使用的话其实无太大效果，因为我们所声明的函数或者是我们所定义的函数在编译器进行编译的过程中，都会默认的为所声明的函数加上该关键字 [[extern]]

```c
Session 1：
*******main.c
int main(void) {
    
    extern int a;

    printf("%d\n", a);

    system("pause");
    return EXIT_SUCCESS;
}

int a = 10;



Session 2:
*******main.c
int main(void) {
    
    extern int a;

    printf("%d\n", a);

    system("pause");
    return EXIT_SUCCESS;
}

*******test.c
int a = 10;



Session 3:
*******main.c
extern int a;

int main(void) {

    printf("%d\n", a);

    system("pause");
    return EXIT_SUCCESS;
}

*******test.c
int a = 10;
```

<br/>

### 常量
<span id="常量"></span>

---

C 语言中的常量是通过关键字 [[const]] 来完成，当我们定义了一个常量，就意味着我们无法通过正常途径去修改这个定义为常量的成员的值，但是我们需要记住的是，当我们把一个常量定义为 [[局部的]]，那么 [[这个常量无法修改的特性是由编译器在编译源程序的过程中所决定的]]，其实更具体点来说，这个变量还是和普通的变量一样存储在 [[栈]] 上，但是因为它使用了 [[const]] 的关键字，所以编译器在编译的时候就会检查这个关键字所定义的变量是否存在修改的情况，由于还是存储在 [[栈]] 上，这也就意味着我们是可以在程序运行时通过 [[间接修改 (指针)]] 的方式去修改这个常量的值，其实简而言之，定义为局部的常量是一种 [[伪常量]]

```c
int main(void){

    const int a = 10;
    return 0;
}
```

!!! INFO
    常量的定义，关键字 [[const]] 并不一定需要放在左值表达式的最左侧，对于 [[const]] 关键字来说，其所存放的位置可以在左值表达式的任意位置，对于普通的常量来说我们放在什么位置也好，其实都是没有区别的，而对于 [[指针类型的常量]] 来说，[[const]] 关键字所写入的位置能够决定 [[指针类型的常量]] 的一些额外特性

那么当我们把 [[const]] 的关键字使用在 [[全局变量]] 身上的时候，那么该常量就会存储在内存的 [.rodata] 段中，也就是说该常量不能被修改的特性是受到 [[系统内核级]] 的保护的，其实也就是我们不能通过指针来实现间接修改，它是真正意义上，[[长存性]] 的常量

```c
#include <stdio.h>

const int a = 10;
int main(void){

    printf("%d\n",a);
    return 0;
}
```

除此之外，常量的定义我们还能在 [[函数的参数]] 身上使用，其实对于参数身上使用，其特性也是符合 [[局部常量]] 的那种特性，但是通过这种方式我们能够达成一个 [[约定俗成]] 的概念，即 [[该参数不能够修改]] 的概念

```c
#include <stdio.h>

void fun_test(const int a){

    printf("%d\n",a);
}

int main(void){

    fun_test(10);
    return 0;
}
```

<br/>

### 静态成员
<span id="静态成员"></span>

---

静态成员使用 [[static]] 关键字来完成定义，它可以使用于 [[函数]] 和 [[变量]]，其存储在内存的 [[.data]] 段或者 [[.bss]] 段中，意味着其生命周期会延续到程序的结束

当静态成员定义为 [[全局成员]] 的时候是一种 <font color = "red">内部链接属性</font> 的变量，意味着该成员的作用域从定义位置开始，到本文件的结束，并且我们不能通过外部声明提升其作用域

```c
#include<stdio.h>

static void fun_test(void){

    printf("Hello,World!");
}

static int a = 10;

int main(void){

    return 0;
}
```

当静态成员定义为 [[局部成员]] 的时候，该成员的作用域从定义位置开始，直至当前函数体的结束，需要注意的是，由于它是静态的，所以它的生命周期会延续到程序的结束，也就是说当我们定义了一个静态的局部变量，当我们第一次操作它并改变了相应的值，那么当我们第二次访问该函数的时候，这个静态局部变量的值就是我们改编后的值

```c
#include<stdio.h>

static void fun_test(void){

    static int a = 0;
    a++;
    printf("Hello,World!");
}

int main(void){

    for (size_t i = 0; i < 5; i++) {

        fun_test();
	}

    return 0;
}
```

对于上面 [[static]] 关键字所修饰的都是 <font color = "red">成员的定义</font>，相对的，我们同样可以使用该关键去修饰一个 <font color = "red">成员的声明</font>，当我们使用 [[static]] 关键字应用于成员的声明的时候，就意味该声明只能够在当前文件的作用域中查找其对应的定义，不能将作用域扩散至其它的编译单元之中

这里对于修饰为 [[static]] 的成员声明再补充两句，我们对于一个成员的声明主要目的就是想让这个声明能够再编译阶段扩展器作用域到其它编译单元 ( 文件 ) 中以寻找符合该声明的定义，而当我们对于一个成员的声明添加了 [[static]] 关键字后，我们原有所期望的对于成员声明的目的就无法达成了，故，使用 [[static]] 关键字去修饰成员的声明的时候，是没有什么意义的，该声明的作用域只能够扩展至当前编译单元中寻找符合的定义，那么既然作用域是限定在当前编译单元了，那为什么我们不直接使用定义的方式而是使用声明的方式呢？


```c
#include<stdio.h>

static void fun_test();
static int a;

void fun_test() {

	printf("OK!\n");
}
int a = 1024;

int main(void) {

	fun_test();

    printf("%d\n",a);

	return 0;
}
```

<br/>

### 基础数据类型
<span id="基础数据类型"></span>

---

#### 原码 反码 补码
<span id="原反补"></span>

计算机对于数值的计算都是通过 [[补码]] 来完成的，即我们一个普通的数字要经过 [[原码]] -> [[反码]] -> [[补码]] 的过程才能交由计算机去读取或者是计算

- 原码: 一个数的原始二进制数，例如 [[32]] 的原码 则为 [[0010 0010]]，并且把 [[最高位]] 作为 [[符号位]]，如果是 [[0]] 即 [[正数]]，如果是 [[1]] 即 [[负数]]

- 反码: 如果原码为正数，那么反码则不变，如果原码为负数，则除了原码的符号位以外，其余全部位全部取反即为反码

- 补码: 如果原码为正数，那么补码则不变，如果原码为负数，则为反码数 [[+1]] 即为补码


!!! INFO
    - 在 C 中，对于基本的数据类型来说是需要区分 [[有符号类型]] 和 [[无符号类型]] 的，即 [[最高位]] 是否用来充当符号位而不参与实际运算
    - 关键字 [[signed]] 所修饰的类型即为 [[有符号类型]]，而我们不使用该关键字所声明的变量的类型默认都为 [[有符号类型]]
    - 关键字 [[unsigned]] 所修饰的类型即为 [[无符号类型]]


<br/>

#### 整型
<span id="整型"></span>

有符号整型:

| Name      | Size                                                                                            | Length                                   | example              |
| --------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------- | -------------------- |
| int       | 4 Bytes                                                                                         | - 2147483648 ~ 2147483647                 | [[int a = 10]]       |
| short     | 2 Bytes                                                                                         | - 32768 ~ 32767                           | [[short a = 10]]     |
| long      | [[Windows]] 下统一为 4 Bytes，而 [[Linux]] 下，[[64位系统]] 为 8 Bytes，[[32位系统]] 为 4 Bytes       | - 2147483648 ~ 2147483647                 | [[long a = 10]]      |
| long long | 8 Bytes                                                                                         | - 9223372036854775808 ~ 9223372036854775807 | [[long long a = 10]] |

无符号整型:

| Name               | Size                                                                                            | Length                   | example                       |
| ------------------ | ----------------------------------------------------------------------------------------------- | ------------------------ | ----------------------------- |
| unsigned int       | 4 Bytes                                                                                         | 0 ~ 4294967295           | [[unsigned int a = 10]]       |
| unsigned short     | 2 Bytes                                                                                         | 0 ~ 65535                | [[unsigned short a = 10]]     |
| unsigned long      | [[Windows]] 下统一为 4 Bytes，而 [[Linux]] 下，[[64位系统]] 为 8 Bytes，[[32位系统]] 为 4 Bytes | 0 ~ 4294967295           | [[unsigned long a = 10]]      |
| unsigned long long | 8 Bytes                                                                                         | 0 ~ 18446744073709551615 | [[unsigned long long a = 10]] |

!!! info
    整型数据在内存中占的字节数与所选择的操作系统有关，虽然 C 语言标准中没有明确规定整型数据的长度，但 long 类型整数的长度不能短于 int 类型， short 类型整数的长度不能长于 int 类型

<br/>

#### Boolen
<span id="Boolen"></span>

在 c 标准定义中，是不存在 [[bool]] 类型和 [[true / false]] 的，c 标准对于 [[true / false]] 的定义为 [[0为假]] [[非0为真]]，如果一定要使用 [[true / false]] 这种写法，可以引入 [[stdbool.h]] 这个头文件，该头文中实现了 [[BOOLEAN]] 和 [[TRUE / FALSE]] 的宏定义，把 [[BOOLEAN]] 定义为 int 类型，并把 [[TRUE]] 定义为 [[1]]，[[FALSE]] 定义为 [[0]]


<br/>

#### 实型
<span id="实型"></span>

| Name   | Size    | Length                         | example           |
| ------ | ------- | ------------------------------ | ----------------- |
| float  | 4 Bytes | - 3.4 * 10^38 ～ 3.4 * 10^38   | [[float a = 10]]  |
| double | 8 Bytes | - 1.7 * 10^-308 ~ 1.7 * 10^308 | [[double a = 10]] |

<br/>

#### Char
<span id="Char"></span>

char 在 C 中除了能够表示一个字符以外，它还能够表示一个 [[1 Bytes]] 大小的整型数据，因为每个 char 类型本身就是一个 [ASCII](https://www.ascii-code.com/) 字符，即每个字符都有一个在 [[1 Bytes]] 大小一类的数字

除了使用 char 来表示一个字符以外，我们还通常用它来 [[解析内存地址结构]]，原因是因为 char 类型本身只是占 [[1 Bytes]]，即计算机中的基本内存单元，可以更好地去操控

| Name          | Size    | Length     | example                    |
| ------------- | ------- | ---------- | -------------------------- |
| unsigned char | 1 Bytes | 0 ~ 255    | [[unsigned char ch = 'A']] |
| signed char   | 1 Bytes | -128 ~ 127 | [[char ch = 97]]           |

<br/>

#### sizeof
<span id="sizeof"></span>

[[sizeof]] 是一种关键字，它可以获取一个 [[数据类型]] 或者 [[已经定义好数据类型的变量]] 其所占用内存空间的具体大小，以字节为单位

[[sizeof]] 关键字的返回值为 [[size_t]] 类型，在 [[32位操作系统]] 下认作为 [[unsigned int]] 类型

```c
#include<stdio.h>

struct MyStruct {

    int value1;
    char value2;
};

int main(void){

    // 取 已经定义好数据类型的变量
    int a = 10;
    size_t size_a = sizeof(a);
    printf("size of a = %d\n",size_a);

    // 取 数据类型
    size_t size_double = sizeof(double);
    printf("size of double = %d\n",size_double);

    // 取 结构体
    size_t size_struct = sizeof(struct MyStruct);
    printf("size of struct = %d\n",size_struct);

    // 取 指针或者是指针所指向的变量
    int value = 10;
    int ptr_value = &a;
    printf("size of pointer = %d\n",ptr_value);
    printf("size of value = %d\n",*ptr_value);

    return 0;
}
```

<br/>

### 指针
<span id="指针"></span>

---

#### 内存单元
<span id="内存单元"></span>

内存单元是计算机中内存最小的存储单位，其大小为 [[1 Bytes]] ，而每一个 [[内存单元]] 都有一个唯一的编码，这个编码的长度可能是 8 位 ( 32 位系统 ) 或 16 位 ( 64 位系统 )，对于这个编码，更为亲民的称呼则为 [[地址]]，而指针是什么？ [[指针的实质其实就是这个地址]]，更具体来说的话，指针是存储了一个变量其所对应内存空间中首地址的变量，也就是指向了一个地址

<br/>

#### 变量在内存中的存储模型
<span id="变量在内存中的存储模型"></span>

在程序编译的过程中，就已经为我们所定义的变量按照变量的数据类型所对应的字节大小规划好了它们所属的内存空间，举个例子，比如说我们定义了一个占用内存空间为 [[4 Bytes]] 的 [[int]] 类型的变量，其存储的值为 [[0x12345678]] ，那么它在内存空间中就有相应的、连续的 [[4个内存单元]] 的存储空间，如下图

```c

                8765 4321 Bit      TOP
               +---------+          ^
               |         |          |
               |1000 0111|          |
               |         |          |
0x00000004<----+---------+          |
               |         |          |
               |0110 0101|          |
               |         |          |
0x00000003<----+---------+          |
               |         |          |
               |0100 0011|          |
               |         |          |
0x00000002<----+---------+          |
               |         |          |
               |0010 0001|          |
               |         |          |
0x00000001<----+---------+          v
                                   LOW

```

通过上图我们可以总结出几点结论

1. 对于一个变量而言，其在内存空间中所使用的是一块 [[地址连续]] 的内存空间，比如说一个 [[int]] 类型占用 [[4 Bytes]]，那么其在内存空间中就是占用了 4 个 [[内存单元]]，且每个内存单元之间是相间一起的，也就是 [[地址连续]]

2. 变量所对应的内存空间的地址是连续的，而且其地址总是会从 [[低位 -> 高位]] 的形式来往上递增，除此之外，需要我们注意的是，[[只要我们去操作一个变量，不管是读取还是写入，操作也是从最低为开始进行的]]，也就是最低位的那 [[1 Bit]]

3. 除此之外，我们会发现一个数在转换为 [[二进制]] 的数值的时候，其最右边的值则对应的最低位，在上图则为 [[0010 0001]]，而最左边的值则为它的最高位，即 [[1000 0111]]

<br/>

#### 获取一个变量其所在内存空间的首地址
<span id="获取一个变量其所在内存空间的首地址"></span>

在 c 语言中，通过关键字 [[&]] 即可获取一个变量所在内存空间的首地址

```c
#include<stdio.h>

int main(void){

    int a = 10;
    printf("%p\n",&a);

    return 0;
}
```

<br/>

#### 指针变量的定义
<span id="指针变量的定义"></span>

指针由于其所存储的是一个变量在内存空间的首地址，故我们定义指针的时候，做左值的操作只需要赋予相应变量的在内存空间中的首地址即可获取到一个 [[安全的指针变量]]

```c
int main(void){

    int a = 20;
    int *ptr = &a;

    return 0;
}
```

定义指针，通过 [[*]] 号来进行定义，一旦在定义变量的过程中，类型与变量名之间出现了 [[*]]，那么编译器就会认为这个定义过程是在定义一个 [[指针变量]]，而上面的代码中，即为定义了一个类型为 [[int *]] 的指针变量 [[p]]

!!! INFO
    一个指针变量在定义完成后，其所指向的内存地址并不是不能改变的，如果有需要，我们是可以在适当的时候改变其指向另一块合法的内存地址


<br/>

#### 指针和地址
<span id="指针和地址"></span>

当一个指针变量定义完成后，[[我们直接使用这个指针变量名的时候即为获取这个指针变量所存储的内存地址，即这个指针所指向的地址]]，而指针既然是一个指针变量，那么它也有所对应的内存空间的地址，我们该如何获取它呢？[[对指针变量名使用 & 操作符即为获取到这个指针变量在内存空间中的首地址]]

这里需要区分两个地址的概念，一个是指针本身在内存空间中的首地址，一个是指针所指向的其它变量在内存空间中的首地址，如下图

```c
TOP                         8765 4321 Bit
 ^                         +---------+--------+                      +---------+
 |                         |         |        |                      |         |
 |                         |1000 0111|        |                      |0000 0000|
 |                         |         |        |                      |         |
 |         0x00000004 <--------------+        |                      +---------+-------> 0x87654324
 |                         |         |        |                      |         |
 |                         |0110 0101|        |                      |0000 0000|
 |                         |         |        |                      |         |
 |         0x00000003 <--------------+        +--------------------> +---------+-------> 0x87654323
 |                         |         |        |                      |         |
 |                         |0100 0011|        |                      |0000 0000|
 |                         |         |        |                      |         |
 |         0x00000002 <--------------+        |                      +---------+-------> 0x87654322
 |                         |         |        |                      |         |
 |                         |0010 0001|        |                      |0001 0100|
 |                         |         |        |                      |         |
 v         0x00000001 <----+---------+--------+                      +---------+-------> 0x87654321
LOW             ^                                                                            ^
                |                                                                            |
                |                                                                            |
                |                                                                            |
                +                                                                            +
      Pointer: ptr -> 0x87654321                                                        Int: a -> 20

```



<br/>

#### 寻址操作
<span id="寻址操作"></span>

根据某个变量的内存空间的首地址能够找到它的存储区域并完成对这块内存区的读写操作，这个操作就叫做 [[寻址]]，而放在指针身上的更贴切的称呼则为：[[指针的解引用]]

解引用操作我们通过操作符 [[*]] 来完成，该操作符能够通过一个给定的合法地址，该合法地址通常是一个变量在内存区域中的首地址，找到这个变量在内存中的具体位置，然后再 [[根据解引用变量的数据类型的大小从首地址往后读取具体个字节的内存单元]] ，再把整体读取到的内存单元拿出来 ( [[即找到内存地址所代表的具体变量]] )，以完成对该内存首地址所指向的内存区域的读写操作，如以下代码

```c
#include<stdio.h>

int main(void){

    int a = 10;
    *(&a) = 20;

    return 0;
}
```

我们通过操作符 [[&]] 拿到了变量 [[a]] 的内存首地址，然后再通过操作符 [[*]] 对该地址进行解引用，找到变量 [[a]] 在内存中的首地址，由于变量 [[a]] 的类型为 [[int]] 即 [[4 Bytes]]，于是，[[*]] 操作符再根据首地址往后读取 [[4 Bytes]] 大小的内存单元，到此为止，我们就可以拿到变量 [[a]] 本身以完成对它的间接读写操作了

上面的示例是直接通过一个变量的地址来进行解引用操作，对于指针变量的使用也是如此，前面说过，指针变量当定义完成后，直接使用指针变量名则是获取这个指针变量所存储的某个变量在内存空间中的首地址吗，即通过 [[*]] 所解引用的即是指针变量所存储的某个变量的内存地址，先来看下使用

```c
#include<stdio.h>

int main(void){

    short a = 10;
    short *p = &a;
    *p = 20;

    return 0;
}
```

以上则是指针变量使用的方式，在前面说到，对于直接对一个地址解引用操作的时候，所解引用的具体字节是根据这个地址本身所映射的变量来决定的，比如说这个地址是属于 [[int]] 类型变量地址的话，那解引用操作所读取的字节则为 [[4 Bytes]]，而对于直接通过一个指针变量来解引用操作的时候，[[具体所读取的字节是通过指针的类型]] 来决定的，在这里，指针的类型为 [[short *]]，即 [[4 Bytes]]，但是还需要注意的是，指针所指向的变量是一个 [[short]] 类型，即本身在内存空间中占用 [[2 Bytes]]，而指针类型又是一个 [[4 Bytes]]，所以本身是不符合常理的

先不要急，我们先拆分来看看这个 [[解引用的表达式]] ，他其实拆分出来分别为 [[p]] 和 [[*p]]，[[p]] 的过程即获取这个指针变量内部所存储的某个变量的内存地址，这时候其实我们对于这个指针变量 [[p]] 本身的类型需要去掉一颗 [[*]]，即 [[short *]] -> [[short]]，在第二步操作的时候则是根据第一步操作所转换掉的类型 ( [[short]] ) 来决定接下来要往内存中读取的字节数，即 [[2 Bytes]]，也就是变量 [[a]] 本身在内存中所存储的 [[完整的]] 数据

!!! 
    简而言之，在指针变量使用的时候，我们需要先对于指针变量本身的类型先去掉一个 [[*]] 来看待即可，这一规则包括 [[数组]] 和 [[多级指针]] 都应遵守

<br/>

#### 指针的类型
<span id="指针的类型"></span>

一个指针变量也有属于它的类型的，如: [[int *]]、[[short *]]、[[char *]]、……

那么指针的类型具体有什么作用呢？ [[指针的类型能够决定指针变量所存储的地址的步长]]

这里还要提及一个步长的概念， [[步长能够决定解引用时所需读取的字节数和对于地址做算数偏移时需要相对于步长数进行偏移]] ，即一个读还有一个是内存地址的偏移

我们先来看一下读：

前面说到，操作符 [[*]] 进行解引用的时候，能够通过所给定的某个变量在内存中的首地址，找到这块变量完整的内存空间以完成对该变量的读写操作，那么这里就有一个疑问，首先一个变量的首地址我们是知道的，因为操作符 [[*]] 所解引用的就是一个变量在内存中的首地址，接下来，假设这个地址为 [[0x00000001]]，并且其所映射的变量是一个 [[short]] 类型的变量，即所存储的内存空间的大小为 [[2 Bytes]]，所以这个变量在内存中具体所占用的地址为： [[0x00000001]] 、 [[0x00000002]]，那么编译器是如何知道操作符 [[*]] 在定位到 [[0x00000001]] 后，需要读取两个字节的数据呢？这个就是靠的 [[读的步长]]

接下来看下内存地址的偏移：

我们还是假定一个 [[short]] 类型的变量，并且其在内存中的首地址为 [[0x00000001]]，我们不妨对这个地址进行 [[+ 1]] 操作，即 [[0x00000001 + 1 = ?]] ，该算数表达式在正常情况下其答案为 [[0x00000002]]，然而它实际上是一个内存地址，对于内存地址进行常量算术操作 ( [[偏移]] ) 应该以其步长作为基准，即 [[0x00000001 + 1 * 步长 = 0x00000003]]

那么步长到底怎么来， [[单纯以一个变量的地址作为衡量的话，那步长就为这个内存地址所映射的变量的数据类型所占用的具体内存空间的大小]] ，如下面代码获取到步长的方式则是以 [[内存地址所映射的变量的类型]] 来决定的

```c
int main(void){

    short a = 10;
    printf("%p\n",&a + 1);

    return 0;
}
```

而步长放在一个指针变量身上的话，步长的参考就不能依照指针变量内部所存储的内存地址所映射到的变量的数据类型来决定的了，对于指针变量来说，步长需要参考指针变量本身的类型来，假设这个指针变量为 [[short *]]，即步长为 [[4]] ( 指针类型在内存中都是占用 4 Bytes 大小的空间 )，而指针所指向的变量是一个 [[short]] 类型，即本身在内存空间中占用 [[2 Bytes]]，而指针类型又是一个 [[4 Bytes]]，所以本身是不符合常理的，我们先以指针变量的类型 [[short *]] 为基础，我们发现因为这里存在一颗 [[*]] 导致这个类型变成了一个指针类型，其实一个指针变量名在定义好后，当我们直接使用这个变量名的时候，其步长的参考要以原有类型先去掉一颗 [[*]]，再以去掉 [[*]] 后的指针类型作为下一次步长判断的基准，就拿刚刚的例子来说，我们有个 [[short *]] 的指针变量内部存储着一个 [[short]] 类型变量的首地址，当我们尝试对这个指针进行解引用的时候，首先是使用了指针变量名，即 [[short *]] -> [[short]]，其次就是通过解引用操作符 [[*]] 对这个地址进行解引用，在找到了这个变量在内存中的首地址后，所以指针变量名其实在使用的过程中，就需要先去掉一颗 [[*]]，即 [[short *]] -> [[short]]，下一步操作即为 [[*]] 操作符的解引用操作，根据上一步剩下的 [[short]] 类型，即 [[2 Bytes]] 来决定步长为 [[2]]，在解引用操作后相应的类型还需要去掉，即 [[short]] -> [[无]]，这种方式不只是针对一级指针，对于多级指针同样也是如此，还是假设我们有如下代码

```c
int main(void){

    short a = 10;
    short *p = &a;
    short **pp = &p;
}
```

我们声明了一个二级指针 [[pp]]，我们尝试对 [[pp]] 进行两次解引用操作 -> [[**pp]]，首先 [[pp]] 为指针类型 [[short **]]，在使用了 [[pp]] 后，该类型要变成 [[short **]] -> [[short *]]，即 [[4 Bytes]]，也就是步长为 [[4]]，在第一次解引用 -> [[*pp]] 的时候，由于此次操作的步长为 [[4]] ，那就是此次解引用通过 [[pp]] 内部存储的是指针变量 [[p]] 在内存中的首地址完整地读取到了 [[p]] 指针变量的内容 ( 指针 [[p]] 类型为 [[int *]]，即 [[4 Bytes]] )，由于此次解引用用了一个 [[*]]，即原本的类型变为 [[short **]] -> [[short *]] -> [[short]]，那么下一次步长则为 [[2]]，那么在第二次解引用的时候 [[**pp]] ，由于步长为 [[2]]，即此次解引用完整的读取到了 [[a]] 变量的完整内容 ( a 变量的类型为 [[short]]，即 [[2 Bytes]] )，那么第二次解引用又使用了一颗 [[*]]，即类型变为 [[short **]] -> [[short *]] -> [[short]] -> [[无]]

那么对于 [[数组]] 或者是 [[多维数组]]，由于数组名本身也是一个指向数组首元素的指针，故也需应用上面所说的规则，只是对于数组来说原本指针类型的 [[*]] 替换为 <kbd>[num]</kbd> 罢了

<bd/>

#### 指针的大小
<span id="指针的大小"></span>

前面说到，指针也属于一个变量，只是他在内存中所存储的是另一个变量在内存中的首地址，那么，既然它是一个变量，也就是说它也有属于他所占用的内存空间的大小

- 在 32 位 系统上，由于内存地址为 8 位 [[0x00000001]] ，即 4 个字节，所以 [[在32位系统上的指针类型的大小则为 4 Bytes]]

- 在 64 位 系统上，由于内存地址为 16 位 [[0x0000000000000001]] ，即 8 个字节，所以 [[在64位系统上的指针类型的大小则为 8 Bytes]]

既然不管是什么指针类型在相同系统架构下所占用的内存空间的大小是相同的，那么我们可以理解为任何指针类型之间的互转都不会出现数据丢失的问题，当然这个数据丢失仅仅只是针对指针内部所存储的内存地址是否保证完整性，但是需要注意的是我们转换后的指针类型是否符合该指针在解引用操作时所需要的步长，否则数据丢失的可能会出现在解引用操作上

在这里需要扩充下，当我们直接通过关键字 [[sizeof]] 填入一个指针变量的时候，所获取到的则为指针类型所对应的大小 [[4 Bytes or 8 Bytes]]，当我们去 [[对指针进行解引用操作的时候]] 获取到的才是指针所指向的变量其所对应的内存空间的大小

```c
#include<stdio.h>

int main(void){

    int a = 10;
    int *p = &a;

    printf("size of pointer = %d\n",sizeof(p));
    printf("size of a = %d\n",sizeof(*p));

    return 0;
}
```

<br/>

#### 地址的算数运算
<span id="地址的算数运算"></span>

当我们对一个内存地址又或者称为指针进行算数运算的时候，这种算术运算并不是简单的算数运算，而是以当前地址所以指向的内存空间首地址整体的存储长度为单位来计算的，简而言之就是运算的同时需要以 [[类型的步长]] 为基准进行计算

- 对于地址和常数进行算术
    - 除 / 乘 : 这两种操作符是不合法的，不允许存在的
    - 加 / 减 : 地址 +/- 常数 * 步长

- 对于地址和地址进行算数
    - 除 / 乘 : 这两种操作符是不合法的，不允许存在的
    - 加 / 减 : (地址1 +/- 地址2) / 步长
        - 地址计算的前提必须是两个地址所映射的变量的数据类型是相同的，两个毫不相干的变量进行内存地址的减法运算，虽然语法和编译器都能够成立该表达式，但是实际做法是毫无意义的，因为我们不知道减出来的结果的地址具体指向是什么东西
        - 该算式的真正运用其实在一个数组中，因为数组中的元素的类型都是相同，并且其内存地址是连续的存储空间，对于人为来说可以更好的控制运算的成果具体所偏移的位置， [[运用在数组中通常用来获取某个下标的元素到某个下标的元素之间所偏移的长度]]
    - 比较运算 : 对于地址的比较运算，语法上是合理的，而且编译器也允许，但是如果我们针对两个毫无相干的变量的内存地址进行比较运算实际是毫无意义的，所以它的真正运用其实在一个数组中，因为数组中的元素的类型都是相同，并且其内存地址是连续的存储空间，所以具体的逻辑作为开发人员来说更好的把控

<br/>

#### 泛型指针
<span id="泛型指针"></span>

泛型指针的类型为 [[void *]]，对于泛型指针来说， [[它可以转换为任意类型的指针]] ，比如说 [[void *]] 可以转换为 [[int *]]

由于泛型指针是泛型的，所以泛型指针在定义后，编译器是不知道它所指向的是何种类型的变量内存地址，即无法知道解引用操作时所需要的步长，所以具体要用某一个泛型指针进行解引用的时候，我们必须要先把它转换成相符类型类型的指针定义才能进行解引用操作

```c
int main(void) {

	int a = 100;
	void *p_void = &a;
	int *p = (int *)p_void;

	printf("%d\n", *p);
	return 0;
}
```

<br/>

#### 野指针
<span id="野指针"></span>

野指针即指针所指向的地址可能是实际存在又或者是不存在的地址，我们对一个野指针进行了解引用操作后，报错方式在 [[windows]] 下 或者是 [[Linux]] 下都不同，但不管如何，野指针的存在肯定是需要杜绝的，如下代码则是一个教科书级别的野指针定义方式

```c
int main(void){

    int a = 10;
    int *p = &a + 1;

    printf("%d\n",*p);

    return 0;
}
```

<br/>

#### 空指针
<span id="空指针"></span>

空指针即指针所指向的地址为 [[0]] -> [[0x00000000]]，也是一个无效的地址，但是它对比野指针来说，它的出现通常用来判断指针的有效性，在某种程度上对比野指针来说更有实际意义

在 c 中空指针的定义通常通过一个宏定义 [[NULL]] ( [[#define NULL ((void *)0)]] ) 来定义

```c
int main(void){

    int *p = malloc(sizeof(int));
    if(p == NULL){

        return -1;
    }

    *p = 20;
    printf("%d\n",*p);

    free(p);

    return 0;
}
```

<br/>

#### const 修饰指针变量
<span id="const修饰指针变量"></span>

前面对于 [[const]] 的特性提到过，它可以放在左值表达式的任意位置，而该特性对于指针变量来说，放在不同的位置都会有不同的含义

- const int *p : 可以修改 [[p]] 指向另外一个变量在内存中的首地址，但是不可以根据 [[p]] 当前所指向的某个变量在内存中的首地址解引用来修改该变量的值
- int const *p : 可以修改 [[p]] 指向另外一个变量在内存中的首地址，但是不可以根据 [[p]] 当前所指向的某个变量在内存中的首地址解引用来修改该变量的值
- int * const p : 可以根据 [[p]] 当前所指向的某个变量在内存中的首地址解引用来修改该变量的值，但是不可以修改 [[p]] 指向另外一个变量在内存中的首地址
- const int *const p : 不可以根据 [[p]] 当前所指向的某个变量在内存中的首地址解引用来修改该变量的值，并且还不可以修改 [[p]] 指向另外一个变量在内存中的首地址

把指针变量修饰为 [[const]] 常用于函数的形参部分，其目的用来限制当前函数上下文内，形参列表中的某个指针变量是要遵循某种规则进行该函数上下文逻辑的书写

<br/>

#### 多级指针
<span id="多级指针"></span>

多级指针从一级指针开始都称为多级指针，那么多级指针是如何定义的？我们都知道一级指针是指向具体某个变量在内存中的首地址，而二级指针则为指向这个一级指针在内存中的首地址，三级指针则为指向这个二级指针在内存中的首地址，依次类推，来看以下代码则为定义了一个 [[4级指针]]

```c
int main(void) {

    int a = 10;
    int *p = &a;
    int **pp = &p;
    int ***ppp = &pp;
    int ****pppp = &ppp;

    printf("%d\n",****pppp);

    return 0;
}
```

在这里，我们通过这个4级指针的解引用再复习一下步长的定义，首先这里指针 [[[pppp]]] 的类型则为 [[[int ****]]]，当我们使用了 [[pppp]] 这个指针名的时候，原有的类型需要先降一颗 [[*]]，即 [[int ****]] -> [[int ***]] ，然后进行第一次解引用操作 [[*pppp]]，这次解引用操作依照上一次所得到的类型来决定步长，由于 [[int ***]] 也是一个指针类型，故为 [[4 Bytes]]，所以步长为 4，所以此次解引用是能够完整读取到指针 [[ppp]] 在内存中的完整内容的，那么在此次解引用完成后，由于使用了一个 [[*]] ，所以原有的类型还需要降一颗 [[*]]，即 [[int ****]] -> [[int ***]] -> [[int **]]，那么进行第二次解引用操作，[[**pppp]] ，此次解引用的步长则依据上一个步骤所得到的类型来决定，即 [[int **]] -> [[4 Bytes]]，那么此次解引用操作后由于又使用了一颗 [[*]]，故原有的类型就变为 [[int ****]] -> [[int ***]] -> [[int **]] -> [[int *]]，那么进行第三次解引用操作 [[***pppp]]，此次则依据 [[int *]] 来决定步长，即 4，于是此次解引用能够完整地读取到指针变量 [[p]] 在内存中的所有内容，那么在此次解引用操作结束后，还需要去掉一颗 [[*]]，即 [[int ****]] -> [[int ***]] -> [[int **]] -> [[int *]] -> [[int]]，那么进行第四次解引用操作 [[****pppp]] 的时候，则以 [[int]] 类型的长度作为步长，即能够完整地读取到变量 a 在内存中的所有内容，即 [[10]]

<br/>

### 内存4区模型
<span id="内存4区模型"></span>

---

内存在 [[程序运行时]] ，整体可以分为以下几个区域

- 静态存储区: 静态存储区即源程序还未加载到内存前 ( [[运行前]] ) 就已经通过编译器分配好具体每个内存段具体所需要分配的字节数，然后在程序正式运行时，内核系统会把刚刚通过编译器所分配的每个内存区的存储信息加载到相应的内存区中，它们的占用空间大小是固定的，就算在程序运行期间也不能随意修改
    - 代码段 [[.text]] :
        - 该空间用于存储二进制化后的代码，存放 [[CPU执行的机器指令]]
        - 代码区是可共享的 [[即另外的执行程序能够访问到它]] ，使该内存区可用于共享的目在于，对频繁被执行的程序，只需要在内存中保有一份它的可执行二进制指令即可
        - 代码区是只读的，使其只读的原因在于防止其它程序会 意外地/恶意地 修改了它的指令码，另外，在代码区还会规划局部变量的一些相关信息
    - 数据段 :
        - .data
            - 存储 [[值初始化为非0]] 的 [[全局变量]] 和 [[静态变量]]
            - 在编译器进行 [[链接]] 的过程中，会把该段设定为 [[读写权限]]
        - .bss 
            - [[存储未初始化 (包括0)]] 的 [[全局变量]] 和 [[静态变量]]，再系统内核加载程序执行前，该段中的数据整体都会 [[被内核初始化为 0/NULL ]]
            - 在编译器进行 [[链接]] 的过程中，会把该段设定为 [[读写权限]]
        - .rodata
            - 只读数据段，存储使用 [[const关键字修饰的全局常量]] 和 使用 [[char 类型指针所修饰的字符串常量]]
            - 在编译器进行 [[链接]] 的过程中，会把该段设定为 [[只读权限]]

- 动态存储区：动态存储去即可以在程序运行时进行动态扩展的区域
    - stack:
        - 栈由系统自动管理，自动分配，自动释放
        - 栈中的内存地址由 [[高地址向低地址延伸]]，并且最遵循着 [[FILO first in last out]] 的存储原则
        - 栈的大小在Windows下默认为 [[1M ~ 10M]]，而在Linux下默认为 [[8M ~ 16M]]
        - 关于 [[stack]] 和 [[stack frame]] 之间的关系，请查看 [函数这一章节](#函数) 

    - heap:
        - 堆由开发人员进行管理和维护，对于堆空间的申请我们需要手动的分配和释放，如果在一个程序运行时向堆中申请了某块空间后并未主动释放，则该空间的生命周期会延续到程序的结束
        - 堆空间的大小默认为 [[1.3 G]]，如果超出后还会在此基础上增加，理论上在硬件能够支持的范围内，堆的空间大小可认为无限大
        - 关于 [[heap]] 的具体使用，请查看 [heap 这一章节](#heap) 

下图以 [[32位 Linux os]] 为基础所展示的内存4区存储模型

```c
						+-------+----------------+  --> 4 Gigabyte	   		Top
						|		|	   			 |	 		 		 		 |
	  Kernel space ←----+		|    			 |					 		 |
						|		|      			 |	 		 		 		 |
						+-------+----------------+	--> 3 Gigabyte	 		 |
								|			  |	 |					 		 |
						+-------+     stack   |	 |					 		 |
						|		|			  v	 |					 		 |
						|		+----------------+	 		 		 		 |
						|       |				 |							 |
						|		|	Stand Lib	 |					 		 |
						|		|				 |					 		 |
						|		+----------------+					 		 |
						|		|	   		  ↑	 |	 		 		 		 |
						|		|  			  |	 |					 		 |
						|		|      		  |	 |	 		 		 		 |
						|		|	   heap	  |	 |					 		 |
						|		|	   		  |	 |	 		 		 		 |
						|		|  			  |	 |					 		 |
						|		|     		  |  |	 		 		 		 |
		User space ←----+		+----------------+					 		 |
						|		|     		 	 |					 		 |
						|		|	  .bss		 +-----+	 		 		 |
						|		|				 |	   |			 		 |
						|		+----------------+	   +-> Read & Write		 |
						|		|     	 	 	 |	   |					 |
						|	 	|	  .data		 +-----+			 		 |
						|	    |                |					 		 |
						|		+----------------+			 		 		 |
						|		|     			 |	   		 	 	 		 |
						|		|	 .rodata	 +-----+			 		 |
						|		|				 |	   |   			 		 |
						|		+----------------+	   +-> Read only 		 |
						|		|				 |	   |			 		 |
						+-------+     .text	 	 +-----+	 		 		 |
								|				 |					 		 |
								+----------------+	--> 0 Gigabyte     	    Low	
```

<br/>

### 数组
<span id="数组"></span>

---

#### 数组的定义
<span id="数组的定义"></span>

数组就是一段存储着多个相同类型数据的内存空间，默认定义下其存储在栈上，在这段内存空间中，数组的每个成员的内存地址都是连续且有序的，[[成员于成员之间相互间隔了 1 个步长的偏移量]]，如以下代码则为我们定义了一个 <kbd>int []</kbd> 类型的数组

```c
int main(void){

    int arrary[3] = {1,2,3};

    return 0;
}
```

对于上面代码中所定义的数组，其在内存的结构如下图

```c
TOP
 ^                                        +---------------------------->   +---------+------------+
 |                                        |                                |0000 0000|            |
 |                                        |                0x0000000B <----+---------+ 0x00000008 |
 |                                        |                                |0000 0000|            |
 |                                        |                0x0000000A <----+---------+     ~      +---> arrary[2] == 3
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000009 <----+---------+ 0x0000000B |
 |                                        |                                |0000 0011|            |
 |                                        |                0x00000008 <----+---------+------------+
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000007 <----+---------+ 0x00000004 |
 |   int arrary[3] = {1,2,3} <------------+                                |0000 0000|            |
 |                                        |                0x00000006 <----+---------+     ~      +---> arrary[1] == 2
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000005 <----+---------+ 0x00000007 |
 |                                        |                                |0000 0010|            |
 |                                        |                0x00000004 <----+---------+------------+
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000003 <----+---------+ 0x00000000 |
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000002 <----+---------+     ~      +---> arrary[0] == 1
 |                                        |                                |0000 0000|            |
 |                                        |                0x00000001 <--------------+ 0x00000003 |
 |                                        |                                |0000 0001|            |
 v                                        +------------>   0x00000000 <----+---------+------------+
LOW
```

<br/>

#### 数组和指针
<span id="数组和指针"></span>

当我们定义好一个数组后，如 [在上一小节](#数组的定义) 的代码中所定义的数组变量 [[arrary]]，这个数组变量 [[arrary]] 在内存中所存放的数据并不是当前数组在内存中的一段内存 ( 整个数组本身 )，而是 [[存放的当前数组中首元素在内存中的首地址]]，也就意味着当我们当都使用这个数组名 [[arrary]] 的时候，获取到的则为当前数组首元素的地址，即 <kbd> arrary == &arrary[0]</kbd>

既然数组变量内部所存放的是当前数组首元素的地址，那是不是就和 [[指针的定义]] 是类似的了？是的，对于数组名来说，我们在 [[大部分情况]] 下可以把它看成是一个指向当前数组首元素的指针，具体来讲的话，这个指针是一个指针常量，即 [[arrary == int * const arrary]] ，也就是说我们可以根据 [[arrary]] 当前所指向的首元素在内存中的首地址解引用来修改该变量的值，但是不可以修改 [[arrary]] 指向另外一处内存地址

当然，上面强调了在 [[大部分情况下]] 我们是可以把数组名看操作是一个指向当前数组首元素的指针的，而在以下两种情况使用数组名的时候，它所代表的则为这一整个数组的本身，即这个数组在内存中所存储的一整段内容

- sizeof: 当我们使用 [[sizeof]] 关键字引用于数组名的时候 [[sizeof(arrary)]]，所获取的长度并不是指针的长度 [[4 Bytes]]，而是获取的一整个数组所占用的内存段的长度
- &: 当我们通过该操作符对于数组名进行操作的时候 [[&arrary]] ，所获取到的地址的类型并不是当前指向当前数组首元素首地址指针的类型 [[int *]]，而是代表着一整个数组的类型，意味着，其步长就不能按照原有指针类型的 [[4 Bytes]] 来计算了，而是要以当前一整个数组所占用的内存段的长度来计算了，也就是说当我们使用该算数表达式 [[&arrary + 1]] ，返回的结果就不是当前数组第二个元素在内存中的首地址了，而是需要偏移过一整个数组的长度来计算
    - 当我们我们单独输出 [[arrary]] [[即数组首元素的地址]] 的时候和使用 [[&arrary]] 所输出的地址是一样的，但这只是一个错觉，这两者间是两个完全不同的关系，首先 [[arrary]] 就代表着数组首元素的地址 <kbd>&arrary[0]</kbd> 但是 [[&arrary]] 代表着的却是一整个数组的地址，但是为什么 [[&arrary]] 的结果和 <kbd>&arrary[0]/arrary</kbd> 的结果是一样的呢？现在先抛出一个问题，数组的本身是跨越好 [[n]] 个存储单元的，怎么表示这几个存储单元组成的整体呢？如果你是编译器，你会怎么做？呃，取其第一个存储单位的值来代表会比较好点，没错，编译器是这么做的，所以两者的值会是相同的相同

在单独使用一个定义好了的数组的数组名的时候，既然它是一个指向数组首元素地址的指针，那是不是意味着我们可以直接通过 [[*]] 操作对数组名进行解引用操作？答案是的，并且其也遵循在 [指针步长](#指针的类型) 这一小节中所强调的对于解引用时所需遵循的规律，还是拿最初所定义的 [[arrary]] 来说，[[arrary]] 作为一个数组变量，其类型为 <kbd>int []</kbd>，当我们使用这个数组名的时候，原来的类型就需要先去掉一个 <kbd>[]</kbd>，即 <kbd>int []</kbd> -> <kbd>int</kbd>，然后我们再进行解引用操作，即 [[*arrary]]，这时候其步长就需要参考 [[int]] 类型，即 [[4 Bytes]]，那么数组首元素的类型也是 [[int]] 类型，即此次解引用操作 [[*arrary]] 是能够完整的读取到这个数组首元素在内存中所存储的内容的，当然这里所解引用的是数组首元素的内容，那么对于其它下标的内容我们同样可以通过偏移的方式来获取，因为前面说到数组中的每个元素之间都是相隔且连续的，如我们想取下标为 [[1]] 的元素的内容那么我们直接在首地址的基础上再往后偏移 [[1]] 位即可获取到，如: [[*(arrary + 1)]] 即为获取当前数组下标为 [[1]] 的元素的内容

我们都知道，<kbd>[n]</kbd> 是取数组下标为 [[n]] 的元素的内容，其实 <kbd>[]</kbd> 可以看作是一种语法糖的形式，其实它的实质也是通过对于数组名的偏移和解引用的操作来访问到具体某个下标的元素，即 <kbd>arrary[n]</kbd> 可以看作为 [[*(arrary + n)]] 的简写形式

虽然数组名其在大多数情况下都代表着一个指向当前数组首元素地址的指针，但是对于指针和数组我们是不能把它们混在一起的，数组名代表着指向数组首元素地址的指针这只是属于数组的一种特性，而数组本身是作为一段连续且有序的内存存储空间，对比指针来说，指针只是一个指向具体某个变量在内存的首地址的变量，其次，对于普通的指针来说，其做 [[++]] 操作是允许的，而数组名虽然也是存储着其首元素的内存地址，而做 [[++]] 操作的时候是不允许的，因为数组是一个 [[指针常量]]，最后，一个数组虽然只是声明，但是我们也能够对它进行解引用操作，因为一个数组一旦声明后编译器就能够为它初始化一段线性连续的内存用于存储，只是解引用后的结果可能是一个随机数罢了，而对于指针来说，我们只是声明的情况下我们对它解引用的时候是一种危险的操作，因为我们并未指定该指针的具体指向，故该指针可能是一个空指针抑或是编译器把这种指针初始化为了一个野指针

<br/>

#### 数组的初始化
<span id="数组的初始化"></span>

如果我们只是声明了一个数组而没有定义，那么当我们访问数组某个下标的元素的时候，只能够获取到该数组对应存储区中编译器所赋予的默认值，原因是因为我们没有进行 [[数组的初始化操作]] ，编译器帮我们进行了一次隐式初始化操作

而对于人为的进行数组的初始化操作，我们只能通过在定义数组的时候就需要进行，并且需要注意的是，不管是人为的进行初始化也好还是隐式进行初始化，一个数组一旦经历过初始化的过程就不能再改变这个数组其内部所存储的当前数组首元素的地址，原因是数组在初始化完成后，数组名是一个 [[指针常量]]

需要注意的是，我们认为的对数组进行初始化操作，哪怕我们只是在当前初始化的过程中仅仅只是指定了初始化一个元素，编译器也会使没有指定初始化值的元素都赋上一个初始化值 [[0]]

```c
int main(void){

    // init arrary
    int arrary[3] = {0};
    return 0;
}
```

<br/>

#### 多维数组
<span id="多维数组"></span>

对于多维数组来说，不管是多少维的数组，我们都需要把所定义的多维数组名当成是一个一维数组来看，其实包括编译器也是这么认为的，只是这个一维数组名由原来是指向具体某个变量在内存中的首地址的指针变成了 [[这个数一维数组名是指向下一维度数组在内存中的首地址的指针]] ，但离不开的是，不管是一维数组也好还是多维数组，数组名总是一个指向当前数组首元素内存地址的指针

其实对于 [[多维]] 的概念是一种抽象形式，对于多维数组来说，其内存存放布局同样还是遵循着数组的规律，每个实质的元素之间的地址都是相间且连续的，而对于编译器来说，我们通过了一个 [[多维]] 的定义，把一个 [[一维]] 的数组划分了不同的维度去供我们或者运行时使用，我们先来上一个定义三维数组的代码，以带出更多需要重点关注的问题

```c
int main(void){

    int arrary[4][3][2] = 
    {
        {
            { 1,2 }, { 3,4 }, { 5,6 }
        },

        {
            { 7,8 }, { 9,10 }, { 11,12 }
        },

        { 
            { 13,14 }, { 15,16 }, { 17,18 }
        },

        {
            { 19,20 }, { 21,22 }, { 23,24 }
        } 
    };
}
```

我们定义了一个类型为 <kbd>int [4][3][2]</kbd> 三维数组 [[arrary]] , 但上面说到，不管多少维的数组也好，我们都需要从一维的角度去看待它，那么我们可以理解为，[[arrary]] 其实其本质为存放了 [[4]] 个 <kbd>int [3][2]</kbd> 数组类型的一维数组，事实也是如此，既然虽然它的 [[arrary]] 的类型可以表达为 <kbd>int [4][3][2]</kbd> ，但它同样也可表达成 <kbd>int [][3][2]</kbd>，除此之外，[[arrary]] 既然是一个一维数组，那么 [[arrary]] 也是一个指向当前数组首元素的地址的指针，即指向的当前数组下一维度类型为 <kbd>int [3][2]</kbd> 的数组，如下

```c
{
    { 1,2 }, { 3,4 }, { 5,6 }
}
```

[[arrary]] 所指向的是一个类型为 <kbd>int [3][2]</kbd> 数组的首地址，对于它来说我们同样也需要把它当成是一个一维数组来看待，即该数组内部所存储的指向当前数组首元素的首地址的指针，即一个类型为 <kbd>int [2]</kbd> 的数组，如下

```c
{ 1,2 }
```

对于它来说可能就非常的眼熟了，就是普通一维数组的定义方式，但是我们同样还需要进一步往下进行确认，即该类型为 <kbd>int [2]</kbd> 的数组其内部所存储的是当前数组首元素的首地址，即类型为 [[int]] 的元素，即 [[1]] 的首地址

通过上面的解析我们会发现一种规律，即 <kbd>int [4][3][2]</kbd> 指向了 <kbd>int [3][2]</kbd> 指向了 <kbd>int [2]</kbd> 指向了 <kbd>int</kbd>，所以我们可以理解为，一个多维数组在定义好后，这个多维数组所存储的地址其实为这个多维数组中，最低维度数组首元素的首地址，如上面的代码则为 三级数组 指向了 二级数组 指向了一级数组 指向了 实体元素，即最低维度数组首元素的首地址，其实我们对于所定义的这个类型为 <kbd>int [4][3][2]</kbd> 的三维数组 [[arrary]] 尝试解引用也是这个结果，首先 [[arrary]] 在使用的时候，要先去掉数组的一个维度，即 <kbd>int [4][3][2]</kbd> -> <kbd>int [3][2]</kbd>，然后进行解引用操作 [[*arrary]] 的时候，解引用所需的步长参考这按照类型 <kbd>int [3][2]</kbd> 来决定，即 [[24 Bytes]]，那么在此次解引用操作结束后，由于使用了一次 [[*]] 操作符，故原有的类型还需要再降一维度，即 <kbd>int [4][3][2]</kbd> -> <kbd>int [3][2]</kbd> -> <kbd>int [2]</kbd>，那么在进行下一次解引用操作的时候 [[**arrary]] 就参考类型 <kbd>int [2]</kbd> 来决定此次解引用操作所需的步长，也就是 [[8 Bytes]]，那么在此次解引用操作结束后，数组再降一级维度，即 <kbd>int [4][3][2]</kbd> -> <kbd>int [3][2]</kbd> -> <kbd>int [2]</kbd> -> [[int]] ，那么在最后一次解引用操作的时候，解引用所需的步长类型参考就按照 [[int]] 类型来，通过这样就能够拿到了最低维度数组首元素的完整数据了

最后，针对于刚刚所定义的多维数组再做一次巩固
```c
arrary				：第一个大组的首地址，在大多数情况下，其值位指向当前元素首元素的地址，在某些情况下代表着这整个三维数组 arrary
&arrary + 1 		：步长为整个三维数组的长度进行偏移一位
arrary + 1			：第二大组的首地址
arrary[0] 			：第一个大组的内容
&arrary[0] + 1		：第二大组的首地址
arrary[0] + 1 		：第一个大组的第二个小组的首地址
arrary[0][0]		：第一个大组的第一个小组的内容
&arrary[0][0] + 1	：第一个大组的第二个小组的首地址
arrary[0][0] + 1  	：第一个大组的第一个小组的第二个元素的首地址
arrary[0][0][0]		：第一个大组的第一个小组的第二个元素的内容
```

<br/>

#### 指针数组
<span id="指针数组"></span>

指针数组，即数组中的元素是其它变量在内存中的首地址，所以我们需要取到实际值的时候需要做两次解引用操作，第一次解引用操作根据数组中某个元素的首地址获取到该元素内部所存放的其他变量在内存中的首地址，第二次解引用操作则是获取上一步所获取到的某个变量在内存中的首地址所映射到的完整的存储空间，即实际值，如下代码，则为定义了一个类型为 <kbd>int *[]</kbd> 类型的指针数组

```c
#include<stdio.h>

int main(void) {

	int a = 10;
	int b = 20;

	int *arrary[2] = { &a,&b };

	printf("%d\n", *arrary[0]);
	printf("%d\n", **(arrary + 1));

	return 0;
}
```

对于指针数组来说，其实他是可以作为一个二级指针所存在的，二级指针所指向的则为一级指针在内存中的首地址，而一级指针内部所存储的才是具体某个变量在内存中的首地址，而指针数组也是如此，指针数组名在定义完成后其内部所存储的则为指向数组首元素的首地址的指针，而数组首元素内部所存储的还是具体某个值在内存中首地址

对于指针数组来说，当我们使用了指针数组名后，原有的类型需要变为 <kbd>int *[]</kbd> -> [[int *]]，在做第一次解引用的时候，即 [[*arrary]] 的解引用所需的步长参考则按照 [[int *]] 来决定，即 [[4 Bytes]]，在此次解引用完成后，所获取到的则为具体某个变量在内存中的首地址，而指针数组的类型需要变为 <kbd>int *[]</kbd> -> [[int *]] -> [[int]] ，那么在下一次解引用的时候 [[**arrary]]，则解引用所需的步长参考则由上一步所计算出来的类型来决定，即 [[int]] ，也就是 [[4 Bytes]]，那么在第二次解引用的时候就能够完整地读取到该变量的值了

!!!INFO
    指针数组的本质还是一个数组，只是其内部的元素的值为某个变量在内存中的首地址

<br/>

#### 数组指针
<span id="数组指针"></span>

数组指针，即一个指针变量指向的是一个数组，先来看下数组指针的定义方式和具体使用

```c
#include<stdio.h>

int main(void){

    int arrary[2][3] = 
	{
		{ 1,2,3 }, { 4,5,6 }
	};

	int (*p_arrary)[3] = arrary;

	printf("%d\n", *(*(p_arrary + 1) + 2));     // Print 6
	printf("%d\n", (*p_arrary)[1]);			    // Print 2

    return 0;
}
```

以上代码则为定义了一个类型为 <kbd>int (*)[3]</kbd> 的数组指针 [[p_arrary]]，我们发现其定义方式和 [[指针数组]] 非常的类似，但是却截然不同，数组指针的定义通过 [[()]] 提升了 [[*]] 的优先级，即 [[*]] 和 [[p_arrary]] 组成了一个指针的定义，而剩下的类型 [[int]] 和 <kbd>[3]</kbd> 则构成了指针 [[p_arrary]] 的类型，也就是说指针 [[p_arrary]] 指向的内存地址所映射的数据类型为 <kbd>int [3]</kbd>，区别于指针数组的定义，指针数组并没有使用 [[()]] 来提升 [[*]] 的优先级，所以所定义的指针数组名则和 <kbd>[]</kbd> 就构成了数组的定义，而数组的类型则为 [[type *]]

对于数组指针来说，它是一个指向一整个数组在内存中的首地址的指针，即对于数组指针的定义可以接受一个数组在内存中的首地址，如上面代码，我们定义了一个类型为 <kbd>int [2][3]</kbd> 的二维数组并使用一个类型为 <kbd>int (\*)[3]</kbd> 的数组指针接收二维数组首元素的地址 <kbd>类型为 int [3] 的一维数组</kbd> ，但是需要注意的是，数组指针的定义通常用于修饰一个多维数组，虽然对于一个单纯的一维数组我们也能够使用数组指针进行定义，比如说上面的代码，如下面的代码，我们以一个类型为 <kbd>int (*)[3]</kbd> 的数组指针接受了类型为 <kbd>int [3]</kbd> 类型的数组的定义

```c
#include<stdio.h>

int main(void){

    int arrary[3] = { 1,2,3 };

	int (*p_arrary)[3] = arrary;

	printf("%d\n", *(*p_arrary));               // Print 1
	printf("%d\n", *((*p_arrary) + 1));	        // Print 2

    return 0;
}
```

虽然这种做法语法上是能够支持，但是不推荐，我们不妨思考，为什么需要数组指针？拿回最初定义的二维数组 [[p_arrary]] 来作为案例，当这个二维数组定义给一个类型为 <kbd>int (*)[3]</kbd> 的数组指针的时候，使用数组指针去偏移一位能够恰好能够偏移一整个一维数组的地址，即这个二维数组的第二个元素，为什么？因为我们所定义的数组指针的类型为 <kbd>int (*)[3]</kbd>，即 <kbd>int (*)[3]</kbd> -> <kbd>int [3]</kbd>，反观二维数组中每个元素可以看成是一个一维数组，具体来说是一个类型为 <kbd>int [3]</kbd> 的一维数组，所以我们使用一个数组指针操作多维数组的时候能够非常好的切合

既然数组指针的定义能够映射到具体的多维数组，就拿最开始所定义的数组 [[arrary]] 和 数组指针 [[p_arrary]]来说，是否就意味着 [[arrary]] 的时候和 [[p_arrary]] 的时候就完全一样的呢？答案是否定的，在大部分情况下数组指针可以当成多维数组来使用，但并不意味着数组指针就代表着一个多维数组，就拿获取元素的个数来说，对于数组指针它并不知道其所指向的数组中具体有几个元素，只能够知道低维数组中的元素的个数，原因是我们直接通过 [[sizeof]] 关键字获取数组指针的具体占用直接大小的时候，只能获取到 [[4 Bytes]]，因为它是一个指针的定义，而对于一个原生的多维数组的时候，如 [[arrary]]，我们通过 [[sizeof]] 获取它的总长度是能够正常获取到的

!!!INFO
    数组指针严格来说他已经不能算是一个数组的定义，它是一个指向一个整个数组在内存中的首地址的指针


<br/>

#### 数组作为函数的形参
<span id="数组作为函数的形参"></span>

当一个数组作为函数的形参的时候，原有的数组在形参中的类型表示会退化成指针的形式以表示对应的数组

- [[一维数组]] --> [[一级指针]]

```c
int arrary[3] --> int *arrary
```

- [[多维数组]] --> [[数组指针]]
```c
int arrary[3][2] --> int (*arrary)[2]
```

- [[指针数组]] --> [[二级指针]]
```c
char *strs[] --> char **strs
```

<br/>

### 字符串
<span id="字符串"></span>

---

#### 字符串在 c 中的定义
<span id="字符串在c中的定义"></span>

字符串是一段 [[char]] 类型的连续存储空间，也就是一个 char 类型的数组，在 c 语言中，字符串并没有具体的 [[string]] 类型进行定义，而是使用类型 <kbd>char []</kbd> 或者是 [[char *]] 用于定义一个字符串的类型

一个标准的字符串定义，尾元素的值必须为 [[\0]] 才能够构成一个字符串的定义，如下面的代码

```c
int main(void){

    char str[] = {'H','e','l','l','o','w','\0'};
}
```

以上代码则为我们定义了一个字符数组，并让字符数组的尾元素的值置为 [[\0]] 以构成字符串的定义，但是在 c 语言中对于字符串的赋值还有更简便的方式 --> [[""]]，通过 [[""]] 所填写的字符集则为一个标准的字符串定义，通常也称之为 [[字符串常量]]，其会内存中空间中自动开辟一块空间用于存储我们写录入的字符组，并会额外添加 [[1 Bytes]] 大小的内存单元以为该字符组的结尾添加一个 [[\0]] 标识符，最后返回这块内存空间的地址，其通常用来作为表达式的右值出现，并且它所返回的是一个地址，也就意味着我么能够使用  <kbd>char []</kbd> 或者是 [[char *]] 类型的定义来接收这个地址，比较特殊的是，所开辟的这块内存空间在内存中的具体位置会根据这类型的不同定义而不同

- char [ ]
    - 因为字符串是内存中一段连续的char空间，所以理当我们是可以使用char数组来定义一个字符串变量
    - 使用字符串数组所修饰的字符串常量，其具体的存储位置只是根据其定义的不同而不同，比如说把这个字符串数组定义在一个函数作用域内，那么这个字符串就是存储在 [[stack]] 上，比如说使用的 static 所修饰，或是声明称全局，那么它就会被放在 [[.data]] 段中

```c
#include<stdio.h>

int main(void){

    char str[] = "Hello,World!";
    printf("%s\n",str);

    return 0;
}
```

- char *
    - 该方式所修饰的字符串，同样也是一段内存空间连续的字符，但是区别于数组的是，由于其本身是指针，所以我们不能使用 [[sizeof]] 去获取该字符串的具体的长度
    - [[char *]] 所修饰的一个字符串常量，会存储在内存的 [[.rodata]] 段中，也就是说，这种方式所修饰的字符串是只读的 [[const char *]] ，即我们可以修改指针变量去指向其他地址，却不能够修改指针变量当前所指向的地址在内存中的内容，除此之外，还有一个特性，由于 .rodata 段中的数据的生命周期会延续到程序的结束，也就是说通过该方式所定义的字符串，如果所赋值的字符串是相同的话，则不同的指针变量会指向同一块内存空间，比如说定义了两个字符串：[[char *str1 = "Hello"; char *str2 = "Hello";]] 这时候这两个 char 类型指针所指向的地址其实是同一个的

```c
#include<stdio.h>

int main(void){

    char *str = "Hello,World!";
    printf("%s\n",str);

    return 0;
}
```

其实，不管是通过 [[char *]] 定义一个字符串也好还是通过一个 <kbd>char []</kbd>，其本质都是一样的， [[char *]] 在定义完成后始终指向字符串首元素的内存地址，并且后面字符的内存地址也是连续的存储空间，而数组本身也是一个指针常量，指向数组首元素的内存地址，但是对于数组或指针，它们之间在类型上还是存在的一些独有的特性，具体就看使用的时候进行取舍了

<br/>

#### c 标准库所提供的针对于字符串操作的 API
<span id="c标准库所提供的针对于字符串操作的API"></span>

#### int sprintf(char *str, const char *format, ...)
##### <string.h>

将 [format形参](#形参format) 所提供的格式化模板再结合所录入的可变参数 [[...]] 生成一个新的字符串，并把这个字符串的数据拷贝到字符指针 [[str]] 所指向的内存空间当中，如果成功返回 [[0]]，如果失败则返回 [[-1]]

如果 [[str]] 所指向的内存段在保证内存空间充足的前体现下，该函数会在写入完成后在结尾添加 [[\0]] 字符串结束标识符

```c
#include <stdio.h>

int main(void){

	char *hello = "Hello";
	char *world = "world";

	char str[64] = { 0 };
	sprintf(str, "%s,%s", hello, world);

    printf("%s\n",str);

    return 0;
}
```

<br/>

#### int sscanf(const char *str, const char *format, ...)
##### <string.h>

将 [format形参](#形参format) 所提供的格式化模式从字符指针 [[str]] 所指向的内存空间中取出数据，并依次写入到所指定的可变参数 [[...]] 所使用的内存空间当中，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    int a, b, c, d;
	char *str = "1 + 2 + 3 = 6";

	sscanf(str, "%d + %d + %d = %d", &a, &b, &c, &d);

	printf("a = %d, b =%d, c = %d, d = %d\n", a, b, c, d);

    return 0;
}
```

<br/>


#### size_t strlen(char const *str) --> <string.h>

获取一个字符串真实有效长度（不包含 [[\0]] )

```c
#include <stdio.h>
#include <string.h>

int main(){

    char *str = "Hello,World!";
	size_t len = strlen(str);

	printf("%d\n", len);

    return 0;
}
```

<br/>

#### char *strstr(char *source_str, char *sub_str)
##### <string.h>

自左向右检索字符串 [[source_str]] 中，字符串 [[sub_str]] 第一次出现的位置，如果存在，则返回出现位置开始的地址，<span style = "color:red">该地址并不是一个新的地址，而是相对于字符串 [[source_str]] 首地址进行 n 位偏移的地址</span> ，如果不存在，则返回空指针

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *source_str = "Hello,World!";
	char *sub_str = "Wo";

	char *find_str = strstr(source_str, sub_str);

	printf("%s\n", find_str);

    return 0;
}
```

```c
+---+
| 0 |
+---+ <---+ 0x00ee7b3B
| d |
+---+ <---+ 0x00ee7b3A
| l |
+---+ <---+ 0x00ee7b39
| r |
+---+ <---+ 0x00ee7b38
| o |
+---+ <---+ 0x00ee7b37
| W |
+---+ <---+ 0x00ee7b36 <----+ find_str
| , |
+---+ <---+ 0x00ee7b35
| o |
+---+ <---+ 0x00ee7b34
| l |
+---+ <---+ 0x00ee7b33
| l |
+---+ <---+ 0x00ee7b32                                     +---+
| e |                                                      | o |
+---+ <---+ 0x00ee7b31                                     +---+ <---+ 0x00ee7b51
| H |                                                      | W |
+---+ <---+ 0x00ee7b30 <----+ source_str                   +---+ <---+ 0x00ee7b50 <----+ sub_str
```

<br/>

#### char *strchr(const char *source_str, int sub_char)
##### <string.h>

自左向右检索字符串 [[source_str]] 中，字符 [[sub_char]] 第一次出现的位置，如果存在，则返回出现位置开始的地址，<span style = "color:red">该地址并不是一个新的地址，而是相对于字符串 [[source_str]] 首地址进行 n 位偏移的地址</span> ，如果不存在，则返回空指针

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *source_str = "Hello,World!";
	char sub_char = 'l';

	char *find_str = strchr(source_str, sub_char);

	printf("%s\n", find_str);

    return 0;
}
```

```c
+---+
| 0 |
+---+ <---+ 0x00ee7b3B
| d |
+---+ <---+ 0x00ee7b3A
| l |
+---+ <---+ 0x00ee7b39
| r |
+---+ <---+ 0x00ee7b38
| o |
+---+ <---+ 0x00ee7b37
| W |
+---+ <---+ 0x00ee7b36 
| , |
+---+ <---+ 0x00ee7b35 
| o |
+---+ <---+ 0x00ee7b34
| l |
+---+ <---+ 0x00ee7b33
| l |
+---+ <---+ 0x00ee7b32 <----+ find_str                                 
| e |                                                      
+---+ <---+ 0x00ee7b31                                     +---+
| H |                                                      | W |
+---+ <---+ 0x00ee7b30 <----+ source_str                   +---+ <---+ sub_char
```

<br/>

#### char *strcpy(char *dest, const char *src)
##### <string.h>

把字符串 [[src]] 中的所有数据数据拷贝到字符串 [[dest]] 中 ( 字符指针 [[src]] 所指向的内存空间中存储的数据拷贝到字符指针 [[dest]] 所指向的内存空间中 )，并返回 [[dest]] 所指向的首地址

该函数的使用是不太安全的，因为我们需要保证 [[dest]] 所指向的内存段的大小要满足于 [[src]] 所指向的内存段，就算 [[dest]] 所指向的内存段的大小小于 [[src]] 所指向的内存段，该函数还是会调用成功，但是可能会产生 [[野指针]] 的数据

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str_source = "Hello,World!";
	char str_cpy[32] = { 0 };

	strcpy(str_cpy, str_source);

	printf("source = %s\n",str_source);
	printf("copy   = %s\n",str_cpy);

    return 0;
}
```

<br/>

#### char *strncpy(char *dest, const char *src, size_t n)
##### <string.h>

把字符串 [[src]] 中的 [[n]] [[Bytes]] 的数据拷贝到字符串 [[dest]] 中 ( 字符指针 [[src]] 所指向的内存空间中存储的前 [[n]] [[Bytes]] 的数据拷贝到字符指针 [[dest]] 所指向的内存空间中 )，并返回 [[dest]] 所指向的首地址

该函数较于 [[strcpy]] 函数是安全的，因为该函数在拷贝的过程中能够指定具体需要从 [[str]] 中拷贝 [[n]] 个 [[bytes]] 的数据，这样就能够减少发生 [[野指针]] 数据的可能

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str_source = "Hello,World!";
	char str_cpy[32] = { 0 };

	strncpy(str_cpy, str_source, strlen(str_source));

	printf("source = %s\n",str_source);
	printf("copy   = %s\n",str_cpy);

    return 0;
}
```

<br/>

#### char *strcat(char *dest, const char *src)
##### <string.h>

把字符串 [[src]] 中的有效数据 ( 不包含 [[\0]] ) 全部追加写入到字符串 [[dest]] 所指向的内存空间当中，并在 [[dest]] 字符串有效数据的末尾添加 [[\0]] 字符，最后会返回 [[dest]] 所指向的首地址

该函数是不安全的，因为我们需要保证 [[dest]] 所指向的内存段要有足够的空间去追加 [[src]] 所指向的内存空间里面的数据，就算 [[dest]] 所指向的内存段的大小并没有足够的空间去追加 [[src]] 所指向的内存空间段里面的数据，该函数还是会调用成功，但是可能会产生 [[野指针]] 的数据

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str_source = "World!";
	char str_dest[16] = "Hello,";
	strcat(str_dest, str_source);

	printf("%s\n", str_dest);
    return 0;
}
```

<br/>

#### char *strncat(char *dest, const char *src, size_t n)
##### <string.h>

把字符串 [[src]] 中前 [[n]] [[Bytes]] 的有效数据 ( 不包含 [[\0]] ) 追加写入到字符串 [[dest]] 所指向的内存空间当中，并在 [[dest]] 字符串有效数据的末尾添加 [[\0]] 字符，最后会返回 [[dest]] 所指向的首地址

该函数较于 [[strcat]] 函数是安全的，因为该函数在调用的过程中能够决定具体需要从 [[str]] 中读取 [[n]] 个 [[bytes]] 的数据再追加到 [[dest]] 所指向的内存空间当中，这样就能够减少发生 [[野指针]] 数据的可能

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str_source = "World!";
	char str_dest[16] = "Hello,";
	strcat(str_dest, str_source, strlen(str_source));

	printf("%s\n", str_dest);
    return 0;
}
```

<br/>

#### int strcmp(const char *str1, const char *str2)
##### <string.h>

挨个比较 [[str1]] 字符串和 [[str2]] 字符串中每个字符的 [[ASCII 码]] 大小
- 如果所有字符都是相同则返回 [[0]] 
- 如果 [[str1]] 中的某个字符 [[>]] [[str2]] 中的某个字符则返回 [[1]]
- 如果 [[str1]] 中的某个字符 [[<]] [[str2]] 中的某个字符则返回 [[-1]]

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str1 = "abc";
	char *str2 = "adc";
	int result = strcmp(str1, str2);

	printf("result = %d\n", result);

    return 0;
}
```

<br/>

#### int strncmp(const char *s1, const char *s2, size_t n)
##### <string.h>

挨个比较 [[str1]] 字符串和 [[str2]] 字符串中前 [[n]] 个字符的 [[ASCII 码]] 大小

- 如果所有字符都是相同则返回 [[0]] 
- 如果 [[str1]] 中的某个字符 [[>]] [[str2]] 中的某个字符则返回 [[1]]
- 如果 [[str1]] 中的某个字符 [[<]] [[str2]] 中的某个字符则返回 [[-1]]

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str1 = "abc";
	char *str2 = "adc";
	int result = strcmp(str1, str2, strlen(str1));

	printf("result = %d\n", result);

    return 0;
}
```

<br/>

#### char *strtok(char *str, const char *delim)
##### <string.h>

根据字符串 [[delim]] 所给定的字符 ( <span style="color:red">可以给定字符串进行多字符匹配，需要注意的是，该函数至始至终都是按照一个字符一个字符去匹配的，而不会根据一串字符串</span> ) 去分割 [[str]] 字符串中的内容，并返回分割后前置的结果的首地址 ( <span style = "color:red">该地址并不是一个新的地址，而是相对于字符串 [[str]] 首地址进行 n 位偏移的地址</span> )，并且会在原有字符串 [[str]] 的基础上，形成分割的部分所映射的内存空间置为 [[\0]]，如果字符串 [[str]] 中没有任何内容以供分隔符 [[delim]] 做分割，则该函数会直接返回 [[str]] 所指向的首地址，举个例子，给定原始字符串为 [["Hello.World.NGPONG"]] 并使用 [["."]] 作为分隔符，则调用一次后的结果则为 [["Hello\0"]] ，而原始字符串的内容则变成 [["Hello\0World.NGPONG"]]

该函数所对应的源文件中保有一个 [[静态变量]] ，该静态变量会保存在上一次调用成功该函数后，所分割的剩余的内容，比如说，给定原始字符串为 [["Hello.World.NGPONG"]] 并使用 [["."]] 作为分隔符，则调用一次后的结果则为 [["Hello\0"]]，而原始字符串的内容则变成 [["Hello\0World.NGPONG"]] ，而在该函数调用完成后，其内部的静态变量所存储的则为 [["World.NGPONG"]]，当我们对于参数 [[str]] 指定为 [[NULL]] 的时候，此次分割操作所需的字符串数据源则采纳上一次分割后所剩下的结果来充当，即 [["World.NGPONG"]]，我们可以采纳这一特性去循环的分割一个字符串中的所有内容，直至该函数的结果返回 [[NULL]] ( 当找不到任何分隔符 [[delim]] 在原始字符串中找不到任何数据进行分割的时候，则返回所传入的 [[str]] 所指向的首地址 ) ，则表示已经没有任何内容以供分割

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char str[] = "He.ll.oW.or.ld!";

	printf("%s\n", strtok(str, "."));

	char *str_split = NULL;
	while (1) {

		str_split = strtok(NULL, ".");
		if (str_split == NULL) {
		
			printf("end of strtok");
			return;
		}
		printf("%s\n", str_split);
	}

    return 0;
}
```
```c
+---+                                                           +---+
| 0 |                                                           | 0 |
+---+ <---+ 0x00ee7b3F                                          +---+ <---+ 0x00ee7b3F
| . |                                                           | 0 |
+---+ <---+ 0x00ee7b3E                                          +---+ <---+ 0x00ee7b3E
| d |                                                           | d |
+---+ <---+ 0x00ee7b3D                                          +---+ <---+ 0x00ee7b3D
| l |                                                           | l |
+---+ <---+ 0x00ee7b3C                                          +---+ <---+ 0x00ee7b3C
| . |                                                           | 0 |
+---+ <---+ 0x00ee7b3B                                          +---+ <---+ 0x00ee7b3B
| r |                                                           | r |
+---+ <---+ 0x00ee7b3A                                          +---+ <---+ 0x00ee7b3A
| o |                                                           | o |
+---+ <---+ 0x00ee7b39                 +-+RESULT+->             +---+ <---+ 0x00ee7b39
| . |                                                           | 0 |
+---+ <---+ 0x00ee7b38                                          +---+ <---+ 0x00ee7b38
| W |                                                           | W |
+---+ <---+ 0x00ee7b37                                          +---+ <---+ 0x00ee7b37
| o |                                                           | o |
+---+ <---+ 0x00ee7b36                                          +---+ <---+ 0x00ee7b36
| . |                                                           | 0 |
+---+ <---+ 0x00ee7b35                                          +---+ <---+ 0x00ee7b35
| l |                                                           | l |
+---+ <---+ 0x00ee7b34                                          +---+ <---+ 0x00ee7b34
| l |                                                           | l |
+---+ <---+ 0x00ee7b33                                          +---+ <---+ 0x00ee7b33
| . |                                                           | 0 |
+---+ <---+ 0x00ee7b32                                          +---+ <---+ 0x00ee7b32
| e |                                                           | e |
+---+ <---+ 0x00ee7b31                                          +---+ <---+ 0x00ee7b31
| H |                                                           | H |
+---+ <---+ 0x00ee7b30 <----+ str                               +---+ <---+ 0x00ee7b30 <----+ str      
```

<br/> 

#### int atoi(const char *str)
##### <string.h>

将字符串转换为整型，如果成功则返回转换成功后的数字，如果失败则返回 [[0]]

该函数会整体扫描 [[str]] 字符串，并跳过空格字符，直到遇到数字或正负号才作为转换依据的开始，而遇到非数字或结束符 [[\0]] 才作为转换依据的结束

```c
#include <stdio.h>
#include <string.h>

int main(void) {

	char *str = "   1024a";

	int i = atoi(str);

	return 0;
}
```

<br/> 

#### int atof(const char *str)
##### <string.h>

将字符串转换为浮点型，如果成功则返回转换成功后的数字，如果失败则返回 [[0]]

该函数会整体扫描 [[str]] 字符串，并跳过空格字符，直到遇到数字或正负号才作为转换依据的开始，而遇到非数字或结束符 [[\0]] 才作为转换依据的结束

```c
#include <stdio.h>
#include <string.h>

int main(void) {

	char *str = "   1024a";

	float i = atof(str);

	return 0;
}
```

<br/> 

#### int atol(const char *str)
##### <string.h>

将字符串转换为长整型，如果成功则返回转换成功后的数字，如果失败则返回 [[0]]

该函数会整体扫描 [[str]] 字符串，并跳过空格字符，直到遇到数字或正负号才作为转换依据的开始，而遇到非数字或结束符 [[\0]] 才作为转换依据的结束

```c
#include <stdio.h>
#include <string.h>

int main(void) {

	char *str = "   1024a";

	long i = atol(str);

	return 0;
}
```

<br/>

#### void *memset(void *ptr, int value, size_t n)
##### <string.h>

初始化指针 [[ptr]] 所指向的内存段中前 [[n]] 的 [[Bytes]] 的值为 [[value]]

由于该函数是按 [[Bytes]] 来进行初始化我们所预设的值 [[value]]，故 [[value]] 的真实取值范围为 [[0 ~ 255]]，即 [[1111 1111]] ，举个例子，比如说我们设置 int 的类型 4 个字节的值为 63，那么这个 int 类型在内存中所真实存储的数据如下图

```c
+---------+
|0011 1111|
+---------+
|0011 1111|
+---------+
|0011 1111|
+---------+
|0011 1111|
+---------+
```

```c
#include <stdio.h>
#include <string.h>

int main(void){

 	char str[8] = { 0 };
	memset(str, 65, sizeof(str) - 1);

	printf("%s\n", str);

    return 0;
}
```

<br/>

#### void *memcpy(void *dest, const void *src, size_t n)
##### <string.h>

将 [[src]] 所指向的内存空间中的前 [[n]] 个 [[Bytes]] 的数据拷贝到 [[dest]] 所指向的内存空间中

虽然该函数对于拷贝的效率比较高，但是对于 [[dest]] 和 [[src]] 所指向的内存空间中存在 <span style="color:red">重叠区域</span> 的问题时，该函数可能会出现错误

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str_source = "Hello,World!";
	char str_dest[64] = { 0 };

	memcpy(str_dest, str_source, strlen(str_source));

	printf("%s\n", str_dest);

    return 0;
}
```

<br/>

#### void *memmove(void *dest, const void *src, size_t n)
##### <string.h>

将 [[src]] 所指向的内存空间中的前 [[n]] 个 [[Bytes]] 的数据拷贝到 [[dest]] 所指向的内存空间中

该函数和 [[memcpy]] 的功能是一致的，但是该函数在对于 [[dest]] 和 [[src]] 所指向的内存空间中存在 <span style="color:red">重叠区域</span> 的问题时，该函数任然能够正常执行，而就效率而言，该函数任然要低于 [[memcpy]]

```c
#include <stdio.h>
#include <string.h>

int main(void){

    char *str_source = "Hello,World!";
	char str_dest[64] = { 0 };

	memmove(str_dest, str_source, strlen(str_source));

	printf("%s\n", str_dest);

    return 0;
}
```

<br/>

#### int memcmp(const void *buffer1, const void *buffer2, size_t n)
##### <string.h>

挨字节比较 [[buffer1]] 所指向的内存空间和 [[buffer2]] 所指向的内存空间中前 [[n]] 个字节的大小

- 如果所有字节都相同，则返回 [[0]] 
- 如果 [[buffer1]] 所指向的内存空间中的某个字节 [[>]] [[buffer2]] 所指向的内存空间中的某个字节，则返回 [[1]]
- 如果 [[buffer1]] 所指向的内存空间中的某个字节 [[<]] [[buffer2]] 所指向的内存空间中的某个字节，则返回 [[-1]]

```c
#include <stdio.h>
#include <string.h>

int main(void){

    /*
	0000 0000
	0000 0000
	0000 0000
	0001 1001
	*/
	int a = 25; 

	/*
	0000 0000
	0000 0000
	0000 0000
	0011 1001
	*/
	int b = 57;

	int result = memcmp(&a, &b, sizeof(int));

    return 0;
}
```


<br/>

### heap
<span id="heap"></span>

---

前面在内存4区中说到，关于堆的管理由开发人员进行维护和释放，在 c 中，对于 [[heap]] 的管理操作由以下几个函数来完成

#### void *malloc(size_t size)
##### <corecrt_malloc.h>

该函数能够在堆中申请 [[size]] 个内存单元的存储空间，如果成功，则返回指向这段存储空间中的首地址的万能指针，意味着在这个首地址往后的 [[size]] 个 ( 包括首地址 ) 字节的地址都是成功申请且安全可用的，如果申请失败，则返回一个空指针

所申请 [[size]] 个内存单元中的地址是 [[连续]] 的，通过这一特性，我们通常把所申请的内存空间用于当作 [[数组]] / [[结构体]] / [[字符串]] 来使用

该函数如果 [[size]] 指定的字节大小为 [[0]] 的时候，还是能够成功申请的，但是一旦我们尝试对所返回的地址进行任意写入操作的时候，我们在后面尝试通过 [[free]] 函数释放这块内存空间的时候就会出现错误，当然这种情况并不仅仅针对我们申请了 [[0 Bytes]] 的空间，而是我们所使用的内存空间不能够大于所申请的内存空间，否则该内存段在调用 [[free]] 函数释放的时候则会出现错误

```c
int main(void) {

    int *nums = malloc(sizeof(int) * 4);
	if (nums == NULL) {
	
		perror("heap error");
		return -1;
	}
	nums[0] = 1;
	nums[1] = 2;
	nums[2] = 3;
	nums[3] = 4;

	for (size_t i = 0; i < 4; i++) {

		printf("%d\t", *(nums + i));
	}

	free(nums);

    return 0;
}
```

<br/>

#### void free(void *ptr)
##### <corecrt_malloc.h>

根据指向堆中所申请的一段存储空间的首地址 [[ptr]] 的指针释放掉其所对应申请的空间

在成功调用完该函数后，ptr 所对应所指向的内存空间不会立即释放，只是标记为释放，并未真正释放，简而言之就是程序放弃了对这块内存空间的使用权限，内核系统会在适当的时候会真正的释放掉这块内存空间所使用的诗句或者是填充为其他数据

对于一个空指针来说该函数是能够成功调用的，并且可以反复进行调用，但是对于非空指针并且是一个已经进行过 [[free 函数调用的指针]] 来说，重复调用则会出现错误

[[ptr]] 必须是一个真实有效的指针，并且 [[它所指向的地址必须为在堆中所申请的内存空间的首地址]] ，比如说申请了 20 个字节的空间，返回地址为 [[0x00000001]]，这时候我们尝试让这个指针偏移1位 ( 指针类型为 [[char *]] )，那指针所指向的地址则为 [[0x00000002]]，这时候我们使用这个指针调用这个 [[free]] 函数的时候则会出错，原因是当前指针的地址并不是所申请的内存空间的首地址 [[0x00000001]] ，造成这种问题的原因是因为每次在堆中申请空间后，都会有一种记录表记录着当前所申请的内存大小，还有其对应的内存单元的首地址，我们申请空间的时候所返回的指针指向的地址为 [[0x00000001]] ，那么那张表中就是记录着 [[0x00000001]] 这时候我们使用 [[0x00000002]] 的地址区释放，就会报错了，因为在表中找不到相应的映射 

```c
#include<stdio.h>

struct Person {

    char *name;
    int age;
};

int main(void){

    struct Person *pers = malloc(sizeof(struct Person[2]));
    if (pers == NULL) {
        
        perror("heap error");
        return -1;
    }

    pers[0].name = "NGPONG";
    pers[0].age = 23;

    pers[1].name = "TEST";
    pers[1].age = 999;

    printf("pers[0] name = %s\n", pers[0].name);
    printf("pers[0] age = %d\n", pers[0].age);
    printf("pers[1] name = %s\n", pers[1].name);
    printf("pers[1] age = %d\n", pers[1].age);

    free(pers);

    return 0;
}
```

<br/>

#### void *calloc(size_t nmemb, size_t size)
##### <corecrt_malloc.h>

该函数能够在堆中申请 [[size]] 个内存单元的存储空间，如果成功，则返回指向这段存储空间中的首地址的万能指针，意味着在这个首地址往后的 [[size * nmemb]] 个 ( 包括首地址 ) 字节的地址都是成功申请且安全可用的，如果申请失败，则返回一个空指针

该函数的使用和 [[malloc]] 一致，故这里不做额外的讲解

```c
#include<stdio.h>

int main(void){

	char *str = calloc(sizeof(char), 64);
	if (str == NULL) {
		
		perror("heap error");
		return -1;
	}

	memcpy(str, "Hello,World!", 13);
	printf("%s\n", str);

	free(str);

    return 0;
}
```

<br/>

#### void *realloc(void *ptr, size_t size)
##### <corecrt_malloc.h>

该函数能够重新分配 [[ptr]] 在堆中可用内存空间的大小，如果重新申请成功，该函数则返回在堆中新分配的内存空间的首地址 ( 可能是原始 [[ptr]] 所指向的地址 ) ，如果申请失败，则返回 [[NULL]]

- 如果指定的 [[ptr]] 所指向的地址所代表的内存段的后面还留有连续的空间，那么就会在已有地址基础上增加内存，[[并返回原始 ptr 所指向的地址]]
- 如果指定的 [[ptr]] 所指向的地址的后面没有连续的空间，那么该函数会在堆中重新申请一块连续的内存，[[并把 ptr 旧内存空间所存储的值拷贝到新申请的内存空间中，同时释放 ptr 所指向的旧内存空间，最后返回新申请的内存的地址]]
- 如果指定的 [[ptr]] 原有的内存空间大小要小于所指定的 [[size]] ，则会根据原有 [[ptr]] 所申请的内存空间去保留 [[size]] 个内存单元，余后的内存空间全部都释放掉，最后返回原始 [[ptr]] 所指向的地址

```c
#include<stdio.h>

int main(void){

	char *str = calloc(sizeof(char), 13);
	if (str == NULL) {
		
		perror("heap error");
		return -1;
	}

	memcpy(str, "Hello,World!", 13);
	printf("%s\n", str);

	str = realloc(str, 32);
	if (str == NULL) {

		perror("heap error");
		return -1;
	}

	memcpy(str, "realloc memtest!", 32);
	printf("%s\n", str);

	free(str);

    return 0;
}
```


<br/>

### 函数
<span id="函数"></span>

---

#### 函数的声明和定义
<span id="函数的声明和定义"></span>

在 c 中，函数的定义和其他语言类似，也是要遵循 [[返回值]] [[函数名]] [[参数]] [[函数体]] 的格式进行一个函数的定义，存在着一点不同的是，，以下代码则为我们定义了一个函数

```c
#include<stdio.h>

int fun_test(void){

    printf("fun_test ok!");
    return 0;
}

int main(void){

    fun_test();
    return 0;
}
```

!!!INFO
    这里需要额外扩充几点
    - 在 c 中，函数的定义通常以 [[int类型的返回值作为当前函数调用的状态]]，如果返回 [[ 0 则代表成功]]，返回 [[非 0 则代表失败]]
    - 一个函数一旦定义成功，其会存储在内存的 [[.text]] 段当中
    - 在 c 中可以对 [[参数]] 列表中使用 [[void]] 以强调该函数是一个无参的函数，虽然使用了该方式后对编译器进行编译的时候没有什么影响，甚至我们把函数定义为无参函数也同样可以传参数进去，但通过这种方式定义一个无参的函数能够让开发人员更好的注意到该函数在参数上的特性


在 c 中，对于一个函数的调用，必须要存在该函数的定义，如果一个函数并没有进行过定义而我们还是尝试使用了这个函数的话，则会出现编译级的错误

此外，如果函数的定义并不在调用该函数代码那一行之前进行的定义，则需要有一个函数的声明，函数声明的作用则是把 [[函数名]] [[函数的返回值类型]] 以及 [[函数形参列表]] ( 不包括函数体，也可以不用包括形参列表中具体变量的变量名 ) 以声明的方式预对编译器进行统治，以便在编译器对调用了该函数代码进行编译的时候，据此声明进行逐文件 ( 包括当前文件的任意位置 ) 检查是否有符合该声明的函数的定义，如果有的话，则会把该声明隐式提升为所映射定义的函数的定义

那么如果调用函数的代码在定义函数之前，并且调用函数代码之前也没有进行过函数的声明，则编译器以默认的格式为我们添加一个 [[函数的声明]]，这个格式则为  [[返回值为 int 类型，函数名相同，没有参数]]，这种方式也称作 [[函数的隐式声明]]，但是这个隐式声明存在一点情况需要注意，比如我们在主函数中调用了一个函数 [[void fun_Test()]] ，这个函数是定义在 main 函数的后面，而 main 函数之前也没有声明过此函数，这时候在编译的时候，由于隐式的帮我把添加一个当前函数的声明 [[int fun_Test()]]，这时候继续编译的时候就会报错了，为什么？因为隐式声明的函数和 [[本身fun_Test]] 函数的定义的返回值是不一样的，一个是 [[int]] ，一个是 [[void]] ，这时候就会出现函数的重载的情况，但是在 c 中函数是无法重载的，所以就会造成编译错误 [[重定义 : 不同的基类型]]

在 c 中，[[不管是函数的声明也还还是函数的定义，都不能存在重载的情况]]，这是 c 语言本身所不支持的，并且，函数的定义不能在相同函数 [[signature]] 的基础上进行重复定义，而函数的声明是支持在相同函数 [[signature]] 的基础上进行重复定义的

```c
#include<stdio.h>

int fun_test(char *str);

int main(void){

    char *str = "Hello,World!";
    fun_test(str);

    return 0;
}

int fun_test(char *str){

    printf("%s\n",str);
}
```

<br/>

#### 栈与栈帧
<span id="栈与栈帧"></span>

什么是栈 ?

栈是计算机系统负责维护的一块动态内存区域，它属于数据结构中的一种，限定仅在表尾进行插入或删除操作的线性表，按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据

!!! 

    这里被叫做压栈，但实际上栈的存储结构由于是高地址向低地址延伸，所以其存储模型是倒过来的，故压栈其实称为 [[顶栈]] 个人认为更为合适

把栈简单理解成集合也不为过，而作为集合中的元素就是帧 ( frame ) ，具体来讲则是 [[栈帧]]

在栈中，始终有一个指针指向栈顶 ( [[最上级栈帧]] ) ，它是 [[ESP(X86) / RSP(X64)]] 寄存器

<span style="color:red">栈是从高地址向低地址延伸</span>，区别于之前所讨论到的二进制数据在内存中的存在方式 ( [[由低向高衍生]] ) ，关于栈为什么要设计从从高地址向低地址衍生的原因，可以参考这篇 [文章](https://www.zhihu.com/question/29520755) 的讨论内容


什么是栈帧

栈帧是栈中所存储的元素，每个所压入栈的栈帧可以代表着一个函数的调用，栈帧也叫过程活动记录，是 [[编译器用来实现 过程 / 函数 调用的一种数据结构]] ，每一次函数的调用，都会把函数中的一些信息做一次独立的封装 ( 栈帧 ) ，并最终把它上压入栈上，以供处理器进行调用，压栈的过程我们可以理解为一个函数生命周期的开始，当一个函数调用结束后 ( 具体来说执行了 [[ret 指令]] ) 并返回相应的值 (压栈前代码执行段的地址) ，这个栈帧也会随之出栈，也就是一个函数的生命周期的结束，在最后会释放掉这个栈帧所使用的内存空间 ( 只是标记为释放，并未真正释放，简而言之就是程序放弃了对这块内存空间的使用权限，在适当的时候会真正的释放或填充为其他数据 )

每个栈帧之间是相互独立的存在，一个独立的栈帧中大致包括

- 函数的返回地址
- 函数的形参
- 函数的非静态局部变量以及编译器自动生成的其他临时变量
- 函数调用的上下文
- 调用函数前代码执行段的地址

<span style="color:red">在一个函数中所定义的非静态局部变量会依代码顺序至上而下的压入栈帧中</span>，<span style="color:red">而一个函数中的形参在默认的 [[调用惯例]] 下会按定义顺序从右至左的压入栈帧中</span>，需要注意的是，它们的地址始终都是从高位到低位进行定义存储的，此外，函数的形参由右至左从高位到低位默认偏移4个字节的内存地址，如果形参的类型大于4个字节，则偏移对应类型存储空间大小的地址，比如说形参为 [[char a,double b,int c]] ,那么它们的内存空间地址则为

- a : 0x00000000
- b : 0x00000004
- c : 0x0000000C

在一个栈帧中，始终有一个指针指向栈帧的底部，他就是 [[EBP]] 寄存器， 前面说到，栈帧是栈里面所压入的元素，而栈帧之间是相互独立的存在的，当我们调用一次函数的时候，就会把当前函数的一些信息依次压入栈中，那么是如何做到不同栈帧之间的独立性呢？就是依靠的两个指针 [[Stack Pointer]] [[Frame Pointer]] ，当函数在调用的时候，内核会封装好函数的信息到一个栈帧中并将其压入栈内，[[Stack Pointer]] 会相应的往后偏移 [[4 (X32) / 8 (X86)]] 位，使得 [[Stack Pointer]] 位于栈帧的顶部，此外， [[Frame Pointer]] 也会移动至 [[Current Stack Frame]] 身上，以此来划定一个栈帧所存在的范围

以下则为栈帧和栈的存储示意图

```c
   TOP	       STACK BOTTOM
    ↑	        	↑
    |	        	|  	   
    |	        	+-------------------------------------------------------------------+
    |	        	|	**********************											|			
    |	        	|	*     More Frame     *   										|			
    |	        	|	**********************  										|
    |	        	|																	|														
    |	        	|	+--------------------+--> Frame Pointer: EBP 					|
    |	         	|	|  Return Address    |											|
    |	        	|	|  Function Content  +--> Function Name: main  					|			
    |	        	|	|  Local variable	 |   										|			
    |	        	|	|  Parameter     	 |  										|			
    |	        	|	+--------------------+--> Stack Pointer: ESP(X86) / RSP(X64)    |				
    |	        	|	   																|	    	
   LOW              +																	+        
                    |
                    ↓
                STACK TOP
```

<br/>

#### 关于函数的返回值问题
<span id="关于函数的返回值问题"></span>

由于一个函数内部的大部分定义的生命周期都活动在一个栈帧的范围内，也就是说在一个函数调用结束后，也就是栈帧出栈后，栈帧内部所使用的存储空间会被标记为释放，所以关于函数的返回值有一些需要进行注意的地方

- 返回普通的变量
    - 这种方式返回是没任何问题的，因为返回的普通变量的值只是对于当前调用函数上下文中某个内存空间所映射的值拷贝到另一个调用者栈帧中的工作

- 返回指针
    - 当我们需要返回指针变量的时候，切记， [[所返回的指针的指向不能是当前所调用函数上下文中的任何一个变量的信息]] ，包括形参、局部变量、使用 [[const]] 所修饰的局部变量、…… 等一切非静态的变量，因为一个函数在调用完成后，其所对应的栈帧也会出栈，并且所使用的内存空间也会被标记为销毁，虽然我们在第一次调用完一个返回指向当前调用函数上下文信息局部变量的指针的时候，这个指针所对应的内存空间的值在后面还是可以继续读取到，毕竟这个指针的内存地址是一个已被标记为销毁的状态，也就是程序只是放弃了对这块内存空间的使用权限，但不意味着马上销毁，意味着系统内核可能会在未来的某个时刻中将这个内存地址所占用的空间真正的释放掉或填充为其他数据，所以需要谨记的是，当使用指针作为函数返回值的时候，一定不能返回当前调用函数上下文中的任何信息的指针

- 返回数组
    - 从语法上是不可行的，所以我们只能够返回一个指针

<br/>

#### 函数指针
<span id="函数指针"></span>

一个函数在编译器进行编译后，它也有属于它的地址，这个地址就是属于该函数的一个入口，相对的，他也是有属于它的类型，比如说我们定义了一个函数

```c
#include<stdio.h>

void fun_test(int a){

    printf("Hello,World!%d",a);
}
```

那么这个函数 [[fun_test]] 的类型就是 [[void (int)]]，既然它有属于它的类型，并且还有一个函数的入口地址，所以我们可以通过一个指针变量来修饰一个函数，而用于修饰函数的指针变量就称为 [[函数指针]]

当我们声明了一个函数指针，那么我们应该怎么样获取一个函数的入口地址以作函数指针的右值？通过 [[&函数名]] / [[单纯的使用函数名]] 即可获取到函数的入口地址，需要注意的是，虽然我们可以通过 [[&函数名]] 拿到函数的入口地址，并把它交给一个函数指针作为存储，但是如果我们单纯的使用 [[&函数名]] 打印函数的入口地址的时候，会发现其和存储在函数指针中的地址是不同的，不过这也没关系，我们只需要理解这种方式是能够正确地拿到某个函数的入口地址即可

当我们已经定义好一个函数指针后，其使用方式也和普通指针存在着一些区别，普通指针的使用方式我们还需要使用操作符 [[*]] 对地址进行解引用后才能操作指针变量内部存储的地址所对应的内存空间，而函数指针在定义好后，我们只需要像普通函数一样使用即可以完成对其所指向的函数首地址的调用，以下代码则为我们定义了一个函数指针并对它进行使用

```c
#include<stdio.h>

int fun_test(char a,short b){

    printf("Hello,World!%d",a + b);
}

int main(void){

    int (*invoker)(char,short) = fun_test;
    invoker('a',256);

}
```

通过上面展示函数指针的定义方式，我们发现函数指针的定义和 [[数组指针]] 的定义方式也是类似，也是通过 [[( )]] 来提升了操作符 [[*]] 的优先级，在以上代码中，即 [[*invoker]] 组成了指针的定义，而其函数的类型就是 [[int (char,short)]]

除了能够定义一个函数指针外，我们还能够定义一个函数指针的数组，如下面的代码

```c
#include<stdio.h>

int fun_test1(void){

    printf("Hello,World1!");
}

int fun_test2(void){

    printf("Hello,World2!");
}

int fun_test3(void){

    printf("Hello,World3!");
}

int main(void){

    int (*invokers[3])(char,short);
    invokers[0] = fun_test1;
    invokers[1] = fun_test2;
    invokers[2] = fun_test3;

    for (size_t i = 0; i < sizeof(invokers) / sizeof(int (*)()); i++) {

        (*(invokers + 1))();
    }
}
```

以上面代码则为函数指针数组的定义和使用，我们发现函数指针数组的定义方式也是通过 [[( )]] 来把 <kbd>*invokers[3]</kbd> 结合为指针数组，而这种类型也是符合 [[指针数组]] 类型的定义，所以，函数指针数组其实就是一个指针数组，每个元素类型是 [[函数指针]] 的类型


<br/>

### 结构体
<span id="结构体"></span>

---

有时我们需要将不同类型的数据组合成一个题有结构的整体，比如说一个学生身上的结构有 [[学号]] [[姓名]] [[性别]] [[年龄]] [[地址]] 等属性，那么如果我们单独定义以上的属性变量是一个比较繁琐过程，数据不便于管理，在 c 语言中给出了另一种构造数据类型，他叫做 [[结构体]] ，它是C语言面向对象的一种体现

结构体也是类型的一种，不过它是一种复合类型，即一个类型中包含了多种类型的定义，既然一个结构体类型的定义是通过开发人员来完成，那么我们其实也可以把结构体理解为一种自定义的类型

<br/>

#### 结构体的声明和定义
<span id="结构体的声明和定义"></span>

在 c 中，不管是声明也好还是定义，通过关键字 [[struct]] 才能够构成结构体类型的定义

关于结构体的声明和定义，我们需要先区分开来 [[结构体类型]] 与 [[结构体变量]] 

结构体类型即我们所自定义的结构体的类型，我们为某一种结构体数据类型所声明的内部存储结构模型就为声明一个结构体的类型，下面的代码则为声明了一种结构体类型 [[struct Person]]

```c
struct Person{

    char *name;
    char *address;
    int age;
    int ID;
}

int main(void){

    return 0;
}
```

!!! INFO 注意
    1. 在 c 语言中所声明的结构体类型我们必须要保证该结构体中至少含有一个成员，在 c 语言中不能存在以空结构体的类型存在
    2. 所声明的结构体类型中，对于非函数类型的成员只能够用作于声明，不能有其定义

当我们声明好了一个 [[结构体类型]] 后，我们就能够使用所声明的结构体类型去声明或定义一个结构体变量了

关于结构体变量的声明有以下三种方式

- 普通声明方式

```c
struct Person {

    int Age;
    int Gender;
    char Name[24];
};

int main(void){

    struct Person per;
}
```

- 声明结构体类型的同时声明了结构体变量，该方式所声明的结构体变量是全局变量

```c
#include<stdio.h>

struct Person {

	int Age;
	int Gender;
	char *Name;
} per, *p_per;

int main(void) {

	per.Age = 22;
	per.Gender = 1;
	per.Name = "NGPONG";

	p_per = &per;

	printf("person age = %d\n", p_per->Age);
	printf("person gender = %s\n", p_per->Gender == 1 ? "男" : "女");
	printf("person age = %s\n", p_per->Name);

	printf("per address = %p\n", &per);
	printf("p_per value = %p\n", p_per);

	return 0;
}
```

- 匿名结构体
    - 匿名结构体类型的声明方式是不需要指定结构体类型的类型名的，也就是说我们在声明一个匿名结构体类型的同时，必须要声明它的结构体变量
    - 所声明的匿名结构体变量则为声明了一个全局的匿名结构体变量

```c
#include<stdio.h>

struct {

    int Age;
    int Gender;
    char Name[24];
} per;

int main(void){

	per.Age = 22;
	per.Gender = 1;
	per.Name = "NGPONG";

    printf("%d\n",per.Age);

    return 0;
}
```

关于结构体变量的定义有以下两种方式 ( 这里所说的定义指的是结构体变量初始化的过程，对于一个结构体变量进行初始化的左值操作语法只有一种，那就是在声明结构体变量的过程中通过 [[{ }]] 为结构体类型中的每个成员的顺序由上至下挨个进行预赋值 )

- 普通定义方式，声明结构体变量的同时进行定义

```c
struct Person {

    int Age;
    int Gender;
    char Name[24];
};

int main(void){

    struct Person per = {22,1,"NGPONG"};
}
```

- 声明结构体类型的同时定义了结构体变量，该方式所定义的结构体变量是全局变量
```c
#include<stdio.h>

struct Person {

	int Age;
	int Gender;
	char *Name;
} per = {22,1,"NGPONG"}, *p_per = &per;

int main(void) {

	printf("person age = %d\n", p_per->Age);
	printf("person gender = %s\n", p_per->Gender == 1 ? "男" : "女");
	printf("person age = %s\n", p_per->Name);
	printf("per address = %p\n", &per);
	printf("p_per value = %p\n", p_per);

	return 0;
}
```

<br/>

#### 结构体的内存地址
<span id="结构体的内存地址"></span>

不得不说，结构体的内存地址和数组之间是存在相似性的，首先，当我们去获取结构体变量的地址和获取结构体变量中首个 ( 最上部 ) 成员的地址发现它们是一样的，但是它们却完全不相同，当我们直接获取一个结构体变量的地址的时候，这个地址的步长则是以结构体本身的类型作为参考，而对于结构体首个成员的地址的步长参考的话，则是以该成员本身的类型来作为参考，如下面代码

```c
struct Person {

    int Age;
    int Gender;
    char Name[24];
};

int main(void){

    struct Person per = {22,1,"NGPONG"};
}
```

当我们直接获取结构体变量 [[per]] 的内存地址的时候，该地址的步长参考则按照结构体本身的类型来，即 [[struct Person]]，而对于结构体首个成员 [[Age]] 的地址的步长参考的话，则是以该成员本身的类型来作为参考，即 [[int]]

回过头来，刚才谈到结构体变量的地址和结构体首个成员的地址是相同的，那是不是意味着一个结构体变量就是一段连续的线性存储空间，其总大小就是结构体类型中所有成员大小的总和呢？对于数组来说，是的，数组中每个元素之间的地址互相之间偏移一个具体类型的单位，即步长，而对于结构体来说，该问题的答案就是 [[不一定]] 了，对于结构体其内部的成员所存放的内存首地址和所存放的长度还存在一个 [[地址补齐]] 的概念，在下一个节点会详细的探讨这一个概念

这里说到结构体的地址，不得不谈及结构体指针的概念，同样，既然我们能够获取到一个结构体变量的内存地址，那我们同样可以使用该结构体类型的指针用于接受，还是如上面的代码，假设我们使用了一个指针 [[struct Person *p_per]] 接受了结构体变量 [[per]] 的内存地址后，我们对于该结构体类型的指针 [[p_per]] 想去取结构体变量中某个成员的值得时候只需要解引用即可，如 [[(*per).Age]] 就是获取结构体成员 [[Age]] 在内存中所存储的值，除此之外，对于 [[(*per).Age]] 操作在 [[c]] 中有一个语法糖作为支持，即 [[(*per).Age]] --> [[per->Age]]

```c
#include<stdioh>

struct Person {

    int Age;
    int Gender;
    char Name[24];
} per = {22,1,"NGPONG"};

int main(void){

    struct Person *p = &per;
    printf("Person Age = %d\n",p->Age);
    printf("Person Gender = %d\n",p->Gender);
    printf("Person Name = %s\n",p->Name);

    return 0;
}
```

<br/>

#### 关于结构体的内存对齐的问题
<span id="关于结构体的内存对齐的问题"></span>

什么是内存补齐？在开始前先开一下内存补齐所带来的效果，如下面代码

```c
struct Postion {
    char x;
    int y;
};
```

在上面的代码中，我们声明了一个结构体类型 [[struct Person]] ，该结构体中有两个类型的成员分别为 [[char]] 和 [[int]]，按道理来说该结构体类型所占用的总字节应该为 [[5 Bytes]]，然而实际上的结果却为 [[8 Bytes]]，这个就是发生了 [[内存对齐]]

那么内存对齐到底有什么用呢？

尽管内存是以内存单元作为单位，即字节，但是大部分处理器并不会按一个内存单元来存取内存，它一般会以 [[2 Bytes]] / [[4 Bytes]] / [[8 Bytes]] / [[6 Bytes]] / [[32 Bytes]] 为单位来存取内存，我们将上述这些存取单位称为 [[内存的存取粒度]] ，我们假定现在考虑 [[4 Bytes 存取粒度]] 的处理器 ( 32位系统 ) 去取一个 [[int]] 类型变量的时候，该处理器只能从地址为4的倍数的内存开始读取数据，假如没有内存对齐机制，数据可以任意存放，假定该 [[int]] 类型变量在内存中的首地址为 [[0x00000001]] 那么其在内存中所占用的内存段分别为

```c
+--------+
|        |
+--------+ +---> 0x00000007
|        |
+--------+ +---> 0x00000006
|        |
+--------+ +---> 0x00000005 +--------+
|00000000|                           |
+--------+ +---> 0x00000004          |
|00000000|                           |
+--------+ +---> 0x00000003          +----> INT
|00000000|                           |
+--------+ +---> 0x00000002          |
|00000000|                           |
+--------+ +---> 0x00000001 +--------+
|        |
+--------+ +---> 0x00000000

```

那么当 CPU 去取内存中的数据的时候，我们假定 CPU 需要先从 [[0x00000000]] 地址开始，开始读取 4 个字节，也就是  [[0x00000000]] [[0x00000001]] [[0x00000002]] [[0x00000003]] ，但是 int 类型变量的首地址在 [[0x00000001]] 上，所以 CPU 本次读取需要剔除掉不需要的字节，保留后三位字节，即剔除掉 [[0x00000000]] 字节上的数据，紧接着 CPU 进行第二次访问内存的时候，从刚刚结束的位置开始，又从内存中读取了 [[4 Bytes]]，也就是 [[0x00000004]] [[0x00000005]] [[0x00000006]] [[0x00000007]] ，因为 int 类型总共只有 [[4 Bytes]] ，而 CPU 在第一次读取的时候已经访问了 [[3 Bytes]] ，故本次需要剔除掉 [[0x00000005]] [[0x00000006]] [[0x00000007]] 这 [[3 Bytes]] ，最后 CPU 再把两次读取后所剩下的结果进行合并再交给寄存器已完成本次对于该 [[int 类型变量]] 所存储的数据的访问工作，而在这个工作之中发生了两次访问内存的工作，增加了多余的工作量，我们可以把此次工作归纳为下图

![v2-3f40af513a94901b36ceb5387982277e_hd](https://i.imgur.com/LkIu3y1.jpg)

那么现在假设使用了内存对齐的机制，那么这个int类型的数据只能存放在按照对齐规则的内存中，比如说 [[0x00000000]] 地址开始的内存，这时候 CPU 就能够一次性把这 [[4 Bytes]] 的数据取出来再交到寄存器手上以完成读取工作，而且不需要做额外的操作，提升了工作效率

![v2-361e2d16876ce8383c9e6ea2dca34474_hd](https://i.imgur.com/VNKvS8q.jpg)

经过刚刚上面所说，我们发现内存对齐前和内存对齐后无非就是改变了 int 类型数据在内存中的首地址就能带来很高的效益，没错，内存对齐的主要思想就是能把一个数据的首地址按照一定的规则合理分配到某个地址上以增加 CPU 的读取效率，那么这个规则是什么样的？

首先再开始前，需要明白两个概念
- 对齐模数 : 每个特定平台上的编译器都有自己的默认 对齐模数 ，$GCC$ 中默认为 [[4]]， $MSVC$ 中默认为 [[8]] ，该值通常呈 $x^2$ 进行变更，我们可以通过以下两个语句对 对齐模数 进行变更或查看
    - #pragma pack(n) : 修改对齐模数为 [[n]]
    - #pragma pack(show) : 查看当前对齐模数，<font color = "red">仅需编译即可</font>
- 对齐单位 : 对齐模数 和当前结构体中 <font color = "red">最大长度成员的字节数</font> 两者间进行对比 ( 如果成员为数组，则取的是数组具体类型的单位，比如说某个成员为 <kbd>int [4]</kbd> 的类型，则使用它的 [[int]] 类型作为对比项 ) ，<font color = "red">取长度更小的那个作为对齐单位</font>

首先，结构体中第一个成员在内存中的首地址并无规定，即它的 [[offset]] 为 [[0]]，我们可以理解为从 [[0]] 开始，但并不一定是从 [[0]] 地址开始，而 <font color = "red">首成员具体所占用的字节长度视下一个成员而定</font> ，如果只有一个成员，那么该结构体的大小就是该成员的大小，而该成员所占用的内存空间的长度也就是该成员具体类型的长度

第一个成员以后的每个成员在内存中的首地址所在的位置，亦或者说往后成员相对于当前结构体的 [[offset]] 都是 <font color = "red">当前成员的大小 ( 如果为数组，仅取数组最低维度的元素的类</font>  和 <font color = "red">当前结构体的对齐单位</font> 进行对比 ( 如果所对比的成员的类型是一个 struct，则需要从该结构体内部的成员开始逐个对比，包括对齐单位也是获取的当前结构体成员的对齐单位，而不是取的包括当前结构体成员的结构体的对齐单位 ) ，取更小那个的整数倍作为该成员的首地址，<font color = "red">如有需要，编译器会在成员与成员之前填充空的字节</font>

在最后，该结构体还需要进行二次偏移，结构体的总大小会偏移为当前结构体的 [[对齐单位]] 的整数倍，具体至结构体中每个成员的 <font color = "red">真实字节大小</font> 的总和的近似值，比如说该结构体的 [[对齐单位]] 为 [[4]] ，结构体中所有成员的这真实字节长度为 [[14]] ，则结构体的总大小会偏移至 [[16(4的整数倍)]]，<font color = "red">如有需要编译器会在最末一个成员之后加上填充空的字节</font>


```c
#pragma pack(4)

/*
占用大小: 6 Bytes
对齐单位: 1
*/
struct student {

	char a;					// 0x00000000               1
	char b;					// 0x00000001               1
	char c;					// 0x00000002               1
	char d;					// 0x00000003               1
	char e;					// 0x00000004               1
	char f;				    // 0x00000005               1
};

/*
占用大小: 16 Bytes
对齐单位: 4
*/
struct person {

	char g;					// 0x00000000 ~ 0x00000003	 4
	int i;					// 0x00000004 ~ 0x00000007	 4
	struct student stu;		// 0x00000008 ~ 0x0000000E	 8
};
```

<br/>

#### 关于结构体的深浅拷贝的问题
<span id="关于结构体的深浅拷贝的问题"></span>

当我们定义了如下两个结构体

```c
#include<stdio.h>
#include<string.h>

struct Person {

    char *name;
    int age;
};

int main(void){

    struct Person tom;
    tom.name = malloc(sizeof(char) * 128);
    strcpy(tom.name, "Tom");
    tom.age = 18;

    struct Person jerry;
    jerry.name = malloc(sizeof(char) * 256);
    strcpy(jerry.name, "Jerry");
    jerry.age = 30;

    tom = jerry;

    free(tom.name);
    free(jerry.name);

    return 0;
}
```

当我们想让 [[tom = jerry]] 的时候，由于 [[=]] 操作符的特性，[[jerry]] 结构体变量中的值都会拷贝到 [[tom]] 身上，这个没什么问题，但是因为 [[jerry]] 和 [[tom]] 中的 [[name]] 都是在堆中申请的内存，所以当我们在最后释放的时候就会出现错误了，如下面代码

```c
free(tom.name);
free(jerry.name);
```

为什么最后释放的时候会发生错误？原因是因为 [[=]] 操作符所做的赋值操作其实都是 [[浅拷贝]] 操作，也就是 [[把右值逐字节拷贝到左值身上]] ，这时候就会出现问题，因为 [[tom = jerry]] ，所以就意味着， [[jerry 在堆中申请的内存地址也是逐字节拷贝到了 tom 身上]]，也就是说 [[tom]] 的 [[name]] 属性和 [[jerry]] 的 [[name]] 属性指向的都是同一块堆中的地址，这时候我们 [[free]] 操作的时候，就会出现重复释放一块相同的堆地址的情况，于是就会出现错误了，其次，原先 [[tom]] 的 [[name]] 属性也是在堆中申请的内存，在做完浅拷贝操作后，原来 [[tom]] 在堆中为 [[name]] 属性所申请的内存地址就给覆盖掉了，我们找不回来，这时候就会出现 [[内存泄漏]] 的问题

为了解决 [[=]] 操作符所存在的浅拷贝的问题而导致的这两种结构体变量重复释放相同的堆地址所引发的错误的问题，我们需要进行深拷贝操作，如下面代码

```c
#include<stdio.h>
#include<string.h>

struct Person {

    char *name;
    int age;
};

int main(void){

    struct Person tom;
    tom.name = malloc(sizeof(char) * 128);
    strcpy(tom.name, "Tom");
    tom.age = 18;

    struct Person jerry;
    jerry.name = malloc(sizeof(char) * 256);
    strcpy(jerry.name, "Jerry");
    jerry.age = 30;

    realloc(tom.name, strlen(jerry.name) + 1);
    strcpy(tom.name, jerry.name);
    tom.age = jerry.age;

    free(tom.name);
    free(jerry.name);

    return 0;
}
```

上面的代码就是一次深拷贝操作，<font color = "red">深拷贝</font> 简而言之就是深度拷贝，并不是只是单纯的像浅拷贝一样只是单纯的拷贝变量本身所存在的字节而不考虑某个变量所指向的另一块内存地址的内容

<br/>

#### 关于结构体中包含自身结构体类型的成员的问题
<span id="关于结构体中包含自身结构体类型的成员的问题"></span>

在一个结构体中，结构体中的成员是无法声明为当前结构体类型，因为在此刻，当前结构体的类型编译器还未确定具体大小，故无法嵌套自身的类型，但是结构体中的成员可以声明为当前结构体类型的指针，因为指针的类型是恒定的，如下面的代码

```c
struct Person {

    char *name;
    int age;
    struct Person *per;
};
```

<br/>

### 共用体
<span id="共用体"></span>

---

共用体是能够在同一个存储空间存储不同类型数据的类型，共用体的声明和使用离不开 [[union]] 关键字，和 [[struct]] 的定义类似，共用体对于开发人员来世也是一种自定义的复合类型，如下代码则为声明了一个共用体类型

```c
union object{

    char var;
    short int_16;
    int int_32;
};

int main(void){

    union object obj;
    obj.int_32 = 0x87654321;
}
```

通过上面的代码则能够声明一个共用体的基础数据类型，而我们在代码中就能够通过所定义的共用体类型名去声明或者定义一个共用体变量，当一个共用体变量被声明出来后，当我们定义了一个共用体变量，并为其中的某个成员进行赋值后，其在内存中的存储方式如下图

```c
+-----------+								Top
|			|								 |
| 1000 0111	+----+							 |
|			|	 |							 |
+-----------+	 |							 |
|			|	 |							 |
| 0110 0101	|	 +--> int_32 (int)			 |
|			|	 |							 |
+-----------+	 |							 |
|			|	 |							 |
| 0100 0011	+----|---+						 |
|			|	 |	 |						 |
+-----------+	 |	 +--> int_16 (short)	 |
|			+----+	 |						 |
| 0010 0001	+--------|-----> var (char)		 |
|			+--------+						 |
+-----------+								low
```

通过上图其实可以看出，我们在共用体当中虽然定义了三种变量类型，[[char var]] [[short int_16]] [[int int_32]] ，但是实际上只分配了 4 个内存单元，也就是在定义共用体数据结构中的 [[int]] 类型成员的大小，通过这点也延伸出了一条需要重点掌握的信息，即 [[一个共用体类型所占用的内存空间大小为该共用体类型中所占用字节大小最大的成员的字节大小]] ，当然这点是相对来说的，我们对于大部分共用体来说都可以套用这一条定论，但是共用体和结构体一样，同样存在着 [[内存对齐]] 的问题，关于内存对齐的详解在 [结构体这一章](#关于结构体的内存对齐的问题) 中已经说的很详细，对于共用体来说同样遵循着这一定律

此外，虽然我们在共用体类型 [[union object]] 中声明了三种成员的类型，但是它们所使用的内存空间都是一样的，都是一个 [[4 Bytes]] 大小的内存空间，并且每个成员的首地址都是从同一个内存单元开始的，即同一个内存首地址，也就是说， [[所声明的一个共用体变量的本身和共用体变量其内部的成员的内存首地址都是一致的，都是指向该共用体变量所占用内存空间段的首地址]] 

既然共用体中的成员使用的都是同一个内存空间，那么我们可以理解为 [[只要任意修改了一个成员的值，那么其它成员也会受到影响]] ，事实也是如此，在上面的代码中我们仅仅修改了 [[int_32]] 变量的值，而整个内存空间的数据都变了，这时候如果我们再去取其中的 [[var]] 变量的时候，也就是一个占用一个内存单元的 [[char]] 类型的成员，其结果则为 [[0010 0001]]，虽然同一内存段可以用来存放几种不同类型的成员，但是在 [[瞬时]] 中，对于共用体中某个类型成员所存放的数据只针对 [[它]] 起作用  ( 其余类型由于占用空间问题，可能会出现占用空间大小之间的偏差问题 )

<br/>

### 文件
<span id="文件"></span>

---

文件具有不同的类型，其分类总体分为以下两类

- 磁盘文件 : 指一组相关数据的有序集合,通常存储在外部介质，如磁盘上，使用时才调入内存，对于磁盘文件来说，还分以下两种不同类型的文件
    - 文本文件 : 基于字符编码的文件
    - 二进制文件 : 基于值编码的文件
- 设备文件 : 设备能够归纳为 [[文件]] 一类是以 [[linux]] 系统的视角来看待的，在 [[linux]] 中，万物皆可称之为文件，因为linux在底层上把 [[文件]] 和 [[设备]] 都统一了起来使用 [[inode]] 进行管理，设备文件具体映射到计算机的各类设备上，如：[[键盘]] / [[屏幕]] / [[显卡]] / [[声卡]] / [[网卡]] / ……

<br/>

#### 在 c 语言中三种特殊的系统文件
<span id="在c语言中三种特殊的系统文件"></span>

在 c 语言中，应用程序在启动的时候会默认的打开三种特殊的 [[系统文件]] ，这三种 [[系统文件]] 会分别映射到所对应的不同的 [[文件缓冲区]] 当中，而这些 [[文件缓冲区]] 又能够映射到不同的 [[I/O 设备]] 身上，所以以抽象概念上来说这三种系统文件是属于 [[设备文件]]

- stdin : Standard Input
    - 标准输入 --> 标准输入流 ( 标准输入文件缓冲区 ) --> 键盘 
- stdout：Standard Output
    - 标准输出 --> 标准输出流 ( 标准输出文件缓冲区 ) --> 屏幕
- stderr：Standard Error
    - 标准错误 --> 标准错误流 ( 标准错误文件缓冲区 ) --> 屏幕

以上三种特殊的系统文件在 c 中以 [[宏定义]] 的方式存在，即我们在 c 中可以直接通过关键字获取并操作对应缓冲区的内容，如果究其底层的话，这三种系统文件分别是以不同的 [[文件指针]] 的形式所存在的，在首次运行我们的应用程序时，os会基于 [[file descriptor]] ( linux下万物皆文件，包括输入输出设备 ) 的封装调用为相关的文件指针赋值，它们的生命周期会延续至程序的退出而关闭，当然，开发者可以在运行时可以手动的选择关闭它们

此外，这三种系统文件不是与计算机的外部存储进行沟通的，而是和计算机的 [[I/O 设备]] 进行沟通，既然所沟通的对象并不是外部存储设备，那么为什么又要把他们称之为存储在外部存储概念上的 [[文件]] 呢？ 以 [[Linux]] 作为背景，在 linux 下万物皆可称之为文件 ( 因为在底层上 Linux 把 [[文件]] 和 [[设备]] 统一起来用 [[inode]] 来管理) ，包括输入输出 设备，而在这里， [[stdin]] / [[stdout]] / [[stderr]] 都不是映射到一个系统上真实存在的文件，以抽象概念来说，默认情况 ( 也可以通过 [[管道]] 技术重定向 [[I/O]] 的位置 ) 下它们映射到的是我们的键盘和看得见的屏幕 ( console )

在这里可能会有疑问，上面对于三种在应用程序启动的过程中就为应用程序所绑定的三种东西时称为 [[stream]] ，时又称之为 [[文件]] ，其实不管是哪种说法，都是正确的，首先它们的确是一种以流的形式所存在，都映射到逻辑概念上的数据流，但是以 os ( linux ) 的目光来看待，它们的确是文件，而我们与文件在进行沟通的时候，两者之间中间有个桥梁，那就是 [[stream]]，即 [[stream]] 是基于 [[文件]] 所存在的，关于文件缓冲区的内容会在 [下一章](#文件缓冲区) 进行详解

<br/>

#### 文件缓冲区
<span id="文件缓冲区"></span>

在开始前我们先了解，缓冲区是什么？

缓冲区其实是一个宏观的概念，用于临时置放输出或输入资料的内存区域，我们都可以把这块内存区域称之为缓冲区，抽象至我们在代码上用于临时存放所采集的 [[I/O]] 数据的数据结构，我们都可以称它为缓冲区，以更深的角度来看的话，缓冲区的概念还需要映射到具体的物理设备，对于物理设备的一次访问操作，我们有一块内存区域去尽可能地存放os与物理设备正在沟通的两者间所需要的 I/O 数据，这块内存区域就叫做缓冲区

对于缓冲区来说，始终都会遵守的一个原则：[[预读入，缓输出]]

那么，什么是文件缓冲区？

文件缓冲区的概念就是缓冲区这个概念跟深一步的解答了，前面说到，缓冲区其更深一次的解答其实是需要映射到具体的物理设备的，我们可以认为，一切关乎到 I/O 操作的文件 ( 需要注意， [[文件]] 不单指以外部存储作为媒介存储在 OS 上的文件，还包括其余的外部 I/O 设备 ) 都有或即将有一个属于自己的缓冲区，那么，为什么它们需要这么一块缓冲区？前面说到，缓冲区是用于临时存放输入输出数据的内存区域，它们这些 I/O 设备关于输入输出的数据为什么不可以以更直接的方式和 CPU 进行沟通，而是又通过一层文件缓冲区，把其对应的输入输出数据存放在里面，CPU 在去里面读取，然后进行计算。在这里，我认为使用 [[HDD]] 来解释是最为合适的，首先我们要明白 HDD 的构造，其内部由多个盘片组成，盘片通过中心圆向外扩散划分了多条磁道，而磁道又通过从盘片圆形外部扩散至中心圆的一条条直线划分了扇区 ( 一个扇区的大小为 [[512 Bytes]] ) ，这些扇区用于存放我们的计算机所产生的数据，那么通过什么来读取这些扇区的数据呢？通过一条 [[震臂]] 还有一块 [[磁头]] 去完成，振臂通过不断地左右伸缩，盘片又通过转动，来完成磁头的寻道工作 ( 找到扇片 ) ，其实简而言之说了这么多，也就是想表明磁盘的 [[I/O操作]] 其实就是一个 [[机械式物理的过程]] ，那么对于时间而言，这种一次寻道 ( 物理访问 ) 的工作是极其消耗时间 ( 对比电的速度 ) 的，为此，我们对于某个存储在 HDD 上的 I/O 操作 ( 拷贝数据等等 ) ，就需要使用到一个 [[文件缓冲区]] （ 默认情况下 os 会为它申请一个 [[4096 Bytes]] 的大小 ） ，当我们需要从 HDD 上读取数据的时候，HDD 就会尽可能地把数据写入到缓冲区里面去，直到缓冲区被填满了后再由程序读取出来进行其他的操作 ( 不一定是缓冲区填满后才进行读取，但是大部分情况下是如此 ) ，对于写入操作的话也是如此，程序也会尽可能地把数据写入到其所对应的缓冲区里面去，直至缓冲区满了或到了适当的时候再写回到 HDD 里面去，回过头来， [[文件缓冲区]] 肯定不单指的是硬盘，像键盘也有属于自己的缓冲区 ( stdin ) ，包括屏幕也有自己的缓冲区（ 抽象上来说为 stdout ），其工作原理和使用缓冲区的原因也是大同小异

这里还要提及一个 [[文件指针]] 的概念 ( [后面](#文件指针) 会讲到 )，在 c 中，我们对于一个文件的 [[I/O 操作]] 都由一个指向文件描述信息 [[文件指针]] 来完成，这个文件指针的类型为 [[FILE *]]，而 [[FILE]] 其实就是用于描述文件信息的结构体类型，前面说到，一切关乎到 [[I/O 读写]] 的文件都有或即将有一个属于自己的缓冲区，那么我们可以理解为，每个成功定义的 [[FILE *]] 的都有一块属于自己的缓冲区


关于这个把 [[文件缓冲区上的数据刷新到具体媒介身上]] 的工作我们会把它称为 [[文件缓冲区的刷新]]，文件缓冲区的刷新其实就是把文件缓冲区中的数据拉出来，并清空当前缓冲区里面的数据，再把从文件缓冲区上取出来的数据交由适当的媒介，那么什么时候才会刷新这个文件缓冲区？前面说到，缓冲区的刷新会在适当的时候进行刷新，这种刷新机制是os以默认的设定下来帮我们自动完成的，当然我们可以认为的进行刷新，人为的刷新就需要使用到 c 中的函数 [[fflush]] 函数来完成，这里讨论的是 os 自动的帮我们刷新缓冲区的机制，关于这种刷新的机制其实还有具体的刷新的方式来区分，我们把它归纳为以下几种类别

- 行缓冲：当接收到 [[\n]] 字符的时候进行一次缓冲区的刷新工作，类比 [[stdin 标准输入流]] ，其具体映射到键盘的操作身上
- 全缓冲：对于文件的读写操作，当缓冲区被填满的时候就会进行一次缓冲区的刷新工作
- 无缓冲：只要缓冲区中存在数据，就会立刻刷新到相应的文件当中， [[perror 文件缓冲区]] 则遵循这一原则


最后，我们再看一下文件缓冲区模型图

```c
								  INPUT/OUTPUT
									   ↑
									   |
						+--------------+--------------+
						|							  |
						|	  +-----------------+	  |
		+---------+		|	  |	buffer			|	  |		+---------+
		|		  |		|	  |	+----+			|	  |		|		  |
		|		  +-----+------>	 +----------------+-----> 		  |
		|		  |			  |	+----+ 4096Byte	|	  		|		  |
		+---------+			  |					|			+---------+
		     |				  +-----------------+			 	 |
			 ↓				  		   |					 	 ↓
		需要使用到I/O				   ↓					  I/O FILE
		数据的地方，可				 Memory
		能是我们的程序
		也可能是其它东西
```

<br/>

#### 文件指针
<span id="文件指针"></span>

文件指针区别于一般的指针，文件指针所指向的内存地址其实是在 [[heap]] 上 ( 这一特性是由于 [[fopen]] 函数所导致的 ) ，此外，文件指针所指向的地址所映射的存储空间里面所存储的并不是具体某个文件的所有字节内容，而是关于具体某个文件的一些描述性信息，在 c 中，文件指针的类型通过 [[FILE]] 来定义，实际上他就是一个 struct 类型，其具具体结构图下面的代码

```c
typedef struct
{
    short           level;		// 缓冲区"满"或者"空"的程度 
    unsigned        flags;		// 文件状态标志 
    char            fd;			// 文件描述符
    unsigned char   hold;		// 如无缓冲区不读取字符
    short           bsize;		// 缓冲区的大小
    unsigned char   *buffer;	// 数据缓冲区的位置 
    unsigned        ar;	 		// 指针，当前的指向 
    unsigned        istemp;		// 临时文件，指示器
    short           token;		// 用于有效性的检查 
} FILE;
```

虽然 [[FILE]] 结构体内部的成员涵盖了某个文件的许多描述信息，但是在 c 中，使用文件指针操作其所指向的文件的时候都需要通过 c 标准库中所给定的文件操作函数来完成，而不是直接访问这个结构体内部成员的信息

回到刚刚所说到那个 [[FILE]] 结构体身上，可以看出，这个结构体所存放的信息是关于一个具体文件的实际描述性的信息，而 c 标准库所提供的关于文件的操作函数就是通过所传入的文件指针其内部地址所指向的内存空间所存储的 struct ( 关于具体文件的描述信息 ) 去找到具体某个文件，然后再对它实行针对当前函数功能的操作，在编写源程序时，开发人员其实不必关心 [[FILE struct]] 的具体细节

但有一点需要我们注意，[[FILE struct]] 中的有一个成员会 <span style="color:red">记录着当前文件中所操作的某个字符的位置</span> ，这个成员叫做 [[文件读写位置指针]] ，文件读写位置指针 在进行偏移的时候所需使用的步长都是使用 [[1 Bytes]] 作为标准，在还未进行过任何读写状态的时候，其起始位置为0，在对文件进行了 读取或写入 操作的时候，文件读写位置指针则会基于此次操作所到达的下标往后进一以保证下一次对于文件进行 读取或写入 操作的时候不会和已操作的位置重叠在一块，我们不管是对文件的读还是写操作，都离不开这个 [[文件读写位置指针]] 它对于当前文件的读写起到了标量的作用，举个例子，一个文本文件中有一段文本 [["abc"]]，当我们第一次通过 [[fgetc]] 函数读取后，文件读写位置指针的矢量就会向后加一，以方便下一次再调用 [[fgetc]] 函数读取到的内容为 [['b']] 而不是原来的 [['a']]

对于文件读写位置指针，我们可以通过 [[fseek]] 函数来手动的调整其位置以保证下一次进行 读取或写入 操作的时候所获取到的数据是我们所预期的数据，这种操作也称之为 <span style="color:red">对文件的随机访问操作</span> ，在 c 中，对于文件的随机读写操作时需要注意一个点，那就是当我们通过改变文件读写位置指针的位置去往已有数据的位置当中去写入数据的时候 ( 插入数据 ) ，所写入的数据并不是以追加的形式呈现，而是以覆盖的形式呈现，比如说一个文本文件中的内容为 [[111112222233333]] ，当我们把文件读写位置指针的位置移动至第 [[5]] 个，并且写入 [[BBBBB]] 的时候，文件最终的结果则为 [[11111BBBBB33333]] ，而不是 [[11111BBBBB2222233333]]

<br/>

#### 文件指针的具体使用
<span id="文件指针的具体使用"></span>

#### FILE *fopen(const char * filename, const char * mode)
##### <stdio.h>

当调用该函数的时候，该函数会根据指定的模式 [[mode]] 和文件的具体位置 [[filename]] 去找到相关的文件并读取文件的描述信息

如果成功读取，则在堆中开辟一块 [[struct FILE]] 大小的内存空间，并根据具体文件的信息创建一个 [[struct FILE]] 写入到刚刚所申请的堆中的地址中，最后返回这个指向堆中地址的 [[FILE *]] 类型的指针，即 [[文件指针]]

如果函数调用失败，也就是打开文件失败，这时候该函数会返回一个 [[空指针]]

该函数并不会把文件的内容一次性全部加载到内存中，该函数的责任只是以对应的模式找到对应文件的信息并创建一个指针指向它

- filename：具体文件的路径 ( 绝对路径 / 相对路径 )
    - 操作系统的某些版本下可能因为该参数导致函数调用失败而返回空指针，如果出现这种情况，需要检查下该参数所给定的路径是否为绝对路径，如果是绝对路径的话需要检查下盘符是否为小写

- mode：打开文件的方式
    - [["r"]] / [["rb"]]：以 [[read only]] 的方式打开一个文本文件，若文件不存在则该函数返回空指针
    - [["w"]] / [["rw"]]：以 [[write only]] 方式打开文件，如果文件存在则删除给定文件并且创建一个新的文件，如果文件不存在则创建一个新的文件
    - [["a"]] / [["ab"]]：以 [[append only]] 方式打开文件，在末尾添加内容，若文件不存在则创建文件，[[append only]] 意味着只能够允许 [[write]] 的操作，而对于 [[read]] 的操作可能会导致失败
    - [["r+"]] / [["rb+"]]：以 [[read & write]] 的方式打开文件，如果文件不存在，则创建一个新的文件
    - [["w+"]] / [["wb+"]]：以 [[read & write]] 的方式打开文件，如果文件存在则删除给定文件并且创建一个新的文件，如果文件不存在则创建一个新的文件
    - [["a+"]] / [["ab+"]]：以 [[append & read & write]] 的方式打开文件，若文件不存在则创建文件，如果文件存在，则在末尾添加内容
    - 参数的后缀为 [["b"]] 则为 [[二进制文件模式]] ，没有则为默认的 [[文本文件模式]] ，且只是在 [[Windows]] 有效，在 [[Linux]] 中用文本文件模式和二进制文件模式的结果是一样的
        - windows：所有的文本文件行都是 [[\r\n]] 作为结尾
            - 文本模式
                - 当读取文件的时候，系统会将所有的 [[\r\n]] 转换成 [[\n]]
                - 当写入文件的时候，系统会将 [[\n]] 转换成 [[\r\n]] 进行写入
            - 二进制模式
                - 以 [[二进制]] 方式打开文件，则读写都不会进行这样的转换
        - Linux：所有的文本文件行都是 [[\n]] 作为结尾
            - 在Unix/Linux平台下，文本模式与二进制模式没有区别，[[\r]] [[\n]] 作为两个字符原样输入输出



```c
#include<stdio.h>

int main(void){

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "w");
    if(fp == 0){

        perror("file pointer error");
        return -1;
    }

    char *str = "Hello,World!";
    fwrite(str,1,strlen(str),fp);

    fclose(fp);

    return 0;
}
```

<br/>

#### int fclose(FILE * stream)
##### <stdio.h>

关闭文件指针 [[stream]] 所指向的被打开的文件，并释放其所占用的内存

每次使用 [[fopen]] 函数所打开的文件都会占用内存资源，如果过多的打开而总不关闭，会占用较多很多内存，并且，一个进程同时打开文件的次数是存在限制的，如果再某一时刻同时打开的文件过多且没有关闭的话，可能会在下一次打开 [[fopen]] 的时候就打开失败了 ( 返回空指针 )

该函数在调用完成后会在其内部针对文件指针指向的文件所打开的文件缓冲区的刷新工作

```c
#include<stdio.h>

int main(void){

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "w");
    if(fp == 0){

        perror("file pointer error");
        return -1;
    }

    fclose(fp);

    return 0;
}
```

<br/>

#### int remove(const char *pathname)
##### <stdio.h>

删除指定路径 [[pathname]] 的文件，成功返回 [[0]]，失败返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    int flag = remove("‪c:/Users/NGPONG/Desktop/111.mp4");
    printf("remove %s\n", flag == 0 ? "SUCCESS" : "FAILUTE");

    return 0;
}
```

<br/>

#### int rename(const char *oldpath, const char *newpath)
##### <stdio.h>

重命名文件，旧地址 [[oldpath]] 更改为新地址 [[newpath]]，成功返回 [[0]]，失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    int flag = rename("test.txt", "abc.txt");
    printf("rename %s\n", flag == 0 ? "SUCCESS" : "FAILUTE");

    return 0;
}
```

<br/>

#### int stat(const char *path, struct stat *buf)
##### <sys/types.h> / <sys/stat.h>

该函数能够获取指定路径 [[path]] 所对应的文件信息，如果调用成功，则把填充到类型为 [[struct stat]] 的结构体中去，并返回 [[0]]，如果调用失败，则返回 [[-1]]

对于操作系统而言，打开一个文件 [[fopen]] 总是会消耗较多的资源的，也就是说如果我们真的只是想单纯的查看某个文件的具体信息 ( 比如说文件的具体大小 ) 而不对文件进行其它的读写操作的话，就不推荐使用 [[fopen]] 函数去打开一个文件在获取里面的内容了，而函数 [[stat]] 并不会去打开一个文件的具体内容，仅仅只是获取到该文件具体的描述信息再把信息填充至结构体 [[struct stat]] 当中，所以针对这种情况的话，使用 [[stat]] 函数对比 [[fopen]] 函数就大大的提升了效率

关于 [[struct stat]] 的结构

```c
struct stat {
    dev_t         st_dev;         	//文件的设备编号
    ino_t         st_ino;			//节点
    mode_t        st_mode;   		//文件的类型和存取的权限
    nlink_t       st_nlink;     	//连到该文件的硬连接数目，刚建立的文件值为1
    uid_t         st_uid;         	//用户ID
    gid_t         st_gid;         	//组ID
    dev_t         st_rdev;      	//(设备类型)若此文件为设备文件，则为其设备编号
    off_t         st_size;        	//文件字节数(文件大小)
    unsigned long st_blksize;   	//块大小(文件系统的I/O 缓冲区大小)
    unsigned long st_blocks;    	//块数
    time_t        st_atime;     	//最后一次访问时间
    time_t        st_mtime;    		//最后一次修改时间
    time_t        st_ctime;     	//最后一次改变时间(指属性)
};
```

```c
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>

int main(void){

    struct stat state = { 0 };
    int flag = stat("c:/Users/NGPONG/Desktop/test.txt", &state);

    if (flag == -1) {
    
        perror("file open error");
    }

    printf("file size = %d\n", state.st_size);
    printf("file last at time = %d\n", state.st_atime);
    printf("file last change time = %d\n", state.st_mtime);

    return 0;
}
```

<br/>

#### int fflush(FILE *stream)
##### <stdio.h>

该函数能够立即刷新文件指针所指向的文件所开启的缓冲区，如果成功返回 [[0]]，如果失败则返回 [[-1]]

关于文件缓冲区的内容在 [这一章](#) 已经有所介绍，这里就不再进行展开了

```c
#include <stdio.h>

int main(void){

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt","w+");
    if(fp == NULL){

        perror("file pointer create error");
        return -1;
    }

    for (size_t i = 0; i < 10; i++) {

        fprintf(fp, "%d\t", (i + 1));
        fflush(fp);
    }

    return 0;
}
```

<br/>

#### int fprintf(FILE * stream, const char * format, ...)
##### <stdio.h>

将 [format形参](#形参format) 所提供的格式化模板再结合所录入的可变参数 [[...]] 生成一个新的字符串的结果并写入到文件指针 [[stream]] 所指向的文件的缓冲区内，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "w");
	if (fp == NULL) {

		perror("fp error");
		return -1;
	}

	fprintf(fp, "Hello,World! My name is %s, I'm %d years old", "NGPONG", 23);

	fclose(fp);

    return 0;
}
```

<br/>

#### int fscanf(FILE * stream, const char * format, ...)
##### <stdio.h>

将 [format形参](#形参format) 所提供的格式化模式从文件指针 [[stream]] 所指向的文件的缓冲区内取出数据，并依次写入到所指定的可变参数 [[...]] 所使用的内存空间当中，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    
	FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
	if (fp == NULL) {

		perror("fp error");
		return 0;
	}

	int age;

	fscanf(fp, "Hello,World! My name is NGPONG, I'm %d years old", &age);

	fclose(fp);

    return -1;
}
```

<br/>

####  char *fgets(char * source, int size, FILE *stream)
##### <stdio.h>

从文件指针 [[stream]] 所指向的文件的缓冲区内获取 [[size]] 字节大小的数据，以文件中的 [['\n']] 作文本次函数调用的读取标识，把所读取到的内容填充至形参 [[souce]] 所指向的内存空间内并返回该内存空间的首地址，如果调用失败，则返回 [[NULL]]

该函数所给定的参数 [[source]] 必须为一个字符数组以保证写入权限，如果给定的是一个字符指针形式的字符串的话，该函数则会调用失败，因为该函数会逐地址写入所录入的字符

该函数在调用前，会先清空所给定的 source 所指向的内存空间的内容，即都赋值为 [[0]]

该函数虽然在文件缓冲区中遇到 [['\n']] 则会作为本次函数调用所需录入字符串的标识，但是在保证 [[source]] 所指向的内存空间结合 [[size]] 所规定的字节大小，在剩余空间允许的情况下也会录入 [['\n']] 字符

该函数是较为安全的，至始至终都会为 [[source]] 所指向的空间保留最后一位的字节内容以录入 [['\0']]，如果超出，则截断最后一位所采集到的数据以保证在录入 [['\0']] 字符时候， [[source]] 所指向的内存空间的足够

```c
#include <stdio.h>

int main(void) {

	FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
	if (fp == NULL) {

		perror("fp error");
		return -1;
	}

	char str[64] = { 0 };
	fgets(str, sizeof(str), fp);

	fclose(fp);
    return 0;
}
```

<br/>

#### int fputs(const char * str, FILE *stream)
##### <stdio.h>

将字符串 [[str]] 写入到文件指针 [[stream]] 所指向文件的缓冲区当中，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void) {

	FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "w");
	if (fp == NULL) {

		perror("fp error");
		return -1;
	}

	char *str = "Hello,World!\n";
	fputs(str, fp);

	fclose(fp);

    return 0;
}
```

<br/>

#### int fgetc(FILE * stream)
##### <stdio.h>

从文件指针 [[stream]] 所指向文件的缓冲区中获取一个字符，如果成功则返回所获取到的字符的 [[ASCII]] 码值，如果函数调用失败，则返回 [[-1]] ，<span style="color:red">如果当前文件指针所指向的文件是一个文本文件的话，[[-1]] 的返回值也意味着当前文本文件中的所有的有效内容都已读取完毕</span>

```c
int main(void) {

	FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
	if (fp == NULL) {

		perror("fp error");
		return -1;
	}

	char str[64] = { 0 };
    int index = 0;
    while((*(str + index) = fgetc(fp)) != -1){

        index++;   
    }
    printf("%s\n",str);

	fclose(fp);
    return 0;
}
```

<br/>

#### int fputc(int ch, FILE * stream)
##### <stdio.h>

将字符 [[ch]] 写入到文件指针 [[stream]] 所指向的文件的缓冲区内，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "w");
	if (fp == NULL) {

		perror("fp error");
		return -1;
	}

    char *str = "Hello,NGPONG!\nTEST!";

    for (size_t i = 0; i < strlen(str); i++) {

        fputc(*(str + i),fp);
	}

    fclose(fp);
    return 0;
}
```

<br/>

#### size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)
##### <stdio.h>

把指针 [[ptr]] 所指向的内存空间中的数据划分为 [[nmemb]] 个数据块，每个数据块占用 [[size]] 字节大小 ，逐数据块写入到文件指针 [[stream]] 所指向的文件的缓冲区当中，如果成功，则返回实际写入的数据块的块数，即形参 [[nmemb]] 所录入的值，如果是败则返回 [[0]]

```c
#include <stdio.h>

typedef struct person {

    int age;
    char name[10];
    int gender;
} person_t;

int write(void) {

    person_t per[3] = {
        22,"NGPONG",1,
        11,"wupeng",0,
        100,"NICK",1
    };

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "w");
    if (fp == NULL) {

        perror("fp error");
        return -1;
    }

    int ret = fwrite(per, sizeof(person_t) * 3, 1 , fp); /* 当前写入操作指定了一个数据块的大小为 person_t 结构体类型数组 per 的大小，并且此次操作需要写入1个数据块，如果成功写入，返回值则为 1 */
    int ret = fwrite(per, 1, sizeof(person_t) * 3 , fp); /* 当前写入操作指定了一个数据块的大小为 1 字节，并且此次操作需要写入结构体数组 per 总长度的数据块，如果成功写入，返回值则为 per 数组的总长度 */

    printf("ret = %d\n", ret);

    fclose(fp);

    return 0;
}
```

<br/>

#### size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
##### <stdio.h>

把文件指针中所指向的文件的缓冲区的数据划分为 [[nmemb]] 个数据块，每个数据块占用 [[size]] 字节大小 ，逐数据块写入到指针 [[ptr]] 所指向的内存空间当中，如果成功，则返回实际写入的数据块的块数，即形参 [[nmemb]] 所录入的值，如果 [[返回值 < nmemb & 返回值 > 0]] ，则代表当前所读取得是最后一行的数据，如果返回值为 [[0]] 则代表文件已经读取完毕抑或是当前函数调用失败

```c
#include <stdio.h>

typedef struct person {

    int age;
    char name[10];
    int gender;
} person_t;

int main(void) {

    person_t per[3] = { 0 };

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
    if (fp == NULL) {

        perror("fp error");
        return -1;
    }

    int index = 0;
	while (fread(per + index, 1, sizeof(person_t), fp)) { index++; }

	for (size_t i = 0; i < sizeof(per) / sizeof(*per); i++) {

		printf("person name = %s,age = %d,gender = %d\n", per[i].name, per[i].age, per[i].gender);
	}

    fclose(fp);
    return 0;
}	
```

<br/>

#### int fseek(FILE *stream, long offset, int whence)
##### <stdio.h>

对文件指针 [[stream]] 所存储的 [[文件读写位置指针]] 的位置基于 [[whence]] 位置下进行 [[offset]] 偏移量的移动，如果成功返回 [[0]]，如果失败则返回 [[-1]]

- [[offset]]：调整位置的偏移量 ( 矢量 ) ，当为正整数的时候，则是向后 ( [[+1]] ) 偏移 offset 位，当为负数的时候则为向后 ( [[-1]] ) 偏移 offset 位
    - <span style = "color:red">文件读写位置指针的默认位置为0，并且也不能小于 0 </span> ，这意味着该参数只能够指定正整数的数字，当该参数小于0  的时候，该函数会调用失败，这时候文件读写位置指针的位置则会偏移至当前文件可读写数据的最末尾处，比如说一个文本文件仅有一段话 [[Helloworld]] ，当我们通过 [[fseek]] 函数去移动文件读写位置指针的位置，并指定偏移量小于 0 的话，则文件读写位置指针的位置下标就会偏移至跑 10 ( 可读写数据的最末尾处 )
    - 这里的偏移量是以 [[Bytes]] 作为单位来衡量的，比如说指定 [[offset]] 为 [[10]]，那么其实就意味着是向后偏移 [[10 Bytes]]

- 指定文件读写位置指针所基于的偏移位置，该参数通常使用三种不同的宏定义来指定
    - SEEK_SET：基于文件开头位置
    - SEEK_CUR：基于当前文件读写位置指针所在的位置
    - SEEK_END：基于文件结尾位置

```c
#include <stdio.h>

int main(void){

    /*
    AAAAABBBBBCCCCC
    ↑
    */
    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
    if (fp == NULL) {

        perror("fp error");
        return -1;
    }

    char str[6] = { 0 };

    /*
    AAAAABBBBBCCCCC
         ↑
    */
    fseek(fp, 5, SEEK_SET);

    /*
    AAAAABBBBBCCCCC
              ↑
    */
    fread(str, sizeof(char), 5, fp);

    printf("%s\n", str);

    fclose(fp);
    return 0;
}
```

在 windows 下，当我们对文件进行了一次读取操作后再进行写入，则会出现错误 ( 也有可能不会出错，而且写入函数也返回调用成功，但是数据却没有写入 ) ， 解决这一错误的方式则为在写入前重置一次 [[文件读写位置指针]] 的当前位置 ( [[fseek(FILE *,0,SEEK_CUR)]] ) 即可再次进行正常的写入操作，如下面的代码

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int main(void) {

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r+");
    if (fp == NULL) {
    
        perror("file pointer error");
        return -1;
    }

    char str[6] = { 0 };
    fgets(str, sizeof(str), fp);
    printf("str = %s,file read&write pointer index = %d\n", str, ftell(fp));

    /*
    如果再次写入前没有进行文件读写位置指针的位置的重新矫正，则写入错误
    */
    fseek(fp, 0, SEEK_CUR);

    fwrite("fffff", 1, 5, fp);
    printf("file read&write pointer index = %d\n", ftell(fp));

    fclose(fp);

    return 0;
}
```

<br/>

#### long ftell(FILE *stream)
##### <stdio.h>

获取，计算并返回文件指针 [[stream]] 所存储的 [[文件读写位置指针]] 当前位置到文件起始位置之间的偏移量 ( <span style = "color:red">以字节为单位</span> )

```c
#include <stdio.h>

int main(void){

    /*
    AAAAABBBBBCCCCC
    ↑
    */
    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
    if (fp == NULL) {

        perror("fp error");
        return -1;
    }

    int fileSize = 0;

    /*
    AAAAABBBBBCCCCC
                   ↑
    */
    fseek(fp, 0, SEEK_END);

    fileSize = ftell(fp);

    printf("file size = %d\n", fileSize);

    fclose(fp);
    return 0;
}
```

<br/>

#### void rewind(FILE *stream)
##### <stdio.h>

回卷文件指针 [[stream]] 所存储的 [[文件读写位置指针]] 的位置到文件起始位置

```c
#include <stdio.h>

int main(void){

    /*
    AAAAABBBBBCCCCC
    ↑
    */
    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r");
    if (fp == NULL) {

        perror("fp error");
        return -1;
    }

    char str[32] = { 0 };
    /*
    AAAAABBBBBCCCCC
                   ↑
    */
    fread(str, sizeof(char), sizeof(str), fp);

    printf("%s\n", str);
    memset(str, 0, sizeof(str));

    /*
    AAAAABBBBBCCCCC
    ↑
    */
    rewind(fp);

    /*
    AAAAABBBBBCCCCC
         ↑
    */
    fread(str, sizeof(char), 5, fp);
   
    printf("%s\n", str);

    fclose(fp);
    return -1;
}
```

<br/>

#### int feof(FILE * stream)
##### <stdio.h>

判断文件指针 [[stream]] 所指向的文件中文件中，文件读写位置指针的位置是否已经到达文件的结尾，如果是的话则返回 [[1]] 不是的话则返回 [[0]]

之前说到，文件指针其所存储的内存地址所映射的具体内容是一个描述文件信息的 [[struct]] ，而这个 [[struct]] 中有一个成员为 [[文件读写位置指针]] ，而该函数的实现机制是通过文件读写位置指针当前所在的位置去对比当前文件的有效数据的长度来判断是否已经到达文件末尾的

在 c 语言中，<span style = "color:red">对于 [[任何文本文件]] 都会有一个结束标记，其值为 [[-1]] </span>，这个结束标记我们是不需要手动添加的，并且我们在文本中是看不到的，只有实际在 c 中通过代码读取文本文件的内容时才会发现它的存在，而 c 语言通过一个宏定义 [[EOF]] ( end of file ) 来表示这个值为 -1 的结束标记，但是关于 [[EOF]] 仅仅只是适用于 [[文本文件]] ，对于 [[二进制文件]] 就不能采用这一标准了，<span style="color:red">因为对于一个二进制文件来说 [[-1]] 是能够存在且为有效值的</span>，所以，如果需要准确的获取到当前所操作的文件指针的文件读写位置指针是否已经偏移至文件的结尾的时候，使用该函数更为合适

```c
#include <stdio.h>

int main(void) {

    FILE *fp = fopen("c:/Users/NGPONG/Desktop/test.txt", "r+");
    if (fp == NULL) {

        perror("fp errpr");
        return -1;
    }

    while (1) {

        char ch = fgetc(fp);
        if (feof(fp)) {
            
            break;
        }
        printf("%c", ch);
    }

    fclose(fp);
    return 0;
}
```


<br/>

### 特殊的关键字
<span id="特殊的关键字"></span>

---

#### typedef
<span id="typedef"></span>

该关键字能够给系统现有的数据类型起别名 ( 新的数据类型 ) ，需要注意的是，我们不能给一个已经经过了 [[typedef]] 定义的新的数据类型使用该关键字再次进行定义

通常使用 [[typedef]] 定义过的新类型约定俗成使用 [[_t]] 进行结尾

Struct
```c
#include<stdio.h>

typedef struct Person {

    int Age;
    char *Name;
    int Gender;
} person_t;

int main(void) {

    person_t per = {10,"NGPONG",1};

    return 0;
}
```

Base data type

```c
#include<stdio.h>

typedef int int32_t;

int main(void) {

    int32_t value = 10;
    value++;

    return 0;
}
```

Pointer

```c
#include<stdio.h>

typedef int *p_t;

int main(void) {
    
    int a = 10;
    p_t p = &a;
    (*p)++;

    return 0;
}
```

Arrary

```c
#include<stdio.h>

typedef int arrary_t[3];

int main(void) {
    
    arrary_t arrary = {1,2,3};
    for (size_t i = 0; i < sizeof(arrary) / sizeof(*arrary); i++) {

        printf("arrary[%d] = %d\n", i, arrary[i]);
    }

    return 0;
}
```

Pointer arrary

```c
#include<stdio.h>

typedef int *ptr_arrary_t[3];

int main(void){

    int a = 10;
    int b = 20;
    int c = 30;

    ptr_arrary_t arrary = { &a,&b,&c };
    for (size_t i = 0; i < sizeof(arrary) / sizeof(*arrary); i++) {

        printf("arrary[%d] = %d\n", i, *arrary[i]);
    }

    return 0;
}
```

Arrary pointer

```c
#include<stdio.h>

typedef int (*arrary_ptr_t)[2];

int main(void){

    int arrary[3][2] = {
        {1,2},
        {3,4},
        {5,6}
    };

    arrary_ptr_t arrary_p = arrary;

    for (size_t i = 0; i < sizeof(arrary) / sizeof(*arrary); i++) {

        printf("row = %d\n", i);
        for (size_t j = 0; j < sizeof(*arrary) / sizeof(**arrary); j++) {

            printf("   col = %d val = %d\n", j, *(*(arrary + i) + j));
        }
    }

    return 0;
}
```

Function

```c
#include<stdio.h>

void fun_test() {

    printf("Hello,World!\n");
}

typedef void fun_t();

int main(void){

    fun_t *f_p = fun_test;
    f_p();

    return 0;
}
```

Function pointer

```c
#include<stdio.h>

void fun_test() {

    printf("Hello,World!\n");
}

typedef void (*fun_p_t)();

int main(void){

    fun_p_t fun = fun_test;
    fun();

    return 0;
}

```

<br/>

#### register
<span id="register"></span>

[[register]] 关键字能够用于变量的声明，作用于告诉编译器， [[建议]] 当前变量使用 [[寄存器]] 进行存储，以提升读写的效率

当然， [[register]] 是建议型的指令，而不是命令型的指令，如果 CPU 有空闲寄存器，那么 [[register]] 就生效，如果没有空闲寄存器，那么 [[register]] 无效，所声明的变量则按普通声明的方式来处理

那么我们该如何判断 [[register]] 是否生效？我们都知道一般变量都是存储在 RAM 当中，其都有一个地址去指向这个变量，而如果声明成功的话，变量则存放在寄存器当中，而在寄存器当中这个变量是没有地址的，我们靠这一特性就可以判断该关键字是否其效果

```c
#include <stdio.h>

int main(void){

    register int a = 10;
    a++;
    printf("%d\n",a);

    return 0;
}
```

<br/>

#### volatile
<span id="volatile"></span>

该关键字能够防止编译器对重复使用的变量进行优化，主要集中在硬件领域开发用的较多，举个例子，跑马灯的控制通常都有一个变量作为标识，比如说 [[int flag = 0]] ， 当它等于 [[0]] 时就代表亮了，等于 [[1]] 时就代表熄灭，而硬件在使用的过程当中，因为跑马灯需要重复的关闭和开启，所以这个变量 [[flag]] 会进行重复的赋值，这时候编译器查看到这个变量存在多次赋值的性质的时候，就自动的帮我把程序在中间运行过程中对于该变量 [[flag]] 所赋值的代码都删除掉，而当我们加了这个关键字之后，就能够防止编译器对于此处所进行的优化

```c
#include <stdio.h>

int main(void){

    volatile int flag = 0;
    flag = 1;
    flag = 0;
    flag = 1;
    flag = 0;

    flag = 1024;
    printf("%d\n",flag);
    
    return 0;
}
```

<br/>

### 编译
<span id="编译"></span>

---

#### 编译时所经历的 4 个步骤
<span id="编译时所经历的4个步骤"></span>

- 预处理
    1. [[头文件]] 的展开，该阶段不进行文件检查，可以展开任意文件
    2. [[宏定义]] 的展开，即进行宏定义替换，将上下文中出现的宏名都替换成所对应的宏值
    3. 替换注释，把注释内容都替换成空行
    4. 条件编译的展开，根据条件来展开指令
    5. 进行一些最基本的语法检查 ( 宏定义、头文件引入和条件编译的语法 )
    6. 将 [[源文件]] 的处理结果生成为 [[预处理文件]]
    7. 预处理文件的后缀通常以 [[.i]] 作为结尾

- 编译
    1. 对上一步骤所生成的预处理文件再逐行进行一次严格的语法检查，该步骤也是最耗时的一个步骤，是4个处理步骤中最占用时间的一个小节
    2. 将 [[预处理文件]] 的处理结果生成为 [[汇编文件]]
    3. 汇编文件的后缀通常以 [[.s]] 作为结尾

- 汇编
    1. 将 [[汇编文件]] 中的汇编指令翻译为二进制编码，并整合为 [[二进制文件]]
    2. 二进制文件的后缀通常以 [[.o]] 作为结尾

- 链接
    1. 数据段合并
    2. 数据地址回填
    3. 库引入 ( [[windows]] 下可以通过 [[Depend.exe]] 来查看可执行文件具体所引用的库 )
    4. 将 [[二进制文件]] 编译为一个 [[可执行程序]]

<br/>

#### GCC
<span id="GCC"></span>

GCC 是一款编译器，其内部完全按照 c 标准来进行的实现，即是一款较为主流且标准的编译器的选择之一，对于 [[GCC]] 的使用而言，其有些参数需要我们进行掌握

#### gcc source

如果 [[source]] 所指定的文件为一个 [[源文件]]，则将文件 [[source]] 编译为 [[可执行文件]]，所生成的可执行文件名为 [[source]] 的文件名

如果 [[source]] 所指定的文件为一个 [[二进制文件]]，则对文件 [[source]] 进行链接操作，并把链接后的结果生成为一个可执行文件，所生成的可执行文件名为 [[source]] 的文件名

```c
gcc helloworld.c

gcc helloworld.o
```

#### gcc -E source.c

对源文件 [[source.c]] 进行预处理，并把预处理的结果输出至在所操控的终端上，如果想把所进行的预处理的结果整合为一个预处理文件，则需要使用到 [[-o]] 指令来指定生成一个预处理文件

```c
gcc -E helloworld.c
```

#### gcc -S source.i

把预处理文件 [[source.i]] 编译为一个汇编文件，所生成的汇编文件名为 [[source]]

```c
gcc -S helloworld.i
```

#### gcc -c source.s

把汇编文件 [[source.s]] 翻译为一个二进制文件，所生成的二进制文件名为 [[source]]

```c
gcc -c helloworld.s
```

#### command -o file
将上一条命令 [[command]] 在进行过某一步骤的编译操作后所生成文件指定文件名为 [[file]]

```c
gcc helloworld.c -o helloworld.exe

gcc -E helloworld.c -o helloworld.i
gcc -S helloworld.i -o helloworld.s
gcc -c helloworld.s -o helloworld.o
gcc helloworld.o -o helloworld.exe
```

<br/>

#### 头文件
<span id="头文件"></span>

头文件以 [[.h]] 作为文件的后缀，区别于源文件，我们在头文件中所编写的内容只是对于某种内容的声明操作以至于头文件在所被包含的源文件在进行预处理阶段的时候，把所声明的工作整合至源文件当中，对于头文件来说，我们通常使用它来进行

- 包含其它的头文件
- 函数的声明
- 类型的声明
- 变量的声明或定义
- 宏的定义

想要源文件中在预处理阶段引入头文件的内容并把其中的内容合并到源文件当中，则需要通过 [[#include]] 指令去引入具体的某个头文件

头文件的编写工作通常需要以 [[头文件守卫]] 的编写作为开始，<span style="color:red">头文件守卫作用与防止重复包含头头文件，以避免同一个源文件中对于某个具体的头文件进行了重复的展开而导致编译速度过慢或者是可能产生的具体某个成员进行了重复定义的问题 </span>

```c
#ifndef __HEADFILENAME_H__
#define __HEADFILENAME_H__ 

/* head file content */

#endif   
```

<br/>

### 预处理指令
<span id="预处理指令"></span>

---

预处理指令能够为 c 程序在进行 [[编译]] 工作前提供给 [[预处理器 ( Preprocessor )]] 进行一些额外的、我们所续期的预处理工作

<br/>

#### 头文件引入
<span id="头文件引入"></span>

头文件的引入工作通过指令 [[#include]] 来完成，它能够指定在源文件当中去包含某个具体的头文件，使预处理器在预处理阶段把所引入的头文件的内容展开至相应的源文件身上

[[#include "file.h"]] ：表示先在使用了该指令的当前文件的所在目录找 file，如果找不到，再按系统指定的目录检索

[[#include <file.h>]] ：表示直接按系统指定的目录检索 file 文件

<br/>

#### 宏
<span id="宏"></span>

宏的定义工作通过 [[宏名]] [[宏值]] 来完成定义，当我们在代码中使用了一个已经定义好了的宏后，那么在 [[预处理阶段]] 会将在代码中所使用的 [[宏名]] 都替换成其所对应的 [[宏值]]，这个过程也成为 [[宏展开]] ，关于这点也可以衍生出另外一个问题，<span style="color:red">宏定义是没有具体的数据类型的，因为其所做的只不过使对于宏名替换成宏值的一个操作，并不知道其具体的数据类型</span>

我们所定义的宏，默认情况下，其有效范围从当前文件中定义宏的位置开始直至文件的结束，当然也可以通过 [[#include]] 指令来把所定义宏内容的文件包括至其它文件中，也就是把宏的作用域提升至其它文件当中，需要注意的是，我们在一个函数的内部也可以定义宏，并且其作用域并不受函数内部的作用域所限制，也就是说在当前定义了宏的函数往下的函数都可以使用到这个宏

在进行宏定义中，宏值可以引用已定义的宏名，但是所引用的宏名必须要在当前宏定义之前进行声明 ( 编译器是逐行进行编译工作的 )

对于宏的不同定义方式所产生的效果也是不同，如下面则是他们的具体使用方式

- 宏常量
    - [[#define 宏名 宏值]]
    ```c
    #include <stdio.h>

    #define PI 3.14

    int main(void){

        double round_area = PI * 10;
        printf("%e\n",round_area);

        return 0;
    }
    ```

- 宏函数
    - [[#define 宏名(参数) 表达式]]
    - 宏函数对比普通函数的调用的开销更小，因为宏函数的调用是不需要进行入栈和出栈操作，仅仅只是一个表达式替换，这种优势可以理解为 [[以空间换时间]]
    - 宏函数的定义一定要针对每个参数还有包括宏函数所定义的整个表达式都要带上括号，以保证这个宏函数定义的一个完整性

    ```c
    #define ADD(x,y) ((x) + (y))

    int main(void){

        printf("result = %d\n",ADD(3,4) * 2);

        return 0;
    }
    ```

- 卸载宏
    - [[#undef 宏名]]
    - 当我们可能通过某个头文件所引入的宏我们并不需要使用亦或者是我们所定义的宏需要进行卸载，则可以通过该表达式来指定所需要进行卸载的宏，当某一个宏在一个文件中进行了卸载，则该宏的作用域则在当前卸载宏的文件中将不复存在，即无法使用

    ```c
    #include <stdio.h>

    #define PI 3.14

    #undef PI

    int main(void){

        return 0;
    }
    ```

- 一些系统为我们所定义好的 [[预定义动态宏]]
    - [[__FILE__]]：获取使用了当前宏名所在文件的路径

    - [[__LINE__]]：获取使用了当前宏名所在的行数

    - [[__DATE__]]：获取使用了当前宏名参与编译时的日期

    - [[__TIME__]]：获取使用了当前宏名参与编译时的时间 

    ```c
    #include <stdio.h>

    int main(){

        printf("file address = %s\n", __FILE__);
        printf("line = %d\n", __LINE__);
        printf("date = %s\n", __DATE__);
        printf("time = %s\n", __TIME__);
    }
    ```

<br/>

#### 条件编译
<span id="条件编译"></span>

一般情况下，源程序中的代码的每一行都需参加编译的过程，但有时希望编译的过程只对源程序中的某一行在满足一定条件时才参与编译，这时候我们就需要针对这部分特殊的源程序行进行 [[条件编译]] 的指定

- [[#ifdef MACRO]] ：检测宏名是否存在 

    ```c
    #include <stdio.h>

    #define MACRO 10

    /* #undef MACRO */

    int main(void){

        int a;
    #ifdef MACRO
        a = MACRO;
    #else
        a = 1024;
    #endif

        printf("%d\n",a);
        return 0;
    }
    ```

- [[#ifndef MACRO]] ：检测宏名是否不存在 

    ```c
    #include <stdio.h>

    #define MACRO 10
    #undef MACRO

    int main(void){

        int a;
    #ifndef MACRO
        a = 1024;
    #else
        a = MACRO;
    #endif

        printf("%d\n",a);
        return 0;
    }
    ```

- [[#if 表达式]] ：指定具体为真的表达式

    ```c
    #include <stdio.h>

    #define MACRO 10
    #undef MACRO

    int main(void){

    #if 1
        printf("OK!");
    #endif

        return 0;
    }
    ```

<br/>

### 位运算
<span id="位运算"></span>

---

#### 位逻辑运算符
<span id="位逻辑运算符"></span>

- [[~]]：按位取反
    - 该操作符能够对于一个操作数的二进制数进行逐位取反工作
    - 由于是所有位进行取反工作，即 [[~]] 操作符所计算出来的真实值可能需要参与 [[反码]] [[补码]] 的运算
    ```c
                                                                       
    int a = ~2 ----------> ~ 0000 0010
                                 |
                               RESULT 
                                 |
                                 v                          
                             1111 1101 --INVERSE--> 1| 0000 0010 --COMPLEMENT--> 1| 0000 0011 --REAL--> int a = -3
    ```

<br/>

- [[&]]：位与
    - 对两个操作数的二进制数进行逐位比较，只要存在一个比较位为 [[0]] 则结果为 [[0]]，两个比较位都为 [[1]] 结果才为 [[1]]
    ```c
    int a = 147 & 61 ---->  1001 0011 
                          & 0011 1101
                                |
                              RESULT 
                                |
                                v   
                            0001 0001 --REAL--> int a = 17;
    ```
    - 特殊应用
        
        判断一个数是否为奇数，和 [[1]] 做位与运算，如果结果为 [[1]] 那么这个数就是奇数，原理是通过 <span style="color:red"> 一个数的二进制位的末位如果是 1 那么这个数肯定是奇数 </span> 这一特性来判断的

<br/>

- [[|]]：位或
    - 对两个操作数进行逐位比较，只要存在一个比较位为 [[1]] 则结果为 [[1]]，两个比较位都为 [[0]] 结果才为 [[0]]
    ```c
    int a = 147 | 61 ---->  1001 0011 
                          | 0011 1101
                                |
                              RESULT 
                                |
                                v 
                            1011 1111 --REAL--> int a = 191
    ```

    - 特殊应用
        
        将一个二进制数的任意位置置为 [[1]]，如：[[0000 0001]] 想转变为 [[1011 1111]] 的话，只需要把原数与 [[1011 1110]] 做位或运算即可，其实先主要是通过位或操作符能够把只要存在一个比较位为 [[1]] 的话，那么结果位的结果就为 [[1]] 的特性来实现的

<br/>
    
- [[^]]：位异或
    - 对两个操作数进行逐位比较，如果两个比较位相同，则结果位为 [[0]]，只要存在一个比较位不相同，那么结果位则为 [[1]]
    ```c
    int a = 147 ^ 61 ---->  1001 0011 
                          ^ 0011 1101
                                |
                              RESULT 
                                |
                                v 
                            1010 1110 --REAL--> int a = 174
    ```

    - 特殊应用
        
        位异或运算存在一个特性，三个数 [[A]] [[B]] [[C]] 进行异或运算的话其结果如下

        ```c
        A ^ B = C
        A ^ C = B
        B ^ C = A
        ```

        通过这一特性我们就能够两个实现变量之间进行交换

        ```c
        int main(void){

            int a = 20;
            int b = 30;

            a ^= b;
            b ^= a;
            a ^= b;
        }
        ```
<br/>

#### 移位运算符
<span id="移位运算符"></span>

- [[<<]] ：左移运算符

    - 将操作数的每一位都按照运算符右侧的值进行按向左移动，移动后的结果低位不足补 [[0]]
    - 移动的过程中，某一位如果超过最高位的限度，则该位需要摒弃
    - 左移运算的结果，相当于 <span style="color:red">原值 * 2^n ( 移动位 )</span> 的结果

    ```c
    int a = 7 << 2 ----> 0000 0111 
                      <<     2
                             |
                           RESULT 
                             |
                             v 
                         0001 1100 --REAL--> int a = 28
    ```

<br/>

- [[>>]] ：右移运算符

    - 将操作数的每一位都按照运算符右侧的值进行按向右移动，移动后，如果原值为无符号位，则高位不足补 [[0]]，而如果原值为有符号位的话，则结果依赖于机器，有可能是使用 [[0]] 来补高位，也有可能是使用 [[符号位]] 来补高位
    - 移动的过程中，某一位如果超过最低位的限度，则该位需要摒弃
    - 右移运算的结果，如果原值位非负数，相当于 <span style="color:red">原值 / 2^n ( 移动位 )</span> 的结果

    ```c
    int a = 138 >> 2 ----> 1000 1010 
                        >>     2
                               |
                             RESULT 
                               |
                               v 
                           0010 0010 --REAL--> int a = 34
    ```
    
<br/>

### 关于系统提供给我们的API中，形参为 [[format]] 时需要注意的问题
<span id="形参format"></span>

---

当我们使用部分 c 标准库所提供出来的 [[API]] 时，特别是针对数据录入的API，经常会函数的形参看到类型为 [[char *]] 参数名为 [[fortmat]] 的格式，并且后面的列表通常跟着一个或者多个 [[可变参数]] ( <span style="color:red">实际上 c 语言中并没有内置可变参数 [[params]] 的标识符，其实现是通过函数形参地址的偏移来找到一个或多个由 [[caller]] 所录入的参数的</span> )，通常拥有该参数的函数功能可以通过 [[format]] 参数中所录入的 [[格式化模板]] ，然后把 [[fortmat]] 后面所跟随的可变参数依照所 [[format]] 中所指定的格式一一录入到一个新的字符串内，那么 <span style="color:red">这个新的字符串可能会直接返回给我们也可能会写入到文件或者某些在可变参数中所指定的内存区域当中去</span> ，这其实并不重要，我们需要明白的是在上面所提到的 [[格式化模板]] 的说话

关于 [[格式化模板]] 其内置了很多标识符以供我们去使用，以下则为常用的一些格式化标识符

- [[%%]]：对于 [[%]] 的转移，以使 [[%]] 不会被认定为一个转移连接符，而是作为一个普通字符进行处理
- [[%d]]：标识一个 10 进制的 signed int 数值
- [[%o]]：标识一个 8 进制的  signed int 数值
- [[%x]]：标识一个 16 进制的 signed int 数值
- [[%u]]：标识一个 10 进制的 unsigned int 数值
- [[%p]]：标识一个内存地址，当然，内存地址也是 [[16进制]] 的数值，所以对于内存地址的格式化操作我们可以使用 [["%x"]] 也可以使用 [["%p"]]
- [[%hd]]：标识一个 signed short 数值
- [[%hu]]：标识一个 unsigned short 数值
- [[%ld]]：标识一个 signed long 数值
- [[%lu]]：标识一个 unsigned long 数值
- [[%lld]]：标识一个 signed long long 数值
- [[%llu]]：标识一个 unsigned long long 数值
- [[%c]]：标识 一个 signed char 字符
- [[%s]]：标识一个字符串，在 c 中，并没有标准字符串 [[string]] 的定义，所以对于格式化字符串操作而言，以 [['\0']] / [['\n']] 作为本次格式化的结束
- [[%f]]：标识 一个 float 数值
- [[%lf]]：标识 一个 double 数值
- [[%(z)x.(m)yk]]
    - [[k]]：格式符类型，为浮点类型，即 [[%f]] / [[%lf]]
    - [[y]]：小数点后面共保留 [[y]] 位进行格式化，如果格式化后的长度不够 [[y]] ，默认情况下使用 [[0]] 进行补正
    - [[m]]：指定 [[y]] 进行长度补正时所使用的数值
    - [[x]]：整体输出保留 [[x]] 位进行格式化，并且对 [[x+1]] 位进行四舍五入，如果格式化后的长度不够 [[x]] ，默认情况下则使用 [[0]] 进行补正
    - [[z]]：指定 [[x]] 进行长度补正时所使用的数值


<br/>

### 控制台
<span id="控制台"></span>

---

[前面](#在c语言中三种特殊的系统文件) 提到过，一个应用程序在启动的时候会打开三种特殊的系统文件，当这三种特殊的系统文件被打开后同时也会开启相对应的 <span style="color:red">作为程序与设备之间进行数据沟通的桥梁</span> 的缓冲区，那么在 c 中，这三种系统文件将以宏定义文件指针的形式长存在当前程序运行时的内存当中，它们分别为 [[stdin]] [[stdout]] [[stderr]]，而对于操作控制台的API来说，其实就是针对这几种特殊系统文件的缓冲区 ( 即 [[stdin]] [[stdout]] [[stderr]] ) 进行读写操作


#### int printf(char const* const format, ...)
##### <stdio.h>

将 [format形参](#形参format) 所提供的格式化模板再结合所录入的可变参数 [[...]] 生成一个新的字符串的结果并写入到文件指针 [[stdout]] 所指向的文件的缓冲区内，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    printf("Hello,World!");
    return 0;
}
```

<br/>

#### int scanf(const char * format, ...)
##### <stdio.h>

将 [format形参](#形参format) 所提供的格式化模式从文件指针 [[stdin]] 所指向的文件的缓冲区内取出数据，以 [[\n]] 作为此次从 [[stdin]] 缓冲区中取出数据的结束标识符，取出的数据依次写入到所指定的可变参数 [[...]] 所使用的内存空间当中，如果成功返回 [[0]]，如果失败则返回 [[-1]]

由于此操作是从 [[stdin]] 中取出数据，也就意味着在调用该函数时会有一个阻塞的过程等待着我们的 [[input]] 设备去录入即将要输入到缓冲区中的数据

对于 [[scanf]] 函数来说，录入字符串是存在一定的安全隐患的，比如说用户所输入的数据长度是 10 位，但是我们用于接受从 [[stdin]] 中所采集到的数据的可变参数 <kbd>char []</kbd> 的长度只有 5 位，但是 [[scanf]] 函数也会把所所有数据录入的数据填充进长度仅有五位的字符数组当中，这也就意味着可能会产生 [[野指针]] 的数据，而对于编译器而言，它也认为使用它来录入字符串会存在安全性的问题，故可能在编译的过程中弹出 [[canf 4996]] 的错误，解决这一错误只需定义一个 [[#define _CRT_SECURE_NO_WARNINGS]] 的宏即可解决

```c
#include <stdio.h>

int main(void){

	int a;
	scanf("%d", &a);
	printf("%d\n", a);

    return 0;
}
```

<br/>

#### int getchar()
##### <stdio.h>

从文件缓冲区 [[stdin]] 中读取所输入的一个 [[char]] 字符，以 [[\n]] 作为此次从 [[stdin]] 缓冲区中取出数据的结束标识符

由于此操作是从 [[stdin]] 中取出数据，也就意味着在调用该函数时会有一个阻塞的过程等待着我们的 [[input]] 设备去录入即将要输入到缓冲区中的数据

```c
#include <stdio.h>

int main(void){

    char ch = getchar();
    printf("%c\n",ch);

    return 0;
}
```

<br/>

#### int putchar(int character)
##### <stdio.h>

将字符 [[character]] 写入到文件指针 [[stdout]] 所指向文件的缓冲区当中，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    putchar('o');
    putchar('k');
    putchar('\n');

    return 0;
}
```

<br/>

#### char *gets(char *str)
##### <stdio.h>

从文件指针 [[stdin]] 所指向的文件的缓冲区内获取数据，以 [[\n]] 作为此次从 [[stdin]] 缓冲区中取出数据的结束标识符，把所读取到的内容填充至形参 [[str]] 所指向的内存空间内并返回该内存空间的首地址，如果调用失败，则返回 [[NULL]]

该函数所给定的参数 [[str]] 必须为一个字符数组以保证写入权限，如果给定的是一个字符指针形式的字符串的话，该函数则会调用失败，因为该函数会逐地址写入所录入的字符

由于此操作是从 [[stdin]] 中取出数据，也就意味着在调用该函数时会有一个阻塞的过程等待着我们的 [[input]] 设备去录入即将要输入到缓冲区中的数据

在函数调用完成后，会根据所录入的数据的结尾添加字符串标识符 [[\0]] 

对于 [[gets]] 函数来说，录入字符串是存在一定的安全隐患的，比如说用户所输入的数据长度是 10 位，但是我们用于接受从 [[stdin]] 中所采集到的数据的可变参数 <kbd>char []</kbd> 的长度只有 5 位，但是 [[gets]] 函数也会把所所有数据录入的数据填充进长度仅有五位的字符数组当中，这也就意味着可能会产生 [[野指针]] 的数据

```c
#include <stdio.h>

int main(void){

	char str[32] = { 0 };
	gets(str);

	printf("%s\n", str);

    return 0;
}
```

<br/>

#### int puts(const char *str)
##### <stdio.h>

将字符串 [[str]] 写入到文件指针 [[stdout]] 所指向文件的缓冲区当中，并且所输出的字符串的最后一位会添加一个 [[\n]] 的字符，如果调用成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>

int main(void){

    puts("Hello,World!");
    return 0;
}
```

<br/>

#### int _getch()
##### <conio.h>

从文件缓冲区 [stdin] 中以 <span style = "color:red">无回显</span> 的方式读取所输入的一个 [[char]] 字符，无回显的方式意味着该函数不需要以 [[\n]] 作为此次从 [[stdin]] 缓冲区中取出数据的结束标识符，并且我们所键入的字符不会再输入到 [[stdout]] 中显示在控制台上

由于此操作是从 [[stdin]] 中取出数据，也就意味着在调用该函数时会有一个阻塞的过程等待着我们的 [[input]] 设备去录入即将要输入到缓冲区中的数据

```c
#include <stdio.h>
#include <conio.h>

int main(void){

    char ch = _getch();
	printf("%c\n", ch);

    return 0;
}
```

<br/>

#### int kbhit()
##### <conio.h>

以 <span style = "color:red">非阻塞</span> 的方式检查 [[stdin]] 中是否有新的数据写入，即检查是否有键盘得输入操作，如果有，则返回 [[1]]，如果没有，则返回 [[0]]

```c
#include <stdio.h>
#include <conio.h>

int main(){

    while (1) {

        if (kbhit()) {
        
            printf("%c", _getch());
        }
    }

    return 0;
}
```

<br/>

### Windows.h
<span id="Windows.h"></span>

---

#### int system(const char *command)

执行系统命令 [[command]]，如果成功返回 [[0]]，如果失败则返回 [[-1]]

该函数会形成阻塞，直至系统命令执行完成或关闭

- [[command]]
    - [[pause]]：控制台程序暂停，形成阻塞，直至用户下一次键入 [[\n]] 则恢复调用
    - [[cls]]：清屏
    - [[cmd]]：打开控制台终端
    - [[mspaint]]：打开 Windows 画图 终端
    - [[calc]]：打开计算器终端

```c
#include <Windows.h>

int main(void){

    system("pause");
    return 0;
}
```

<br/>

#### int Sleep(long millisecond)

当前上下文线程休眠 [[millisecond]] 毫秒，如果成功返回 [[0]]，如果失败则返回 [[-1]]

```c
#include <stdio.h>
#include <Windows.h>

int main(void){

	Sleep(3000);
	printf("%s\n", "Hello,World!");

    return 0;
}
```

<br/>

### stdlib.h
<span id="stdlib.h"></span>

---

#### void srand(int value)

添加一个 <span style="color:red">随机数种子</span>，重置函数 [[rand]] 的随机数计数标识，如果在使用函数 [[rand]] 获取随机数之前没有添加随机数种子，则获取到的是一个伪随机数

```c
#include <stdlib>
#include <time.h>

int main(void){

    srand(time(NULL));

    return 0;
}
```

<br/>

#### int rand(void)

获取一个随机数，如果在调用该函数前不进行随机数种子的种植操作 [[srand]] ，则该函数所获取到的随机数是一个伪随机数，伪随机数即不是真正的随机数，虽然每次调用该函数后获取到的随机数都不一样，但程序进行了重启后，我们会发现再次获取随机数的结果和重启前的结果是一模一样的，即不是真正的随机数

```c
#include <stdlib>
#include <time.h>

int main(void){

    srand(time(NULL));
	for (size_t i = 0; i < 10; i++) {

		printf("%d\n", rand());
	}

    return 0;
}
```

<br/>

#### void exit(int code)

退出当前进程，[[code]] 则为退出标识，是正常退出 [[0]] 还是异常退出 [[-1]]，在 [[main]] 函数调用完成后的也是通过该函数来退出进程，并且根据 [[main]] 函数的返回值来赋值 [[code]] 形参

```c
#include <stdlib.h>

int main(void){

    exit(0);
    return 0;
}
```
